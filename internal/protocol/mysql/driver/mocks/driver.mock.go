// Code generated by MockGen. DO NOT EDIT.
// Source: ./types.go
//
// Generated by this command:
//
//	mockgen -source=./types.go -destination=mocks/driver.mock.go -package=mocks -typed
//
// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	driver "database/sql/driver"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockDriver is a mock of Driver interface.
type MockDriver struct {
	ctrl     *gomock.Controller
	recorder *MockDriverMockRecorder
}

// MockDriverMockRecorder is the mock recorder for MockDriver.
type MockDriverMockRecorder struct {
	mock *MockDriver
}

// NewMockDriver creates a new mock instance.
func NewMockDriver(ctrl *gomock.Controller) *MockDriver {
	mock := &MockDriver{ctrl: ctrl}
	mock.recorder = &MockDriverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDriver) EXPECT() *MockDriverMockRecorder {
	return m.recorder
}

// OpenConnector mocks base method.
func (m *MockDriver) OpenConnector(name string) (driver.Connector, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenConnector", name)
	ret0, _ := ret[0].(driver.Connector)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenConnector indicates an expected call of OpenConnector.
func (mr *MockDriverMockRecorder) OpenConnector(name any) *DriverOpenConnectorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenConnector", reflect.TypeOf((*MockDriver)(nil).OpenConnector), name)
	return &DriverOpenConnectorCall{Call: call}
}

// DriverOpenConnectorCall wrap *gomock.Call
type DriverOpenConnectorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *DriverOpenConnectorCall) Return(arg0 driver.Connector, arg1 error) *DriverOpenConnectorCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *DriverOpenConnectorCall) Do(f func(string) (driver.Connector, error)) *DriverOpenConnectorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *DriverOpenConnectorCall) DoAndReturn(f func(string) (driver.Connector, error)) *DriverOpenConnectorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockConnector is a mock of Connector interface.
type MockConnector struct {
	ctrl     *gomock.Controller
	recorder *MockConnectorMockRecorder
}

// MockConnectorMockRecorder is the mock recorder for MockConnector.
type MockConnectorMockRecorder struct {
	mock *MockConnector
}

// NewMockConnector creates a new mock instance.
func NewMockConnector(ctrl *gomock.Controller) *MockConnector {
	mock := &MockConnector{ctrl: ctrl}
	mock.recorder = &MockConnectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConnector) EXPECT() *MockConnectorMockRecorder {
	return m.recorder
}

// Connect mocks base method.
func (m *MockConnector) Connect(arg0 context.Context) (driver.Conn, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Connect", arg0)
	ret0, _ := ret[0].(driver.Conn)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Connect indicates an expected call of Connect.
func (mr *MockConnectorMockRecorder) Connect(arg0 any) *ConnectorConnectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockConnector)(nil).Connect), arg0)
	return &ConnectorConnectCall{Call: call}
}

// ConnectorConnectCall wrap *gomock.Call
type ConnectorConnectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectorConnectCall) Return(arg0 driver.Conn, arg1 error) *ConnectorConnectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectorConnectCall) Do(f func(context.Context) (driver.Conn, error)) *ConnectorConnectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectorConnectCall) DoAndReturn(f func(context.Context) (driver.Conn, error)) *ConnectorConnectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Driver mocks base method.
func (m *MockConnector) Driver() driver.Driver {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Driver")
	ret0, _ := ret[0].(driver.Driver)
	return ret0
}

// Driver indicates an expected call of Driver.
func (mr *MockConnectorMockRecorder) Driver() *ConnectorDriverCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*MockConnector)(nil).Driver))
	return &ConnectorDriverCall{Call: call}
}

// ConnectorDriverCall wrap *gomock.Call
type ConnectorDriverCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnectorDriverCall) Return(arg0 driver.Driver) *ConnectorDriverCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnectorDriverCall) Do(f func() driver.Driver) *ConnectorDriverCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnectorDriverCall) DoAndReturn(f func() driver.Driver) *ConnectorDriverCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockConn is a mock of Conn interface.
type MockConn struct {
	ctrl     *gomock.Controller
	recorder *MockConnMockRecorder
}

// MockConnMockRecorder is the mock recorder for MockConn.
type MockConnMockRecorder struct {
	mock *MockConn
}

// NewMockConn creates a new mock instance.
func NewMockConn(ctrl *gomock.Controller) *MockConn {
	mock := &MockConn{ctrl: ctrl}
	mock.recorder = &MockConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConn) EXPECT() *MockConnMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockConn) Begin() (driver.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(driver.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockConnMockRecorder) Begin() *ConnBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockConn)(nil).Begin))
	return &ConnBeginCall{Call: call}
}

// ConnBeginCall wrap *gomock.Call
type ConnBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnBeginCall) Return(arg0 driver.Tx, arg1 error) *ConnBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnBeginCall) Do(f func() (driver.Tx, error)) *ConnBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnBeginCall) DoAndReturn(f func() (driver.Tx, error)) *ConnBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BeginTx mocks base method.
func (m *MockConn) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx", ctx, opts)
	ret0, _ := ret[0].(driver.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MockConnMockRecorder) BeginTx(ctx, opts any) *ConnBeginTxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockConn)(nil).BeginTx), ctx, opts)
	return &ConnBeginTxCall{Call: call}
}

// ConnBeginTxCall wrap *gomock.Call
type ConnBeginTxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnBeginTxCall) Return(arg0 driver.Tx, arg1 error) *ConnBeginTxCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnBeginTxCall) Do(f func(context.Context, driver.TxOptions) (driver.Tx, error)) *ConnBeginTxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnBeginTxCall) DoAndReturn(f func(context.Context, driver.TxOptions) (driver.Tx, error)) *ConnBeginTxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CheckNamedValue mocks base method.
func (m *MockConn) CheckNamedValue(arg0 *driver.NamedValue) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckNamedValue", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckNamedValue indicates an expected call of CheckNamedValue.
func (mr *MockConnMockRecorder) CheckNamedValue(arg0 any) *ConnCheckNamedValueCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckNamedValue", reflect.TypeOf((*MockConn)(nil).CheckNamedValue), arg0)
	return &ConnCheckNamedValueCall{Call: call}
}

// ConnCheckNamedValueCall wrap *gomock.Call
type ConnCheckNamedValueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnCheckNamedValueCall) Return(arg0 error) *ConnCheckNamedValueCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnCheckNamedValueCall) Do(f func(*driver.NamedValue) error) *ConnCheckNamedValueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnCheckNamedValueCall) DoAndReturn(f func(*driver.NamedValue) error) *ConnCheckNamedValueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockConn) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockConnMockRecorder) Close() *ConnCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConn)(nil).Close))
	return &ConnCloseCall{Call: call}
}

// ConnCloseCall wrap *gomock.Call
type ConnCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnCloseCall) Return(arg0 error) *ConnCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnCloseCall) Do(f func() error) *ConnCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnCloseCall) DoAndReturn(f func() error) *ConnCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExecContext mocks base method.
func (m *MockConn) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecContext", ctx, query, args)
	ret0, _ := ret[0].(driver.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockConnMockRecorder) ExecContext(ctx, query, args any) *ConnExecContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockConn)(nil).ExecContext), ctx, query, args)
	return &ConnExecContextCall{Call: call}
}

// ConnExecContextCall wrap *gomock.Call
type ConnExecContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnExecContextCall) Return(arg0 driver.Result, arg1 error) *ConnExecContextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnExecContextCall) Do(f func(context.Context, string, []driver.NamedValue) (driver.Result, error)) *ConnExecContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnExecContextCall) DoAndReturn(f func(context.Context, string, []driver.NamedValue) (driver.Result, error)) *ConnExecContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsValid mocks base method.
func (m *MockConn) IsValid() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsValid")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsValid indicates an expected call of IsValid.
func (mr *MockConnMockRecorder) IsValid() *ConnIsValidCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsValid", reflect.TypeOf((*MockConn)(nil).IsValid))
	return &ConnIsValidCall{Call: call}
}

// ConnIsValidCall wrap *gomock.Call
type ConnIsValidCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnIsValidCall) Return(arg0 bool) *ConnIsValidCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnIsValidCall) Do(f func() bool) *ConnIsValidCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnIsValidCall) DoAndReturn(f func() bool) *ConnIsValidCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ping mocks base method.
func (m *MockConn) Ping(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockConnMockRecorder) Ping(ctx any) *ConnPingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockConn)(nil).Ping), ctx)
	return &ConnPingCall{Call: call}
}

// ConnPingCall wrap *gomock.Call
type ConnPingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnPingCall) Return(arg0 error) *ConnPingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnPingCall) Do(f func(context.Context) error) *ConnPingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnPingCall) DoAndReturn(f func(context.Context) error) *ConnPingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Prepare mocks base method.
func (m *MockConn) Prepare(query string) (driver.Stmt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", query)
	ret0, _ := ret[0].(driver.Stmt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prepare indicates an expected call of Prepare.
func (mr *MockConnMockRecorder) Prepare(query any) *ConnPrepareCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockConn)(nil).Prepare), query)
	return &ConnPrepareCall{Call: call}
}

// ConnPrepareCall wrap *gomock.Call
type ConnPrepareCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnPrepareCall) Return(arg0 driver.Stmt, arg1 error) *ConnPrepareCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnPrepareCall) Do(f func(string) (driver.Stmt, error)) *ConnPrepareCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnPrepareCall) DoAndReturn(f func(string) (driver.Stmt, error)) *ConnPrepareCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareContext mocks base method.
func (m *MockConn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareContext", ctx, query)
	ret0, _ := ret[0].(driver.Stmt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareContext indicates an expected call of PrepareContext.
func (mr *MockConnMockRecorder) PrepareContext(ctx, query any) *ConnPrepareContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareContext", reflect.TypeOf((*MockConn)(nil).PrepareContext), ctx, query)
	return &ConnPrepareContextCall{Call: call}
}

// ConnPrepareContextCall wrap *gomock.Call
type ConnPrepareContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnPrepareContextCall) Return(arg0 driver.Stmt, arg1 error) *ConnPrepareContextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnPrepareContextCall) Do(f func(context.Context, string) (driver.Stmt, error)) *ConnPrepareContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnPrepareContextCall) DoAndReturn(f func(context.Context, string) (driver.Stmt, error)) *ConnPrepareContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryContext mocks base method.
func (m *MockConn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryContext", ctx, query, args)
	ret0, _ := ret[0].(driver.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryContext indicates an expected call of QueryContext.
func (mr *MockConnMockRecorder) QueryContext(ctx, query, args any) *ConnQueryContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockConn)(nil).QueryContext), ctx, query, args)
	return &ConnQueryContextCall{Call: call}
}

// ConnQueryContextCall wrap *gomock.Call
type ConnQueryContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnQueryContextCall) Return(arg0 driver.Rows, arg1 error) *ConnQueryContextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnQueryContextCall) Do(f func(context.Context, string, []driver.NamedValue) (driver.Rows, error)) *ConnQueryContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnQueryContextCall) DoAndReturn(f func(context.Context, string, []driver.NamedValue) (driver.Rows, error)) *ConnQueryContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResetSession mocks base method.
func (m *MockConn) ResetSession(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResetSession", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResetSession indicates an expected call of ResetSession.
func (mr *MockConnMockRecorder) ResetSession(ctx any) *ConnResetSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetSession", reflect.TypeOf((*MockConn)(nil).ResetSession), ctx)
	return &ConnResetSessionCall{Call: call}
}

// ConnResetSessionCall wrap *gomock.Call
type ConnResetSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ConnResetSessionCall) Return(arg0 error) *ConnResetSessionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ConnResetSessionCall) Do(f func(context.Context) error) *ConnResetSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ConnResetSessionCall) DoAndReturn(f func(context.Context) error) *ConnResetSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRows is a mock of Rows interface.
type MockRows struct {
	ctrl     *gomock.Controller
	recorder *MockRowsMockRecorder
}

// MockRowsMockRecorder is the mock recorder for MockRows.
type MockRowsMockRecorder struct {
	mock *MockRows
}

// NewMockRows creates a new mock instance.
func NewMockRows(ctrl *gomock.Controller) *MockRows {
	mock := &MockRows{ctrl: ctrl}
	mock.recorder = &MockRowsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRows) EXPECT() *MockRowsMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockRows) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockRowsMockRecorder) Close() *RowsCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRows)(nil).Close))
	return &RowsCloseCall{Call: call}
}

// RowsCloseCall wrap *gomock.Call
type RowsCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsCloseCall) Return(arg0 error) *RowsCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsCloseCall) Do(f func() error) *RowsCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsCloseCall) DoAndReturn(f func() error) *RowsCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ColumnTypeDatabaseTypeName mocks base method.
func (m *MockRows) ColumnTypeDatabaseTypeName(index int) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ColumnTypeDatabaseTypeName", index)
	ret0, _ := ret[0].(string)
	return ret0
}

// ColumnTypeDatabaseTypeName indicates an expected call of ColumnTypeDatabaseTypeName.
func (mr *MockRowsMockRecorder) ColumnTypeDatabaseTypeName(index any) *RowsColumnTypeDatabaseTypeNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ColumnTypeDatabaseTypeName", reflect.TypeOf((*MockRows)(nil).ColumnTypeDatabaseTypeName), index)
	return &RowsColumnTypeDatabaseTypeNameCall{Call: call}
}

// RowsColumnTypeDatabaseTypeNameCall wrap *gomock.Call
type RowsColumnTypeDatabaseTypeNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsColumnTypeDatabaseTypeNameCall) Return(arg0 string) *RowsColumnTypeDatabaseTypeNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsColumnTypeDatabaseTypeNameCall) Do(f func(int) string) *RowsColumnTypeDatabaseTypeNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsColumnTypeDatabaseTypeNameCall) DoAndReturn(f func(int) string) *RowsColumnTypeDatabaseTypeNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ColumnTypeNullable mocks base method.
func (m *MockRows) ColumnTypeNullable(index int) (bool, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ColumnTypeNullable", index)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ColumnTypeNullable indicates an expected call of ColumnTypeNullable.
func (mr *MockRowsMockRecorder) ColumnTypeNullable(index any) *RowsColumnTypeNullableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ColumnTypeNullable", reflect.TypeOf((*MockRows)(nil).ColumnTypeNullable), index)
	return &RowsColumnTypeNullableCall{Call: call}
}

// RowsColumnTypeNullableCall wrap *gomock.Call
type RowsColumnTypeNullableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsColumnTypeNullableCall) Return(nullable, ok bool) *RowsColumnTypeNullableCall {
	c.Call = c.Call.Return(nullable, ok)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsColumnTypeNullableCall) Do(f func(int) (bool, bool)) *RowsColumnTypeNullableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsColumnTypeNullableCall) DoAndReturn(f func(int) (bool, bool)) *RowsColumnTypeNullableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ColumnTypePrecisionScale mocks base method.
func (m *MockRows) ColumnTypePrecisionScale(index int) (int64, int64, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ColumnTypePrecisionScale", index)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(bool)
	return ret0, ret1, ret2
}

// ColumnTypePrecisionScale indicates an expected call of ColumnTypePrecisionScale.
func (mr *MockRowsMockRecorder) ColumnTypePrecisionScale(index any) *RowsColumnTypePrecisionScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ColumnTypePrecisionScale", reflect.TypeOf((*MockRows)(nil).ColumnTypePrecisionScale), index)
	return &RowsColumnTypePrecisionScaleCall{Call: call}
}

// RowsColumnTypePrecisionScaleCall wrap *gomock.Call
type RowsColumnTypePrecisionScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsColumnTypePrecisionScaleCall) Return(precision, scale int64, ok bool) *RowsColumnTypePrecisionScaleCall {
	c.Call = c.Call.Return(precision, scale, ok)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsColumnTypePrecisionScaleCall) Do(f func(int) (int64, int64, bool)) *RowsColumnTypePrecisionScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsColumnTypePrecisionScaleCall) DoAndReturn(f func(int) (int64, int64, bool)) *RowsColumnTypePrecisionScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ColumnTypeScanType mocks base method.
func (m *MockRows) ColumnTypeScanType(index int) reflect.Type {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ColumnTypeScanType", index)
	ret0, _ := ret[0].(reflect.Type)
	return ret0
}

// ColumnTypeScanType indicates an expected call of ColumnTypeScanType.
func (mr *MockRowsMockRecorder) ColumnTypeScanType(index any) *RowsColumnTypeScanTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ColumnTypeScanType", reflect.TypeOf((*MockRows)(nil).ColumnTypeScanType), index)
	return &RowsColumnTypeScanTypeCall{Call: call}
}

// RowsColumnTypeScanTypeCall wrap *gomock.Call
type RowsColumnTypeScanTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsColumnTypeScanTypeCall) Return(arg0 reflect.Type) *RowsColumnTypeScanTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsColumnTypeScanTypeCall) Do(f func(int) reflect.Type) *RowsColumnTypeScanTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsColumnTypeScanTypeCall) DoAndReturn(f func(int) reflect.Type) *RowsColumnTypeScanTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Columns mocks base method.
func (m *MockRows) Columns() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Columns")
	ret0, _ := ret[0].([]string)
	return ret0
}

// Columns indicates an expected call of Columns.
func (mr *MockRowsMockRecorder) Columns() *RowsColumnsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Columns", reflect.TypeOf((*MockRows)(nil).Columns))
	return &RowsColumnsCall{Call: call}
}

// RowsColumnsCall wrap *gomock.Call
type RowsColumnsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsColumnsCall) Return(arg0 []string) *RowsColumnsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsColumnsCall) Do(f func() []string) *RowsColumnsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsColumnsCall) DoAndReturn(f func() []string) *RowsColumnsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasNextResultSet mocks base method.
func (m *MockRows) HasNextResultSet() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasNextResultSet")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasNextResultSet indicates an expected call of HasNextResultSet.
func (mr *MockRowsMockRecorder) HasNextResultSet() *RowsHasNextResultSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasNextResultSet", reflect.TypeOf((*MockRows)(nil).HasNextResultSet))
	return &RowsHasNextResultSetCall{Call: call}
}

// RowsHasNextResultSetCall wrap *gomock.Call
type RowsHasNextResultSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsHasNextResultSetCall) Return(arg0 bool) *RowsHasNextResultSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsHasNextResultSetCall) Do(f func() bool) *RowsHasNextResultSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsHasNextResultSetCall) DoAndReturn(f func() bool) *RowsHasNextResultSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Next mocks base method.
func (m *MockRows) Next(dest []driver.Value) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next", dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockRowsMockRecorder) Next(dest any) *RowsNextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockRows)(nil).Next), dest)
	return &RowsNextCall{Call: call}
}

// RowsNextCall wrap *gomock.Call
type RowsNextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsNextCall) Return(arg0 error) *RowsNextCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsNextCall) Do(f func([]driver.Value) error) *RowsNextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsNextCall) DoAndReturn(f func([]driver.Value) error) *RowsNextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NextResultSet mocks base method.
func (m *MockRows) NextResultSet() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NextResultSet")
	ret0, _ := ret[0].(error)
	return ret0
}

// NextResultSet indicates an expected call of NextResultSet.
func (mr *MockRowsMockRecorder) NextResultSet() *RowsNextResultSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NextResultSet", reflect.TypeOf((*MockRows)(nil).NextResultSet))
	return &RowsNextResultSetCall{Call: call}
}

// RowsNextResultSetCall wrap *gomock.Call
type RowsNextResultSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RowsNextResultSetCall) Return(arg0 error) *RowsNextResultSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RowsNextResultSetCall) Do(f func() error) *RowsNextResultSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RowsNextResultSetCall) DoAndReturn(f func() error) *RowsNextResultSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStmt is a mock of Stmt interface.
type MockStmt struct {
	ctrl     *gomock.Controller
	recorder *MockStmtMockRecorder
}

// MockStmtMockRecorder is the mock recorder for MockStmt.
type MockStmtMockRecorder struct {
	mock *MockStmt
}

// NewMockStmt creates a new mock instance.
func NewMockStmt(ctrl *gomock.Controller) *MockStmt {
	mock := &MockStmt{ctrl: ctrl}
	mock.recorder = &MockStmtMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStmt) EXPECT() *MockStmtMockRecorder {
	return m.recorder
}

// CheckNamedValue mocks base method.
func (m *MockStmt) CheckNamedValue(arg0 *driver.NamedValue) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckNamedValue", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckNamedValue indicates an expected call of CheckNamedValue.
func (mr *MockStmtMockRecorder) CheckNamedValue(arg0 any) *StmtCheckNamedValueCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckNamedValue", reflect.TypeOf((*MockStmt)(nil).CheckNamedValue), arg0)
	return &StmtCheckNamedValueCall{Call: call}
}

// StmtCheckNamedValueCall wrap *gomock.Call
type StmtCheckNamedValueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtCheckNamedValueCall) Return(arg0 error) *StmtCheckNamedValueCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtCheckNamedValueCall) Do(f func(*driver.NamedValue) error) *StmtCheckNamedValueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtCheckNamedValueCall) DoAndReturn(f func(*driver.NamedValue) error) *StmtCheckNamedValueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockStmt) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockStmtMockRecorder) Close() *StmtCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockStmt)(nil).Close))
	return &StmtCloseCall{Call: call}
}

// StmtCloseCall wrap *gomock.Call
type StmtCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtCloseCall) Return(arg0 error) *StmtCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtCloseCall) Do(f func() error) *StmtCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtCloseCall) DoAndReturn(f func() error) *StmtCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ColumnConverter mocks base method.
func (m *MockStmt) ColumnConverter(idx int) driver.ValueConverter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ColumnConverter", idx)
	ret0, _ := ret[0].(driver.ValueConverter)
	return ret0
}

// ColumnConverter indicates an expected call of ColumnConverter.
func (mr *MockStmtMockRecorder) ColumnConverter(idx any) *StmtColumnConverterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ColumnConverter", reflect.TypeOf((*MockStmt)(nil).ColumnConverter), idx)
	return &StmtColumnConverterCall{Call: call}
}

// StmtColumnConverterCall wrap *gomock.Call
type StmtColumnConverterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtColumnConverterCall) Return(arg0 driver.ValueConverter) *StmtColumnConverterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtColumnConverterCall) Do(f func(int) driver.ValueConverter) *StmtColumnConverterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtColumnConverterCall) DoAndReturn(f func(int) driver.ValueConverter) *StmtColumnConverterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockStmt) Exec(args []driver.Value) (driver.Result, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec", args)
	ret0, _ := ret[0].(driver.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockStmtMockRecorder) Exec(args any) *StmtExecCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockStmt)(nil).Exec), args)
	return &StmtExecCall{Call: call}
}

// StmtExecCall wrap *gomock.Call
type StmtExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtExecCall) Return(arg0 driver.Result, arg1 error) *StmtExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtExecCall) Do(f func([]driver.Value) (driver.Result, error)) *StmtExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtExecCall) DoAndReturn(f func([]driver.Value) (driver.Result, error)) *StmtExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExecContext mocks base method.
func (m *MockStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecContext", ctx, args)
	ret0, _ := ret[0].(driver.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockStmtMockRecorder) ExecContext(ctx, args any) *StmtExecContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockStmt)(nil).ExecContext), ctx, args)
	return &StmtExecContextCall{Call: call}
}

// StmtExecContextCall wrap *gomock.Call
type StmtExecContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtExecContextCall) Return(arg0 driver.Result, arg1 error) *StmtExecContextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtExecContextCall) Do(f func(context.Context, []driver.NamedValue) (driver.Result, error)) *StmtExecContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtExecContextCall) DoAndReturn(f func(context.Context, []driver.NamedValue) (driver.Result, error)) *StmtExecContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NumInput mocks base method.
func (m *MockStmt) NumInput() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NumInput")
	ret0, _ := ret[0].(int)
	return ret0
}

// NumInput indicates an expected call of NumInput.
func (mr *MockStmtMockRecorder) NumInput() *StmtNumInputCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NumInput", reflect.TypeOf((*MockStmt)(nil).NumInput))
	return &StmtNumInputCall{Call: call}
}

// StmtNumInputCall wrap *gomock.Call
type StmtNumInputCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtNumInputCall) Return(arg0 int) *StmtNumInputCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtNumInputCall) Do(f func() int) *StmtNumInputCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtNumInputCall) DoAndReturn(f func() int) *StmtNumInputCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockStmt) Query(args []driver.Value) (driver.Rows, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", args)
	ret0, _ := ret[0].(driver.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockStmtMockRecorder) Query(args any) *StmtQueryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockStmt)(nil).Query), args)
	return &StmtQueryCall{Call: call}
}

// StmtQueryCall wrap *gomock.Call
type StmtQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtQueryCall) Return(arg0 driver.Rows, arg1 error) *StmtQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtQueryCall) Do(f func([]driver.Value) (driver.Rows, error)) *StmtQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtQueryCall) DoAndReturn(f func([]driver.Value) (driver.Rows, error)) *StmtQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryContext mocks base method.
func (m *MockStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryContext", ctx, args)
	ret0, _ := ret[0].(driver.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryContext indicates an expected call of QueryContext.
func (mr *MockStmtMockRecorder) QueryContext(ctx, args any) *StmtQueryContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockStmt)(nil).QueryContext), ctx, args)
	return &StmtQueryContextCall{Call: call}
}

// StmtQueryContextCall wrap *gomock.Call
type StmtQueryContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StmtQueryContextCall) Return(arg0 driver.Rows, arg1 error) *StmtQueryContextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StmtQueryContextCall) Do(f func(context.Context, []driver.NamedValue) (driver.Rows, error)) *StmtQueryContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StmtQueryContextCall) DoAndReturn(f func(context.Context, []driver.NamedValue) (driver.Rows, error)) *StmtQueryContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTx is a mock of Tx interface.
type MockTx struct {
	ctrl     *gomock.Controller
	recorder *MockTxMockRecorder
}

// MockTxMockRecorder is the mock recorder for MockTx.
type MockTxMockRecorder struct {
	mock *MockTx
}

// NewMockTx creates a new mock instance.
func NewMockTx(ctrl *gomock.Controller) *MockTx {
	mock := &MockTx{ctrl: ctrl}
	mock.recorder = &MockTxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTx) EXPECT() *MockTxMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockTx) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTxMockRecorder) Commit() *TxCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTx)(nil).Commit))
	return &TxCommitCall{Call: call}
}

// TxCommitCall wrap *gomock.Call
type TxCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxCommitCall) Return(arg0 error) *TxCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxCommitCall) Do(f func() error) *TxCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxCommitCall) DoAndReturn(f func() error) *TxCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rollback mocks base method.
func (m *MockTx) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTxMockRecorder) Rollback() *TxRollbackCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTx)(nil).Rollback))
	return &TxRollbackCall{Call: call}
}

// TxRollbackCall wrap *gomock.Call
type TxRollbackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxRollbackCall) Return(arg0 error) *TxRollbackCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxRollbackCall) Do(f func() error) *TxRollbackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxRollbackCall) DoAndReturn(f func() error) *TxRollbackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockResult is a mock of Result interface.
type MockResult struct {
	ctrl     *gomock.Controller
	recorder *MockResultMockRecorder
}

// MockResultMockRecorder is the mock recorder for MockResult.
type MockResultMockRecorder struct {
	mock *MockResult
}

// NewMockResult creates a new mock instance.
func NewMockResult(ctrl *gomock.Controller) *MockResult {
	mock := &MockResult{ctrl: ctrl}
	mock.recorder = &MockResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResult) EXPECT() *MockResultMockRecorder {
	return m.recorder
}

// LastInsertId mocks base method.
func (m *MockResult) LastInsertId() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastInsertId")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LastInsertId indicates an expected call of LastInsertId.
func (mr *MockResultMockRecorder) LastInsertId() *ResultLastInsertIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastInsertId", reflect.TypeOf((*MockResult)(nil).LastInsertId))
	return &ResultLastInsertIdCall{Call: call}
}

// ResultLastInsertIdCall wrap *gomock.Call
type ResultLastInsertIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ResultLastInsertIdCall) Return(arg0 int64, arg1 error) *ResultLastInsertIdCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ResultLastInsertIdCall) Do(f func() (int64, error)) *ResultLastInsertIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ResultLastInsertIdCall) DoAndReturn(f func() (int64, error)) *ResultLastInsertIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RowsAffected mocks base method.
func (m *MockResult) RowsAffected() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsAffected")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RowsAffected indicates an expected call of RowsAffected.
func (mr *MockResultMockRecorder) RowsAffected() *ResultRowsAffectedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsAffected", reflect.TypeOf((*MockResult)(nil).RowsAffected))
	return &ResultRowsAffectedCall{Call: call}
}

// ResultRowsAffectedCall wrap *gomock.Call
type ResultRowsAffectedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ResultRowsAffectedCall) Return(arg0 int64, arg1 error) *ResultRowsAffectedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ResultRowsAffectedCall) Do(f func() (int64, error)) *ResultRowsAffectedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ResultRowsAffectedCall) DoAndReturn(f func() (int64, error)) *ResultRowsAffectedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
