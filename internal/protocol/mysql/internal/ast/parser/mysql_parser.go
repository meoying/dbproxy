// Code generated from /Users/zhuwenliang/w/dbproxy/internal/protocol/mysql/internal/ast/MySqlParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // MySqlParser
import (
	"fmt"
	"strconv"
  	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type MySqlParser struct {
	*antlr.BaseParser
}

var MySqlParserParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func mysqlparserParserInit() {
  staticData := &MySqlParserParserStaticData
  staticData.LiteralNames = []string{
    "", "'/* @proxy'", "'*/'", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", 
    "'ANALYZE'", "'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", 
    "'BETWEEN'", "'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", 
    "'CAST'", "'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", 
    "'CONDITION'", "'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", 
    "'CROSS'", "'CURRENT'", "'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", 
    "'DATABASE'", "'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'", 
    "'DELETE'", "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DIAGNOSTICS'", 
    "'DISTINCT'", "'DISTINCTROW'", "'DROP'", "'EACH'", "'ELSE'", "'ELSEIF'", 
    "'EMPTY'", "'ENCLOSED'", "'ENFORCED'", "'ESCAPED'", "'EXCEPT'", "'EXISTS'", 
    "'EXIT'", "'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", 
    "'FROM'", "'FULLTEXT'", "'GENERATED'", "'GET'", "'GRANT'", "'GROUP'", 
    "'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'", "'IF'", "'IGNORE'", "'IGNORED'", 
    "'IN'", "'INDEX'", "'INFILE'", "'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'", 
    "'INTO'", "'IS'", "'ITERATE'", "'JOIN'", "'KEY'", "'KEYS'", "'KILL'", 
    "'LATERAL'", "'LEADING'", "'LEAVE'", "'LEFT'", "'LIKE'", "'LIMIT'", 
    "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'", "'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", 
    "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", "'MATCH'", "'MAXVALUE'", 
    "'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'", 
    "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'", "'OPTION'", "'OPTIONAL'", 
    "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'", "'OUTER'", "'OUTFILE'", 
    "'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'", "'PURGE'", "'RANGE'", 
    "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", "'RELEASE'", "'RENAME'", 
    "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'", "'RESTRICT'", "'RETAIN'", 
    "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'", 
    "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", "'SIGNAL'", "'SKIP'", 
    "'SKIP_QUERY_REWRITE'", "'SPATIAL'", "'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", 
    "'SQLWARNING'", "'SQL_BIG_RESULT'", "'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", 
    "'SSL'", "'STACKED'", "'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'", 
    "'TABLE'", "'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", 
    "'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", 
    "'UPDATE'", "'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'", 
    "'WHILE'", "'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'TINYINT'", 
    "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'", "'INT'", "'INT1'", "'INT2'", 
    "'INT3'", "'INT4'", "'INT8'", "'INTEGER'", "'BIGINT'", "'REAL'", "'DOUBLE'", 
    "'PRECISION'", "'FLOAT'", "'FLOAT4'", "'FLOAT8'", "'DECIMAL'", "'DEC'", 
    "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'", "'DATETIME'", "'YEAR'", 
    "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'", "'BINARY'", "'VARBINARY'", 
    "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'", "'LONGBLOB'", "'TINYTEXT'", 
    "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'", "'ENUM'", "'VARYING'", "'SERIAL'", 
    "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'", 
    "'HOUR_SECOND'", "'MINUTE_SECOND'", "'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", 
    "'HOUR_MICROSECOND'", "'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", 
    "'JSON_ARRAY_APPEND'", "'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", 
    "'JSON_DEPTH'", "'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'", 
    "'JSON_MERGE'", "'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'", 
    "'JSON_OBJECTAGG'", "'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'", 
    "'JSON_REMOVE'", "'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'", 
    "'JSON_SEARCH'", "'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'", 
    "'JSON_TABLE'", "'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'", 
    "'NESTED'", "'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'", 
    "'BIT_XOR'", "'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'", 
    "'GROUP_CONCAT'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'", 
    "'NTILE'", "'NTH_VALUE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", 
    "'STD'", "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", 
    "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", 
    "'LOCALTIME'", "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'", 
    "'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'", 
    "'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'", 
    "'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'", 
    "'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'", 
    "'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'", 
    "'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'", 
    "'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'", 
    "'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'", 
    "'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'", 
    "'COMPLETION'", "'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", "'CONNECT'", 
    "'CONNECTION'", "'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", 
    "'CONSTRAINT_NAME'", "'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", 
    "'CPU'", "'CYCLE'", "'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", 
    "'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", 
    "'DIRECTORY'", "'DISABLE'", "'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", 
    "'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'", 
    "'ENCRYPTION_KEY_ID'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", 
    "'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", 
    "'EXCHANGE'", "'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", 
    "'FAILED_LOGIN_ATTEMPTS'", "'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", 
    "'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", 
    "'FOUND'", "'FULL'", "'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", 
    "'GROUP_REPLICATION'", "'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", 
    "'HOST'", "'HOSTS'", "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", 
    "'INCREMENT'", "'INDEXES'", "'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", 
    "'INSTALL'", "'INSTANCE'", "'INSTANT'", "'INVISIBLE'", "'INVOKER'", 
    "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'", "'ISSUER'", "'JSON'", 
    "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", 
    "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", 
    "'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", 
    "'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'", "'MASTER_PASSWORD'", 
    "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'", "'MASTER_SSL_CA'", 
    "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", 
    "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'", 
    "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'", 
    "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'", 
    "'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'", 
    "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'", 
    "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NOCACHE'", 
    "'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", "'NOWAIT'", 
    "'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", "'OF'", 
    "'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'", 
    "'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PAGE_COMPRESSED'", 
    "'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'", 
    "'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", "'PHASE'", "'PLUGIN'", 
    "'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", "'PRECEDING'", 
    "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", "'PROFILE'", "'PROFILES'", 
    "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", "'RECURSIVE'", 
    "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'", 
    "'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'", 
    "'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", 
    "'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'", 
    "'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'", 
    "'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'", 
    "'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'", 
    "'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'", 
    "'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'", 
    "'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'", 
    "'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'", 
    "'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'", 
    "'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", 
    "'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'", 
    "'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'", 
    "'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'", 
    "'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'", 
    "'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'", 
    "'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'", 
    "'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'", 
    "'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'", 
    "'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'", 
    "'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'", 
    "'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'", 
    "'MICROSECOND'", "'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ABORT_EXEMPT'", 
    "'AUDIT_ADMIN'", "'AUTHENTICATION_POLICY_ADMIN'", "'BACKUP_ADMIN'", 
    "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'", "'CONNECTION_ADMIN'", 
    "'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", "'FILE'", "'FIREWALL_ADMIN'", 
    "'FIREWALL_EXEMPT'", "'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'", 
    "'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'", "'GROUP_REPLICATION_ADMIN'", 
    "'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'", "'INVOKE'", 
    "'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'", 
    "'PRIVILEGES'", "'PROCESS'", "'RELOAD'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'", 
    "'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'", 
    "'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'", "'SHOW_ROUTINE'", 
    "'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLES'", "'TABLE_ENCRYPTION_ADMIN'", 
    "'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'", 
    "'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'", 
    "'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'", 
    "'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'", 
    "'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'", 
    "'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'", 
    "'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", 
    "'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'", 
    "'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", 
    "'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", 
    "'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", 
    "'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", 
    "'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", 
    "'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", 
    "'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", 
    "'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'", 
    "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'", 
    "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'", 
    "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'", 
    "'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'", 
    "'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", 
    "'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'", 
    "'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'", 
    "'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", 
    "'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'", 
    "'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", 
    "'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", 
    "'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", 
    "'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", 
    "'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'", 
    "'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", 
    "'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", 
    "'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'", 
    "'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", 
    "'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", 
    "'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'", 
    "'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", 
    "'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", 
    "'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'", 
    "'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'", 
    "'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'", 
    "'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'", 
    "'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'", 
    "'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", 
    "'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'", 
    "'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'", 
    "'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'", 
    "'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'", 
    "'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'", 
    "'RANDOM'", "'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", 
    "'ROW_COUNT'", "'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'", 
    "'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'", 
    "'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'", 
    "'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'", 
    "'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'", 
    "'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'", 
    "'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'", 
    "'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'", 
    "'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'", 
    "'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'", 
    "'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'", 
    "'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'", 
    "'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'", 
    "'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'", 
    "'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'", 
    "'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'", 
    "'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'", 
    "'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'", 
    "'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'", 
    "'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'", 
    "'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'", 
    "'TO_DAYS'", "'TO_SECONDS'", "'TP_CONNECTION_ADMIN'", "'UCASE'", "'UNCOMPRESS'", 
    "'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", 
    "'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", 
    "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'", 
    "'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='", 
    "'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'", 
    "'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'", 
    "'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'", 
    "'1'", "'2'", "'''", "'\"'", "'`'", "':'",
  }
  staticData.SymbolicNames = []string{
    "", "COMMENT_START", "COMMENT_END", "SPACE", "LINE_COMMENT", "ADD", 
    "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC", "ATTRIBUTE", 
    "BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE", "CASE", 
    "CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION", 
    "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_ROLE", 
    "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES", "DECLARE", "DEFAULT", 
    "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", "DIAGNOSTICS", 
    "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF", "EMPTY", 
    "ENCLOSED", "ENFORCED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", 
    "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", 
    "GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF", 
    "IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT", 
    "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", 
    "LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", 
    "LOAD", "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", 
    "MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", 
    "NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY", 
    "OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY", 
    "PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP", 
    "RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", 
    "RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS", 
    "SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", "SKIP_QUERY_REWRITE", 
    "SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", 
    "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING", 
    "STATEMENT", "STRAIGHT_JOIN", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING", 
    "TRIGGER", "TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", 
    "UPDATE", "USAGE", "USE", "USING", "VALUES", "WHEN", "WHERE", "WHILE", 
    "WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT", "SMALLINT", "MEDIUMINT", 
    "MIDDLEINT", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", 
    "BIGINT", "REAL", "DOUBLE", "PRECISION", "FLOAT", "FLOAT4", "FLOAT8", 
    "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME", "TIMESTAMP", "DATETIME", 
    "YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL", "BINARY", "VARBINARY", 
    "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB", "TINYTEXT", "TEXT", 
    "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH", 
    "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND", 
    "MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "HOUR_MICROSECOND", 
    "DAY_MICROSECOND", "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_ARRAY_APPEND", 
    "JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH", 
    "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MERGE", 
    "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG", 
    "JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE", 
    "JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_SEARCH", 
    "JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_TABLE", 
    "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE", "NESTED", "ORDINALITY", 
    "PATH", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "CUME_DIST", 
    "DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", "LAG", "LAST_VALUE", "LEAD", 
    "MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK", "RANK", "ROW_NUMBER", 
    "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", 
    "VARIANCE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME", 
    "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", 
    "NOW", "POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", 
    "UTC_TIME", "UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE", 
    "ALGORITHM", "ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", 
    "AUTO_INCREMENT", "AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK", 
    "BOOL", "BOOLEAN", "BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED", 
    "CHANNEL", "CHECKSUM", "PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT", 
    "CLOSE", "CLUSTERING", "COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT", 
    "COLUMN_NAME", "COMMENT", "COMMIT", "COMPACT", "COMPLETION", "COMPRESSED", 
    "COMPRESSION", "CONCURRENT", "CONNECT", "CONNECTION", "CONSISTENT", 
    "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", "CONSTRAINT_NAME", "CONTAINS", 
    "CONTEXT", "CONTRIBUTORS", "COPY", "CPU", "CYCLE", "CURSOR_NAME", "DATA", 
    "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE", 
    "DES_KEY_FILE", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE", 
    "DUPLICATE", "DYNAMIC", "ENABLE", "ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID", 
    "END", "ENDS", "ENGINE", "ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", 
    "EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", 
    "EXTENDED", "EXTENT_SIZE", "FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS", 
    "FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING", 
    "FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS", 
    "GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS", 
    "IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES", 
    "INITIAL_SIZE", "INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT", 
    "INVISIBLE", "INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", 
    "JSON", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", 
    "LIST", "LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION", 
    "MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", 
    "MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", 
    "MASTER_RETRY_COUNT", "MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", 
    "MASTER_SSL_CERT", "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", 
    "MASTER_SSL_KEY", "MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", 
    "MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", 
    "MAX_USER_CONNECTIONS", "MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", 
    "MID", "MIGRATE", "MIN_ROWS", "MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", 
    "NAME", "NAMES", "NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", 
    "NOCYCLE", "NOMAXVALUE", "NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", 
    "ODBC", "OFFLINE", "OFFSET", "OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", 
    "ONLY", "OPEN", "OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS", 
    "PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL", "PARSER", "PARTIAL", 
    "PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", "PHASE", 
    "PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING", 
    "PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES", 
    "PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE", 
    "REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG", 
    "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE", 
    "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB", 
    "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION", 
    "RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", "RETURNS", 
    "REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT", 
    "RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER", 
    "SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT", 
    "SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", 
    "SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE", 
    "SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT", 
    "STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING", 
    "SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND", 
    "SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY", 
    "TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL", 
    "TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", 
    "UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES", 
    "VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", 
    "WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML", 
    "YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY", 
    "HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN", 
    "AUDIT_ABORT_EXEMPT", "AUDIT_ADMIN", "AUTHENTICATION_POLICY_ADMIN", 
    "BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN", 
    "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "EXECUTE", "FILE", "FIREWALL_ADMIN", 
    "FIREWALL_EXEMPT", "FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS", 
    "FLUSH_TABLES", "FLUSH_USER_RESOURCES", "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE", 
    "INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA", "NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", 
    "PERSIST_RO_VARIABLES_ADMIN", "PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER", 
    "REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER", 
    "ROLE_ADMIN", "ROUTINE", "S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN", 
    "SET_USER_ID", "SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN", 
    "TABLES", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN", 
    "ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257", 
    "CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030", 
    "GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R", 
    "KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", 
    "SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32", 
    "UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", 
    "INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA", 
    "TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE", 
    "GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING", 
    "MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE", 
    "ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN", 
    "ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE", 
    "ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN", 
    "ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME", 
    "CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH", 
    "COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", 
    "CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", 
    "CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST", 
    "CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", 
    "DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION", 
    "DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE", 
    "ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE", 
    "FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64", 
    "FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB", 
    "GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT", 
    "GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB", 
    "GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT", 
    "HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA", 
    "INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL", 
    "ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", 
    "IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", 
    "LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB", 
    "LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", 
    "LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS", 
    "MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", 
    "MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT", 
    "MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT", 
    "MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB", 
    "MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF", 
    "NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH", 
    "ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT", 
    "POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT", 
    "POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM", 
    "RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", 
    "RTRIM", "SEC_TO_TIME", "SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", 
    "SHA", "SHA1", "SHA2", "SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", 
    "SQL_THREAD_WAIT_AFTER_GTIDS", "SQRT", "SRID", "STARTPOINT", "STRCMP", 
    "STR_TO_DATE", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", 
    "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CROSSES", "ST_DIFFERENCE", 
    "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE", 
    "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", "ST_GEOMCOLLFROMTXT", 
    "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", "ST_GEOMETRYCOLLECTIONFROMWKB", 
    "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", 
    "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", "ST_INTERIORRINGN", "ST_INTERSECTION", 
    "ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", 
    "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT", "ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", 
    "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", "ST_NUMPOINTS", "ST_OVERLAPS", 
    "ST_POINTFROMTEXT", "ST_POINTFROMWKB", "ST_POINTN", "ST_POLYFROMTEXT", 
    "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", "ST_POLYGONFROMWKB", "ST_SRID", 
    "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN", 
    "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", "SUBTIME", "SYSTEM_USER", 
    "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_FORMAT", "TIME_TO_SEC", 
    "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "TP_CONNECTION_ADMIN", 
    "UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", 
    "UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", 
    "VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR", 
    "WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN", 
    "PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", 
    "AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE", 
    "PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL", 
    "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP", 
    "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL", 
    "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB", 
    "REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING", 
    "FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL", 
    "DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL", 
    "BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID", 
    "HOST_IP_ADDRESS", "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION",
  }
  staticData.RuleNames = []string{
    "root", "sqlStatements", "sqlStatement", "emptyStatement_", "ddlStatement", 
    "dmlStatement", "transactionStatement", "replicationStatement", "preparedStatement", 
    "compoundStatement", "administrationStatement", "utilityStatement", 
    "createDatabase", "createEvent", "createIndex", "createLogfileGroup", 
    "createProcedure", "createFunction", "createRole", "createServer", "createTable", 
    "createTablespaceInnodb", "createTablespaceNdb", "createTrigger", "withClause", 
    "commonTableExpressions", "cteName", "cteColumnName", "createView", 
    "createDatabaseOption", "charSet", "currentUserExpression", "ownerStatement", 
    "scheduleExpression", "timestampValue", "intervalExpr", "intervalType", 
    "enableType", "indexType", "indexOption", "procedureParameter", "functionParameter", 
    "routineOption", "serverOption", "createDefinitions", "createDefinition", 
    "columnDefinition", "columnConstraint", "tableConstraint", "referenceDefinition", 
    "referenceAction", "referenceControlType", "indexColumnDefinition", 
    "tableOption", "tableType", "tablespaceStorage", "partitionDefinitions", 
    "partitionFunctionDefinition", "subpartitionFunctionDefinition", "partitionDefinition", 
    "partitionDefinerAtom", "partitionDefinerVector", "subpartitionDefinition", 
    "partitionOption", "alterDatabase", "alterEvent", "alterFunction", "alterInstance", 
    "alterLogfileGroup", "alterProcedure", "alterServer", "alterTable", 
    "alterTablespace", "alterView", "alterSpecification", "alterPartitionSpecification", 
    "dropDatabase", "dropEvent", "dropIndex", "dropLogfileGroup", "dropProcedure", 
    "dropFunction", "dropServer", "dropTable", "dropTablespace", "dropTrigger", 
    "dropView", "dropRole", "setRole", "renameTable", "renameTableClause", 
    "truncateTable", "callStatement", "deleteStatement", "doStatement", 
    "handlerStatement", "insertStatement", "loadDataStatement", "loadXmlStatement", 
    "replaceStatement", "selectStatement", "updateStatement", "valuesStatement", 
    "insertStatementValue", "updatedElement", "assignmentField", "lockClause", 
    "singleDeleteStatement", "multipleDeleteStatement", "handlerOpenStatement", 
    "handlerReadIndexStatement", "handlerReadStatement", "handlerCloseStatement", 
    "singleUpdateStatement", "multipleUpdateStatement", "orderByClause", 
    "orderByExpression", "tableSources", "tableSource", "tableSourceItem", 
    "indexHint", "indexHintType", "joinPart", "joinSpec", "queryExpression", 
    "queryExpressionNointo", "querySpecification", "proxyHint", "annotation", 
    "key", "value", "querySpecificationNointo", "unionParenthesis", "unionStatement", 
    "lateralStatement", "jsonTable", "jsonColumnList", "jsonColumn", "jsonOnEmpty", 
    "jsonOnError", "selectSpec", "selectElements", "selectElement", "selectIntoExpression", 
    "selectFieldsInto", "selectLinesInto", "fromClause", "groupByClause", 
    "havingClause", "windowClause", "groupByItem", "limitClause", "limitClauseAtom", 
    "startTransaction", "beginWork", "commitWork", "rollbackWork", "savepointStatement", 
    "rollbackStatement", "releaseStatement", "lockTables", "unlockTables", 
    "setAutocommitStatement", "setTransactionStatement", "transactionMode", 
    "lockTableElement", "lockAction", "transactionOption", "transactionLevel", 
    "changeMaster", "changeReplicationFilter", "purgeBinaryLogs", "resetMaster", 
    "resetSlave", "startSlave", "stopSlave", "startGroupReplication", "stopGroupReplication", 
    "masterOption", "stringMasterOption", "decimalMasterOption", "boolMasterOption", 
    "channelOption", "replicationFilter", "tablePair", "threadType", "untilOption", 
    "connectionOption", "gtuidSet", "xaStartTransaction", "xaEndTransaction", 
    "xaPrepareStatement", "xaCommitWork", "xaRollbackWork", "xaRecoverWork", 
    "prepareStatement", "executeStatement", "deallocatePrepare", "routineBody", 
    "blockStatement", "caseStatement", "ifStatement", "iterateStatement", 
    "leaveStatement", "loopStatement", "repeatStatement", "returnStatement", 
    "whileStatement", "cursorStatement", "declareVariable", "declareCondition", 
    "declareCursor", "declareHandler", "handlerConditionValue", "procedureSqlStatement", 
    "caseAlternative", "elifAlternative", "alterUser", "createUser", "dropUser", 
    "grantStatement", "roleOption", "grantProxy", "renameUser", "revokeStatement", 
    "revokeProxy", "setPasswordStatement", "userSpecification", "userAuthOption", 
    "authOptionClause", "authenticationRule", "tlsOption", "userResourceOption", 
    "userPasswordOption", "userLockOption", "privelegeClause", "privilege", 
    "privilegeLevel", "renameUserClause", "analyzeTable", "checkTable", 
    "checksumTable", "optimizeTable", "repairTable", "checkTableOption", 
    "createUdfunction", "installPlugin", "uninstallPlugin", "setStatement", 
    "showStatement", "variableClause", "showCommonEntity", "showFilter", 
    "showGlobalInfoClause", "showSchemaEntity", "showProfileType", "binlogStatement", 
    "cacheIndexStatement", "flushStatement", "killStatement", "loadIndexIntoCache", 
    "resetStatement", "shutdownStatement", "tableIndexes", "flushOption", 
    "flushTableOption", "loadedTableIndexes", "simpleDescribeStatement", 
    "fullDescribeStatement", "helpStatement", "useStatement", "signalStatement", 
    "resignalStatement", "signalConditionInformation", "withStatement", 
    "tableStatement", "diagnosticsStatement", "diagnosticsConditionInformationName", 
    "describeObjectClause", "fullId", "tableName", "roleName", "fullColumnName", 
    "indexColumnName", "simpleUserName", "hostName", "userName", "mysqlVariable", 
    "charsetName", "collationName", "engineName", "engineNameBase", "uuidSet", 
    "xid", "xuidStringId", "authPlugin", "uid", "simpleId", "dottedId", 
    "decimalLiteral", "fileSizeLiteral", "stringLiteral", "booleanLiteral", 
    "hexadecimalLiteral", "nullNotnull", "constant", "dataType", "collectionOptions", 
    "convertedDataType", "lengthOneDimension", "lengthTwoDimension", "lengthTwoOptionalDimension", 
    "uidList", "fullColumnNameList", "tables", "indexColumnNames", "expressions", 
    "expressionsWithDefaults", "constants", "simpleStrings", "userVariables", 
    "defaultValue", "currentTimestamp", "expressionOrDefault", "ifExists", 
    "ifNotExists", "orReplace", "waitNowaitClause", "functionCall", "specificFunction", 
    "caseFuncAlternative", "levelsInWeightString", "levelInWeightListElement", 
    "aggregateWindowedFunction", "nonAggregateWindowedFunction", "overClause", 
    "windowSpec", "windowName", "frameClause", "frameUnits", "frameExtent", 
    "frameBetween", "frameRange", "partitionClause", "scalarFunctionName", 
    "passwordFunctionClause", "functionArgs", "functionArg", "expression", 
    "predicate", "expressionAtom", "unaryOperator", "comparisonOperator", 
    "logicalOperator", "bitOperator", "multOperator", "addOperator", "jsonOperator", 
    "charsetNameBase", "transactionLevelBase", "privilegesBase", "intervalTypeBase", 
    "dataTypeBase", "keywordsCanBeId", "functionNameBase",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 1161, 7512, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 
	89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 
	7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 
	99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
	104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 
	108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 
	113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 
	117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 
	122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 
	126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 
	131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 
	135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 
	140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 
	144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 
	149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 
	153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 
	158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 
	162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 
	167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 
	171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 
	176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 
	180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 
	185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 
	189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 
	194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 
	198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 
	203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 
	207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 
	212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 
	216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 
	221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7, 
	225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 
	230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 
	234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 
	239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7, 
	243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2, 
	248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7, 
	252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2, 
	257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7, 
	261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2, 
	266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7, 
	270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2, 
	275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7, 
	279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2, 
	284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7, 
	288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2, 
	293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7, 
	297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2, 
	302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7, 
	306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2, 
	311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7, 
	315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2, 
	320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7, 
	324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2, 
	329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7, 
	333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2, 
	338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7, 
	342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2, 
	347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7, 
	351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2, 
	356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7, 
	360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 1, 
	0, 3, 0, 732, 8, 0, 1, 0, 1, 0, 3, 0, 736, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 
	1, 1, 3, 1, 743, 8, 1, 1, 1, 3, 1, 746, 8, 1, 1, 1, 5, 1, 749, 8, 1, 10, 
	1, 12, 1, 752, 9, 1, 1, 1, 1, 1, 1, 1, 3, 1, 757, 8, 1, 1, 1, 3, 1, 760, 
	8, 1, 1, 1, 3, 1, 763, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 
	3, 2, 772, 8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 
	1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 
	1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 
	1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 814, 8, 4, 1, 5, 1, 5, 
	1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 
	829, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 
	840, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 
	1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 857, 8, 7, 1, 8, 1, 8, 1, 8, 3, 8, 
	862, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 
	1, 9, 1, 9, 1, 9, 3, 9, 877, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 
	10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 
	1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 904, 
	8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 913, 8, 
	11, 1, 12, 1, 12, 1, 12, 3, 12, 918, 8, 12, 1, 12, 1, 12, 5, 12, 922, 8, 
	12, 10, 12, 12, 12, 925, 9, 12, 1, 13, 1, 13, 3, 13, 929, 8, 13, 1, 13, 
	1, 13, 3, 13, 933, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 
	13, 3, 13, 942, 8, 13, 1, 13, 3, 13, 945, 8, 13, 1, 13, 3, 13, 948, 8, 
	13, 1, 13, 1, 13, 3, 13, 952, 8, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 
	3, 14, 959, 8, 14, 1, 14, 3, 14, 962, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 
	967, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 973, 8, 14, 10, 14, 12, 
	14, 976, 9, 14, 1, 14, 1, 14, 3, 14, 980, 8, 14, 1, 14, 1, 14, 1, 14, 3, 
	14, 985, 8, 14, 1, 14, 5, 14, 988, 8, 14, 10, 14, 12, 14, 991, 9, 14, 1, 
	15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1002, 
	8, 15, 1, 15, 3, 15, 1005, 8, 15, 1, 15, 1, 15, 3, 15, 1009, 8, 15, 1, 
	15, 3, 15, 1012, 8, 15, 1, 15, 1, 15, 3, 15, 1016, 8, 15, 1, 15, 3, 15, 
	1019, 8, 15, 1, 15, 1, 15, 3, 15, 1023, 8, 15, 1, 15, 3, 15, 1026, 8, 15, 
	1, 15, 3, 15, 1029, 8, 15, 1, 15, 1, 15, 3, 15, 1033, 8, 15, 1, 15, 3, 
	15, 1036, 8, 15, 1, 15, 1, 15, 3, 15, 1040, 8, 15, 1, 15, 1, 15, 1, 16, 
	1, 16, 3, 16, 1046, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1052, 8, 
	16, 1, 16, 1, 16, 5, 16, 1056, 8, 16, 10, 16, 12, 16, 1059, 9, 16, 1, 16, 
	1, 16, 5, 16, 1063, 8, 16, 10, 16, 12, 16, 1066, 9, 16, 1, 16, 1, 16, 1, 
	17, 1, 17, 3, 17, 1072, 8, 17, 1, 17, 3, 17, 1075, 8, 17, 1, 17, 1, 17, 
	3, 17, 1079, 8, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1084, 8, 17, 1, 17, 1, 
	17, 5, 17, 1088, 8, 17, 10, 17, 12, 17, 1091, 9, 17, 1, 17, 1, 17, 1, 17, 
	1, 17, 5, 17, 1097, 8, 17, 10, 17, 12, 17, 1100, 9, 17, 1, 17, 1, 17, 3, 
	17, 1104, 8, 17, 1, 18, 1, 18, 1, 18, 3, 18, 1109, 8, 18, 1, 18, 1, 18, 
	1, 18, 5, 18, 1114, 8, 18, 10, 18, 12, 18, 1117, 9, 18, 1, 19, 1, 19, 1, 
	19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 
	1131, 8, 19, 10, 19, 12, 19, 1134, 9, 19, 1, 19, 1, 19, 1, 20, 1, 20, 3, 
	20, 1140, 8, 20, 1, 20, 1, 20, 3, 20, 1144, 8, 20, 1, 20, 1, 20, 1, 20, 
	1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1154, 8, 20, 1, 20, 1, 20, 3, 
	20, 1158, 8, 20, 1, 20, 1, 20, 3, 20, 1162, 8, 20, 1, 20, 1, 20, 3, 20, 
	1166, 8, 20, 1, 20, 1, 20, 3, 20, 1170, 8, 20, 1, 20, 5, 20, 1173, 8, 20, 
	10, 20, 12, 20, 1176, 9, 20, 3, 20, 1178, 8, 20, 1, 20, 3, 20, 1181, 8, 
	20, 1, 20, 3, 20, 1184, 8, 20, 1, 20, 3, 20, 1187, 8, 20, 1, 20, 1, 20, 
	1, 20, 1, 20, 3, 20, 1193, 8, 20, 1, 20, 1, 20, 3, 20, 1197, 8, 20, 1, 
	20, 1, 20, 1, 20, 1, 20, 3, 20, 1203, 8, 20, 1, 20, 5, 20, 1206, 8, 20, 
	10, 20, 12, 20, 1209, 9, 20, 3, 20, 1211, 8, 20, 1, 20, 3, 20, 1214, 8, 
	20, 3, 20, 1216, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 
	1, 21, 1, 21, 3, 21, 1227, 8, 21, 1, 21, 1, 21, 3, 21, 1231, 8, 21, 1, 
	21, 3, 21, 1234, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 
	1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1248, 8, 22, 1, 22, 3, 22, 1251, 
	8, 22, 1, 22, 1, 22, 3, 22, 1255, 8, 22, 1, 22, 3, 22, 1258, 8, 22, 1, 
	22, 1, 22, 3, 22, 1262, 8, 22, 1, 22, 3, 22, 1265, 8, 22, 1, 22, 1, 22, 
	3, 22, 1269, 8, 22, 1, 22, 3, 22, 1272, 8, 22, 1, 22, 1, 22, 3, 22, 1276, 
	8, 22, 1, 22, 3, 22, 1279, 8, 22, 1, 22, 3, 22, 1282, 8, 22, 1, 22, 1, 
	22, 3, 22, 1286, 8, 22, 1, 22, 3, 22, 1289, 8, 22, 1, 22, 1, 22, 3, 22, 
	1293, 8, 22, 1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 1299, 8, 23, 1, 23, 1, 
	23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 
	1312, 8, 23, 1, 23, 1, 23, 1, 24, 1, 24, 3, 24, 1318, 8, 24, 1, 24, 1, 
	24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 1327, 8, 25, 10, 25, 12, 
	25, 1330, 9, 25, 1, 25, 1, 25, 3, 25, 1334, 8, 25, 1, 25, 1, 25, 1, 25, 
	1, 25, 1, 25, 1, 25, 3, 25, 1342, 8, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 
	28, 1, 28, 3, 28, 1350, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1355, 8, 28, 
	1, 28, 3, 28, 1358, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1363, 8, 28, 1, 
	28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1371, 8, 28, 1, 28, 1, 28, 
	1, 28, 3, 28, 1376, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1382, 8, 
	28, 1, 28, 1, 28, 1, 28, 3, 28, 1387, 8, 28, 1, 28, 1, 28, 3, 28, 1391, 
	8, 28, 3, 28, 1393, 8, 28, 1, 29, 3, 29, 1396, 8, 29, 1, 29, 1, 29, 3, 
	29, 1400, 8, 29, 1, 29, 1, 29, 3, 29, 1404, 8, 29, 1, 29, 3, 29, 1407, 
	8, 29, 1, 29, 1, 29, 3, 29, 1411, 8, 29, 1, 29, 1, 29, 3, 29, 1415, 8, 
	29, 1, 29, 1, 29, 3, 29, 1419, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 
	1425, 8, 29, 1, 29, 3, 29, 1428, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 
	30, 3, 30, 1435, 8, 30, 1, 31, 1, 31, 1, 31, 3, 31, 1440, 8, 31, 1, 32, 
	1, 32, 1, 32, 1, 32, 3, 32, 1446, 8, 32, 1, 33, 1, 33, 1, 33, 5, 33, 1451, 
	8, 33, 10, 33, 12, 33, 1454, 9, 33, 1, 33, 1, 33, 1, 33, 3, 33, 1459, 8, 
	33, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1465, 8, 33, 10, 33, 12, 33, 1468, 
	9, 33, 3, 33, 1470, 8, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1475, 8, 33, 10, 
	33, 12, 33, 1478, 9, 33, 3, 33, 1480, 8, 33, 3, 33, 1482, 8, 33, 1, 34, 
	1, 34, 1, 34, 1, 34, 3, 34, 1488, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 3, 
	35, 1494, 8, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 
	1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 1511, 8, 36, 1, 
	37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1518, 8, 37, 1, 38, 1, 38, 1, 38, 
	1, 39, 1, 39, 3, 39, 1525, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 
	39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 1537, 8, 39, 1, 39, 1, 39, 1, 39, 
	3, 39, 1542, 8, 39, 1, 39, 3, 39, 1545, 8, 39, 1, 40, 3, 40, 1548, 8, 40, 
	1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 
	42, 3, 42, 1561, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 
	1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1574, 8, 42, 1, 42, 1, 42, 1, 42, 3, 
	42, 1579, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 
	1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1595, 8, 43, 1, 44, 1, 
	44, 1, 44, 1, 44, 5, 44, 1601, 8, 44, 10, 44, 12, 44, 1604, 9, 44, 1, 44, 
	1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1613, 8, 45, 1, 45, 3, 
	45, 1616, 8, 45, 1, 45, 3, 45, 1619, 8, 45, 1, 46, 1, 46, 5, 46, 1623, 
	8, 46, 10, 46, 12, 46, 1626, 9, 46, 1, 46, 3, 46, 1629, 8, 46, 1, 46, 3, 
	46, 1632, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 
	1, 47, 3, 47, 1643, 8, 47, 1, 47, 3, 47, 1646, 8, 47, 1, 47, 1, 47, 1, 
	47, 3, 47, 1651, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 
	1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1664, 8, 47, 1, 47, 1, 47, 1, 47, 1, 
	47, 1, 47, 3, 47, 1671, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 
	1678, 8, 47, 3, 47, 1680, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 
	47, 1687, 8, 47, 1, 48, 1, 48, 3, 48, 1691, 8, 48, 3, 48, 1693, 8, 48, 
	1, 48, 1, 48, 1, 48, 3, 48, 1698, 8, 48, 1, 48, 3, 48, 1701, 8, 48, 1, 
	48, 1, 48, 5, 48, 1705, 8, 48, 10, 48, 12, 48, 1708, 9, 48, 1, 48, 1, 48, 
	3, 48, 1712, 8, 48, 3, 48, 1714, 8, 48, 1, 48, 1, 48, 3, 48, 1718, 8, 48, 
	1, 48, 3, 48, 1721, 8, 48, 1, 48, 3, 48, 1724, 8, 48, 1, 48, 1, 48, 5, 
	48, 1728, 8, 48, 10, 48, 12, 48, 1731, 9, 48, 1, 48, 1, 48, 3, 48, 1735, 
	8, 48, 3, 48, 1737, 8, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1742, 8, 48, 1, 
	48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1749, 8, 48, 3, 48, 1751, 8, 48, 
	1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1758, 8, 48, 1, 49, 1, 49, 1, 
	49, 3, 49, 1763, 8, 49, 1, 49, 1, 49, 3, 49, 1767, 8, 49, 1, 49, 3, 49, 
	1770, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1778, 8, 
	50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1786, 8, 50, 3, 50, 
	1788, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 
	51, 1798, 8, 51, 1, 52, 1, 52, 3, 52, 1802, 8, 52, 1, 52, 3, 52, 1805, 
	8, 52, 1, 52, 1, 52, 5, 52, 1809, 8, 52, 10, 52, 12, 52, 1812, 9, 52, 1, 
	52, 1, 52, 3, 52, 1816, 8, 52, 1, 52, 3, 52, 1819, 8, 52, 1, 52, 1, 52, 
	5, 52, 1823, 8, 52, 10, 52, 12, 52, 1826, 9, 52, 3, 52, 1828, 8, 52, 1, 
	53, 1, 53, 3, 53, 1832, 8, 53, 1, 53, 3, 53, 1835, 8, 53, 1, 53, 1, 53, 
	3, 53, 1839, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1844, 8, 53, 1, 53, 1, 
	53, 1, 53, 3, 53, 1849, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1854, 8, 53, 
	1, 53, 1, 53, 3, 53, 1858, 8, 53, 1, 53, 1, 53, 3, 53, 1862, 8, 53, 1, 
	53, 1, 53, 3, 53, 1866, 8, 53, 1, 53, 1, 53, 3, 53, 1870, 8, 53, 1, 53, 
	1, 53, 3, 53, 1874, 8, 53, 1, 53, 1, 53, 3, 53, 1878, 8, 53, 1, 53, 1, 
	53, 1, 53, 3, 53, 1883, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1888, 8, 53, 
	1, 53, 1, 53, 1, 53, 3, 53, 1893, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 
	53, 1899, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1904, 8, 53, 1, 53, 1, 53, 
	1, 53, 3, 53, 1909, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1914, 8, 53, 1, 
	53, 1, 53, 1, 53, 3, 53, 1919, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1924, 
	8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1930, 8, 53, 1, 53, 1, 53, 1, 
	53, 3, 53, 1935, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1940, 8, 53, 1, 53, 
	1, 53, 1, 53, 3, 53, 1945, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1950, 8, 
	53, 1, 53, 1, 53, 1, 53, 3, 53, 1955, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 
	1960, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1965, 8, 53, 1, 53, 1, 53, 1, 
	53, 1, 53, 1, 53, 3, 53, 1972, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1977, 
	8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1982, 8, 53, 1, 53, 1, 53, 1, 53, 3, 
	53, 1987, 8, 53, 1, 53, 1, 53, 3, 53, 1991, 8, 53, 1, 53, 1, 53, 1, 53, 
	3, 53, 1996, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 2004, 
	8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 2009, 8, 53, 1, 53, 1, 53, 1, 53, 1, 
	53, 3, 53, 2015, 8, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 
	1, 56, 1, 56, 1, 56, 3, 56, 2027, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 
	56, 3, 56, 2034, 8, 56, 3, 56, 2036, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 
	5, 56, 2042, 8, 56, 10, 56, 12, 56, 2045, 9, 56, 1, 56, 1, 56, 3, 56, 2049, 
	8, 56, 1, 57, 3, 57, 2052, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 
	57, 3, 57, 2060, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2066, 8, 57, 
	1, 57, 1, 57, 3, 57, 2070, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 
	57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2083, 8, 57, 1, 57, 1, 57, 
	1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2095, 8, 
	57, 3, 57, 2097, 8, 57, 1, 58, 3, 58, 2100, 8, 58, 1, 58, 1, 58, 1, 58, 
	1, 58, 1, 58, 1, 58, 3, 58, 2108, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 
	58, 2114, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 2120, 8, 58, 1, 59, 
	1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2131, 8, 
	59, 10, 59, 12, 59, 2134, 9, 59, 1, 59, 1, 59, 5, 59, 2138, 8, 59, 10, 
	59, 12, 59, 2141, 9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2147, 8, 59, 
	10, 59, 12, 59, 2150, 9, 59, 1, 59, 1, 59, 3, 59, 2154, 8, 59, 1, 59, 1, 
	59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2163, 8, 59, 10, 59, 12, 
	59, 2166, 9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2172, 8, 59, 10, 59, 
	12, 59, 2175, 9, 59, 1, 59, 1, 59, 3, 59, 2179, 8, 59, 1, 59, 1, 59, 1, 
	59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2189, 8, 59, 10, 59, 12, 
	59, 2192, 9, 59, 1, 59, 1, 59, 5, 59, 2196, 8, 59, 10, 59, 12, 59, 2199, 
	9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2205, 8, 59, 10, 59, 12, 59, 
	2208, 9, 59, 1, 59, 1, 59, 3, 59, 2212, 8, 59, 1, 59, 1, 59, 1, 59, 1, 
	59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2222, 8, 59, 10, 59, 12, 59, 2225, 
	9, 59, 1, 59, 1, 59, 5, 59, 2229, 8, 59, 10, 59, 12, 59, 2232, 9, 59, 1, 
	59, 1, 59, 1, 59, 1, 59, 5, 59, 2238, 8, 59, 10, 59, 12, 59, 2241, 9, 59, 
	1, 59, 1, 59, 3, 59, 2245, 8, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2250, 8, 
	59, 10, 59, 12, 59, 2253, 9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2259, 
	8, 59, 10, 59, 12, 59, 2262, 9, 59, 1, 59, 1, 59, 3, 59, 2266, 8, 59, 3, 
	59, 2268, 8, 59, 1, 60, 1, 60, 1, 60, 3, 60, 2273, 8, 60, 1, 61, 1, 61, 
	1, 61, 1, 61, 4, 61, 2279, 8, 61, 11, 61, 12, 61, 2280, 1, 61, 1, 61, 1, 
	62, 1, 62, 1, 62, 5, 62, 2288, 8, 62, 10, 62, 12, 62, 2291, 9, 62, 1, 63, 
	3, 63, 2294, 8, 63, 1, 63, 3, 63, 2297, 8, 63, 1, 63, 1, 63, 3, 63, 2301, 
	8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2306, 8, 63, 1, 63, 1, 63, 1, 63, 1, 
	63, 3, 63, 2312, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2318, 8, 63, 
	1, 63, 1, 63, 1, 63, 3, 63, 2323, 8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2328, 
	8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2333, 8, 63, 1, 63, 1, 63, 1, 63, 3, 
	63, 2338, 8, 63, 1, 63, 3, 63, 2341, 8, 63, 1, 64, 1, 64, 1, 64, 3, 64, 
	2346, 8, 64, 1, 64, 4, 64, 2349, 8, 64, 11, 64, 12, 64, 2350, 1, 64, 1, 
	64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2361, 8, 64, 1, 65, 
	1, 65, 3, 65, 2365, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2372, 
	8, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2377, 8, 65, 1, 65, 3, 65, 2380, 8, 
	65, 1, 65, 1, 65, 1, 65, 3, 65, 2385, 8, 65, 1, 65, 3, 65, 2388, 8, 65, 
	1, 65, 1, 65, 3, 65, 2392, 8, 65, 1, 65, 1, 65, 3, 65, 2396, 8, 65, 1, 
	66, 1, 66, 1, 66, 1, 66, 5, 66, 2402, 8, 66, 10, 66, 12, 66, 2405, 9, 66, 
	1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 
	68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 2423, 8, 68, 1, 68, 3, 68, 
	2426, 8, 68, 1, 68, 3, 68, 2429, 8, 68, 1, 68, 1, 68, 3, 68, 2433, 8, 68, 
	1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 5, 69, 2441, 8, 69, 10, 69, 12, 
	69, 2444, 9, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 
	5, 70, 2454, 8, 70, 10, 70, 12, 70, 2457, 9, 70, 1, 70, 1, 70, 1, 71, 1, 
	71, 3, 71, 2463, 8, 71, 1, 71, 3, 71, 2466, 8, 71, 1, 71, 1, 71, 1, 71, 
	3, 71, 2471, 8, 71, 1, 71, 1, 71, 1, 71, 5, 71, 2476, 8, 71, 10, 71, 12, 
	71, 2479, 9, 71, 3, 71, 2481, 8, 71, 1, 71, 3, 71, 2484, 8, 71, 1, 72, 
	1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2495, 8, 
	72, 1, 72, 3, 72, 2498, 8, 72, 1, 72, 1, 72, 3, 72, 2502, 8, 72, 1, 72, 
	1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2510, 8, 73, 1, 73, 3, 73, 2513, 
	8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2518, 8, 73, 1, 73, 1, 73, 1, 73, 1, 
	73, 1, 73, 1, 73, 3, 73, 2526, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 
	2532, 8, 73, 1, 73, 1, 73, 3, 73, 2536, 8, 73, 1, 74, 1, 74, 3, 74, 2540, 
	8, 74, 1, 74, 5, 74, 2543, 8, 74, 10, 74, 12, 74, 2546, 9, 74, 1, 74, 1, 
	74, 3, 74, 2550, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2557, 
	8, 74, 1, 74, 1, 74, 3, 74, 2561, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 
	74, 1, 74, 1, 74, 5, 74, 2570, 8, 74, 10, 74, 12, 74, 2573, 9, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2580, 8, 74, 1, 74, 3, 74, 2583, 8, 
	74, 1, 74, 1, 74, 5, 74, 2587, 8, 74, 10, 74, 12, 74, 2590, 9, 74, 1, 74, 
	1, 74, 1, 74, 3, 74, 2595, 8, 74, 3, 74, 2597, 8, 74, 1, 74, 1, 74, 1, 
	74, 3, 74, 2602, 8, 74, 1, 74, 3, 74, 2605, 8, 74, 1, 74, 1, 74, 5, 74, 
	2609, 8, 74, 10, 74, 12, 74, 2612, 9, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2617, 
	8, 74, 3, 74, 2619, 8, 74, 1, 74, 1, 74, 3, 74, 2623, 8, 74, 1, 74, 3, 
	74, 2626, 8, 74, 1, 74, 3, 74, 2629, 8, 74, 1, 74, 1, 74, 5, 74, 2633, 
	8, 74, 10, 74, 12, 74, 2636, 9, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2641, 8, 
	74, 1, 74, 3, 74, 2644, 8, 74, 1, 74, 1, 74, 5, 74, 2648, 8, 74, 10, 74, 
	12, 74, 2651, 9, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2656, 8, 74, 3, 74, 2658, 
	8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2663, 8, 74, 1, 74, 1, 74, 1, 74, 1, 
	74, 1, 74, 1, 74, 3, 74, 2671, 8, 74, 3, 74, 2673, 8, 74, 1, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2682, 8, 74, 1, 74, 3, 74, 2685, 
	8, 74, 1, 74, 3, 74, 2688, 8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2693, 8, 
	74, 3, 74, 2695, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 
	3, 74, 2704, 8, 74, 1, 74, 3, 74, 2707, 8, 74, 1, 74, 3, 74, 2710, 8, 74, 
	1, 74, 1, 74, 1, 74, 3, 74, 2715, 8, 74, 3, 74, 2717, 8, 74, 1, 74, 1, 
	74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2726, 8, 74, 1, 74, 1, 74, 
	1, 74, 3, 74, 2731, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 
	74, 2739, 8, 74, 1, 74, 1, 74, 3, 74, 2743, 8, 74, 1, 74, 1, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 3, 74, 2751, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 
	74, 1, 74, 1, 74, 1, 74, 3, 74, 2761, 8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 
	2766, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2773, 8, 74, 1, 
	74, 1, 74, 3, 74, 2777, 8, 74, 1, 74, 1, 74, 3, 74, 2781, 8, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 
	74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2800, 8, 74, 1, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2810, 8, 74, 1, 74, 1, 
	74, 1, 74, 1, 74, 3, 74, 2816, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 
	74, 2833, 8, 74, 1, 74, 1, 74, 3, 74, 2837, 8, 74, 1, 74, 1, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2847, 8, 74, 1, 74, 1, 74, 1, 
	74, 3, 74, 2852, 8, 74, 1, 74, 3, 74, 2855, 8, 74, 1, 74, 1, 74, 1, 74, 
	1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2864, 8, 74, 1, 74, 1, 74, 1, 74, 1, 
	74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2875, 8, 74, 1, 74, 1, 74, 
	1, 74, 1, 74, 5, 74, 2881, 8, 74, 10, 74, 12, 74, 2884, 9, 74, 1, 74, 1, 
	74, 1, 74, 3, 74, 2889, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 
	5, 75, 2897, 8, 75, 10, 75, 12, 75, 2900, 9, 75, 1, 75, 1, 75, 1, 75, 1, 
	75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2911, 8, 75, 1, 75, 1, 75, 
	1, 75, 1, 75, 1, 75, 3, 75, 2918, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 
	75, 3, 75, 2925, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 
	1, 75, 1, 75, 1, 75, 1, 75, 5, 75, 2938, 8, 75, 10, 75, 12, 75, 2941, 9, 
	75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 
	3, 75, 2953, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2959, 8, 75, 1, 
	75, 1, 75, 1, 75, 1, 75, 3, 75, 2965, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 
	3, 75, 2971, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2977, 8, 75, 1, 
	75, 1, 75, 1, 75, 1, 75, 3, 75, 2983, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 
	3, 75, 2989, 8, 75, 1, 76, 1, 76, 1, 76, 3, 76, 2994, 8, 76, 1, 76, 1, 
	76, 1, 77, 1, 77, 1, 77, 3, 77, 3001, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 
	1, 78, 3, 78, 3008, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 3015, 
	8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 3020, 8, 78, 1, 78, 5, 78, 3023, 8, 
	78, 10, 78, 12, 78, 3026, 9, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 
	79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 3, 80, 3039, 8, 80, 1, 80, 1, 80, 
	1, 81, 1, 81, 1, 81, 3, 81, 3046, 8, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 
	82, 3, 82, 3053, 8, 82, 1, 82, 1, 82, 1, 83, 1, 83, 3, 83, 3059, 8, 83, 
	1, 83, 1, 83, 3, 83, 3063, 8, 83, 1, 83, 1, 83, 3, 83, 3067, 8, 83, 1, 
	84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 3074, 8, 84, 1, 84, 3, 84, 3077, 
	8, 84, 1, 85, 1, 85, 1, 85, 3, 85, 3082, 8, 85, 1, 85, 1, 85, 1, 86, 1, 
	86, 1, 86, 3, 86, 3089, 8, 86, 1, 86, 1, 86, 1, 86, 5, 86, 3094, 8, 86, 
	10, 86, 12, 86, 3097, 9, 86, 1, 86, 3, 86, 3100, 8, 86, 1, 87, 1, 87, 1, 
	87, 3, 87, 3105, 8, 87, 1, 87, 1, 87, 1, 87, 5, 87, 3110, 8, 87, 10, 87, 
	12, 87, 3113, 9, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 
	88, 5, 88, 3123, 8, 88, 10, 88, 12, 88, 3126, 9, 88, 3, 88, 3128, 8, 88, 
	1, 88, 1, 88, 1, 88, 3, 88, 3133, 8, 88, 1, 88, 1, 88, 1, 88, 3, 88, 3138, 
	8, 88, 5, 88, 3140, 8, 88, 10, 88, 12, 88, 3143, 9, 88, 1, 88, 1, 88, 1, 
	88, 3, 88, 3148, 8, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 3155, 
	8, 89, 10, 89, 12, 89, 3158, 9, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 
	1, 91, 3, 91, 3166, 8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 
	92, 3, 92, 3175, 8, 92, 1, 92, 3, 92, 3178, 8, 92, 1, 93, 1, 93, 3, 93, 
	3182, 8, 93, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 3191, 
	8, 95, 1, 96, 1, 96, 3, 96, 3195, 8, 96, 1, 96, 3, 96, 3198, 8, 96, 1, 
	96, 3, 96, 3201, 8, 96, 1, 96, 3, 96, 3204, 8, 96, 1, 96, 1, 96, 1, 96, 
	1, 96, 3, 96, 3210, 8, 96, 1, 96, 3, 96, 3213, 8, 96, 1, 96, 1, 96, 3, 
	96, 3217, 8, 96, 1, 96, 3, 96, 3220, 8, 96, 1, 96, 1, 96, 3, 96, 3224, 
	8, 96, 1, 96, 3, 96, 3227, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 3233, 
	8, 96, 10, 96, 12, 96, 3236, 9, 96, 3, 96, 3238, 8, 96, 1, 96, 1, 96, 1, 
	96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 3247, 8, 96, 10, 96, 12, 96, 3250, 
	9, 96, 3, 96, 3252, 8, 96, 1, 97, 1, 97, 1, 97, 3, 97, 3257, 8, 97, 1, 
	97, 3, 97, 3260, 8, 97, 1, 97, 1, 97, 1, 97, 3, 97, 3265, 8, 97, 1, 97, 
	1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 3275, 8, 97, 1, 
	97, 1, 97, 1, 97, 3, 97, 3280, 8, 97, 1, 97, 1, 97, 4, 97, 3284, 8, 97, 
	11, 97, 12, 97, 3285, 3, 97, 3288, 8, 97, 1, 97, 1, 97, 4, 97, 3292, 8, 
	97, 11, 97, 12, 97, 3293, 3, 97, 3296, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 
	3, 97, 3302, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97, 3308, 8, 97, 10, 
	97, 12, 97, 3311, 9, 97, 1, 97, 1, 97, 3, 97, 3315, 8, 97, 1, 97, 1, 97, 
	1, 97, 1, 97, 5, 97, 3321, 8, 97, 10, 97, 12, 97, 3324, 9, 97, 3, 97, 3326, 
	8, 97, 1, 98, 1, 98, 1, 98, 3, 98, 3331, 8, 98, 1, 98, 3, 98, 3334, 8, 
	98, 1, 98, 1, 98, 1, 98, 3, 98, 3339, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 
	1, 98, 1, 98, 3, 98, 3347, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 
	98, 3, 98, 3355, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 3361, 8, 98, 
	1, 98, 1, 98, 1, 98, 1, 98, 5, 98, 3367, 8, 98, 10, 98, 12, 98, 3370, 9, 
	98, 1, 98, 1, 98, 3, 98, 3374, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 5, 98, 
	3380, 8, 98, 10, 98, 12, 98, 3383, 9, 98, 3, 98, 3385, 8, 98, 1, 99, 1, 
	99, 3, 99, 3389, 8, 99, 1, 99, 3, 99, 3392, 8, 99, 1, 99, 1, 99, 1, 99, 
	1, 99, 1, 99, 1, 99, 3, 99, 3400, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 
	99, 3406, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 5, 99, 3413, 8, 99, 
	10, 99, 12, 99, 3416, 9, 99, 3, 99, 3418, 8, 99, 1, 100, 1, 100, 3, 100, 
	3422, 8, 100, 1, 100, 1, 100, 3, 100, 3426, 8, 100, 1, 100, 1, 100, 3, 
	100, 3430, 8, 100, 1, 100, 4, 100, 3433, 8, 100, 11, 100, 12, 100, 3434, 
	1, 100, 1, 100, 3, 100, 3439, 8, 100, 1, 100, 1, 100, 3, 100, 3443, 8, 
	100, 3, 100, 3445, 8, 100, 1, 100, 3, 100, 3448, 8, 100, 1, 100, 3, 100, 
	3451, 8, 100, 1, 100, 3, 100, 3454, 8, 100, 1, 100, 1, 100, 4, 100, 3458, 
	8, 100, 11, 100, 12, 100, 3459, 1, 100, 1, 100, 3, 100, 3464, 8, 100, 1, 
	100, 3, 100, 3467, 8, 100, 1, 100, 3, 100, 3470, 8, 100, 1, 100, 3, 100, 
	3473, 8, 100, 1, 100, 3, 100, 3476, 8, 100, 1, 100, 1, 100, 1, 100, 4, 
	100, 3481, 8, 100, 11, 100, 12, 100, 3482, 3, 100, 3485, 8, 100, 1, 101, 
	1, 101, 3, 101, 3489, 8, 101, 1, 102, 1, 102, 1, 102, 3, 102, 3494, 8, 
	102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 3500, 8, 102, 1, 102, 5, 102, 
	3503, 8, 102, 10, 102, 12, 102, 3506, 9, 102, 1, 103, 1, 103, 1, 103, 1, 
	103, 3, 103, 3512, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 3518, 
	8, 103, 1, 103, 5, 103, 3521, 8, 103, 10, 103, 12, 103, 3524, 9, 103, 3, 
	103, 3526, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 3532, 8, 104, 
	1, 105, 1, 105, 3, 105, 3536, 8, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 
	106, 1, 106, 3, 106, 3544, 8, 106, 1, 107, 1, 107, 3, 107, 3548, 8, 107, 
	1, 107, 3, 107, 3551, 8, 107, 1, 107, 3, 107, 3554, 8, 107, 1, 107, 3, 
	107, 3557, 8, 107, 1, 107, 1, 107, 1, 107, 3, 107, 3562, 8, 107, 1, 107, 
	3, 107, 3565, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 3572, 
	8, 107, 1, 107, 1, 107, 3, 107, 3576, 8, 107, 1, 107, 3, 107, 3579, 8, 
	107, 1, 107, 1, 107, 3, 107, 3583, 8, 107, 1, 108, 1, 108, 3, 108, 3587, 
	8, 108, 1, 108, 3, 108, 3590, 8, 108, 1, 108, 3, 108, 3593, 8, 108, 1, 
	108, 3, 108, 3596, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3601, 8, 108, 
	1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3607, 8, 108, 5, 108, 3609, 8, 
	108, 10, 108, 12, 108, 3612, 9, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 
	108, 1, 108, 1, 108, 3, 108, 3621, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 
	3, 108, 3627, 8, 108, 5, 108, 3629, 8, 108, 10, 108, 12, 108, 3632, 9, 
	108, 1, 108, 1, 108, 1, 108, 3, 108, 3637, 8, 108, 1, 108, 1, 108, 3, 108, 
	3641, 8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 3647, 8, 109, 1, 
	109, 3, 109, 3650, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 
	1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 3662, 8, 110, 1, 110, 1, 110, 3, 
	110, 3666, 8, 110, 1, 110, 1, 110, 3, 110, 3670, 8, 110, 1, 111, 1, 111, 
	1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 3678, 8, 111, 1, 111, 1, 111, 3, 
	111, 3682, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 3, 113, 
	3690, 8, 113, 1, 113, 3, 113, 3693, 8, 113, 1, 113, 3, 113, 3696, 8, 113, 
	1, 113, 1, 113, 3, 113, 3700, 8, 113, 1, 113, 3, 113, 3703, 8, 113, 1, 
	113, 1, 113, 1, 113, 1, 113, 5, 113, 3709, 8, 113, 10, 113, 12, 113, 3712, 
	9, 113, 1, 113, 1, 113, 3, 113, 3716, 8, 113, 1, 113, 3, 113, 3719, 8, 
	113, 1, 113, 3, 113, 3722, 8, 113, 1, 114, 1, 114, 3, 114, 3726, 8, 114, 
	1, 114, 3, 114, 3729, 8, 114, 1, 114, 3, 114, 3732, 8, 114, 1, 114, 1, 
	114, 1, 114, 1, 114, 1, 114, 5, 114, 3739, 8, 114, 10, 114, 12, 114, 3742, 
	9, 114, 1, 114, 1, 114, 3, 114, 3746, 8, 114, 1, 115, 1, 115, 1, 115, 1, 
	115, 1, 115, 5, 115, 3753, 8, 115, 10, 115, 12, 115, 3756, 9, 115, 1, 116, 
	1, 116, 3, 116, 3760, 8, 116, 1, 117, 1, 117, 1, 117, 5, 117, 3765, 8, 
	117, 10, 117, 12, 117, 3768, 9, 117, 1, 118, 1, 118, 5, 118, 3772, 8, 118, 
	10, 118, 12, 118, 3775, 9, 118, 1, 118, 1, 118, 1, 118, 5, 118, 3780, 8, 
	118, 10, 118, 12, 118, 3783, 9, 118, 1, 118, 1, 118, 1, 118, 3, 118, 3788, 
	8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 3796, 8, 
	119, 1, 119, 3, 119, 3799, 8, 119, 1, 119, 3, 119, 3802, 8, 119, 1, 119, 
	1, 119, 1, 119, 5, 119, 3807, 8, 119, 10, 119, 12, 119, 3810, 9, 119, 3, 
	119, 3812, 8, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 3819, 
	8, 119, 1, 119, 3, 119, 3822, 8, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 
	119, 1, 119, 3, 119, 3830, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 
	3836, 8, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121, 1, 
	121, 1, 121, 3, 121, 3847, 8, 121, 1, 122, 3, 122, 3850, 8, 122, 1, 122, 
	1, 122, 3, 122, 3854, 8, 122, 1, 122, 1, 122, 5, 122, 3858, 8, 122, 10, 
	122, 12, 122, 3861, 9, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 3867, 
	8, 122, 10, 122, 12, 122, 3870, 9, 122, 1, 122, 1, 122, 3, 122, 3874, 8, 
	122, 1, 122, 1, 122, 3, 122, 3878, 8, 122, 1, 122, 1, 122, 5, 122, 3882, 
	8, 122, 10, 122, 12, 122, 3885, 9, 122, 1, 122, 1, 122, 1, 122, 3, 122, 
	3890, 8, 122, 3, 122, 3892, 8, 122, 1, 122, 1, 122, 3, 122, 3896, 8, 122, 
	1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 3905, 8, 
	123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 
	124, 3915, 8, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 
	1, 125, 3, 125, 3925, 8, 125, 1, 126, 1, 126, 3, 126, 3929, 8, 126, 1, 
	126, 5, 126, 3932, 8, 126, 10, 126, 12, 126, 3935, 9, 126, 1, 126, 1, 126, 
	3, 126, 3939, 8, 126, 1, 126, 1, 126, 3, 126, 3943, 8, 126, 1, 126, 3, 
	126, 3946, 8, 126, 1, 126, 3, 126, 3949, 8, 126, 1, 126, 3, 126, 3952, 
	8, 126, 1, 126, 3, 126, 3955, 8, 126, 1, 126, 1, 126, 3, 126, 3959, 8, 
	126, 1, 126, 5, 126, 3962, 8, 126, 10, 126, 12, 126, 3965, 9, 126, 1, 126, 
	1, 126, 1, 126, 3, 126, 3970, 8, 126, 1, 126, 3, 126, 3973, 8, 126, 1, 
	126, 3, 126, 3976, 8, 126, 1, 126, 3, 126, 3979, 8, 126, 1, 126, 3, 126, 
	3982, 8, 126, 1, 126, 3, 126, 3985, 8, 126, 3, 126, 3987, 8, 126, 1, 127, 
	1, 127, 4, 127, 3991, 8, 127, 11, 127, 12, 127, 3992, 1, 127, 1, 127, 1, 
	128, 1, 128, 1, 128, 1, 128, 3, 128, 4001, 8, 128, 1, 129, 1, 129, 1, 129, 
	1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 3, 129, 4012, 8, 129, 1, 
	130, 1, 130, 1, 131, 1, 131, 5, 131, 4018, 8, 131, 10, 131, 12, 131, 4021, 
	9, 131, 1, 131, 1, 131, 1, 131, 3, 131, 4026, 8, 131, 1, 131, 3, 131, 4029, 
	8, 131, 1, 131, 3, 131, 4032, 8, 131, 1, 131, 3, 131, 4035, 8, 131, 1, 
	131, 3, 131, 4038, 8, 131, 1, 131, 3, 131, 4041, 8, 131, 1, 132, 1, 132, 
	3, 132, 4045, 8, 132, 1, 132, 1, 132, 1, 133, 1, 133, 3, 133, 4051, 8, 
	133, 1, 133, 1, 133, 3, 133, 4055, 8, 133, 1, 134, 1, 134, 1, 134, 1, 134, 
	1, 134, 1, 134, 3, 134, 4063, 8, 134, 1, 134, 1, 134, 3, 134, 4067, 8, 
	134, 1, 134, 3, 134, 4070, 8, 134, 3, 134, 4072, 8, 134, 1, 135, 1, 135, 
	1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 
	3, 135, 4085, 8, 135, 1, 135, 3, 135, 4088, 8, 135, 1, 136, 1, 136, 1, 
	136, 5, 136, 4093, 8, 136, 10, 136, 12, 136, 4096, 9, 136, 1, 137, 1, 137, 
	1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 4105, 8, 137, 1, 137, 3, 
	137, 4108, 8, 137, 1, 137, 1, 137, 1, 137, 3, 137, 4113, 8, 137, 3, 137, 
	4115, 8, 137, 1, 137, 1, 137, 3, 137, 4119, 8, 137, 1, 137, 1, 137, 1, 
	137, 1, 137, 1, 137, 1, 137, 3, 137, 4127, 8, 137, 1, 138, 1, 138, 1, 138, 
	1, 138, 3, 138, 4133, 8, 138, 1, 138, 1, 138, 1, 138, 1, 139, 1, 139, 1, 
	139, 1, 139, 3, 139, 4142, 8, 139, 1, 139, 1, 139, 1, 139, 1, 140, 1, 140, 
	1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 4155, 8, 140, 1, 
	141, 1, 141, 3, 141, 4159, 8, 141, 1, 141, 1, 141, 5, 141, 4163, 8, 141, 
	10, 141, 12, 141, 4166, 9, 141, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 
	1, 142, 3, 142, 4174, 8, 142, 1, 142, 3, 142, 4177, 8, 142, 1, 142, 1, 
	142, 3, 142, 4181, 8, 142, 1, 142, 3, 142, 4184, 8, 142, 1, 142, 1, 142, 
	3, 142, 4188, 8, 142, 1, 142, 1, 142, 3, 142, 4192, 8, 142, 1, 142, 3, 
	142, 4195, 8, 142, 3, 142, 4197, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 
	5, 143, 4203, 8, 143, 10, 143, 12, 143, 4206, 9, 143, 1, 143, 1, 143, 1, 
	143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 4217, 8, 143, 
	1, 143, 1, 143, 4, 143, 4221, 8, 143, 11, 143, 12, 143, 4222, 3, 143, 4225, 
	8, 143, 1, 143, 1, 143, 4, 143, 4229, 8, 143, 11, 143, 12, 143, 4230, 3, 
	143, 4233, 8, 143, 3, 143, 4235, 8, 143, 1, 144, 1, 144, 1, 144, 1, 144, 
	3, 144, 4241, 8, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 
	144, 4249, 8, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 
	4257, 8, 145, 1, 146, 1, 146, 3, 146, 4261, 8, 146, 1, 146, 1, 146, 3, 
	146, 4265, 8, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 5, 147, 4272, 
	8, 147, 10, 147, 12, 147, 4275, 9, 147, 1, 147, 1, 147, 3, 147, 4279, 8, 
	147, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 
	149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 5, 149, 4297, 
	8, 149, 10, 149, 12, 149, 4300, 9, 149, 1, 150, 1, 150, 3, 150, 4304, 8, 
	150, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 4310, 8, 151, 1, 151, 1, 151, 
	1, 151, 1, 151, 1, 151, 3, 151, 4317, 8, 151, 1, 152, 1, 152, 1, 152, 3, 
	152, 4322, 8, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 5, 153, 4329, 
	8, 153, 10, 153, 12, 153, 4332, 9, 153, 3, 153, 4334, 8, 153, 1, 154, 1, 
	154, 3, 154, 4338, 8, 154, 1, 154, 3, 154, 4341, 8, 154, 1, 155, 1, 155, 
	3, 155, 4345, 8, 155, 1, 155, 1, 155, 3, 155, 4349, 8, 155, 1, 155, 3, 
	155, 4352, 8, 155, 1, 155, 3, 155, 4355, 8, 155, 1, 155, 3, 155, 4358, 
	8, 155, 1, 155, 3, 155, 4361, 8, 155, 1, 156, 1, 156, 3, 156, 4365, 8, 
	156, 1, 156, 1, 156, 3, 156, 4369, 8, 156, 1, 156, 3, 156, 4372, 8, 156, 
	1, 156, 3, 156, 4375, 8, 156, 1, 156, 3, 156, 4378, 8, 156, 1, 156, 3, 
	156, 4381, 8, 156, 1, 157, 1, 157, 1, 157, 1, 158, 1, 158, 3, 158, 4388, 
	8, 158, 1, 158, 1, 158, 3, 158, 4392, 8, 158, 1, 158, 1, 158, 1, 159, 1, 
	159, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 5, 160, 4405, 
	8, 160, 10, 160, 12, 160, 4408, 9, 160, 1, 160, 3, 160, 4411, 8, 160, 1, 
	161, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 163, 1, 
	163, 3, 163, 4423, 8, 163, 1, 163, 1, 163, 1, 163, 1, 163, 5, 163, 4429, 
	8, 163, 10, 163, 12, 163, 4432, 9, 163, 1, 164, 1, 164, 1, 164, 1, 164, 
	1, 164, 1, 164, 1, 164, 3, 164, 4441, 8, 164, 1, 165, 1, 165, 3, 165, 4445, 
	8, 165, 1, 165, 3, 165, 4448, 8, 165, 1, 165, 1, 165, 1, 166, 1, 166, 3, 
	166, 4454, 8, 166, 1, 166, 3, 166, 4457, 8, 166, 1, 166, 3, 166, 4460, 
	8, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 3, 167, 
	4469, 8, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 3, 
	168, 4478, 8, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 
	4486, 8, 169, 10, 169, 12, 169, 4489, 9, 169, 1, 169, 3, 169, 4492, 8, 
	169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 5, 170, 4500, 8, 170, 
	10, 170, 12, 170, 4503, 9, 170, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 
	1, 171, 1, 171, 3, 171, 4512, 8, 171, 1, 172, 1, 172, 1, 172, 1, 173, 1, 
	173, 1, 173, 3, 173, 4520, 8, 173, 1, 173, 3, 173, 4523, 8, 173, 1, 174, 
	1, 174, 1, 174, 1, 174, 1, 174, 5, 174, 4530, 8, 174, 10, 174, 12, 174, 
	4533, 9, 174, 3, 174, 4535, 8, 174, 1, 174, 1, 174, 3, 174, 4539, 8, 174, 
	1, 174, 5, 174, 4542, 8, 174, 10, 174, 12, 174, 4545, 9, 174, 1, 174, 3, 
	174, 4548, 8, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 5, 175, 4555, 
	8, 175, 10, 175, 12, 175, 4558, 9, 175, 3, 175, 4560, 8, 175, 1, 176, 1, 
	176, 1, 176, 1, 177, 1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 
	178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 
	178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 5, 178, 4589, 
	8, 178, 10, 178, 12, 178, 4592, 9, 178, 3, 178, 4594, 8, 178, 1, 178, 3, 
	178, 4597, 8, 178, 1, 179, 1, 179, 1, 180, 1, 180, 1, 181, 1, 181, 1, 182, 
	1, 182, 1, 182, 1, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 
	1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 
	1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 
	1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 
	1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 
	5, 183, 4651, 8, 183, 10, 183, 12, 183, 4654, 9, 183, 1, 183, 1, 183, 3, 
	183, 4658, 8, 183, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 185, 
	1, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 
	1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 
	1, 186, 3, 186, 4686, 8, 186, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 
	187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 3, 187, 4700, 8, 187, 
	1, 188, 1, 188, 1, 188, 5, 188, 4705, 8, 188, 10, 188, 12, 188, 4708, 9, 
	188, 1, 188, 3, 188, 4711, 8, 188, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 
	4717, 8, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 3, 190, 4725, 
	8, 190, 3, 190, 4727, 8, 190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 192, 1, 
	192, 1, 192, 1, 192, 1, 192, 3, 192, 4738, 8, 192, 1, 193, 1, 193, 1, 193, 
	1, 193, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 4748, 8, 194, 1, 195, 1, 
	195, 1, 195, 1, 195, 1, 195, 3, 195, 4755, 8, 195, 1, 196, 1, 196, 1, 196, 
	1, 196, 3, 196, 4761, 8, 196, 1, 197, 1, 197, 1, 197, 1, 197, 1, 198, 1, 
	198, 3, 198, 4769, 8, 198, 1, 199, 1, 199, 1, 199, 3, 199, 4774, 8, 199, 
	1, 199, 1, 199, 1, 199, 1, 199, 5, 199, 4780, 8, 199, 10, 199, 12, 199, 
	4783, 9, 199, 1, 199, 1, 199, 1, 199, 5, 199, 4788, 8, 199, 10, 199, 12, 
	199, 4791, 9, 199, 1, 199, 1, 199, 1, 199, 5, 199, 4796, 8, 199, 10, 199, 
	12, 199, 4799, 9, 199, 1, 199, 1, 199, 1, 199, 5, 199, 4804, 8, 199, 10, 
	199, 12, 199, 4807, 9, 199, 1, 199, 5, 199, 4810, 8, 199, 10, 199, 12, 
	199, 4813, 9, 199, 1, 199, 1, 199, 3, 199, 4817, 8, 199, 1, 200, 1, 200, 
	1, 200, 3, 200, 4822, 8, 200, 1, 200, 4, 200, 4825, 8, 200, 11, 200, 12, 
	200, 4826, 1, 200, 1, 200, 4, 200, 4831, 8, 200, 11, 200, 12, 200, 4832, 
	3, 200, 4835, 8, 200, 1, 200, 1, 200, 1, 200, 1, 201, 1, 201, 1, 201, 1, 
	201, 4, 201, 4844, 8, 201, 11, 201, 12, 201, 4845, 1, 201, 5, 201, 4849, 
	8, 201, 10, 201, 12, 201, 4852, 9, 201, 1, 201, 1, 201, 4, 201, 4856, 8, 
	201, 11, 201, 12, 201, 4857, 3, 201, 4860, 8, 201, 1, 201, 1, 201, 1, 201, 
	1, 202, 1, 202, 1, 202, 1, 203, 1, 203, 1, 203, 1, 204, 1, 204, 1, 204, 
	3, 204, 4874, 8, 204, 1, 204, 1, 204, 4, 204, 4878, 8, 204, 11, 204, 12, 
	204, 4879, 1, 204, 1, 204, 1, 204, 3, 204, 4885, 8, 204, 1, 205, 1, 205, 
	1, 205, 3, 205, 4890, 8, 205, 1, 205, 1, 205, 4, 205, 4894, 8, 205, 11, 
	205, 12, 205, 4895, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 4903, 
	8, 205, 1, 206, 1, 206, 1, 206, 1, 207, 1, 207, 1, 207, 3, 207, 4911, 8, 
	207, 1, 207, 1, 207, 1, 207, 1, 207, 4, 207, 4917, 8, 207, 11, 207, 12, 
	207, 4918, 1, 207, 1, 207, 1, 207, 3, 207, 4924, 8, 207, 1, 208, 1, 208, 
	1, 208, 1, 208, 3, 208, 4930, 8, 208, 1, 208, 3, 208, 4933, 8, 208, 1, 
	208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 4941, 8, 208, 1, 209, 
	1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 4948, 8, 209, 1, 210, 1, 210, 1, 
	210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 4957, 8, 210, 1, 210, 3, 210, 
	4960, 8, 210, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 212, 1, 
	212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 5, 212, 4975, 8, 212, 10, 
	212, 12, 212, 4978, 9, 212, 1, 212, 1, 212, 1, 213, 1, 213, 1, 213, 3, 
	213, 4985, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213, 
	4993, 8, 213, 1, 214, 1, 214, 3, 214, 4997, 8, 214, 1, 214, 1, 214, 1, 
	215, 1, 215, 1, 215, 3, 215, 5004, 8, 215, 1, 215, 1, 215, 4, 215, 5008, 
	8, 215, 11, 215, 12, 215, 5009, 1, 216, 1, 216, 1, 216, 1, 216, 4, 216, 
	5016, 8, 216, 11, 216, 12, 216, 5017, 1, 217, 1, 217, 1, 217, 1, 217, 1, 
	217, 5, 217, 5025, 8, 217, 10, 217, 12, 217, 5028, 9, 217, 1, 217, 1, 217, 
	1, 217, 3, 217, 5033, 8, 217, 1, 217, 1, 217, 1, 217, 5, 217, 5038, 8, 
	217, 10, 217, 12, 217, 5041, 9, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 
	217, 5047, 8, 217, 1, 217, 5, 217, 5050, 8, 217, 10, 217, 12, 217, 5053, 
	9, 217, 3, 217, 5055, 8, 217, 3, 217, 5057, 8, 217, 1, 217, 1, 217, 4, 
	217, 5061, 8, 217, 11, 217, 12, 217, 5062, 3, 217, 5065, 8, 217, 1, 217, 
	1, 217, 5, 217, 5069, 8, 217, 10, 217, 12, 217, 5072, 9, 217, 1, 217, 1, 
	217, 1, 217, 1, 217, 3, 217, 5078, 8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 
	5083, 8, 217, 1, 217, 1, 217, 3, 217, 5087, 8, 217, 1, 217, 1, 217, 1, 
	217, 1, 217, 3, 217, 5093, 8, 217, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 
	5, 218, 5100, 8, 218, 10, 218, 12, 218, 5103, 9, 218, 1, 218, 1, 218, 1, 
	218, 3, 218, 5108, 8, 218, 1, 218, 1, 218, 1, 218, 5, 218, 5113, 8, 218, 
	10, 218, 12, 218, 5116, 9, 218, 1, 218, 1, 218, 1, 218, 3, 218, 5121, 8, 
	218, 1, 218, 1, 218, 1, 218, 1, 218, 3, 218, 5127, 8, 218, 1, 218, 5, 218, 
	5130, 8, 218, 10, 218, 12, 218, 5133, 9, 218, 3, 218, 5135, 8, 218, 3, 
	218, 5137, 8, 218, 1, 218, 1, 218, 4, 218, 5141, 8, 218, 11, 218, 12, 218, 
	5142, 3, 218, 5145, 8, 218, 1, 218, 1, 218, 5, 218, 5149, 8, 218, 10, 218, 
	12, 218, 5152, 9, 218, 1, 218, 1, 218, 1, 218, 1, 218, 3, 218, 5158, 8, 
	218, 3, 218, 5160, 8, 218, 1, 219, 1, 219, 1, 219, 3, 219, 5165, 8, 219, 
	1, 219, 1, 219, 1, 219, 5, 219, 5170, 8, 219, 10, 219, 12, 219, 5173, 9, 
	219, 1, 220, 1, 220, 1, 220, 1, 220, 5, 220, 5179, 8, 220, 10, 220, 12, 
	220, 5182, 9, 220, 1, 220, 1, 220, 3, 220, 5186, 8, 220, 1, 220, 1, 220, 
	1, 220, 1, 220, 1, 220, 5, 220, 5193, 8, 220, 10, 220, 12, 220, 5196, 9, 
	220, 1, 220, 1, 220, 1, 220, 1, 220, 3, 220, 5202, 8, 220, 1, 220, 5, 220, 
	5205, 8, 220, 10, 220, 12, 220, 5208, 9, 220, 3, 220, 5210, 8, 220, 3, 
	220, 5212, 8, 220, 1, 220, 1, 220, 1, 220, 1, 220, 5, 220, 5218, 8, 220, 
	10, 220, 12, 220, 5221, 9, 220, 3, 220, 5223, 8, 220, 1, 220, 1, 220, 1, 
	220, 1, 220, 1, 220, 1, 220, 3, 220, 5231, 8, 220, 1, 220, 1, 220, 1, 220, 
	3, 220, 5236, 8, 220, 1, 220, 1, 220, 1, 220, 3, 220, 5241, 8, 220, 5, 
	220, 5243, 8, 220, 10, 220, 12, 220, 5246, 9, 220, 1, 220, 1, 220, 1, 220, 
	3, 220, 5251, 8, 220, 1, 220, 1, 220, 1, 220, 3, 220, 5256, 8, 220, 5, 
	220, 5258, 8, 220, 10, 220, 12, 220, 5261, 9, 220, 1, 220, 1, 220, 1, 220, 
	3, 220, 5266, 8, 220, 3, 220, 5268, 8, 220, 1, 221, 1, 221, 1, 221, 1, 
	221, 1, 221, 1, 221, 1, 221, 5, 221, 5277, 8, 221, 10, 221, 12, 221, 5280, 
	9, 221, 3, 221, 5282, 8, 221, 1, 221, 1, 221, 1, 221, 5, 221, 5287, 8, 
	221, 10, 221, 12, 221, 5290, 9, 221, 3, 221, 5292, 8, 221, 1, 222, 1, 222, 
	1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 5, 222, 5302, 8, 222, 10, 
	222, 12, 222, 5305, 9, 222, 1, 222, 1, 222, 1, 222, 3, 222, 5310, 8, 222, 
	1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 5, 223, 5317, 8, 223, 10, 223, 
	12, 223, 5320, 9, 223, 1, 224, 1, 224, 1, 224, 1, 224, 5, 224, 5326, 8, 
	224, 10, 224, 12, 224, 5329, 9, 224, 1, 224, 1, 224, 3, 224, 5333, 8, 224, 
	1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 5, 224, 5340, 8, 224, 10, 224, 
	12, 224, 5343, 9, 224, 1, 224, 1, 224, 1, 224, 3, 224, 5348, 8, 224, 1, 
	224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 5, 224, 5357, 8, 224, 
	10, 224, 12, 224, 5360, 9, 224, 1, 224, 1, 224, 1, 224, 3, 224, 5365, 8, 
	224, 1, 224, 1, 224, 1, 224, 3, 224, 5370, 8, 224, 5, 224, 5372, 8, 224, 
	10, 224, 12, 224, 5375, 9, 224, 1, 224, 1, 224, 1, 224, 3, 224, 5380, 8, 
	224, 1, 224, 1, 224, 1, 224, 3, 224, 5385, 8, 224, 5, 224, 5387, 8, 224, 
	10, 224, 12, 224, 5390, 9, 224, 3, 224, 5392, 8, 224, 1, 225, 1, 225, 1, 
	225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 5, 225, 5402, 8, 225, 10, 
	225, 12, 225, 5405, 9, 225, 1, 226, 1, 226, 1, 226, 1, 226, 3, 226, 5411, 
	8, 226, 1, 226, 1, 226, 1, 226, 3, 226, 5416, 8, 226, 1, 227, 1, 227, 1, 
	227, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 
	228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 
	228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 5446, 
	8, 228, 1, 229, 1, 229, 3, 229, 5450, 8, 229, 1, 229, 1, 229, 1, 229, 3, 
	229, 5455, 8, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 3, 230, 5462, 
	8, 230, 1, 230, 3, 230, 5465, 8, 230, 1, 230, 1, 230, 1, 230, 1, 230, 3, 
	230, 5471, 8, 230, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 
	1, 231, 3, 231, 5481, 8, 231, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 
	232, 1, 232, 1, 232, 3, 232, 5491, 8, 232, 1, 233, 1, 233, 1, 233, 1, 233, 
	1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 5501, 8, 233, 1, 233, 1, 233, 1, 
	233, 1, 233, 3, 233, 5507, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 
	1, 233, 1, 233, 3, 233, 5516, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 
	233, 5522, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 5529, 
	8, 233, 3, 233, 5531, 8, 233, 1, 234, 1, 234, 1, 234, 1, 235, 1, 235, 1, 
	235, 1, 235, 1, 235, 3, 235, 5541, 8, 235, 1, 236, 1, 236, 3, 236, 5545, 
	8, 236, 1, 236, 1, 236, 3, 236, 5549, 8, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 3, 236, 5559, 8, 236, 1, 236, 1, 236, 
	1, 236, 3, 236, 5564, 8, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 
	236, 1, 236, 3, 236, 5636, 8, 236, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 
	1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 1, 237, 
	1, 237, 1, 237, 3, 237, 5654, 8, 237, 1, 238, 1, 238, 1, 238, 1, 238, 1, 
	239, 1, 239, 3, 239, 5662, 8, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 
	1, 239, 1, 239, 1, 239, 5, 239, 5672, 8, 239, 10, 239, 12, 239, 5675, 9, 
	239, 1, 239, 1, 239, 1, 239, 1, 239, 3, 239, 5681, 8, 239, 3, 239, 5683, 
	8, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 5, 239, 5691, 8, 
	239, 10, 239, 12, 239, 5694, 9, 239, 3, 239, 5696, 8, 239, 1, 240, 1, 240, 
	1, 240, 1, 240, 5, 240, 5702, 8, 240, 10, 240, 12, 240, 5705, 9, 240, 1, 
	241, 1, 241, 1, 241, 1, 241, 3, 241, 5711, 8, 241, 1, 242, 1, 242, 3, 242, 
	5715, 8, 242, 1, 242, 1, 242, 1, 242, 1, 243, 1, 243, 3, 243, 5722, 8, 
	243, 1, 243, 1, 243, 1, 243, 3, 243, 5727, 8, 243, 1, 243, 3, 243, 5730, 
	8, 243, 1, 243, 3, 243, 5733, 8, 243, 1, 244, 1, 244, 1, 244, 1, 244, 1, 
	244, 1, 244, 1, 244, 3, 244, 5742, 8, 244, 1, 245, 1, 245, 3, 245, 5746, 
	8, 245, 1, 245, 1, 245, 3, 245, 5750, 8, 245, 1, 245, 1, 245, 1, 245, 1, 
	245, 1, 245, 1, 245, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 
	247, 1, 247, 1, 247, 1, 247, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 
	248, 5773, 8, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 248, 5780, 
	8, 248, 5, 248, 5782, 8, 248, 10, 248, 12, 248, 5785, 9, 248, 1, 248, 1, 
	248, 1, 248, 1, 248, 3, 248, 5791, 8, 248, 1, 248, 1, 248, 1, 248, 1, 248, 
	1, 248, 3, 248, 5798, 8, 248, 1, 248, 3, 248, 5801, 8, 248, 1, 248, 1, 
	248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 
	248, 1, 248, 5, 248, 5815, 8, 248, 10, 248, 12, 248, 5818, 9, 248, 3, 248, 
	5820, 8, 248, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 
	249, 3, 249, 5830, 8, 249, 1, 249, 1, 249, 3, 249, 5834, 8, 249, 1, 249, 
	1, 249, 1, 249, 1, 249, 3, 249, 5840, 8, 249, 1, 249, 3, 249, 5843, 8, 
	249, 1, 249, 1, 249, 1, 249, 3, 249, 5848, 8, 249, 1, 249, 1, 249, 3, 249, 
	5852, 8, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 5859, 8, 
	249, 1, 249, 3, 249, 5862, 8, 249, 1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 
	5868, 8, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 
	249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 
	249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 5892, 8, 249, 1, 249, 
	3, 249, 5895, 8, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 
	249, 1, 249, 1, 249, 1, 249, 3, 249, 5907, 8, 249, 1, 249, 3, 249, 5910, 
	8, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 
	3, 249, 5920, 8, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 3, 
	249, 5928, 8, 249, 1, 249, 1, 249, 3, 249, 5932, 8, 249, 1, 249, 1, 249, 
	1, 249, 1, 249, 1, 249, 3, 249, 5939, 8, 249, 1, 249, 3, 249, 5942, 8, 
	249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 5, 249, 5949, 8, 249, 10, 
	249, 12, 249, 5952, 9, 249, 1, 249, 1, 249, 1, 249, 3, 249, 5957, 8, 249, 
	1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 5963, 8, 249, 1, 249, 1, 249, 1, 
	249, 1, 249, 1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 5973, 8, 249, 3, 249, 
	5975, 8, 249, 1, 250, 1, 250, 1, 250, 1, 250, 3, 250, 5981, 8, 250, 1, 
	250, 3, 250, 5984, 8, 250, 1, 250, 3, 250, 5987, 8, 250, 1, 251, 1, 251, 
	1, 251, 1, 251, 1, 251, 1, 251, 1, 251, 1, 251, 1, 251, 1, 251, 3, 251, 
	5999, 8, 251, 1, 251, 3, 251, 6002, 8, 251, 1, 252, 1, 252, 1, 252, 1, 
	252, 3, 252, 6008, 8, 252, 1, 253, 3, 253, 6011, 8, 253, 1, 253, 1, 253, 
	1, 253, 1, 253, 1, 253, 1, 253, 3, 253, 6019, 8, 253, 1, 253, 1, 253, 1, 
	253, 1, 253, 1, 253, 1, 253, 3, 253, 6027, 8, 253, 1, 254, 1, 254, 1, 254, 
	1, 254, 3, 254, 6033, 8, 254, 1, 254, 1, 254, 3, 254, 6037, 8, 254, 1, 
	255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 
	255, 1, 255, 1, 255, 3, 255, 6051, 8, 255, 1, 256, 1, 256, 1, 256, 1, 257, 
	1, 257, 1, 257, 1, 257, 1, 257, 5, 257, 6061, 8, 257, 10, 257, 12, 257, 
	6064, 9, 257, 1, 257, 1, 257, 1, 257, 1, 257, 3, 257, 6070, 8, 257, 1, 
	257, 3, 257, 6073, 8, 257, 1, 257, 1, 257, 1, 257, 1, 258, 1, 258, 3, 258, 
	6080, 8, 258, 1, 258, 1, 258, 1, 258, 5, 258, 6085, 8, 258, 10, 258, 12, 
	258, 6088, 9, 258, 1, 259, 1, 259, 3, 259, 6092, 8, 259, 1, 259, 1, 259, 
	1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 5, 260, 6103, 8, 
	260, 10, 260, 12, 260, 6106, 9, 260, 1, 261, 1, 261, 1, 261, 1, 261, 1, 
	262, 1, 262, 1, 263, 1, 263, 3, 263, 6116, 8, 263, 1, 263, 1, 263, 1, 263, 
	1, 263, 3, 263, 6122, 8, 263, 1, 264, 1, 264, 1, 264, 3, 264, 6127, 8, 
	264, 1, 264, 1, 264, 1, 264, 1, 264, 1, 264, 1, 264, 1, 264, 1, 264, 1, 
	264, 1, 264, 1, 264, 3, 264, 6140, 8, 264, 3, 264, 6142, 8, 264, 1, 264, 
	1, 264, 1, 264, 3, 264, 6147, 8, 264, 1, 264, 1, 264, 3, 264, 6151, 8, 
	264, 1, 264, 3, 264, 6154, 8, 264, 3, 264, 6156, 8, 264, 1, 265, 1, 265, 
	1, 265, 1, 265, 1, 265, 3, 265, 6163, 8, 265, 1, 266, 1, 266, 1, 266, 1, 
	266, 1, 266, 3, 266, 6170, 8, 266, 1, 266, 3, 266, 6173, 8, 266, 1, 266, 
	3, 266, 6176, 8, 266, 1, 266, 1, 266, 1, 266, 1, 266, 3, 266, 6182, 8, 
	266, 1, 266, 1, 266, 3, 266, 6186, 8, 266, 1, 267, 1, 267, 1, 267, 1, 267, 
	3, 267, 6192, 8, 267, 1, 268, 1, 268, 1, 268, 1, 268, 3, 268, 6198, 8, 
	268, 1, 268, 1, 268, 1, 269, 1, 269, 1, 269, 1, 270, 1, 270, 1, 270, 1, 
	271, 1, 271, 1, 271, 3, 271, 6211, 8, 271, 1, 271, 1, 271, 1, 271, 3, 271, 
	6216, 8, 271, 1, 271, 1, 271, 1, 271, 1, 271, 5, 271, 6222, 8, 271, 10, 
	271, 12, 271, 6225, 9, 271, 3, 271, 6227, 8, 271, 1, 272, 1, 272, 1, 272, 
	3, 272, 6232, 8, 272, 1, 272, 1, 272, 1, 272, 3, 272, 6237, 8, 272, 1, 
	272, 1, 272, 1, 272, 1, 272, 5, 272, 6243, 8, 272, 10, 272, 12, 272, 6246, 
	9, 272, 3, 272, 6248, 8, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 1, 
	273, 3, 273, 6256, 8, 273, 1, 274, 1, 274, 3, 274, 6260, 8, 274, 1, 274, 
	1, 274, 1, 274, 5, 274, 6265, 8, 274, 10, 274, 12, 274, 6268, 9, 274, 1, 
	275, 1, 275, 1, 275, 3, 275, 6273, 8, 275, 1, 275, 3, 275, 6276, 8, 275, 
	1, 276, 1, 276, 3, 276, 6280, 8, 276, 1, 276, 1, 276, 1, 276, 1, 276, 1, 
	276, 1, 276, 1, 276, 1, 276, 1, 276, 5, 276, 6291, 8, 276, 10, 276, 12, 
	276, 6294, 9, 276, 1, 276, 1, 276, 1, 276, 3, 276, 6299, 8, 276, 1, 276, 
	1, 276, 1, 276, 1, 276, 1, 276, 1, 276, 1, 276, 1, 276, 5, 276, 6309, 8, 
	276, 10, 276, 12, 276, 6312, 9, 276, 3, 276, 6314, 8, 276, 1, 277, 1, 277, 
	1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 3, 278, 6323, 8, 278, 1, 278, 1, 
	278, 1, 278, 3, 278, 6328, 8, 278, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279, 
	6334, 8, 279, 1, 280, 1, 280, 1, 281, 1, 281, 3, 281, 6340, 8, 281, 1, 
	282, 1, 282, 1, 282, 3, 282, 6345, 8, 282, 3, 282, 6347, 8, 282, 1, 282, 
	3, 282, 6350, 8, 282, 1, 282, 1, 282, 3, 282, 6354, 8, 282, 3, 282, 6356, 
	8, 282, 1, 283, 1, 283, 3, 283, 6360, 8, 283, 1, 283, 1, 283, 1, 283, 1, 
	283, 3, 283, 6366, 8, 283, 1, 283, 3, 283, 6369, 8, 283, 1, 283, 3, 283, 
	6372, 8, 283, 1, 284, 1, 284, 1, 284, 1, 284, 3, 284, 6378, 8, 284, 1, 
	285, 1, 285, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 3, 286, 6387, 8, 286, 
	1, 287, 1, 287, 1, 288, 1, 288, 1, 288, 1, 288, 3, 288, 6395, 8, 288, 1, 
	289, 1, 289, 3, 289, 6399, 8, 289, 1, 290, 1, 290, 1, 290, 3, 290, 6404, 
	8, 290, 1, 291, 1, 291, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 
	1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 4, 292, 
	6422, 8, 292, 11, 292, 12, 292, 6423, 1, 293, 1, 293, 1, 293, 1, 293, 1, 
	293, 3, 293, 6431, 8, 293, 3, 293, 6433, 8, 293, 1, 294, 1, 294, 1, 294, 
	4, 294, 6438, 8, 294, 11, 294, 12, 294, 6439, 3, 294, 6442, 8, 294, 1, 
	295, 1, 295, 3, 295, 6446, 8, 295, 1, 296, 1, 296, 1, 296, 3, 296, 6451, 
	8, 296, 1, 297, 1, 297, 1, 297, 1, 297, 1, 297, 1, 297, 1, 297, 1, 297, 
	1, 297, 3, 297, 6462, 8, 297, 1, 298, 1, 298, 1, 298, 3, 298, 6467, 8, 
	298, 1, 299, 1, 299, 1, 300, 1, 300, 3, 300, 6473, 8, 300, 1, 301, 3, 301, 
	6476, 8, 301, 1, 301, 1, 301, 3, 301, 6480, 8, 301, 1, 301, 4, 301, 6483, 
	8, 301, 11, 301, 12, 301, 6484, 1, 301, 3, 301, 6488, 8, 301, 1, 301, 1, 
	301, 3, 301, 6492, 8, 301, 1, 301, 1, 301, 3, 301, 6496, 8, 301, 3, 301, 
	6498, 8, 301, 1, 302, 1, 302, 1, 303, 3, 303, 6503, 8, 303, 1, 303, 1, 
	303, 1, 304, 3, 304, 6508, 8, 304, 1, 304, 1, 304, 1, 305, 1, 305, 1, 305, 
	1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 3, 305, 6521, 8, 305, 1, 
	305, 3, 305, 6524, 8, 305, 1, 306, 1, 306, 3, 306, 6528, 8, 306, 1, 306, 
	3, 306, 6531, 8, 306, 1, 306, 3, 306, 6534, 8, 306, 1, 306, 1, 306, 1, 
	306, 3, 306, 6539, 8, 306, 1, 306, 1, 306, 1, 306, 3, 306, 6544, 8, 306, 
	1, 306, 1, 306, 1, 306, 1, 306, 3, 306, 6550, 8, 306, 1, 306, 3, 306, 6553, 
	8, 306, 1, 306, 1, 306, 1, 306, 3, 306, 6558, 8, 306, 1, 306, 3, 306, 6561, 
	8, 306, 1, 306, 1, 306, 1, 306, 3, 306, 6566, 8, 306, 1, 306, 3, 306, 6569, 
	8, 306, 1, 306, 1, 306, 3, 306, 6573, 8, 306, 1, 306, 5, 306, 6576, 8, 
	306, 10, 306, 12, 306, 6579, 9, 306, 1, 306, 1, 306, 3, 306, 6583, 8, 306, 
	1, 306, 5, 306, 6586, 8, 306, 10, 306, 12, 306, 6589, 9, 306, 1, 306, 1, 
	306, 3, 306, 6593, 8, 306, 1, 306, 3, 306, 6596, 8, 306, 1, 306, 5, 306, 
	6599, 8, 306, 10, 306, 12, 306, 6602, 9, 306, 1, 306, 1, 306, 3, 306, 6606, 
	8, 306, 1, 306, 5, 306, 6609, 8, 306, 10, 306, 12, 306, 6612, 9, 306, 1, 
	306, 1, 306, 1, 306, 3, 306, 6617, 8, 306, 1, 306, 1, 306, 1, 306, 3, 306, 
	6622, 8, 306, 1, 306, 1, 306, 1, 306, 3, 306, 6627, 8, 306, 1, 306, 1, 
	306, 1, 306, 3, 306, 6632, 8, 306, 1, 306, 1, 306, 3, 306, 6636, 8, 306, 
	1, 306, 3, 306, 6639, 8, 306, 1, 306, 1, 306, 1, 306, 3, 306, 6644, 8, 
	306, 1, 306, 1, 306, 3, 306, 6648, 8, 306, 1, 306, 1, 306, 3, 306, 6652, 
	8, 306, 1, 307, 1, 307, 1, 307, 1, 307, 5, 307, 6658, 8, 307, 10, 307, 
	12, 307, 6661, 9, 307, 1, 307, 1, 307, 1, 308, 1, 308, 3, 308, 6667, 8, 
	308, 1, 308, 1, 308, 3, 308, 6671, 8, 308, 1, 308, 1, 308, 1, 308, 3, 308, 
	6676, 8, 308, 1, 308, 1, 308, 1, 308, 3, 308, 6681, 8, 308, 1, 308, 1, 
	308, 3, 308, 6685, 8, 308, 3, 308, 6687, 8, 308, 1, 308, 3, 308, 6690, 
	8, 308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 310, 1, 310, 1, 310, 1, 310, 
	1, 310, 1, 310, 1, 311, 1, 311, 1, 311, 1, 311, 3, 311, 6706, 8, 311, 1, 
	311, 1, 311, 1, 312, 1, 312, 1, 312, 5, 312, 6713, 8, 312, 10, 312, 12, 
	312, 6716, 9, 312, 1, 313, 1, 313, 1, 313, 5, 313, 6721, 8, 313, 10, 313, 
	12, 313, 6724, 9, 313, 1, 314, 1, 314, 1, 314, 5, 314, 6729, 8, 314, 10, 
	314, 12, 314, 6732, 9, 314, 1, 315, 1, 315, 1, 315, 1, 315, 5, 315, 6738, 
	8, 315, 10, 315, 12, 315, 6741, 9, 315, 1, 315, 1, 315, 1, 316, 1, 316, 
	1, 316, 5, 316, 6748, 8, 316, 10, 316, 12, 316, 6751, 9, 316, 1, 317, 1, 
	317, 1, 317, 5, 317, 6756, 8, 317, 10, 317, 12, 317, 6759, 9, 317, 1, 318, 
	1, 318, 1, 318, 5, 318, 6764, 8, 318, 10, 318, 12, 318, 6767, 9, 318, 1, 
	319, 1, 319, 1, 319, 5, 319, 6772, 8, 319, 10, 319, 12, 319, 6775, 9, 319, 
	1, 320, 1, 320, 1, 320, 5, 320, 6780, 8, 320, 10, 320, 12, 320, 6783, 9, 
	320, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 
	321, 3, 321, 6794, 8, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 3, 321, 
	6801, 8, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 
	321, 3, 321, 6811, 8, 321, 1, 322, 1, 322, 1, 322, 3, 322, 6816, 8, 322, 
	1, 322, 3, 322, 6819, 8, 322, 1, 322, 1, 322, 1, 322, 3, 322, 6824, 8, 
	322, 1, 322, 3, 322, 6827, 8, 322, 1, 323, 1, 323, 3, 323, 6831, 8, 323, 
	1, 324, 1, 324, 1, 324, 1, 325, 1, 325, 1, 325, 1, 325, 1, 326, 1, 326, 
	1, 326, 1, 327, 1, 327, 1, 327, 3, 327, 6846, 8, 327, 1, 328, 1, 328, 1, 
	328, 1, 328, 1, 328, 1, 328, 3, 328, 6854, 8, 328, 1, 328, 1, 328, 1, 328, 
	1, 328, 1, 328, 3, 328, 6861, 8, 328, 1, 328, 1, 328, 1, 328, 3, 328, 6866, 
	8, 328, 1, 329, 1, 329, 1, 329, 3, 329, 6871, 8, 329, 1, 329, 1, 329, 1, 
	329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 
	329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 
	329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 
	329, 4, 329, 6903, 8, 329, 11, 329, 12, 329, 6904, 1, 329, 1, 329, 3, 329, 
	6909, 8, 329, 1, 329, 1, 329, 1, 329, 1, 329, 4, 329, 6915, 8, 329, 11, 
	329, 12, 329, 6916, 1, 329, 1, 329, 3, 329, 6921, 8, 329, 1, 329, 1, 329, 
	1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 6930, 8, 329, 1, 329, 1, 
	329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 6938, 8, 329, 1, 329, 1, 329, 
	1, 329, 3, 329, 6943, 8, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 
	329, 3, 329, 6951, 8, 329, 1, 329, 1, 329, 1, 329, 3, 329, 6956, 8, 329, 
	1, 329, 1, 329, 1, 329, 3, 329, 6961, 8, 329, 3, 329, 6963, 8, 329, 1, 
	329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 6972, 8, 329, 
	1, 329, 1, 329, 1, 329, 3, 329, 6977, 8, 329, 1, 329, 1, 329, 1, 329, 1, 
	329, 1, 329, 1, 329, 3, 329, 6985, 8, 329, 1, 329, 1, 329, 1, 329, 3, 329, 
	6990, 8, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 6998, 
	8, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 7006, 8, 
	329, 1, 329, 3, 329, 7009, 8, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 
	1, 329, 1, 329, 1, 329, 3, 329, 7019, 8, 329, 1, 329, 1, 329, 1, 329, 1, 
	329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 1, 
	329, 1, 329, 1, 329, 1, 329, 3, 329, 7037, 8, 329, 1, 329, 3, 329, 7040, 
	8, 329, 1, 329, 3, 329, 7043, 8, 329, 1, 329, 1, 329, 3, 329, 7047, 8, 
	329, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 331, 1, 331, 1, 331, 1, 
	331, 5, 331, 7058, 8, 331, 10, 331, 12, 331, 7061, 9, 331, 1, 331, 1, 331, 
	1, 331, 1, 331, 1, 331, 3, 331, 7068, 8, 331, 1, 332, 1, 332, 3, 332, 7072, 
	8, 332, 1, 333, 1, 333, 1, 333, 3, 333, 7077, 8, 333, 1, 333, 1, 333, 1, 
	333, 3, 333, 7082, 8, 333, 1, 333, 1, 333, 1, 333, 1, 333, 3, 333, 7088, 
	8, 333, 1, 333, 1, 333, 1, 333, 3, 333, 7093, 8, 333, 1, 333, 1, 333, 3, 
	333, 7097, 8, 333, 1, 333, 1, 333, 1, 333, 3, 333, 7102, 8, 333, 1, 333, 
	1, 333, 1, 333, 3, 333, 7107, 8, 333, 1, 333, 1, 333, 1, 333, 3, 333, 7112, 
	8, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 5, 333, 7120, 8, 
	333, 10, 333, 12, 333, 7123, 9, 333, 3, 333, 7125, 8, 333, 1, 333, 1, 333, 
	3, 333, 7129, 8, 333, 1, 333, 1, 333, 3, 333, 7133, 8, 333, 1, 334, 1, 
	334, 1, 334, 1, 334, 1, 334, 3, 334, 7140, 8, 334, 1, 334, 1, 334, 3, 334, 
	7144, 8, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 
	334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 
	334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 
	334, 1, 334, 3, 334, 7173, 8, 334, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 
	1, 335, 3, 335, 7181, 8, 335, 1, 336, 3, 336, 7184, 8, 336, 1, 336, 3, 
	336, 7187, 8, 336, 1, 336, 3, 336, 7190, 8, 336, 1, 336, 3, 336, 7193, 
	8, 336, 1, 337, 1, 337, 1, 338, 1, 338, 1, 338, 1, 339, 1, 339, 1, 340, 
	1, 340, 3, 340, 7204, 8, 340, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 
	342, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342, 3, 342, 7218, 8, 342, 
	1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 5, 343, 7225, 8, 343, 10, 343, 
	12, 343, 7228, 9, 343, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 
	1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 
	1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 
	3, 344, 7254, 8, 344, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 346, 1, 
	346, 1, 346, 1, 346, 3, 346, 7265, 8, 346, 1, 346, 1, 346, 1, 346, 1, 346, 
	1, 346, 3, 346, 7272, 8, 346, 5, 346, 7274, 8, 346, 10, 346, 12, 346, 7277, 
	9, 346, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 7283, 8, 347, 1, 348, 1, 
	348, 1, 348, 1, 348, 1, 348, 1, 348, 3, 348, 7291, 8, 348, 1, 348, 1, 348, 
	1, 348, 3, 348, 7296, 8, 348, 1, 348, 1, 348, 1, 348, 1, 348, 5, 348, 7302, 
	8, 348, 10, 348, 12, 348, 7305, 9, 348, 1, 349, 1, 349, 1, 349, 1, 349, 
	1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 7316, 8, 349, 1, 349, 1, 
	349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 
	349, 3, 349, 7329, 8, 349, 1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 7335, 
	8, 349, 1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 7341, 8, 349, 1, 349, 1, 
	349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 
	349, 1, 349, 1, 349, 1, 349, 3, 349, 7357, 8, 349, 1, 349, 1, 349, 1, 349, 
	1, 349, 3, 349, 7363, 8, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 
	349, 1, 349, 5, 349, 7372, 8, 349, 10, 349, 12, 349, 7375, 9, 349, 1, 350, 
	1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 
	1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 5, 350, 7394, 8, 
	350, 10, 350, 12, 350, 7397, 9, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 
	350, 1, 350, 1, 350, 4, 350, 7406, 8, 350, 11, 350, 12, 350, 7407, 1, 350, 
	1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 
	1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 3, 350, 7425, 8, 350, 1, 350, 1, 
	350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 
	350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 5, 
	350, 7446, 8, 350, 10, 350, 12, 350, 7449, 9, 350, 1, 351, 1, 351, 1, 352, 
	1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 
	1, 352, 1, 352, 1, 352, 1, 352, 3, 352, 7467, 8, 352, 1, 353, 1, 353, 1, 
	353, 1, 353, 1, 353, 1, 353, 1, 353, 3, 353, 7476, 8, 353, 1, 354, 1, 354, 
	1, 354, 1, 354, 1, 354, 1, 354, 1, 354, 3, 354, 7485, 8, 354, 1, 355, 1, 
	355, 1, 356, 1, 356, 1, 357, 1, 357, 1, 357, 1, 357, 1, 357, 3, 357, 7496, 
	8, 357, 1, 358, 1, 358, 1, 359, 1, 359, 1, 360, 1, 360, 1, 361, 1, 361, 
	1, 362, 1, 362, 1, 363, 1, 363, 1, 364, 1, 364, 1, 364, 0, 3, 696, 698, 
	700, 365, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 
	34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 
	70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 
	166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 
	196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 
	226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 
	256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 
	286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 
	316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 
	346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 
	376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 
	406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 
	436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 
	466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 
	496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 
	526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 
	556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 
	586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 
	616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 
	646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 
	676, 678, 680, 682, 684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 
	706, 708, 710, 712, 714, 716, 718, 720, 722, 724, 726, 728, 0, 144, 2, 
	0, 39, 39, 150, 150, 2, 0, 531, 531, 537, 537, 3, 0, 69, 69, 159, 159, 
	181, 181, 3, 0, 42, 42, 384, 384, 454, 454, 4, 0, 42, 42, 419, 419, 529, 
	529, 611, 611, 2, 0, 514, 514, 1148, 1148, 2, 0, 78, 78, 141, 141, 2, 0, 
	15, 15, 334, 334, 3, 0, 44, 44, 85, 85, 184, 184, 2, 0, 434, 434, 558, 
	558, 3, 0, 506, 506, 650, 650, 658, 658, 2, 0, 392, 392, 460, 460, 2, 0, 
	352, 352, 474, 474, 2, 0, 42, 42, 1138, 1139, 2, 0, 350, 350, 443, 443, 
	2, 0, 459, 459, 673, 673, 3, 0, 80, 80, 84, 84, 125, 125, 3, 0, 42, 42, 
	402, 402, 431, 431, 3, 0, 42, 42, 398, 398, 792, 792, 2, 0, 637, 637, 672, 
	672, 2, 0, 81, 81, 91, 91, 3, 0, 436, 436, 548, 548, 613, 613, 2, 0, 69, 
	69, 159, 159, 1, 0, 356, 357, 1, 0, 1138, 1139, 2, 0, 1148, 1148, 1156, 
	1156, 2, 0, 81, 81, 388, 388, 2, 0, 545, 545, 1148, 1148, 2, 0, 546, 546, 
	1148, 1148, 3, 0, 430, 430, 469, 469, 521, 521, 7, 0, 42, 42, 370, 370, 
	372, 372, 402, 402, 431, 431, 573, 573, 1156, 1156, 2, 0, 514, 514, 530, 
	530, 1, 0, 1139, 1140, 2, 0, 5, 5, 51, 51, 4, 0, 42, 42, 384, 384, 454, 
	454, 458, 458, 2, 0, 26, 26, 30, 30, 2, 0, 12, 12, 175, 175, 2, 0, 192, 
	192, 677, 677, 2, 0, 21, 21, 144, 144, 3, 0, 43, 43, 75, 75, 106, 106, 
	2, 0, 106, 106, 374, 374, 2, 0, 365, 365, 427, 427, 2, 0, 101, 101, 601, 
	601, 2, 0, 43, 43, 106, 106, 2, 0, 6, 6, 49, 49, 2, 0, 188, 188, 669, 669, 
	4, 0, 430, 430, 469, 469, 520, 520, 562, 562, 2, 0, 430, 430, 520, 520, 
	2, 0, 13, 13, 45, 45, 3, 0, 66, 66, 78, 78, 186, 186, 2, 0, 34, 34, 83, 
	83, 2, 0, 97, 97, 148, 148, 2, 0, 6, 6, 49, 50, 1, 0, 626, 627, 2, 0, 172, 
	172, 742, 742, 2, 0, 439, 439, 609, 609, 2, 0, 226, 226, 477, 477, 5, 0, 
	107, 107, 482, 483, 485, 485, 489, 497, 575, 575, 4, 0, 479, 480, 484, 
	484, 486, 487, 576, 576, 3, 0, 108, 108, 478, 478, 488, 488, 2, 0, 462, 
	462, 628, 628, 2, 0, 622, 622, 624, 624, 2, 0, 344, 344, 629, 629, 2, 0, 
	90, 90, 591, 591, 2, 0, 51, 51, 390, 390, 3, 0, 31, 31, 61, 61, 179, 179, 
	3, 0, 131, 131, 172, 172, 437, 437, 3, 0, 12, 12, 19, 19, 187, 187, 2, 
	0, 42, 42, 121, 121, 2, 0, 103, 103, 182, 182, 2, 0, 360, 360, 614, 614, 
	2, 0, 40, 40, 671, 671, 2, 0, 115, 115, 474, 474, 2, 0, 422, 422, 568, 
	568, 4, 0, 206, 206, 208, 208, 214, 214, 638, 638, 2, 0, 1108, 1108, 1124, 
	1124, 2, 0, 345, 345, 577, 577, 2, 0, 68, 68, 80, 80, 6, 0, 131, 131, 172, 
	172, 177, 177, 415, 415, 437, 437, 671, 671, 2, 0, 513, 513, 634, 634, 
	2, 0, 412, 412, 675, 675, 2, 0, 131, 131, 437, 437, 3, 0, 81, 81, 92, 92, 
	452, 452, 3, 0, 439, 439, 474, 474, 609, 609, 2, 0, 634, 634, 670, 670, 
	2, 0, 376, 376, 567, 567, 6, 0, 226, 226, 409, 409, 411, 411, 438, 438, 
	574, 574, 615, 615, 2, 0, 45, 46, 62, 62, 3, 0, 422, 422, 550, 550, 885, 
	885, 2, 0, 466, 466, 652, 652, 10, 0, 359, 359, 367, 367, 378, 380, 387, 
	387, 507, 507, 515, 515, 639, 639, 646, 646, 836, 836, 1005, 1005, 2, 0, 
	35, 35, 168, 168, 2, 0, 117, 117, 996, 996, 11, 0, 359, 359, 367, 367, 
	378, 380, 387, 387, 507, 507, 515, 515, 592, 592, 639, 639, 646, 646, 836, 
	836, 1005, 1005, 2, 0, 1137, 1137, 1158, 1159, 1, 0, 1159, 1160, 2, 0, 
	375, 375, 787, 798, 3, 0, 1138, 1140, 1149, 1149, 1151, 1151, 2, 0, 63, 
	63, 178, 178, 2, 0, 116, 116, 1152, 1152, 5, 0, 25, 25, 222, 224, 231, 
	231, 233, 236, 518, 518, 2, 0, 25, 25, 222, 222, 2, 0, 25, 25, 222, 223, 
	1, 0, 196, 207, 3, 0, 183, 183, 195, 195, 612, 612, 2, 0, 211, 216, 431, 
	431, 6, 0, 217, 217, 228, 228, 230, 230, 232, 232, 239, 239, 348, 349, 
	4, 0, 218, 221, 226, 227, 229, 229, 346, 346, 2, 0, 153, 153, 237, 237, 
	2, 0, 466, 466, 803, 811, 3, 0, 211, 211, 226, 226, 518, 518, 6, 0, 200, 
	200, 206, 206, 209, 209, 217, 218, 220, 221, 466, 466, 1, 0, 214, 215, 
	2, 0, 183, 183, 612, 612, 2, 0, 200, 200, 206, 206, 2, 0, 315, 316, 322, 
	322, 3, 0, 150, 150, 313, 316, 331, 331, 1, 0, 325, 326, 3, 0, 17, 17, 
	95, 95, 176, 176, 2, 0, 222, 222, 226, 226, 2, 0, 217, 218, 220, 220, 3, 
	0, 13, 13, 45, 45, 994, 994, 3, 0, 286, 286, 298, 299, 309, 309, 3, 0, 
	287, 289, 305, 308, 310, 312, 2, 0, 295, 295, 297, 297, 2, 0, 293, 293, 
	296, 296, 2, 0, 291, 292, 302, 304, 2, 0, 133, 133, 601, 601, 2, 0, 433, 
	433, 559, 559, 2, 0, 535, 535, 551, 551, 2, 0, 114, 114, 1127, 1127, 3, 
	0, 63, 63, 178, 178, 662, 662, 2, 0, 137, 137, 149, 149, 3, 0, 6, 6, 337, 
	337, 618, 618, 3, 0, 114, 114, 1120, 1121, 1127, 1128, 2, 0, 1117, 1119, 
	1122, 1123, 1, 0, 1120, 1121, 2, 0, 226, 226, 746, 786, 1, 0, 799, 802, 
	5, 0, 708, 709, 725, 727, 733, 733, 739, 740, 742, 742, 1, 0, 689, 696, 
	3, 0, 217, 221, 234, 234, 237, 237, 58, 0, 11, 11, 14, 14, 18, 18, 29, 
	29, 35, 35, 37, 37, 42, 42, 48, 48, 55, 55, 57, 57, 59, 59, 73, 73, 79, 
	79, 94, 94, 117, 117, 121, 121, 124, 124, 130, 130, 158, 158, 168, 168, 
	239, 239, 283, 290, 294, 294, 298, 299, 305, 312, 332, 385, 387, 403, 405, 
	405, 407, 432, 434, 450, 452, 458, 460, 521, 523, 523, 527, 544, 547, 558, 
	560, 589, 591, 606, 608, 636, 638, 672, 674, 675, 677, 682, 684, 688, 697, 
	697, 699, 707, 710, 712, 717, 718, 720, 724, 728, 732, 734, 734, 736, 738, 
	741, 741, 743, 745, 792, 792, 836, 836, 875, 875, 1000, 1000, 1005, 1005, 
	1088, 1088, 23, 0, 39, 39, 97, 97, 148, 148, 150, 150, 217, 219, 221, 221, 
	251, 282, 290, 293, 295, 297, 300, 304, 324, 324, 459, 459, 673, 673, 689, 
	696, 736, 736, 803, 803, 806, 835, 837, 874, 876, 999, 1001, 1004, 1006, 
	1087, 1089, 1107, 1123, 1123, 8848, 0, 731, 1, 0, 0, 0, 2, 750, 1, 0, 0, 
	0, 4, 771, 1, 0, 0, 0, 6, 773, 1, 0, 0, 0, 8, 813, 1, 0, 0, 0, 10, 828, 
	1, 0, 0, 0, 12, 839, 1, 0, 0, 0, 14, 856, 1, 0, 0, 0, 16, 861, 1, 0, 0, 
	0, 18, 876, 1, 0, 0, 0, 20, 903, 1, 0, 0, 0, 22, 912, 1, 0, 0, 0, 24, 914, 
	1, 0, 0, 0, 26, 926, 1, 0, 0, 0, 28, 956, 1, 0, 0, 0, 30, 992, 1, 0, 0, 
	0, 32, 1043, 1, 0, 0, 0, 34, 1069, 1, 0, 0, 0, 36, 1105, 1, 0, 0, 0, 38, 
	1118, 1, 0, 0, 0, 40, 1215, 1, 0, 0, 0, 42, 1217, 1, 0, 0, 0, 44, 1235, 
	1, 0, 0, 0, 46, 1296, 1, 0, 0, 0, 48, 1315, 1, 0, 0, 0, 50, 1321, 1, 0, 
	0, 0, 52, 1343, 1, 0, 0, 0, 54, 1345, 1, 0, 0, 0, 56, 1347, 1, 0, 0, 0, 
	58, 1427, 1, 0, 0, 0, 60, 1434, 1, 0, 0, 0, 62, 1436, 1, 0, 0, 0, 64, 1441, 
	1, 0, 0, 0, 66, 1481, 1, 0, 0, 0, 68, 1487, 1, 0, 0, 0, 70, 1489, 1, 0, 
	0, 0, 72, 1510, 1, 0, 0, 0, 74, 1517, 1, 0, 0, 0, 76, 1519, 1, 0, 0, 0, 
	78, 1544, 1, 0, 0, 0, 80, 1547, 1, 0, 0, 0, 82, 1552, 1, 0, 0, 0, 84, 1578, 
	1, 0, 0, 0, 86, 1594, 1, 0, 0, 0, 88, 1596, 1, 0, 0, 0, 90, 1618, 1, 0, 
	0, 0, 92, 1620, 1, 0, 0, 0, 94, 1686, 1, 0, 0, 0, 96, 1757, 1, 0, 0, 0, 
	98, 1759, 1, 0, 0, 0, 100, 1787, 1, 0, 0, 0, 102, 1797, 1, 0, 0, 0, 104, 
	1827, 1, 0, 0, 0, 106, 2014, 1, 0, 0, 0, 108, 2016, 1, 0, 0, 0, 110, 2018, 
	1, 0, 0, 0, 112, 2021, 1, 0, 0, 0, 114, 2096, 1, 0, 0, 0, 116, 2119, 1, 
	0, 0, 0, 118, 2267, 1, 0, 0, 0, 120, 2272, 1, 0, 0, 0, 122, 2274, 1, 0, 
	0, 0, 124, 2284, 1, 0, 0, 0, 126, 2340, 1, 0, 0, 0, 128, 2360, 1, 0, 0, 
	0, 130, 2362, 1, 0, 0, 0, 132, 2397, 1, 0, 0, 0, 134, 2406, 1, 0, 0, 0, 
	136, 2413, 1, 0, 0, 0, 138, 2436, 1, 0, 0, 0, 140, 2445, 1, 0, 0, 0, 142, 
	2460, 1, 0, 0, 0, 144, 2485, 1, 0, 0, 0, 146, 2505, 1, 0, 0, 0, 148, 2888, 
	1, 0, 0, 0, 150, 2988, 1, 0, 0, 0, 152, 2990, 1, 0, 0, 0, 154, 2997, 1, 
	0, 0, 0, 156, 3004, 1, 0, 0, 0, 158, 3027, 1, 0, 0, 0, 160, 3035, 1, 0, 
	0, 0, 162, 3042, 1, 0, 0, 0, 164, 3049, 1, 0, 0, 0, 166, 3056, 1, 0, 0, 
	0, 168, 3068, 1, 0, 0, 0, 170, 3078, 1, 0, 0, 0, 172, 3085, 1, 0, 0, 0, 
	174, 3101, 1, 0, 0, 0, 176, 3147, 1, 0, 0, 0, 178, 3149, 1, 0, 0, 0, 180, 
	3159, 1, 0, 0, 0, 182, 3163, 1, 0, 0, 0, 184, 3169, 1, 0, 0, 0, 186, 3181, 
	1, 0, 0, 0, 188, 3183, 1, 0, 0, 0, 190, 3190, 1, 0, 0, 0, 192, 3192, 1, 
	0, 0, 0, 194, 3253, 1, 0, 0, 0, 196, 3327, 1, 0, 0, 0, 198, 3386, 1, 0, 
	0, 0, 200, 3484, 1, 0, 0, 0, 202, 3488, 1, 0, 0, 0, 204, 3490, 1, 0, 0, 
	0, 206, 3525, 1, 0, 0, 0, 208, 3527, 1, 0, 0, 0, 210, 3535, 1, 0, 0, 0, 
	212, 3543, 1, 0, 0, 0, 214, 3545, 1, 0, 0, 0, 216, 3584, 1, 0, 0, 0, 218, 
	3642, 1, 0, 0, 0, 220, 3651, 1, 0, 0, 0, 222, 3671, 1, 0, 0, 0, 224, 3683, 
	1, 0, 0, 0, 226, 3687, 1, 0, 0, 0, 228, 3723, 1, 0, 0, 0, 230, 3747, 1, 
	0, 0, 0, 232, 3757, 1, 0, 0, 0, 234, 3761, 1, 0, 0, 0, 236, 3787, 1, 0, 
	0, 0, 238, 3829, 1, 0, 0, 0, 240, 3831, 1, 0, 0, 0, 242, 3846, 1, 0, 0, 
	0, 244, 3895, 1, 0, 0, 0, 246, 3904, 1, 0, 0, 0, 248, 3914, 1, 0, 0, 0, 
	250, 3924, 1, 0, 0, 0, 252, 3986, 1, 0, 0, 0, 254, 3988, 1, 0, 0, 0, 256, 
	3996, 1, 0, 0, 0, 258, 4011, 1, 0, 0, 0, 260, 4013, 1, 0, 0, 0, 262, 4015, 
	1, 0, 0, 0, 264, 4042, 1, 0, 0, 0, 266, 4048, 1, 0, 0, 0, 268, 4056, 1, 
	0, 0, 0, 270, 4073, 1, 0, 0, 0, 272, 4089, 1, 0, 0, 0, 274, 4126, 1, 0, 
	0, 0, 276, 4132, 1, 0, 0, 0, 278, 4141, 1, 0, 0, 0, 280, 4154, 1, 0, 0, 
	0, 282, 4158, 1, 0, 0, 0, 284, 4196, 1, 0, 0, 0, 286, 4234, 1, 0, 0, 0, 
	288, 4248, 1, 0, 0, 0, 290, 4256, 1, 0, 0, 0, 292, 4260, 1, 0, 0, 0, 294, 
	4266, 1, 0, 0, 0, 296, 4280, 1, 0, 0, 0, 298, 4283, 1, 0, 0, 0, 300, 4301, 
	1, 0, 0, 0, 302, 4305, 1, 0, 0, 0, 304, 4321, 1, 0, 0, 0, 306, 4323, 1, 
	0, 0, 0, 308, 4335, 1, 0, 0, 0, 310, 4342, 1, 0, 0, 0, 312, 4362, 1, 0, 
	0, 0, 314, 4382, 1, 0, 0, 0, 316, 4385, 1, 0, 0, 0, 318, 4395, 1, 0, 0, 
	0, 320, 4399, 1, 0, 0, 0, 322, 4412, 1, 0, 0, 0, 324, 4415, 1, 0, 0, 0, 
	326, 4420, 1, 0, 0, 0, 328, 4440, 1, 0, 0, 0, 330, 4442, 1, 0, 0, 0, 332, 
	4459, 1, 0, 0, 0, 334, 4468, 1, 0, 0, 0, 336, 4477, 1, 0, 0, 0, 338, 4479, 
	1, 0, 0, 0, 340, 4493, 1, 0, 0, 0, 342, 4504, 1, 0, 0, 0, 344, 4513, 1, 
	0, 0, 0, 346, 4516, 1, 0, 0, 0, 348, 4524, 1, 0, 0, 0, 350, 4549, 1, 0, 
	0, 0, 352, 4561, 1, 0, 0, 0, 354, 4564, 1, 0, 0, 0, 356, 4596, 1, 0, 0, 
	0, 358, 4598, 1, 0, 0, 0, 360, 4600, 1, 0, 0, 0, 362, 4602, 1, 0, 0, 0, 
	364, 4604, 1, 0, 0, 0, 366, 4657, 1, 0, 0, 0, 368, 4659, 1, 0, 0, 0, 370, 
	4665, 1, 0, 0, 0, 372, 4685, 1, 0, 0, 0, 374, 4699, 1, 0, 0, 0, 376, 4710, 
	1, 0, 0, 0, 378, 4712, 1, 0, 0, 0, 380, 4718, 1, 0, 0, 0, 382, 4728, 1, 
	0, 0, 0, 384, 4732, 1, 0, 0, 0, 386, 4739, 1, 0, 0, 0, 388, 4743, 1, 0, 
	0, 0, 390, 4749, 1, 0, 0, 0, 392, 4756, 1, 0, 0, 0, 394, 4762, 1, 0, 0, 
	0, 396, 4768, 1, 0, 0, 0, 398, 4773, 1, 0, 0, 0, 400, 4818, 1, 0, 0, 0, 
	402, 4839, 1, 0, 0, 0, 404, 4864, 1, 0, 0, 0, 406, 4867, 1, 0, 0, 0, 408, 
	4873, 1, 0, 0, 0, 410, 4889, 1, 0, 0, 0, 412, 4904, 1, 0, 0, 0, 414, 4910, 
	1, 0, 0, 0, 416, 4940, 1, 0, 0, 0, 418, 4942, 1, 0, 0, 0, 420, 4949, 1, 
	0, 0, 0, 422, 4961, 1, 0, 0, 0, 424, 4967, 1, 0, 0, 0, 426, 4992, 1, 0, 
	0, 0, 428, 4996, 1, 0, 0, 0, 430, 5000, 1, 0, 0, 0, 432, 5011, 1, 0, 0, 
	0, 434, 5092, 1, 0, 0, 0, 436, 5159, 1, 0, 0, 0, 438, 5161, 1, 0, 0, 0, 
	440, 5267, 1, 0, 0, 0, 442, 5291, 1, 0, 0, 0, 444, 5293, 1, 0, 0, 0, 446, 
	5311, 1, 0, 0, 0, 448, 5391, 1, 0, 0, 0, 450, 5393, 1, 0, 0, 0, 452, 5406, 
	1, 0, 0, 0, 454, 5417, 1, 0, 0, 0, 456, 5445, 1, 0, 0, 0, 458, 5449, 1, 
	0, 0, 0, 460, 5470, 1, 0, 0, 0, 462, 5480, 1, 0, 0, 0, 464, 5490, 1, 0, 
	0, 0, 466, 5530, 1, 0, 0, 0, 468, 5532, 1, 0, 0, 0, 470, 5535, 1, 0, 0, 
	0, 472, 5635, 1, 0, 0, 0, 474, 5653, 1, 0, 0, 0, 476, 5655, 1, 0, 0, 0, 
	478, 5659, 1, 0, 0, 0, 480, 5697, 1, 0, 0, 0, 482, 5706, 1, 0, 0, 0, 484, 
	5712, 1, 0, 0, 0, 486, 5719, 1, 0, 0, 0, 488, 5741, 1, 0, 0, 0, 490, 5743, 
	1, 0, 0, 0, 492, 5757, 1, 0, 0, 0, 494, 5763, 1, 0, 0, 0, 496, 5819, 1, 
	0, 0, 0, 498, 5974, 1, 0, 0, 0, 500, 5986, 1, 0, 0, 0, 502, 6001, 1, 0, 
	0, 0, 504, 6007, 1, 0, 0, 0, 506, 6026, 1, 0, 0, 0, 508, 6036, 1, 0, 0, 
	0, 510, 6050, 1, 0, 0, 0, 512, 6052, 1, 0, 0, 0, 514, 6055, 1, 0, 0, 0, 
	516, 6077, 1, 0, 0, 0, 518, 6089, 1, 0, 0, 0, 520, 6095, 1, 0, 0, 0, 522, 
	6107, 1, 0, 0, 0, 524, 6111, 1, 0, 0, 0, 526, 6113, 1, 0, 0, 0, 528, 6155, 
	1, 0, 0, 0, 530, 6162, 1, 0, 0, 0, 532, 6164, 1, 0, 0, 0, 534, 6187, 1, 
	0, 0, 0, 536, 6193, 1, 0, 0, 0, 538, 6201, 1, 0, 0, 0, 540, 6204, 1, 0, 
	0, 0, 542, 6207, 1, 0, 0, 0, 544, 6228, 1, 0, 0, 0, 546, 6249, 1, 0, 0, 
	0, 548, 6257, 1, 0, 0, 0, 550, 6269, 1, 0, 0, 0, 552, 6277, 1, 0, 0, 0, 
	554, 6315, 1, 0, 0, 0, 556, 6327, 1, 0, 0, 0, 558, 6329, 1, 0, 0, 0, 560, 
	6335, 1, 0, 0, 0, 562, 6339, 1, 0, 0, 0, 564, 6355, 1, 0, 0, 0, 566, 6368, 
	1, 0, 0, 0, 568, 6377, 1, 0, 0, 0, 570, 6379, 1, 0, 0, 0, 572, 6386, 1, 
	0, 0, 0, 574, 6388, 1, 0, 0, 0, 576, 6394, 1, 0, 0, 0, 578, 6398, 1, 0, 
	0, 0, 580, 6403, 1, 0, 0, 0, 582, 6405, 1, 0, 0, 0, 584, 6407, 1, 0, 0, 
	0, 586, 6425, 1, 0, 0, 0, 588, 6441, 1, 0, 0, 0, 590, 6445, 1, 0, 0, 0, 
	592, 6450, 1, 0, 0, 0, 594, 6461, 1, 0, 0, 0, 596, 6466, 1, 0, 0, 0, 598, 
	6468, 1, 0, 0, 0, 600, 6472, 1, 0, 0, 0, 602, 6497, 1, 0, 0, 0, 604, 6499, 
	1, 0, 0, 0, 606, 6502, 1, 0, 0, 0, 608, 6507, 1, 0, 0, 0, 610, 6523, 1, 
	0, 0, 0, 612, 6651, 1, 0, 0, 0, 614, 6653, 1, 0, 0, 0, 616, 6686, 1, 0, 
	0, 0, 618, 6691, 1, 0, 0, 0, 620, 6695, 1, 0, 0, 0, 622, 6701, 1, 0, 0, 
	0, 624, 6709, 1, 0, 0, 0, 626, 6717, 1, 0, 0, 0, 628, 6725, 1, 0, 0, 0, 
	630, 6733, 1, 0, 0, 0, 632, 6744, 1, 0, 0, 0, 634, 6752, 1, 0, 0, 0, 636, 
	6760, 1, 0, 0, 0, 638, 6768, 1, 0, 0, 0, 640, 6776, 1, 0, 0, 0, 642, 6810, 
	1, 0, 0, 0, 644, 6826, 1, 0, 0, 0, 646, 6830, 1, 0, 0, 0, 648, 6832, 1, 
	0, 0, 0, 650, 6835, 1, 0, 0, 0, 652, 6839, 1, 0, 0, 0, 654, 6845, 1, 0, 
	0, 0, 656, 6865, 1, 0, 0, 0, 658, 7046, 1, 0, 0, 0, 660, 7048, 1, 0, 0, 
	0, 662, 7067, 1, 0, 0, 0, 664, 7069, 1, 0, 0, 0, 666, 7132, 1, 0, 0, 0, 
	668, 7172, 1, 0, 0, 0, 670, 7174, 1, 0, 0, 0, 672, 7183, 1, 0, 0, 0, 674, 
	7194, 1, 0, 0, 0, 676, 7196, 1, 0, 0, 0, 678, 7199, 1, 0, 0, 0, 680, 7203, 
	1, 0, 0, 0, 682, 7205, 1, 0, 0, 0, 684, 7217, 1, 0, 0, 0, 686, 7219, 1, 
	0, 0, 0, 688, 7253, 1, 0, 0, 0, 690, 7255, 1, 0, 0, 0, 692, 7264, 1, 0, 
	0, 0, 694, 7282, 1, 0, 0, 0, 696, 7295, 1, 0, 0, 0, 698, 7306, 1, 0, 0, 
	0, 700, 7424, 1, 0, 0, 0, 702, 7450, 1, 0, 0, 0, 704, 7466, 1, 0, 0, 0, 
	706, 7475, 1, 0, 0, 0, 708, 7484, 1, 0, 0, 0, 710, 7486, 1, 0, 0, 0, 712, 
	7488, 1, 0, 0, 0, 714, 7495, 1, 0, 0, 0, 716, 7497, 1, 0, 0, 0, 718, 7499, 
	1, 0, 0, 0, 720, 7501, 1, 0, 0, 0, 722, 7503, 1, 0, 0, 0, 724, 7505, 1, 
	0, 0, 0, 726, 7507, 1, 0, 0, 0, 728, 7509, 1, 0, 0, 0, 730, 732, 3, 2, 
	1, 0, 731, 730, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732, 735, 1, 0, 0, 0, 
	733, 734, 5, 1121, 0, 0, 734, 736, 5, 1121, 0, 0, 735, 733, 1, 0, 0, 0, 
	735, 736, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 738, 5, 0, 0, 1, 738, 
	1, 1, 0, 0, 0, 739, 742, 3, 4, 2, 0, 740, 741, 5, 1121, 0, 0, 741, 743, 
	5, 1121, 0, 0, 742, 740, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 745, 1, 
	0, 0, 0, 744, 746, 5, 1136, 0, 0, 745, 744, 1, 0, 0, 0, 745, 746, 1, 0, 
	0, 0, 746, 749, 1, 0, 0, 0, 747, 749, 3, 6, 3, 0, 748, 739, 1, 0, 0, 0, 
	748, 747, 1, 0, 0, 0, 749, 752, 1, 0, 0, 0, 750, 748, 1, 0, 0, 0, 750, 
	751, 1, 0, 0, 0, 751, 762, 1, 0, 0, 0, 752, 750, 1, 0, 0, 0, 753, 759, 
	3, 4, 2, 0, 754, 755, 5, 1121, 0, 0, 755, 757, 5, 1121, 0, 0, 756, 754, 
	1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 760, 5, 1136, 
	0, 0, 759, 756, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 763, 1, 0, 0, 0, 
	761, 763, 3, 6, 3, 0, 762, 753, 1, 0, 0, 0, 762, 761, 1, 0, 0, 0, 763, 
	3, 1, 0, 0, 0, 764, 772, 3, 8, 4, 0, 765, 772, 3, 10, 5, 0, 766, 772, 3, 
	12, 6, 0, 767, 772, 3, 14, 7, 0, 768, 772, 3, 16, 8, 0, 769, 772, 3, 20, 
	10, 0, 770, 772, 3, 22, 11, 0, 771, 764, 1, 0, 0, 0, 771, 765, 1, 0, 0, 
	0, 771, 766, 1, 0, 0, 0, 771, 767, 1, 0, 0, 0, 771, 768, 1, 0, 0, 0, 771, 
	769, 1, 0, 0, 0, 771, 770, 1, 0, 0, 0, 772, 5, 1, 0, 0, 0, 773, 774, 5, 
	1136, 0, 0, 774, 7, 1, 0, 0, 0, 775, 814, 3, 24, 12, 0, 776, 814, 3, 26, 
	13, 0, 777, 814, 3, 28, 14, 0, 778, 814, 3, 30, 15, 0, 779, 814, 3, 32, 
	16, 0, 780, 814, 3, 34, 17, 0, 781, 814, 3, 38, 19, 0, 782, 814, 3, 40, 
	20, 0, 783, 814, 3, 42, 21, 0, 784, 814, 3, 44, 22, 0, 785, 814, 3, 46, 
	23, 0, 786, 814, 3, 56, 28, 0, 787, 814, 3, 36, 18, 0, 788, 814, 3, 128, 
	64, 0, 789, 814, 3, 130, 65, 0, 790, 814, 3, 132, 66, 0, 791, 814, 3, 134, 
	67, 0, 792, 814, 3, 136, 68, 0, 793, 814, 3, 138, 69, 0, 794, 814, 3, 140, 
	70, 0, 795, 814, 3, 142, 71, 0, 796, 814, 3, 144, 72, 0, 797, 814, 3, 146, 
	73, 0, 798, 814, 3, 152, 76, 0, 799, 814, 3, 154, 77, 0, 800, 814, 3, 156, 
	78, 0, 801, 814, 3, 158, 79, 0, 802, 814, 3, 160, 80, 0, 803, 814, 3, 162, 
	81, 0, 804, 814, 3, 164, 82, 0, 805, 814, 3, 166, 83, 0, 806, 814, 3, 168, 
	84, 0, 807, 814, 3, 170, 85, 0, 808, 814, 3, 172, 86, 0, 809, 814, 3, 174, 
	87, 0, 810, 814, 3, 176, 88, 0, 811, 814, 3, 178, 89, 0, 812, 814, 3, 182, 
	91, 0, 813, 775, 1, 0, 0, 0, 813, 776, 1, 0, 0, 0, 813, 777, 1, 0, 0, 0, 
	813, 778, 1, 0, 0, 0, 813, 779, 1, 0, 0, 0, 813, 780, 1, 0, 0, 0, 813, 
	781, 1, 0, 0, 0, 813, 782, 1, 0, 0, 0, 813, 783, 1, 0, 0, 0, 813, 784, 
	1, 0, 0, 0, 813, 785, 1, 0, 0, 0, 813, 786, 1, 0, 0, 0, 813, 787, 1, 0, 
	0, 0, 813, 788, 1, 0, 0, 0, 813, 789, 1, 0, 0, 0, 813, 790, 1, 0, 0, 0, 
	813, 791, 1, 0, 0, 0, 813, 792, 1, 0, 0, 0, 813, 793, 1, 0, 0, 0, 813, 
	794, 1, 0, 0, 0, 813, 795, 1, 0, 0, 0, 813, 796, 1, 0, 0, 0, 813, 797, 
	1, 0, 0, 0, 813, 798, 1, 0, 0, 0, 813, 799, 1, 0, 0, 0, 813, 800, 1, 0, 
	0, 0, 813, 801, 1, 0, 0, 0, 813, 802, 1, 0, 0, 0, 813, 803, 1, 0, 0, 0, 
	813, 804, 1, 0, 0, 0, 813, 805, 1, 0, 0, 0, 813, 806, 1, 0, 0, 0, 813, 
	807, 1, 0, 0, 0, 813, 808, 1, 0, 0, 0, 813, 809, 1, 0, 0, 0, 813, 810, 
	1, 0, 0, 0, 813, 811, 1, 0, 0, 0, 813, 812, 1, 0, 0, 0, 814, 9, 1, 0, 0, 
	0, 815, 829, 3, 200, 100, 0, 816, 829, 3, 192, 96, 0, 817, 829, 3, 202, 
	101, 0, 818, 829, 3, 186, 93, 0, 819, 829, 3, 198, 99, 0, 820, 829, 3, 
	184, 92, 0, 821, 829, 3, 194, 97, 0, 822, 829, 3, 196, 98, 0, 823, 829, 
	3, 188, 94, 0, 824, 829, 3, 190, 95, 0, 825, 829, 3, 204, 102, 0, 826, 
	829, 3, 548, 274, 0, 827, 829, 3, 550, 275, 0, 828, 815, 1, 0, 0, 0, 828, 
	816, 1, 0, 0, 0, 828, 817, 1, 0, 0, 0, 828, 818, 1, 0, 0, 0, 828, 819, 
	1, 0, 0, 0, 828, 820, 1, 0, 0, 0, 828, 821, 1, 0, 0, 0, 828, 822, 1, 0, 
	0, 0, 828, 823, 1, 0, 0, 0, 828, 824, 1, 0, 0, 0, 828, 825, 1, 0, 0, 0, 
	828, 826, 1, 0, 0, 0, 828, 827, 1, 0, 0, 0, 829, 11, 1, 0, 0, 0, 830, 840, 
	3, 306, 153, 0, 831, 840, 3, 308, 154, 0, 832, 840, 3, 310, 155, 0, 833, 
	840, 3, 312, 156, 0, 834, 840, 3, 314, 157, 0, 835, 840, 3, 316, 158, 0, 
	836, 840, 3, 318, 159, 0, 837, 840, 3, 320, 160, 0, 838, 840, 3, 322, 161, 
	0, 839, 830, 1, 0, 0, 0, 839, 831, 1, 0, 0, 0, 839, 832, 1, 0, 0, 0, 839, 
	833, 1, 0, 0, 0, 839, 834, 1, 0, 0, 0, 839, 835, 1, 0, 0, 0, 839, 836, 
	1, 0, 0, 0, 839, 837, 1, 0, 0, 0, 839, 838, 1, 0, 0, 0, 840, 13, 1, 0, 
	0, 0, 841, 857, 3, 338, 169, 0, 842, 857, 3, 340, 170, 0, 843, 857, 3, 
	342, 171, 0, 844, 857, 3, 344, 172, 0, 845, 857, 3, 346, 173, 0, 846, 857, 
	3, 348, 174, 0, 847, 857, 3, 350, 175, 0, 848, 857, 3, 352, 176, 0, 849, 
	857, 3, 354, 177, 0, 850, 857, 3, 378, 189, 0, 851, 857, 3, 380, 190, 0, 
	852, 857, 3, 382, 191, 0, 853, 857, 3, 384, 192, 0, 854, 857, 3, 386, 193, 
	0, 855, 857, 3, 388, 194, 0, 856, 841, 1, 0, 0, 0, 856, 842, 1, 0, 0, 0, 
	856, 843, 1, 0, 0, 0, 856, 844, 1, 0, 0, 0, 856, 845, 1, 0, 0, 0, 856, 
	846, 1, 0, 0, 0, 856, 847, 1, 0, 0, 0, 856, 848, 1, 0, 0, 0, 856, 849, 
	1, 0, 0, 0, 856, 850, 1, 0, 0, 0, 856, 851, 1, 0, 0, 0, 856, 852, 1, 0, 
	0, 0, 856, 853, 1, 0, 0, 0, 856, 854, 1, 0, 0, 0, 856, 855, 1, 0, 0, 0, 
	857, 15, 1, 0, 0, 0, 858, 862, 3, 390, 195, 0, 859, 862, 3, 392, 196, 0, 
	860, 862, 3, 394, 197, 0, 861, 858, 1, 0, 0, 0, 861, 859, 1, 0, 0, 0, 861, 
	860, 1, 0, 0, 0, 862, 17, 1, 0, 0, 0, 863, 877, 3, 398, 199, 0, 864, 877, 
	3, 400, 200, 0, 865, 877, 3, 402, 201, 0, 866, 877, 3, 406, 203, 0, 867, 
	877, 3, 408, 204, 0, 868, 877, 3, 410, 205, 0, 869, 877, 3, 414, 207, 0, 
	870, 877, 3, 404, 202, 0, 871, 877, 3, 412, 206, 0, 872, 877, 3, 416, 208, 
	0, 873, 874, 3, 548, 274, 0, 874, 875, 3, 10, 5, 0, 875, 877, 1, 0, 0, 
	0, 876, 863, 1, 0, 0, 0, 876, 864, 1, 0, 0, 0, 876, 865, 1, 0, 0, 0, 876, 
	866, 1, 0, 0, 0, 876, 867, 1, 0, 0, 0, 876, 868, 1, 0, 0, 0, 876, 869, 
	1, 0, 0, 0, 876, 870, 1, 0, 0, 0, 876, 871, 1, 0, 0, 0, 876, 872, 1, 0, 
	0, 0, 876, 873, 1, 0, 0, 0, 877, 19, 1, 0, 0, 0, 878, 904, 3, 434, 217, 
	0, 879, 904, 3, 436, 218, 0, 880, 904, 3, 438, 219, 0, 881, 904, 3, 440, 
	220, 0, 882, 904, 3, 444, 222, 0, 883, 904, 3, 446, 223, 0, 884, 904, 3, 
	448, 224, 0, 885, 904, 3, 450, 225, 0, 886, 904, 3, 478, 239, 0, 887, 904, 
	3, 480, 240, 0, 888, 904, 3, 482, 241, 0, 889, 904, 3, 484, 242, 0, 890, 
	904, 3, 486, 243, 0, 891, 904, 3, 490, 245, 0, 892, 904, 3, 492, 246, 0, 
	893, 904, 3, 494, 247, 0, 894, 904, 3, 496, 248, 0, 895, 904, 3, 498, 249, 
	0, 896, 904, 3, 512, 256, 0, 897, 904, 3, 514, 257, 0, 898, 904, 3, 516, 
	258, 0, 899, 904, 3, 518, 259, 0, 900, 904, 3, 520, 260, 0, 901, 904, 3, 
	522, 261, 0, 902, 904, 3, 524, 262, 0, 903, 878, 1, 0, 0, 0, 903, 879, 
	1, 0, 0, 0, 903, 880, 1, 0, 0, 0, 903, 881, 1, 0, 0, 0, 903, 882, 1, 0, 
	0, 0, 903, 883, 1, 0, 0, 0, 903, 884, 1, 0, 0, 0, 903, 885, 1, 0, 0, 0, 
	903, 886, 1, 0, 0, 0, 903, 887, 1, 0, 0, 0, 903, 888, 1, 0, 0, 0, 903, 
	889, 1, 0, 0, 0, 903, 890, 1, 0, 0, 0, 903, 891, 1, 0, 0, 0, 903, 892, 
	1, 0, 0, 0, 903, 893, 1, 0, 0, 0, 903, 894, 1, 0, 0, 0, 903, 895, 1, 0, 
	0, 0, 903, 896, 1, 0, 0, 0, 903, 897, 1, 0, 0, 0, 903, 898, 1, 0, 0, 0, 
	903, 899, 1, 0, 0, 0, 903, 900, 1, 0, 0, 0, 903, 901, 1, 0, 0, 0, 903, 
	902, 1, 0, 0, 0, 904, 21, 1, 0, 0, 0, 905, 913, 3, 534, 267, 0, 906, 913, 
	3, 536, 268, 0, 907, 913, 3, 538, 269, 0, 908, 913, 3, 540, 270, 0, 909, 
	913, 3, 542, 271, 0, 910, 913, 3, 544, 272, 0, 911, 913, 3, 552, 276, 0, 
	912, 905, 1, 0, 0, 0, 912, 906, 1, 0, 0, 0, 912, 907, 1, 0, 0, 0, 912, 
	908, 1, 0, 0, 0, 912, 909, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0, 912, 911, 
	1, 0, 0, 0, 913, 23, 1, 0, 0, 0, 914, 915, 5, 33, 0, 0, 915, 917, 7, 0, 
	0, 0, 916, 918, 3, 650, 325, 0, 917, 916, 1, 0, 0, 0, 917, 918, 1, 0, 0, 
	0, 918, 919, 1, 0, 0, 0, 919, 923, 3, 592, 296, 0, 920, 922, 3, 58, 29, 
	0, 921, 920, 1, 0, 0, 0, 922, 925, 1, 0, 0, 0, 923, 921, 1, 0, 0, 0, 923, 
	924, 1, 0, 0, 0, 924, 25, 1, 0, 0, 0, 925, 923, 1, 0, 0, 0, 926, 928, 5, 
	33, 0, 0, 927, 929, 3, 64, 32, 0, 928, 927, 1, 0, 0, 0, 928, 929, 1, 0, 
	0, 0, 929, 930, 1, 0, 0, 0, 930, 932, 5, 415, 0, 0, 931, 933, 3, 650, 325, 
	0, 932, 931, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 934, 1, 0, 0, 0, 934, 
	935, 3, 558, 279, 0, 935, 936, 5, 118, 0, 0, 936, 937, 5, 605, 0, 0, 937, 
	944, 3, 66, 33, 0, 938, 939, 5, 118, 0, 0, 939, 941, 5, 371, 0, 0, 940, 
	942, 5, 114, 0, 0, 941, 940, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 943, 
	1, 0, 0, 0, 943, 945, 5, 561, 0, 0, 944, 938, 1, 0, 0, 0, 944, 945, 1, 
	0, 0, 0, 945, 947, 1, 0, 0, 0, 946, 948, 3, 74, 37, 0, 947, 946, 1, 0, 
	0, 0, 947, 948, 1, 0, 0, 0, 948, 951, 1, 0, 0, 0, 949, 950, 5, 368, 0, 
	0, 950, 952, 5, 1148, 0, 0, 951, 949, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 
	952, 953, 1, 0, 0, 0, 953, 954, 5, 399, 0, 0, 954, 955, 3, 396, 198, 0, 
	955, 27, 1, 0, 0, 0, 956, 958, 5, 33, 0, 0, 957, 959, 7, 1, 0, 0, 958, 
	957, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 961, 1, 0, 0, 0, 960, 962, 
	7, 2, 0, 0, 961, 960, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 963, 1, 0, 
	0, 0, 963, 964, 5, 81, 0, 0, 964, 966, 3, 592, 296, 0, 965, 967, 3, 76, 
	38, 0, 966, 965, 1, 0, 0, 0, 966, 967, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 
	968, 969, 5, 118, 0, 0, 969, 970, 3, 560, 280, 0, 970, 974, 3, 630, 315, 
	0, 971, 973, 3, 78, 39, 0, 972, 971, 1, 0, 0, 0, 973, 976, 1, 0, 0, 0, 
	974, 972, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 989, 1, 0, 0, 0, 976, 
	974, 1, 0, 0, 0, 977, 979, 5, 336, 0, 0, 978, 980, 5, 1124, 0, 0, 979, 
	978, 1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981, 988, 
	7, 3, 0, 0, 982, 984, 5, 103, 0, 0, 983, 985, 5, 1124, 0, 0, 984, 983, 
	1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986, 988, 7, 4, 
	0, 0, 987, 977, 1, 0, 0, 0, 987, 982, 1, 0, 0, 0, 988, 991, 1, 0, 0, 0, 
	989, 987, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 29, 1, 0, 0, 0, 991, 989, 
	1, 0, 0, 0, 992, 993, 5, 33, 0, 0, 993, 994, 5, 475, 0, 0, 994, 995, 5, 
	73, 0, 0, 995, 996, 3, 592, 296, 0, 996, 997, 5, 5, 0, 0, 997, 998, 5, 
	659, 0, 0, 998, 1004, 5, 1148, 0, 0, 999, 1001, 5, 453, 0, 0, 1000, 1002, 
	5, 1124, 0, 0, 1001, 1000, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1003, 
	1, 0, 0, 0, 1003, 1005, 3, 600, 300, 0, 1004, 999, 1, 0, 0, 0, 1004, 1005, 
	1, 0, 0, 0, 1005, 1011, 1, 0, 0, 0, 1006, 1008, 5, 660, 0, 0, 1007, 1009, 
	5, 1124, 0, 0, 1008, 1007, 1, 0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1010, 
	1, 0, 0, 0, 1010, 1012, 3, 600, 300, 0, 1011, 1006, 1, 0, 0, 0, 1011, 1012, 
	1, 0, 0, 0, 1012, 1018, 1, 0, 0, 0, 1013, 1015, 5, 572, 0, 0, 1014, 1016, 
	5, 1124, 0, 0, 1015, 1014, 1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016, 1017, 
	1, 0, 0, 0, 1017, 1019, 3, 600, 300, 0, 1018, 1013, 1, 0, 0, 0, 1018, 1019, 
	1, 0, 0, 0, 1019, 1025, 1, 0, 0, 0, 1020, 1022, 5, 528, 0, 0, 1021, 1023, 
	5, 1124, 0, 0, 1022, 1021, 1, 0, 0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 1024, 
	1, 0, 0, 0, 1024, 1026, 3, 592, 296, 0, 1025, 1020, 1, 0, 0, 0, 1025, 1026, 
	1, 0, 0, 0, 1026, 1028, 1, 0, 0, 0, 1027, 1029, 5, 674, 0, 0, 1028, 1027, 
	1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1035, 1, 0, 0, 0, 1030, 1032, 
	5, 368, 0, 0, 1031, 1033, 5, 1124, 0, 0, 1032, 1031, 1, 0, 0, 0, 1032, 
	1033, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1036, 5, 1148, 0, 0, 1035, 
	1030, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 
	1039, 5, 409, 0, 0, 1038, 1040, 5, 1124, 0, 0, 1039, 1038, 1, 0, 0, 0, 
	1039, 1040, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1042, 3, 580, 290, 
	0, 1042, 31, 1, 0, 0, 0, 1043, 1045, 5, 33, 0, 0, 1044, 1046, 3, 64, 32, 
	0, 1045, 1044, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 
	0, 1047, 1048, 5, 131, 0, 0, 1048, 1049, 3, 558, 279, 0, 1049, 1051, 5, 
	1133, 0, 0, 1050, 1052, 3, 80, 40, 0, 1051, 1050, 1, 0, 0, 0, 1051, 1052, 
	1, 0, 0, 0, 1052, 1057, 1, 0, 0, 0, 1053, 1054, 5, 1135, 0, 0, 1054, 1056, 
	3, 80, 40, 0, 1055, 1053, 1, 0, 0, 0, 1056, 1059, 1, 0, 0, 0, 1057, 1055, 
	1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 1060, 1, 0, 0, 0, 1059, 1057, 
	1, 0, 0, 0, 1060, 1064, 5, 1134, 0, 0, 1061, 1063, 3, 84, 42, 0, 1062, 
	1061, 1, 0, 0, 0, 1063, 1066, 1, 0, 0, 0, 1064, 1062, 1, 0, 0, 0, 1064, 
	1065, 1, 0, 0, 0, 1065, 1067, 1, 0, 0, 0, 1066, 1064, 1, 0, 0, 0, 1067, 
	1068, 3, 396, 198, 0, 1068, 33, 1, 0, 0, 0, 1069, 1071, 5, 33, 0, 0, 1070, 
	1072, 3, 64, 32, 0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 
	1074, 1, 0, 0, 0, 1073, 1075, 5, 335, 0, 0, 1074, 1073, 1, 0, 0, 0, 1074, 
	1075, 1, 0, 0, 0, 1075, 1076, 1, 0, 0, 0, 1076, 1078, 5, 437, 0, 0, 1077, 
	1079, 3, 650, 325, 0, 1078, 1077, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 
	1080, 1, 0, 0, 0, 1080, 1081, 3, 558, 279, 0, 1081, 1083, 5, 1133, 0, 0, 
	1082, 1084, 3, 82, 41, 0, 1083, 1082, 1, 0, 0, 0, 1083, 1084, 1, 0, 0, 
	0, 1084, 1089, 1, 0, 0, 0, 1085, 1086, 5, 1135, 0, 0, 1086, 1088, 3, 82, 
	41, 0, 1087, 1085, 1, 0, 0, 0, 1088, 1091, 1, 0, 0, 0, 1089, 1087, 1, 0, 
	0, 0, 1089, 1090, 1, 0, 0, 0, 1090, 1092, 1, 0, 0, 0, 1091, 1089, 1, 0, 
	0, 0, 1092, 1093, 5, 1134, 0, 0, 1093, 1094, 5, 594, 0, 0, 1094, 1098, 
	3, 612, 306, 0, 1095, 1097, 3, 84, 42, 0, 1096, 1095, 1, 0, 0, 0, 1097, 
	1100, 1, 0, 0, 0, 1098, 1096, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 
	1103, 1, 0, 0, 0, 1100, 1098, 1, 0, 0, 0, 1101, 1104, 3, 396, 198, 0, 1102, 
	1104, 3, 412, 206, 0, 1103, 1101, 1, 0, 0, 0, 1103, 1102, 1, 0, 0, 0, 1104, 
	35, 1, 0, 0, 0, 1105, 1106, 5, 33, 0, 0, 1106, 1108, 5, 596, 0, 0, 1107, 
	1109, 3, 650, 325, 0, 1108, 1107, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 
	1110, 1, 0, 0, 0, 1110, 1115, 3, 562, 281, 0, 1111, 1112, 5, 1135, 0, 0, 
	1112, 1114, 3, 562, 281, 0, 1113, 1111, 1, 0, 0, 0, 1114, 1117, 1, 0, 0, 
	0, 1115, 1113, 1, 0, 0, 0, 1115, 1116, 1, 0, 0, 0, 1116, 37, 1, 0, 0, 0, 
	1117, 1115, 1, 0, 0, 0, 1118, 1119, 5, 33, 0, 0, 1119, 1120, 5, 608, 0, 
	0, 1120, 1121, 3, 592, 296, 0, 1121, 1122, 5, 67, 0, 0, 1122, 1123, 5, 
	388, 0, 0, 1123, 1124, 5, 679, 0, 0, 1124, 1125, 7, 5, 0, 0, 1125, 1126, 
	5, 541, 0, 0, 1126, 1127, 5, 1133, 0, 0, 1127, 1132, 3, 86, 43, 0, 1128, 
	1129, 5, 1135, 0, 0, 1129, 1131, 3, 86, 43, 0, 1130, 1128, 1, 0, 0, 0, 
	1131, 1134, 1, 0, 0, 0, 1132, 1130, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 
	1133, 1135, 1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1135, 1136, 5, 1134, 0, 
	0, 1136, 39, 1, 0, 0, 0, 1137, 1139, 5, 33, 0, 0, 1138, 1140, 5, 649, 0, 
	0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 
	0, 1141, 1143, 5, 172, 0, 0, 1142, 1144, 3, 650, 325, 0, 1143, 1142, 1, 
	0, 0, 0, 1143, 1144, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145, 1153, 3, 
	560, 280, 0, 1146, 1147, 5, 98, 0, 0, 1147, 1154, 3, 560, 280, 0, 1148, 
	1149, 5, 1133, 0, 0, 1149, 1150, 5, 98, 0, 0, 1150, 1151, 3, 560, 280, 
	0, 1151, 1152, 5, 1134, 0, 0, 1152, 1154, 1, 0, 0, 0, 1153, 1146, 1, 0, 
	0, 0, 1153, 1148, 1, 0, 0, 0, 1154, 1216, 1, 0, 0, 0, 1155, 1157, 5, 33, 
	0, 0, 1156, 1158, 5, 649, 0, 0, 1157, 1156, 1, 0, 0, 0, 1157, 1158, 1, 
	0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1161, 5, 172, 0, 0, 1160, 1162, 
	3, 650, 325, 0, 1161, 1160, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1163, 
	1, 0, 0, 0, 1163, 1165, 3, 560, 280, 0, 1164, 1166, 3, 88, 44, 0, 1165, 
	1164, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166, 1177, 1, 0, 0, 0, 1167, 
	1174, 3, 106, 53, 0, 1168, 1170, 5, 1135, 0, 0, 1169, 1168, 1, 0, 0, 0, 
	1169, 1170, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1173, 3, 106, 53, 
	0, 1172, 1169, 1, 0, 0, 0, 1173, 1176, 1, 0, 0, 0, 1174, 1172, 1, 0, 0, 
	0, 1174, 1175, 1, 0, 0, 0, 1175, 1178, 1, 0, 0, 0, 1176, 1174, 1, 0, 0, 
	0, 1177, 1167, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1180, 1, 0, 0, 
	0, 1179, 1181, 3, 112, 56, 0, 1180, 1179, 1, 0, 0, 0, 1180, 1181, 1, 0, 
	0, 0, 1181, 1183, 1, 0, 0, 0, 1182, 1184, 7, 6, 0, 0, 1183, 1182, 1, 0, 
	0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1186, 1, 0, 0, 0, 1185, 1187, 5, 12, 
	0, 0, 1186, 1185, 1, 0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187, 1188, 1, 0, 
	0, 0, 1188, 1189, 3, 200, 100, 0, 1189, 1216, 1, 0, 0, 0, 1190, 1192, 5, 
	33, 0, 0, 1191, 1193, 5, 649, 0, 0, 1192, 1191, 1, 0, 0, 0, 1192, 1193, 
	1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194, 1196, 5, 172, 0, 0, 1195, 1197, 
	3, 650, 325, 0, 1196, 1195, 1, 0, 0, 0, 1196, 1197, 1, 0, 0, 0, 1197, 1198, 
	1, 0, 0, 0, 1198, 1199, 3, 560, 280, 0, 1199, 1210, 3, 88, 44, 0, 1200, 
	1207, 3, 106, 53, 0, 1201, 1203, 5, 1135, 0, 0, 1202, 1201, 1, 0, 0, 0, 
	1202, 1203, 1, 0, 0, 0, 1203, 1204, 1, 0, 0, 0, 1204, 1206, 3, 106, 53, 
	0, 1205, 1202, 1, 0, 0, 0, 1206, 1209, 1, 0, 0, 0, 1207, 1205, 1, 0, 0, 
	0, 1207, 1208, 1, 0, 0, 0, 1208, 1211, 1, 0, 0, 0, 1209, 1207, 1, 0, 0, 
	0, 1210, 1200, 1, 0, 0, 0, 1210, 1211, 1, 0, 0, 0, 1211, 1213, 1, 0, 0, 
	0, 1212, 1214, 3, 112, 56, 0, 1213, 1212, 1, 0, 0, 0, 1213, 1214, 1, 0, 
	0, 0, 1214, 1216, 1, 0, 0, 0, 1215, 1137, 1, 0, 0, 0, 1215, 1155, 1, 0, 
	0, 0, 1215, 1190, 1, 0, 0, 0, 1216, 41, 1, 0, 0, 0, 1217, 1218, 5, 33, 
	0, 0, 1218, 1219, 5, 647, 0, 0, 1219, 1220, 3, 592, 296, 0, 1220, 1221, 
	5, 5, 0, 0, 1221, 1222, 5, 389, 0, 0, 1222, 1226, 5, 1148, 0, 0, 1223, 
	1224, 5, 428, 0, 0, 1224, 1225, 5, 1124, 0, 0, 1225, 1227, 3, 600, 300, 
	0, 1226, 1223, 1, 0, 0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1233, 1, 0, 0, 
	0, 1228, 1230, 5, 409, 0, 0, 1229, 1231, 5, 1124, 0, 0, 1230, 1229, 1, 
	0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1234, 3, 
	580, 290, 0, 1233, 1228, 1, 0, 0, 0, 1233, 1234, 1, 0, 0, 0, 1234, 43, 
	1, 0, 0, 0, 1235, 1236, 5, 33, 0, 0, 1236, 1237, 5, 647, 0, 0, 1237, 1238, 
	3, 592, 296, 0, 1238, 1239, 5, 5, 0, 0, 1239, 1240, 5, 389, 0, 0, 1240, 
	1241, 5, 1148, 0, 0, 1241, 1242, 5, 186, 0, 0, 1242, 1243, 5, 475, 0, 0, 
	1243, 1244, 5, 73, 0, 0, 1244, 1250, 3, 592, 296, 0, 1245, 1247, 5, 423, 
	0, 0, 1246, 1248, 5, 1124, 0, 0, 1247, 1246, 1, 0, 0, 0, 1247, 1248, 1, 
	0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249, 1251, 3, 600, 300, 0, 1250, 1245, 
	1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 1257, 1, 0, 0, 0, 1252, 1254, 
	5, 453, 0, 0, 1253, 1255, 5, 1124, 0, 0, 1254, 1253, 1, 0, 0, 0, 1254, 
	1255, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256, 1258, 3, 600, 300, 0, 1257, 
	1252, 1, 0, 0, 0, 1257, 1258, 1, 0, 0, 0, 1258, 1264, 1, 0, 0, 0, 1259, 
	1261, 5, 341, 0, 0, 1260, 1262, 5, 1124, 0, 0, 1261, 1260, 1, 0, 0, 0, 
	1261, 1262, 1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263, 1265, 3, 600, 300, 
	0, 1264, 1259, 1, 0, 0, 0, 1264, 1265, 1, 0, 0, 0, 1265, 1271, 1, 0, 0, 
	0, 1266, 1268, 5, 501, 0, 0, 1267, 1269, 5, 1124, 0, 0, 1268, 1267, 1, 
	0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 1270, 1, 0, 0, 0, 1270, 1272, 3, 
	600, 300, 0, 1271, 1266, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 1278, 
	1, 0, 0, 0, 1273, 1275, 5, 528, 0, 0, 1274, 1276, 5, 1124, 0, 0, 1275, 
	1274, 1, 0, 0, 0, 1275, 1276, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 
	1279, 3, 592, 296, 0, 1278, 1273, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0, 1279, 
	1281, 1, 0, 0, 0, 1280, 1282, 5, 674, 0, 0, 1281, 1280, 1, 0, 0, 0, 1281, 
	1282, 1, 0, 0, 0, 1282, 1288, 1, 0, 0, 0, 1283, 1285, 5, 368, 0, 0, 1284, 
	1286, 5, 1124, 0, 0, 1285, 1284, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 
	1287, 1, 0, 0, 0, 1287, 1289, 5, 1148, 0, 0, 1288, 1283, 1, 0, 0, 0, 1288, 
	1289, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1292, 5, 409, 0, 0, 1291, 
	1293, 5, 1124, 0, 0, 1292, 1291, 1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 
	1294, 1, 0, 0, 0, 1294, 1295, 3, 580, 290, 0, 1295, 45, 1, 0, 0, 0, 1296, 
	1298, 5, 33, 0, 0, 1297, 1299, 3, 64, 32, 0, 1298, 1297, 1, 0, 0, 0, 1298, 
	1299, 1, 0, 0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1301, 5, 177, 0, 0, 1301, 
	1302, 3, 558, 279, 0, 1302, 1303, 7, 7, 0, 0, 1303, 1304, 7, 8, 0, 0, 1304, 
	1305, 5, 118, 0, 0, 1305, 1306, 3, 560, 280, 0, 1306, 1307, 5, 65, 0, 0, 
	1307, 1308, 5, 52, 0, 0, 1308, 1311, 5, 600, 0, 0, 1309, 1310, 7, 9, 0, 
	0, 1310, 1312, 3, 558, 279, 0, 1311, 1309, 1, 0, 0, 0, 1311, 1312, 1, 0, 
	0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1314, 3, 396, 198, 0, 1314, 47, 1, 
	0, 0, 0, 1315, 1317, 5, 192, 0, 0, 1316, 1318, 5, 571, 0, 0, 1317, 1316, 
	1, 0, 0, 0, 1317, 1318, 1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1320, 
	3, 50, 25, 0, 1320, 49, 1, 0, 0, 0, 1321, 1333, 3, 52, 26, 0, 1322, 1323, 
	5, 1133, 0, 0, 1323, 1328, 3, 54, 27, 0, 1324, 1325, 5, 1135, 0, 0, 1325, 
	1327, 3, 54, 27, 0, 1326, 1324, 1, 0, 0, 0, 1327, 1330, 1, 0, 0, 0, 1328, 
	1326, 1, 0, 0, 0, 1328, 1329, 1, 0, 0, 0, 1329, 1331, 1, 0, 0, 0, 1330, 
	1328, 1, 0, 0, 0, 1331, 1332, 5, 1134, 0, 0, 1332, 1334, 1, 0, 0, 0, 1333, 
	1322, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 
	1336, 5, 12, 0, 0, 1336, 1337, 5, 1133, 0, 0, 1337, 1338, 3, 10, 5, 0, 
	1338, 1341, 5, 1134, 0, 0, 1339, 1340, 5, 1135, 0, 0, 1340, 1342, 3, 50, 
	25, 0, 1341, 1339, 1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 51, 1, 0, 
	0, 0, 1343, 1344, 3, 592, 296, 0, 1344, 53, 1, 0, 0, 0, 1345, 1346, 3, 
	592, 296, 0, 1346, 55, 1, 0, 0, 0, 1347, 1349, 5, 33, 0, 0, 1348, 1350, 
	3, 652, 326, 0, 1349, 1348, 1, 0, 0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 1354, 
	1, 0, 0, 0, 1351, 1352, 5, 336, 0, 0, 1352, 1353, 5, 1124, 0, 0, 1353, 
	1355, 7, 10, 0, 0, 1354, 1351, 1, 0, 0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 
	1357, 1, 0, 0, 0, 1356, 1358, 3, 64, 32, 0, 1357, 1356, 1, 0, 0, 0, 1357, 
	1358, 1, 0, 0, 0, 1358, 1362, 1, 0, 0, 0, 1359, 1360, 5, 160, 0, 0, 1360, 
	1361, 5, 606, 0, 0, 1361, 1363, 7, 11, 0, 0, 1362, 1359, 1, 0, 0, 0, 1362, 
	1363, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 1365, 5, 671, 0, 0, 1365, 
	1370, 3, 558, 279, 0, 1366, 1367, 5, 1133, 0, 0, 1367, 1368, 3, 624, 312, 
	0, 1368, 1369, 5, 1134, 0, 0, 1369, 1371, 1, 0, 0, 0, 1370, 1366, 1, 0, 
	0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 1392, 5, 12, 
	0, 0, 1373, 1375, 5, 1133, 0, 0, 1374, 1376, 3, 48, 24, 0, 1375, 1374, 
	1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 1378, 
	3, 200, 100, 0, 1378, 1379, 5, 1134, 0, 0, 1379, 1393, 1, 0, 0, 0, 1380, 
	1382, 3, 48, 24, 0, 1381, 1380, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0, 1382, 
	1383, 1, 0, 0, 0, 1383, 1390, 3, 200, 100, 0, 1384, 1386, 5, 192, 0, 0, 
	1385, 1387, 7, 12, 0, 0, 1386, 1385, 1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 
	1387, 1388, 1, 0, 0, 0, 1388, 1389, 5, 26, 0, 0, 1389, 1391, 5, 120, 0, 
	0, 1390, 1384, 1, 0, 0, 0, 1390, 1391, 1, 0, 0, 0, 1391, 1393, 1, 0, 0, 
	0, 1392, 1373, 1, 0, 0, 0, 1392, 1381, 1, 0, 0, 0, 1393, 57, 1, 0, 0, 0, 
	1394, 1396, 5, 42, 0, 0, 1395, 1394, 1, 0, 0, 0, 1395, 1396, 1, 0, 0, 0, 
	1396, 1397, 1, 0, 0, 0, 1397, 1399, 3, 60, 30, 0, 1398, 1400, 5, 1124, 
	0, 0, 1399, 1398, 1, 0, 0, 0, 1399, 1400, 1, 0, 0, 0, 1400, 1403, 1, 0, 
	0, 0, 1401, 1404, 3, 576, 288, 0, 1402, 1404, 5, 42, 0, 0, 1403, 1401, 
	1, 0, 0, 0, 1403, 1402, 1, 0, 0, 0, 1404, 1428, 1, 0, 0, 0, 1405, 1407, 
	5, 42, 0, 0, 1406, 1405, 1, 0, 0, 0, 1406, 1407, 1, 0, 0, 0, 1407, 1408, 
	1, 0, 0, 0, 1408, 1410, 5, 27, 0, 0, 1409, 1411, 5, 1124, 0, 0, 1410, 1409, 
	1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411, 1412, 1, 0, 0, 0, 1412, 1428, 
	3, 578, 289, 0, 1413, 1415, 5, 42, 0, 0, 1414, 1413, 1, 0, 0, 0, 1414, 
	1415, 1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416, 1418, 5, 405, 0, 0, 1417, 
	1419, 5, 1124, 0, 0, 1418, 1417, 1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 
	1420, 1, 0, 0, 0, 1420, 1428, 5, 1148, 0, 0, 1421, 1422, 5, 134, 0, 0, 
	1422, 1424, 5, 538, 0, 0, 1423, 1425, 5, 1124, 0, 0, 1424, 1423, 1, 0, 
	0, 0, 1424, 1425, 1, 0, 0, 0, 1425, 1426, 1, 0, 0, 0, 1426, 1428, 7, 13, 
	0, 0, 1427, 1395, 1, 0, 0, 0, 1427, 1406, 1, 0, 0, 0, 1427, 1414, 1, 0, 
	0, 0, 1427, 1421, 1, 0, 0, 0, 1428, 59, 1, 0, 0, 0, 1429, 1430, 5, 25, 
	0, 0, 1430, 1435, 5, 153, 0, 0, 1431, 1435, 5, 841, 0, 0, 1432, 1433, 5, 
	222, 0, 0, 1433, 1435, 5, 153, 0, 0, 1434, 1429, 1, 0, 0, 0, 1434, 1431, 
	1, 0, 0, 0, 1434, 1432, 1, 0, 0, 0, 1435, 61, 1, 0, 0, 0, 1436, 1439, 5, 
	37, 0, 0, 1437, 1438, 5, 1133, 0, 0, 1438, 1440, 5, 1134, 0, 0, 1439, 1437, 
	1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 63, 1, 0, 0, 0, 1441, 1442, 5, 
	392, 0, 0, 1442, 1445, 5, 1124, 0, 0, 1443, 1446, 3, 572, 286, 0, 1444, 
	1446, 3, 62, 31, 0, 1445, 1443, 1, 0, 0, 0, 1445, 1444, 1, 0, 0, 0, 1446, 
	65, 1, 0, 0, 0, 1447, 1448, 5, 338, 0, 0, 1448, 1452, 3, 68, 34, 0, 1449, 
	1451, 3, 70, 35, 0, 1450, 1449, 1, 0, 0, 0, 1451, 1454, 1, 0, 0, 0, 1452, 
	1450, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 1482, 1, 0, 0, 0, 1454, 
	1452, 1, 0, 0, 0, 1455, 1458, 5, 417, 0, 0, 1456, 1459, 3, 598, 299, 0, 
	1457, 1459, 3, 696, 348, 0, 1458, 1456, 1, 0, 0, 0, 1458, 1457, 1, 0, 0, 
	0, 1459, 1460, 1, 0, 0, 0, 1460, 1469, 3, 72, 36, 0, 1461, 1462, 5, 630, 
	0, 0, 1462, 1466, 3, 68, 34, 0, 1463, 1465, 3, 70, 35, 0, 1464, 1463, 1, 
	0, 0, 0, 1465, 1468, 1, 0, 0, 0, 1466, 1464, 1, 0, 0, 0, 1466, 1467, 1, 
	0, 0, 0, 1467, 1470, 1, 0, 0, 0, 1468, 1466, 1, 0, 0, 0, 1469, 1461, 1, 
	0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 1479, 1, 0, 0, 0, 1471, 1472, 5, 
	408, 0, 0, 1472, 1476, 3, 68, 34, 0, 1473, 1475, 3, 70, 35, 0, 1474, 1473, 
	1, 0, 0, 0, 1475, 1478, 1, 0, 0, 0, 1476, 1474, 1, 0, 0, 0, 1476, 1477, 
	1, 0, 0, 0, 1477, 1480, 1, 0, 0, 0, 1478, 1476, 1, 0, 0, 0, 1479, 1471, 
	1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480, 1482, 1, 0, 0, 0, 1481, 1447, 
	1, 0, 0, 0, 1481, 1455, 1, 0, 0, 0, 1482, 67, 1, 0, 0, 0, 1483, 1488, 5, 
	315, 0, 0, 1484, 1488, 3, 602, 301, 0, 1485, 1488, 3, 598, 299, 0, 1486, 
	1488, 3, 696, 348, 0, 1487, 1483, 1, 0, 0, 0, 1487, 1484, 1, 0, 0, 0, 1487, 
	1485, 1, 0, 0, 0, 1487, 1486, 1, 0, 0, 0, 1488, 69, 1, 0, 0, 0, 1489, 1490, 
	5, 1120, 0, 0, 1490, 1493, 5, 86, 0, 0, 1491, 1494, 3, 598, 299, 0, 1492, 
	1494, 3, 696, 348, 0, 1493, 1491, 1, 0, 0, 0, 1493, 1492, 1, 0, 0, 0, 1494, 
	1495, 1, 0, 0, 0, 1495, 1496, 3, 72, 36, 0, 1496, 71, 1, 0, 0, 0, 1497, 
	1511, 3, 722, 361, 0, 1498, 1511, 5, 221, 0, 0, 1499, 1511, 5, 240, 0, 
	0, 1500, 1511, 5, 241, 0, 0, 1501, 1511, 5, 242, 0, 0, 1502, 1511, 5, 243, 
	0, 0, 1503, 1511, 5, 244, 0, 0, 1504, 1511, 5, 245, 0, 0, 1505, 1511, 5, 
	246, 0, 0, 1506, 1511, 5, 247, 0, 0, 1507, 1511, 5, 248, 0, 0, 1508, 1511, 
	5, 249, 0, 0, 1509, 1511, 5, 250, 0, 0, 1510, 1497, 1, 0, 0, 0, 1510, 1498, 
	1, 0, 0, 0, 1510, 1499, 1, 0, 0, 0, 1510, 1500, 1, 0, 0, 0, 1510, 1501, 
	1, 0, 0, 0, 1510, 1502, 1, 0, 0, 0, 1510, 1503, 1, 0, 0, 0, 1510, 1504, 
	1, 0, 0, 0, 1510, 1505, 1, 0, 0, 0, 1510, 1506, 1, 0, 0, 0, 1510, 1507, 
	1, 0, 0, 0, 1510, 1508, 1, 0, 0, 0, 1510, 1509, 1, 0, 0, 0, 1511, 73, 1, 
	0, 0, 0, 1512, 1518, 5, 403, 0, 0, 1513, 1518, 5, 396, 0, 0, 1514, 1515, 
	5, 396, 0, 0, 1515, 1516, 5, 118, 0, 0, 1516, 1518, 5, 614, 0, 0, 1517, 
	1512, 1, 0, 0, 0, 1517, 1513, 1, 0, 0, 0, 1517, 1514, 1, 0, 0, 0, 1518, 
	75, 1, 0, 0, 0, 1519, 1520, 5, 187, 0, 0, 1520, 1521, 7, 14, 0, 0, 1521, 
	77, 1, 0, 0, 0, 1522, 1524, 5, 467, 0, 0, 1523, 1525, 5, 1124, 0, 0, 1524, 
	1523, 1, 0, 0, 0, 1524, 1525, 1, 0, 0, 0, 1525, 1526, 1, 0, 0, 0, 1526, 
	1545, 3, 600, 300, 0, 1527, 1545, 3, 76, 38, 0, 1528, 1529, 5, 192, 0, 
	0, 1529, 1530, 5, 547, 0, 0, 1530, 1545, 3, 592, 296, 0, 1531, 1532, 5, 
	368, 0, 0, 1532, 1545, 5, 1148, 0, 0, 1533, 1545, 7, 15, 0, 0, 1534, 1536, 
	5, 875, 0, 0, 1535, 1537, 5, 1124, 0, 0, 1536, 1535, 1, 0, 0, 0, 1536, 
	1537, 1, 0, 0, 0, 1537, 1538, 1, 0, 0, 0, 1538, 1545, 5, 1148, 0, 0, 1539, 
	1541, 5, 1000, 0, 0, 1540, 1542, 5, 1124, 0, 0, 1541, 1540, 1, 0, 0, 0, 
	1541, 1542, 1, 0, 0, 0, 1542, 1543, 1, 0, 0, 0, 1543, 1545, 5, 1148, 0, 
	0, 1544, 1522, 1, 0, 0, 0, 1544, 1527, 1, 0, 0, 0, 1544, 1528, 1, 0, 0, 
	0, 1544, 1531, 1, 0, 0, 0, 1544, 1533, 1, 0, 0, 0, 1544, 1534, 1, 0, 0, 
	0, 1544, 1539, 1, 0, 0, 0, 1545, 79, 1, 0, 0, 0, 1546, 1548, 7, 16, 0, 
	0, 1547, 1546, 1, 0, 0, 0, 1547, 1548, 1, 0, 0, 0, 1548, 1549, 1, 0, 0, 
	0, 1549, 1550, 3, 592, 296, 0, 1550, 1551, 3, 612, 306, 0, 1551, 81, 1, 
	0, 0, 0, 1552, 1553, 3, 592, 296, 0, 1553, 1554, 3, 612, 306, 0, 1554, 
	83, 1, 0, 0, 0, 1555, 1556, 5, 368, 0, 0, 1556, 1579, 5, 1148, 0, 0, 1557, 
	1558, 5, 468, 0, 0, 1558, 1579, 5, 160, 0, 0, 1559, 1561, 5, 114, 0, 0, 
	1560, 1559, 1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1562, 1, 0, 0, 0, 
	1562, 1579, 5, 47, 0, 0, 1563, 1564, 5, 381, 0, 0, 1564, 1574, 5, 160, 
	0, 0, 1565, 1566, 5, 521, 0, 0, 1566, 1574, 5, 160, 0, 0, 1567, 1568, 5, 
	135, 0, 0, 1568, 1569, 5, 160, 0, 0, 1569, 1574, 5, 388, 0, 0, 1570, 1571, 
	5, 112, 0, 0, 1571, 1572, 5, 160, 0, 0, 1572, 1574, 5, 388, 0, 0, 1573, 
	1563, 1, 0, 0, 0, 1573, 1565, 1, 0, 0, 0, 1573, 1567, 1, 0, 0, 0, 1573, 
	1570, 1, 0, 0, 0, 1574, 1579, 1, 0, 0, 0, 1575, 1576, 5, 160, 0, 0, 1576, 
	1577, 5, 606, 0, 0, 1577, 1579, 7, 11, 0, 0, 1578, 1555, 1, 0, 0, 0, 1578, 
	1557, 1, 0, 0, 0, 1578, 1560, 1, 0, 0, 0, 1578, 1573, 1, 0, 0, 0, 1578, 
	1575, 1, 0, 0, 0, 1579, 85, 1, 0, 0, 0, 1580, 1581, 5, 446, 0, 0, 1581, 
	1595, 5, 1148, 0, 0, 1582, 1583, 5, 39, 0, 0, 1583, 1595, 5, 1148, 0, 0, 
	1584, 1585, 5, 665, 0, 0, 1585, 1595, 5, 1148, 0, 0, 1586, 1587, 5, 551, 
	0, 0, 1587, 1595, 5, 1148, 0, 0, 1588, 1589, 5, 617, 0, 0, 1589, 1595, 
	5, 1148, 0, 0, 1590, 1591, 5, 542, 0, 0, 1591, 1595, 5, 1148, 0, 0, 1592, 
	1593, 5, 557, 0, 0, 1593, 1595, 3, 598, 299, 0, 1594, 1580, 1, 0, 0, 0, 
	1594, 1582, 1, 0, 0, 0, 1594, 1584, 1, 0, 0, 0, 1594, 1586, 1, 0, 0, 0, 
	1594, 1588, 1, 0, 0, 0, 1594, 1590, 1, 0, 0, 0, 1594, 1592, 1, 0, 0, 0, 
	1595, 87, 1, 0, 0, 0, 1596, 1597, 5, 1133, 0, 0, 1597, 1602, 3, 90, 45, 
	0, 1598, 1599, 5, 1135, 0, 0, 1599, 1601, 3, 90, 45, 0, 1600, 1598, 1, 
	0, 0, 0, 1601, 1604, 1, 0, 0, 0, 1602, 1600, 1, 0, 0, 0, 1602, 1603, 1, 
	0, 0, 0, 1603, 1605, 1, 0, 0, 0, 1604, 1602, 1, 0, 0, 0, 1605, 1606, 5, 
	1134, 0, 0, 1606, 89, 1, 0, 0, 0, 1607, 1608, 3, 564, 282, 0, 1608, 1609, 
	3, 92, 46, 0, 1609, 1619, 1, 0, 0, 0, 1610, 1612, 3, 96, 48, 0, 1611, 1613, 
	5, 114, 0, 0, 1612, 1611, 1, 0, 0, 0, 1612, 1613, 1, 0, 0, 0, 1613, 1615, 
	1, 0, 0, 0, 1614, 1616, 5, 57, 0, 0, 1615, 1614, 1, 0, 0, 0, 1615, 1616, 
	1, 0, 0, 0, 1616, 1619, 1, 0, 0, 0, 1617, 1619, 3, 104, 52, 0, 1618, 1607, 
	1, 0, 0, 0, 1618, 1610, 1, 0, 0, 0, 1618, 1617, 1, 0, 0, 0, 1619, 91, 1, 
	0, 0, 0, 1620, 1624, 3, 612, 306, 0, 1621, 1623, 3, 94, 47, 0, 1622, 1621, 
	1, 0, 0, 0, 1623, 1626, 1, 0, 0, 0, 1624, 1622, 1, 0, 0, 0, 1624, 1625, 
	1, 0, 0, 0, 1625, 1628, 1, 0, 0, 0, 1626, 1624, 1, 0, 0, 0, 1627, 1629, 
	5, 114, 0, 0, 1628, 1627, 1, 0, 0, 0, 1628, 1629, 1, 0, 0, 0, 1629, 1631, 
	1, 0, 0, 0, 1630, 1632, 5, 57, 0, 0, 1631, 1630, 1, 0, 0, 0, 1631, 1632, 
	1, 0, 0, 0, 1632, 93, 1, 0, 0, 0, 1633, 1687, 3, 608, 304, 0, 1634, 1635, 
	5, 42, 0, 0, 1635, 1687, 3, 642, 321, 0, 1636, 1687, 5, 673, 0, 0, 1637, 
	1687, 5, 459, 0, 0, 1638, 1643, 5, 342, 0, 0, 1639, 1640, 5, 118, 0, 0, 
	1640, 1641, 5, 184, 0, 0, 1641, 1643, 3, 644, 322, 0, 1642, 1638, 1, 0, 
	0, 0, 1642, 1639, 1, 0, 0, 0, 1643, 1687, 1, 0, 0, 0, 1644, 1646, 5, 130, 
	0, 0, 1645, 1644, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646, 1647, 1, 0, 
	0, 0, 1647, 1687, 5, 91, 0, 0, 1648, 1650, 5, 181, 0, 0, 1649, 1651, 5, 
	91, 0, 0, 1650, 1649, 1, 0, 0, 0, 1650, 1651, 1, 0, 0, 0, 1651, 1687, 1, 
	0, 0, 0, 1652, 1653, 5, 368, 0, 0, 1653, 1687, 5, 1148, 0, 0, 1654, 1655, 
	5, 366, 0, 0, 1655, 1687, 7, 17, 0, 0, 1656, 1657, 5, 636, 0, 0, 1657, 
	1687, 7, 18, 0, 0, 1658, 1687, 3, 98, 49, 0, 1659, 1660, 5, 27, 0, 0, 1660, 
	1687, 3, 578, 289, 0, 1661, 1662, 5, 70, 0, 0, 1662, 1664, 5, 8, 0, 0, 
	1663, 1661, 1, 0, 0, 0, 1663, 1664, 1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 
	1665, 1666, 5, 12, 0, 0, 1666, 1667, 5, 1133, 0, 0, 1667, 1668, 3, 696, 
	348, 0, 1668, 1670, 5, 1134, 0, 0, 1669, 1671, 7, 19, 0, 0, 1670, 1669, 
	1, 0, 0, 0, 1670, 1671, 1, 0, 0, 0, 1671, 1687, 1, 0, 0, 0, 1672, 1673, 
	5, 239, 0, 0, 1673, 1674, 5, 42, 0, 0, 1674, 1687, 5, 669, 0, 0, 1675, 
	1677, 5, 30, 0, 0, 1676, 1678, 3, 592, 296, 0, 1677, 1676, 1, 0, 0, 0, 
	1677, 1678, 1, 0, 0, 0, 1678, 1680, 1, 0, 0, 0, 1679, 1675, 1, 0, 0, 0, 
	1679, 1680, 1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1682, 5, 26, 0, 0, 
	1682, 1683, 5, 1133, 0, 0, 1683, 1684, 3, 696, 348, 0, 1684, 1685, 5, 1134, 
	0, 0, 1685, 1687, 1, 0, 0, 0, 1686, 1633, 1, 0, 0, 0, 1686, 1634, 1, 0, 
	0, 0, 1686, 1636, 1, 0, 0, 0, 1686, 1637, 1, 0, 0, 0, 1686, 1642, 1, 0, 
	0, 0, 1686, 1645, 1, 0, 0, 0, 1686, 1648, 1, 0, 0, 0, 1686, 1652, 1, 0, 
	0, 0, 1686, 1654, 1, 0, 0, 0, 1686, 1656, 1, 0, 0, 0, 1686, 1658, 1, 0, 
	0, 0, 1686, 1659, 1, 0, 0, 0, 1686, 1663, 1, 0, 0, 0, 1686, 1672, 1, 0, 
	0, 0, 1686, 1679, 1, 0, 0, 0, 1687, 95, 1, 0, 0, 0, 1688, 1690, 5, 30, 
	0, 0, 1689, 1691, 3, 592, 296, 0, 1690, 1689, 1, 0, 0, 0, 1690, 1691, 1, 
	0, 0, 0, 1691, 1693, 1, 0, 0, 0, 1692, 1688, 1, 0, 0, 0, 1692, 1693, 1, 
	0, 0, 0, 1693, 1694, 1, 0, 0, 0, 1694, 1695, 5, 130, 0, 0, 1695, 1697, 
	5, 91, 0, 0, 1696, 1698, 3, 592, 296, 0, 1697, 1696, 1, 0, 0, 0, 1697, 
	1698, 1, 0, 0, 0, 1698, 1700, 1, 0, 0, 0, 1699, 1701, 3, 76, 38, 0, 1700, 
	1699, 1, 0, 0, 0, 1700, 1701, 1, 0, 0, 0, 1701, 1702, 1, 0, 0, 0, 1702, 
	1706, 3, 630, 315, 0, 1703, 1705, 3, 78, 39, 0, 1704, 1703, 1, 0, 0, 0, 
	1705, 1708, 1, 0, 0, 0, 1706, 1704, 1, 0, 0, 0, 1706, 1707, 1, 0, 0, 0, 
	1707, 1758, 1, 0, 0, 0, 1708, 1706, 1, 0, 0, 0, 1709, 1711, 5, 30, 0, 0, 
	1710, 1712, 3, 592, 296, 0, 1711, 1710, 1, 0, 0, 0, 1711, 1712, 1, 0, 0, 
	0, 1712, 1714, 1, 0, 0, 0, 1713, 1709, 1, 0, 0, 0, 1713, 1714, 1, 0, 0, 
	0, 1714, 1715, 1, 0, 0, 0, 1715, 1717, 5, 181, 0, 0, 1716, 1718, 7, 20, 
	0, 0, 1717, 1716, 1, 0, 0, 0, 1717, 1718, 1, 0, 0, 0, 1718, 1720, 1, 0, 
	0, 0, 1719, 1721, 3, 592, 296, 0, 1720, 1719, 1, 0, 0, 0, 1720, 1721, 1, 
	0, 0, 0, 1721, 1723, 1, 0, 0, 0, 1722, 1724, 3, 76, 38, 0, 1723, 1722, 
	1, 0, 0, 0, 1723, 1724, 1, 0, 0, 0, 1724, 1725, 1, 0, 0, 0, 1725, 1729, 
	3, 630, 315, 0, 1726, 1728, 3, 78, 39, 0, 1727, 1726, 1, 0, 0, 0, 1728, 
	1731, 1, 0, 0, 0, 1729, 1727, 1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0, 1730, 
	1758, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1732, 1734, 5, 30, 0, 0, 1733, 
	1735, 3, 592, 296, 0, 1734, 1733, 1, 0, 0, 0, 1734, 1735, 1, 0, 0, 0, 1735, 
	1737, 1, 0, 0, 0, 1736, 1732, 1, 0, 0, 0, 1736, 1737, 1, 0, 0, 0, 1737, 
	1738, 1, 0, 0, 0, 1738, 1739, 5, 67, 0, 0, 1739, 1741, 5, 91, 0, 0, 1740, 
	1742, 3, 592, 296, 0, 1741, 1740, 1, 0, 0, 0, 1741, 1742, 1, 0, 0, 0, 1742, 
	1743, 1, 0, 0, 0, 1743, 1744, 3, 630, 315, 0, 1744, 1745, 3, 98, 49, 0, 
	1745, 1758, 1, 0, 0, 0, 1746, 1748, 5, 30, 0, 0, 1747, 1749, 3, 592, 296, 
	0, 1748, 1747, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749, 1751, 1, 0, 0, 
	0, 1750, 1746, 1, 0, 0, 0, 1750, 1751, 1, 0, 0, 0, 1751, 1752, 1, 0, 0, 
	0, 1752, 1753, 5, 26, 0, 0, 1753, 1754, 5, 1133, 0, 0, 1754, 1755, 3, 696, 
	348, 0, 1755, 1756, 5, 1134, 0, 0, 1756, 1758, 1, 0, 0, 0, 1757, 1692, 
	1, 0, 0, 0, 1757, 1713, 1, 0, 0, 0, 1757, 1736, 1, 0, 0, 0, 1757, 1750, 
	1, 0, 0, 0, 1758, 97, 1, 0, 0, 0, 1759, 1760, 5, 136, 0, 0, 1760, 1762, 
	3, 560, 280, 0, 1761, 1763, 3, 630, 315, 0, 1762, 1761, 1, 0, 0, 0, 1762, 
	1763, 1, 0, 0, 0, 1763, 1766, 1, 0, 0, 0, 1764, 1765, 5, 109, 0, 0, 1765, 
	1767, 7, 21, 0, 0, 1766, 1764, 1, 0, 0, 0, 1766, 1767, 1, 0, 0, 0, 1767, 
	1769, 1, 0, 0, 0, 1768, 1770, 3, 100, 50, 0, 1769, 1768, 1, 0, 0, 0, 1769, 
	1770, 1, 0, 0, 0, 1770, 99, 1, 0, 0, 0, 1771, 1772, 5, 118, 0, 0, 1772, 
	1773, 5, 44, 0, 0, 1773, 1777, 3, 102, 51, 0, 1774, 1775, 5, 118, 0, 0, 
	1775, 1776, 5, 184, 0, 0, 1776, 1778, 3, 102, 51, 0, 1777, 1774, 1, 0, 
	0, 0, 1777, 1778, 1, 0, 0, 0, 1778, 1788, 1, 0, 0, 0, 1779, 1780, 5, 118, 
	0, 0, 1780, 1781, 5, 184, 0, 0, 1781, 1785, 3, 102, 51, 0, 1782, 1783, 
	5, 118, 0, 0, 1783, 1784, 5, 44, 0, 0, 1784, 1786, 3, 102, 51, 0, 1785, 
	1782, 1, 0, 0, 0, 1785, 1786, 1, 0, 0, 0, 1786, 1788, 1, 0, 0, 0, 1787, 
	1771, 1, 0, 0, 0, 1787, 1779, 1, 0, 0, 0, 1788, 101, 1, 0, 0, 0, 1789, 
	1798, 5, 144, 0, 0, 1790, 1798, 5, 21, 0, 0, 1791, 1792, 5, 153, 0, 0, 
	1792, 1798, 5, 116, 0, 0, 1793, 1794, 5, 521, 0, 0, 1794, 1798, 5, 333, 
	0, 0, 1795, 1796, 5, 153, 0, 0, 1796, 1798, 5, 42, 0, 0, 1797, 1789, 1, 
	0, 0, 0, 1797, 1790, 1, 0, 0, 0, 1797, 1791, 1, 0, 0, 0, 1797, 1793, 1, 
	0, 0, 0, 1797, 1795, 1, 0, 0, 0, 1798, 103, 1, 0, 0, 0, 1799, 1801, 7, 
	20, 0, 0, 1800, 1802, 3, 592, 296, 0, 1801, 1800, 1, 0, 0, 0, 1801, 1802, 
	1, 0, 0, 0, 1802, 1804, 1, 0, 0, 0, 1803, 1805, 3, 76, 38, 0, 1804, 1803, 
	1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1806, 1, 0, 0, 0, 1806, 1810, 
	3, 630, 315, 0, 1807, 1809, 3, 78, 39, 0, 1808, 1807, 1, 0, 0, 0, 1809, 
	1812, 1, 0, 0, 0, 1810, 1808, 1, 0, 0, 0, 1810, 1811, 1, 0, 0, 0, 1811, 
	1828, 1, 0, 0, 0, 1812, 1810, 1, 0, 0, 0, 1813, 1815, 7, 22, 0, 0, 1814, 
	1816, 7, 20, 0, 0, 1815, 1814, 1, 0, 0, 0, 1815, 1816, 1, 0, 0, 0, 1816, 
	1818, 1, 0, 0, 0, 1817, 1819, 3, 592, 296, 0, 1818, 1817, 1, 0, 0, 0, 1818, 
	1819, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1820, 1824, 3, 630, 315, 0, 1821, 
	1823, 3, 78, 39, 0, 1822, 1821, 1, 0, 0, 0, 1823, 1826, 1, 0, 0, 0, 1824, 
	1822, 1, 0, 0, 0, 1824, 1825, 1, 0, 0, 0, 1825, 1828, 1, 0, 0, 0, 1826, 
	1824, 1, 0, 0, 0, 1827, 1799, 1, 0, 0, 0, 1827, 1813, 1, 0, 0, 0, 1828, 
	105, 1, 0, 0, 0, 1829, 1831, 5, 409, 0, 0, 1830, 1832, 5, 1124, 0, 0, 1831, 
	1830, 1, 0, 0, 0, 1831, 1832, 1, 0, 0, 0, 1832, 1834, 1, 0, 0, 0, 1833, 
	1835, 3, 580, 290, 0, 1834, 1833, 1, 0, 0, 0, 1834, 1835, 1, 0, 0, 0, 1835, 
	2015, 1, 0, 0, 0, 1836, 1838, 5, 875, 0, 0, 1837, 1839, 5, 1124, 0, 0, 
	1838, 1837, 1, 0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839, 1840, 1, 0, 0, 0, 
	1840, 2015, 5, 1148, 0, 0, 1841, 1843, 5, 341, 0, 0, 1842, 1844, 5, 1124, 
	0, 0, 1843, 1842, 1, 0, 0, 0, 1843, 1844, 1, 0, 0, 0, 1844, 1845, 1, 0, 
	0, 0, 1845, 2015, 3, 598, 299, 0, 1846, 1848, 5, 342, 0, 0, 1847, 1849, 
	5, 1124, 0, 0, 1848, 1847, 1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849, 1850, 
	1, 0, 0, 0, 1850, 2015, 3, 598, 299, 0, 1851, 1853, 5, 343, 0, 0, 1852, 
	1854, 5, 1124, 0, 0, 1853, 1852, 1, 0, 0, 0, 1853, 1854, 1, 0, 0, 0, 1854, 
	1855, 1, 0, 0, 0, 1855, 2015, 3, 598, 299, 0, 1856, 1858, 5, 42, 0, 0, 
	1857, 1856, 1, 0, 0, 0, 1857, 1858, 1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0, 
	1859, 1861, 3, 60, 30, 0, 1860, 1862, 5, 1124, 0, 0, 1861, 1860, 1, 0, 
	0, 0, 1861, 1862, 1, 0, 0, 0, 1862, 1865, 1, 0, 0, 0, 1863, 1866, 3, 576, 
	288, 0, 1864, 1866, 5, 42, 0, 0, 1865, 1863, 1, 0, 0, 0, 1865, 1864, 1, 
	0, 0, 0, 1866, 2015, 1, 0, 0, 0, 1867, 1869, 7, 23, 0, 0, 1868, 1870, 5, 
	1124, 0, 0, 1869, 1868, 1, 0, 0, 0, 1869, 1870, 1, 0, 0, 0, 1870, 1871, 
	1, 0, 0, 0, 1871, 2015, 7, 24, 0, 0, 1872, 1874, 5, 42, 0, 0, 1873, 1872, 
	1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 1875, 1, 0, 0, 0, 1875, 1877, 
	5, 27, 0, 0, 1876, 1878, 5, 1124, 0, 0, 1877, 1876, 1, 0, 0, 0, 1877, 1878, 
	1, 0, 0, 0, 1878, 1879, 1, 0, 0, 0, 1879, 2015, 3, 578, 289, 0, 1880, 1882, 
	5, 368, 0, 0, 1881, 1883, 5, 1124, 0, 0, 1882, 1881, 1, 0, 0, 0, 1882, 
	1883, 1, 0, 0, 0, 1883, 1884, 1, 0, 0, 0, 1884, 2015, 5, 1148, 0, 0, 1885, 
	1887, 5, 373, 0, 0, 1886, 1888, 5, 1124, 0, 0, 1887, 1886, 1, 0, 0, 0, 
	1887, 1888, 1, 0, 0, 0, 1888, 1889, 1, 0, 0, 0, 1889, 2015, 7, 25, 0, 0, 
	1890, 1892, 5, 376, 0, 0, 1891, 1893, 5, 1124, 0, 0, 1892, 1891, 1, 0, 
	0, 0, 1892, 1893, 1, 0, 0, 0, 1893, 1894, 1, 0, 0, 0, 1894, 2015, 5, 1148, 
	0, 0, 1895, 1896, 7, 26, 0, 0, 1896, 1898, 5, 395, 0, 0, 1897, 1899, 5, 
	1124, 0, 0, 1898, 1897, 1, 0, 0, 0, 1898, 1899, 1, 0, 0, 0, 1899, 1900, 
	1, 0, 0, 0, 1900, 2015, 5, 1148, 0, 0, 1901, 1903, 5, 393, 0, 0, 1902, 
	1904, 5, 1124, 0, 0, 1903, 1902, 1, 0, 0, 0, 1903, 1904, 1, 0, 0, 0, 1904, 
	1905, 1, 0, 0, 0, 1905, 2015, 7, 24, 0, 0, 1906, 1908, 5, 405, 0, 0, 1907, 
	1909, 5, 1124, 0, 0, 1908, 1907, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 
	1910, 1, 0, 0, 0, 1910, 2015, 5, 1148, 0, 0, 1911, 1913, 7, 27, 0, 0, 1912, 
	1914, 5, 1124, 0, 0, 1913, 1912, 1, 0, 0, 0, 1913, 1914, 1, 0, 0, 0, 1914, 
	1915, 1, 0, 0, 0, 1915, 2015, 7, 24, 0, 0, 1916, 1918, 7, 28, 0, 0, 1917, 
	1919, 5, 1124, 0, 0, 1918, 1917, 1, 0, 0, 0, 1918, 1919, 1, 0, 0, 0, 1919, 
	1920, 1, 0, 0, 0, 1920, 2015, 3, 598, 299, 0, 1921, 1923, 5, 406, 0, 0, 
	1922, 1924, 5, 1124, 0, 0, 1923, 1922, 1, 0, 0, 0, 1923, 1924, 1, 0, 0, 
	0, 1924, 1925, 1, 0, 0, 0, 1925, 2015, 3, 598, 299, 0, 1926, 1927, 5, 81, 
	0, 0, 1927, 1929, 5, 395, 0, 0, 1928, 1930, 5, 1124, 0, 0, 1929, 1928, 
	1, 0, 0, 0, 1929, 1930, 1, 0, 0, 0, 1930, 1931, 1, 0, 0, 0, 1931, 2015, 
	5, 1148, 0, 0, 1932, 1934, 5, 455, 0, 0, 1933, 1935, 5, 1124, 0, 0, 1934, 
	1933, 1, 0, 0, 0, 1934, 1935, 1, 0, 0, 0, 1935, 1936, 1, 0, 0, 0, 1936, 
	2015, 7, 29, 0, 0, 1937, 1939, 5, 467, 0, 0, 1938, 1940, 5, 1124, 0, 0, 
	1939, 1938, 1, 0, 0, 0, 1939, 1940, 1, 0, 0, 0, 1940, 1941, 1, 0, 0, 0, 
	1941, 2015, 3, 600, 300, 0, 1942, 1944, 5, 500, 0, 0, 1943, 1945, 5, 1124, 
	0, 0, 1944, 1943, 1, 0, 0, 0, 1944, 1945, 1, 0, 0, 0, 1945, 1946, 1, 0, 
	0, 0, 1946, 2015, 3, 598, 299, 0, 1947, 1949, 5, 510, 0, 0, 1948, 1950, 
	5, 1124, 0, 0, 1949, 1948, 1, 0, 0, 0, 1949, 1950, 1, 0, 0, 0, 1950, 1951, 
	1, 0, 0, 0, 1951, 2015, 3, 598, 299, 0, 1952, 1954, 5, 543, 0, 0, 1953, 
	1955, 5, 1124, 0, 0, 1954, 1953, 1, 0, 0, 0, 1954, 1955, 1, 0, 0, 0, 1955, 
	1956, 1, 0, 0, 0, 1956, 2015, 7, 13, 0, 0, 1957, 1959, 5, 551, 0, 0, 1958, 
	1960, 5, 1124, 0, 0, 1959, 1958, 1, 0, 0, 0, 1959, 1960, 1, 0, 0, 0, 1960, 
	1961, 1, 0, 0, 0, 1961, 2015, 5, 1148, 0, 0, 1962, 1964, 5, 602, 0, 0, 
	1963, 1965, 5, 1124, 0, 0, 1964, 1963, 1, 0, 0, 0, 1964, 1965, 1, 0, 0, 
	0, 1965, 1966, 1, 0, 0, 0, 1966, 2015, 7, 30, 0, 0, 1967, 1968, 5, 629, 
	0, 0, 1968, 2015, 5, 653, 0, 0, 1969, 1971, 5, 1000, 0, 0, 1970, 1972, 
	5, 1124, 0, 0, 1971, 1970, 1, 0, 0, 0, 1971, 1972, 1, 0, 0, 0, 1972, 1973, 
	1, 0, 0, 0, 1973, 2015, 5, 1148, 0, 0, 1974, 1976, 5, 631, 0, 0, 1975, 
	1977, 5, 1124, 0, 0, 1976, 1975, 1, 0, 0, 0, 1976, 1977, 1, 0, 0, 0, 1977, 
	1978, 1, 0, 0, 0, 1978, 2015, 7, 13, 0, 0, 1979, 1981, 5, 632, 0, 0, 1980, 
	1982, 5, 1124, 0, 0, 1981, 1980, 1, 0, 0, 0, 1981, 1982, 1, 0, 0, 0, 1982, 
	1983, 1, 0, 0, 0, 1983, 2015, 7, 13, 0, 0, 1984, 1986, 5, 633, 0, 0, 1985, 
	1987, 5, 1124, 0, 0, 1986, 1985, 1, 0, 0, 0, 1986, 1987, 1, 0, 0, 0, 1987, 
	1990, 1, 0, 0, 0, 1988, 1991, 5, 42, 0, 0, 1989, 1991, 3, 598, 299, 0, 
	1990, 1988, 1, 0, 0, 0, 1990, 1989, 1, 0, 0, 0, 1991, 2015, 1, 0, 0, 0, 
	1992, 1993, 5, 647, 0, 0, 1993, 1995, 3, 592, 296, 0, 1994, 1996, 3, 110, 
	55, 0, 1995, 1994, 1, 0, 0, 0, 1995, 1996, 1, 0, 0, 0, 1996, 2015, 1, 0, 
	0, 0, 1997, 1998, 5, 648, 0, 0, 1998, 1999, 5, 1124, 0, 0, 1999, 2015, 
	3, 108, 54, 0, 2000, 2015, 3, 110, 55, 0, 2001, 2003, 5, 654, 0, 0, 2002, 
	2004, 5, 1124, 0, 0, 2003, 2002, 1, 0, 0, 0, 2003, 2004, 1, 0, 0, 0, 2004, 
	2005, 1, 0, 0, 0, 2005, 2015, 7, 24, 0, 0, 2006, 2008, 5, 180, 0, 0, 2007, 
	2009, 5, 1124, 0, 0, 2008, 2007, 1, 0, 0, 0, 2008, 2009, 1, 0, 0, 0, 2009, 
	2010, 1, 0, 0, 0, 2010, 2011, 5, 1133, 0, 0, 2011, 2012, 3, 628, 314, 0, 
	2012, 2013, 5, 1134, 0, 0, 2013, 2015, 1, 0, 0, 0, 2014, 1829, 1, 0, 0, 
	0, 2014, 1836, 1, 0, 0, 0, 2014, 1841, 1, 0, 0, 0, 2014, 1846, 1, 0, 0, 
	0, 2014, 1851, 1, 0, 0, 0, 2014, 1857, 1, 0, 0, 0, 2014, 1867, 1, 0, 0, 
	0, 2014, 1873, 1, 0, 0, 0, 2014, 1880, 1, 0, 0, 0, 2014, 1885, 1, 0, 0, 
	0, 2014, 1890, 1, 0, 0, 0, 2014, 1895, 1, 0, 0, 0, 2014, 1901, 1, 0, 0, 
	0, 2014, 1906, 1, 0, 0, 0, 2014, 1911, 1, 0, 0, 0, 2014, 1916, 1, 0, 0, 
	0, 2014, 1921, 1, 0, 0, 0, 2014, 1926, 1, 0, 0, 0, 2014, 1932, 1, 0, 0, 
	0, 2014, 1937, 1, 0, 0, 0, 2014, 1942, 1, 0, 0, 0, 2014, 1947, 1, 0, 0, 
	0, 2014, 1952, 1, 0, 0, 0, 2014, 1957, 1, 0, 0, 0, 2014, 1962, 1, 0, 0, 
	0, 2014, 1967, 1, 0, 0, 0, 2014, 1969, 1, 0, 0, 0, 2014, 1974, 1, 0, 0, 
	0, 2014, 1979, 1, 0, 0, 0, 2014, 1984, 1, 0, 0, 0, 2014, 1992, 1, 0, 0, 
	0, 2014, 1997, 1, 0, 0, 0, 2014, 2000, 1, 0, 0, 0, 2014, 2001, 1, 0, 0, 
	0, 2014, 2006, 1, 0, 0, 0, 2015, 107, 1, 0, 0, 0, 2016, 2017, 7, 31, 0, 
	0, 2017, 109, 1, 0, 0, 0, 2018, 2019, 5, 636, 0, 0, 2019, 2020, 7, 18, 
	0, 0, 2020, 111, 1, 0, 0, 0, 2021, 2022, 5, 129, 0, 0, 2022, 2023, 5, 19, 
	0, 0, 2023, 2026, 3, 114, 57, 0, 2024, 2025, 5, 550, 0, 0, 2025, 2027, 
	3, 598, 299, 0, 2026, 2024, 1, 0, 0, 0, 2026, 2027, 1, 0, 0, 0, 2027, 2035, 
	1, 0, 0, 0, 2028, 2029, 5, 641, 0, 0, 2029, 2030, 5, 19, 0, 0, 2030, 2033, 
	3, 116, 58, 0, 2031, 2032, 5, 642, 0, 0, 2032, 2034, 3, 598, 299, 0, 2033, 
	2031, 1, 0, 0, 0, 2033, 2034, 1, 0, 0, 0, 2034, 2036, 1, 0, 0, 0, 2035, 
	2028, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2048, 1, 0, 0, 0, 2037, 
	2038, 5, 1133, 0, 0, 2038, 2043, 3, 118, 59, 0, 2039, 2040, 5, 1135, 0, 
	0, 2040, 2042, 3, 118, 59, 0, 2041, 2039, 1, 0, 0, 0, 2042, 2045, 1, 0, 
	0, 0, 2043, 2041, 1, 0, 0, 0, 2043, 2044, 1, 0, 0, 0, 2044, 2046, 1, 0, 
	0, 0, 2045, 2043, 1, 0, 0, 0, 2046, 2047, 5, 1134, 0, 0, 2047, 2049, 1, 
	0, 0, 0, 2048, 2037, 1, 0, 0, 0, 2048, 2049, 1, 0, 0, 0, 2049, 113, 1, 
	0, 0, 0, 2050, 2052, 5, 100, 0, 0, 2051, 2050, 1, 0, 0, 0, 2051, 2052, 
	1, 0, 0, 0, 2052, 2053, 1, 0, 0, 0, 2053, 2054, 5, 443, 0, 0, 2054, 2055, 
	5, 1133, 0, 0, 2055, 2056, 3, 696, 348, 0, 2056, 2057, 5, 1134, 0, 0, 2057, 
	2097, 1, 0, 0, 0, 2058, 2060, 5, 100, 0, 0, 2059, 2058, 1, 0, 0, 0, 2059, 
	2060, 1, 0, 0, 0, 2060, 2061, 1, 0, 0, 0, 2061, 2065, 5, 91, 0, 0, 2062, 
	2063, 5, 336, 0, 0, 2063, 2064, 5, 1124, 0, 0, 2064, 2066, 7, 32, 0, 0, 
	2065, 2062, 1, 0, 0, 0, 2065, 2066, 1, 0, 0, 0, 2066, 2067, 1, 0, 0, 0, 
	2067, 2069, 5, 1133, 0, 0, 2068, 2070, 3, 624, 312, 0, 2069, 2068, 1, 0, 
	0, 0, 2069, 2070, 1, 0, 0, 0, 2070, 2071, 1, 0, 0, 0, 2071, 2097, 5, 1134, 
	0, 0, 2072, 2082, 5, 133, 0, 0, 2073, 2074, 5, 1133, 0, 0, 2074, 2075, 
	3, 696, 348, 0, 2075, 2076, 5, 1134, 0, 0, 2076, 2083, 1, 0, 0, 0, 2077, 
	2078, 5, 365, 0, 0, 2078, 2079, 5, 1133, 0, 0, 2079, 2080, 3, 624, 312, 
	0, 2080, 2081, 5, 1134, 0, 0, 2081, 2083, 1, 0, 0, 0, 2082, 2073, 1, 0, 
	0, 0, 2082, 2077, 1, 0, 0, 0, 2083, 2097, 1, 0, 0, 0, 2084, 2094, 5, 473, 
	0, 0, 2085, 2086, 5, 1133, 0, 0, 2086, 2087, 3, 696, 348, 0, 2087, 2088, 
	5, 1134, 0, 0, 2088, 2095, 1, 0, 0, 0, 2089, 2090, 5, 365, 0, 0, 2090, 
	2091, 5, 1133, 0, 0, 2091, 2092, 3, 624, 312, 0, 2092, 2093, 5, 1134, 0, 
	0, 2093, 2095, 1, 0, 0, 0, 2094, 2085, 1, 0, 0, 0, 2094, 2089, 1, 0, 0, 
	0, 2095, 2097, 1, 0, 0, 0, 2096, 2051, 1, 0, 0, 0, 2096, 2059, 1, 0, 0, 
	0, 2096, 2072, 1, 0, 0, 0, 2096, 2084, 1, 0, 0, 0, 2097, 115, 1, 0, 0, 
	0, 2098, 2100, 5, 100, 0, 0, 2099, 2098, 1, 0, 0, 0, 2099, 2100, 1, 0, 
	0, 0, 2100, 2101, 1, 0, 0, 0, 2101, 2102, 5, 443, 0, 0, 2102, 2103, 5, 
	1133, 0, 0, 2103, 2104, 3, 696, 348, 0, 2104, 2105, 5, 1134, 0, 0, 2105, 
	2120, 1, 0, 0, 0, 2106, 2108, 5, 100, 0, 0, 2107, 2106, 1, 0, 0, 0, 2107, 
	2108, 1, 0, 0, 0, 2108, 2109, 1, 0, 0, 0, 2109, 2113, 5, 91, 0, 0, 2110, 
	2111, 5, 336, 0, 0, 2111, 2112, 5, 1124, 0, 0, 2112, 2114, 7, 32, 0, 0, 
	2113, 2110, 1, 0, 0, 0, 2113, 2114, 1, 0, 0, 0, 2114, 2115, 1, 0, 0, 0, 
	2115, 2116, 5, 1133, 0, 0, 2116, 2117, 3, 624, 312, 0, 2117, 2118, 5, 1134, 
	0, 0, 2118, 2120, 1, 0, 0, 0, 2119, 2099, 1, 0, 0, 0, 2119, 2107, 1, 0, 
	0, 0, 2120, 117, 1, 0, 0, 0, 2121, 2122, 5, 129, 0, 0, 2122, 2123, 3, 592, 
	296, 0, 2123, 2124, 5, 188, 0, 0, 2124, 2125, 5, 471, 0, 0, 2125, 2126, 
	5, 651, 0, 0, 2126, 2127, 5, 1133, 0, 0, 2127, 2132, 3, 120, 60, 0, 2128, 
	2129, 5, 1135, 0, 0, 2129, 2131, 3, 120, 60, 0, 2130, 2128, 1, 0, 0, 0, 
	2131, 2134, 1, 0, 0, 0, 2132, 2130, 1, 0, 0, 0, 2132, 2133, 1, 0, 0, 0, 
	2133, 2135, 1, 0, 0, 0, 2134, 2132, 1, 0, 0, 0, 2135, 2139, 5, 1134, 0, 
	0, 2136, 2138, 3, 126, 63, 0, 2137, 2136, 1, 0, 0, 0, 2138, 2141, 1, 0, 
	0, 0, 2139, 2137, 1, 0, 0, 0, 2139, 2140, 1, 0, 0, 0, 2140, 2153, 1, 0, 
	0, 0, 2141, 2139, 1, 0, 0, 0, 2142, 2143, 5, 1133, 0, 0, 2143, 2148, 3, 
	124, 62, 0, 2144, 2145, 5, 1135, 0, 0, 2145, 2147, 3, 124, 62, 0, 2146, 
	2144, 1, 0, 0, 0, 2147, 2150, 1, 0, 0, 0, 2148, 2146, 1, 0, 0, 0, 2148, 
	2149, 1, 0, 0, 0, 2149, 2151, 1, 0, 0, 0, 2150, 2148, 1, 0, 0, 0, 2151, 
	2152, 5, 1134, 0, 0, 2152, 2154, 1, 0, 0, 0, 2153, 2142, 1, 0, 0, 0, 2153, 
	2154, 1, 0, 0, 0, 2154, 2268, 1, 0, 0, 0, 2155, 2156, 5, 129, 0, 0, 2156, 
	2157, 3, 592, 296, 0, 2157, 2158, 5, 188, 0, 0, 2158, 2159, 5, 471, 0, 
	0, 2159, 2160, 5, 651, 0, 0, 2160, 2164, 3, 120, 60, 0, 2161, 2163, 3, 
	126, 63, 0, 2162, 2161, 1, 0, 0, 0, 2163, 2166, 1, 0, 0, 0, 2164, 2162, 
	1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2178, 1, 0, 0, 0, 2166, 2164, 
	1, 0, 0, 0, 2167, 2168, 5, 1133, 0, 0, 2168, 2173, 3, 124, 62, 0, 2169, 
	2170, 5, 1135, 0, 0, 2170, 2172, 3, 124, 62, 0, 2171, 2169, 1, 0, 0, 0, 
	2172, 2175, 1, 0, 0, 0, 2173, 2171, 1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 
	2174, 2176, 1, 0, 0, 0, 2175, 2173, 1, 0, 0, 0, 2176, 2177, 5, 1134, 0, 
	0, 2177, 2179, 1, 0, 0, 0, 2178, 2167, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 
	0, 2179, 2268, 1, 0, 0, 0, 2180, 2181, 5, 129, 0, 0, 2181, 2182, 3, 592, 
	296, 0, 2182, 2183, 5, 188, 0, 0, 2183, 2184, 5, 80, 0, 0, 2184, 2185, 
	5, 1133, 0, 0, 2185, 2190, 3, 120, 60, 0, 2186, 2187, 5, 1135, 0, 0, 2187, 
	2189, 3, 120, 60, 0, 2188, 2186, 1, 0, 0, 0, 2189, 2192, 1, 0, 0, 0, 2190, 
	2188, 1, 0, 0, 0, 2190, 2191, 1, 0, 0, 0, 2191, 2193, 1, 0, 0, 0, 2192, 
	2190, 1, 0, 0, 0, 2193, 2197, 5, 1134, 0, 0, 2194, 2196, 3, 126, 63, 0, 
	2195, 2194, 1, 0, 0, 0, 2196, 2199, 1, 0, 0, 0, 2197, 2195, 1, 0, 0, 0, 
	2197, 2198, 1, 0, 0, 0, 2198, 2211, 1, 0, 0, 0, 2199, 2197, 1, 0, 0, 0, 
	2200, 2201, 5, 1133, 0, 0, 2201, 2206, 3, 124, 62, 0, 2202, 2203, 5, 1135, 
	0, 0, 2203, 2205, 3, 124, 62, 0, 2204, 2202, 1, 0, 0, 0, 2205, 2208, 1, 
	0, 0, 0, 2206, 2204, 1, 0, 0, 0, 2206, 2207, 1, 0, 0, 0, 2207, 2209, 1, 
	0, 0, 0, 2208, 2206, 1, 0, 0, 0, 2209, 2210, 5, 1134, 0, 0, 2210, 2212, 
	1, 0, 0, 0, 2211, 2200, 1, 0, 0, 0, 2211, 2212, 1, 0, 0, 0, 2212, 2268, 
	1, 0, 0, 0, 2213, 2214, 5, 129, 0, 0, 2214, 2215, 3, 592, 296, 0, 2215, 
	2216, 5, 188, 0, 0, 2216, 2217, 5, 80, 0, 0, 2217, 2218, 5, 1133, 0, 0, 
	2218, 2223, 3, 122, 61, 0, 2219, 2220, 5, 1135, 0, 0, 2220, 2222, 3, 122, 
	61, 0, 2221, 2219, 1, 0, 0, 0, 2222, 2225, 1, 0, 0, 0, 2223, 2221, 1, 0, 
	0, 0, 2223, 2224, 1, 0, 0, 0, 2224, 2226, 1, 0, 0, 0, 2225, 2223, 1, 0, 
	0, 0, 2226, 2230, 5, 1134, 0, 0, 2227, 2229, 3, 126, 63, 0, 2228, 2227, 
	1, 0, 0, 0, 2229, 2232, 1, 0, 0, 0, 2230, 2228, 1, 0, 0, 0, 2230, 2231, 
	1, 0, 0, 0, 2231, 2244, 1, 0, 0, 0, 2232, 2230, 1, 0, 0, 0, 2233, 2234, 
	5, 1133, 0, 0, 2234, 2239, 3, 124, 62, 0, 2235, 2236, 5, 1135, 0, 0, 2236, 
	2238, 3, 124, 62, 0, 2237, 2235, 1, 0, 0, 0, 2238, 2241, 1, 0, 0, 0, 2239, 
	2237, 1, 0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240, 2242, 1, 0, 0, 0, 2241, 
	2239, 1, 0, 0, 0, 2242, 2243, 5, 1134, 0, 0, 2243, 2245, 1, 0, 0, 0, 2244, 
	2233, 1, 0, 0, 0, 2244, 2245, 1, 0, 0, 0, 2245, 2268, 1, 0, 0, 0, 2246, 
	2247, 5, 129, 0, 0, 2247, 2251, 3, 592, 296, 0, 2248, 2250, 3, 126, 63, 
	0, 2249, 2248, 1, 0, 0, 0, 2250, 2253, 1, 0, 0, 0, 2251, 2249, 1, 0, 0, 
	0, 2251, 2252, 1, 0, 0, 0, 2252, 2265, 1, 0, 0, 0, 2253, 2251, 1, 0, 0, 
	0, 2254, 2255, 5, 1133, 0, 0, 2255, 2260, 3, 124, 62, 0, 2256, 2257, 5, 
	1135, 0, 0, 2257, 2259, 3, 124, 62, 0, 2258, 2256, 1, 0, 0, 0, 2259, 2262, 
	1, 0, 0, 0, 2260, 2258, 1, 0, 0, 0, 2260, 2261, 1, 0, 0, 0, 2261, 2263, 
	1, 0, 0, 0, 2262, 2260, 1, 0, 0, 0, 2263, 2264, 5, 1134, 0, 0, 2264, 2266, 
	1, 0, 0, 0, 2265, 2254, 1, 0, 0, 0, 2265, 2266, 1, 0, 0, 0, 2266, 2268, 
	1, 0, 0, 0, 2267, 2121, 1, 0, 0, 0, 2267, 2155, 1, 0, 0, 0, 2267, 2180, 
	1, 0, 0, 0, 2267, 2213, 1, 0, 0, 0, 2267, 2246, 1, 0, 0, 0, 2268, 119, 
	1, 0, 0, 0, 2269, 2273, 3, 610, 305, 0, 2270, 2273, 3, 696, 348, 0, 2271, 
	2273, 5, 110, 0, 0, 2272, 2269, 1, 0, 0, 0, 2272, 2270, 1, 0, 0, 0, 2272, 
	2271, 1, 0, 0, 0, 2273, 121, 1, 0, 0, 0, 2274, 2275, 5, 1133, 0, 0, 2275, 
	2278, 3, 120, 60, 0, 2276, 2277, 5, 1135, 0, 0, 2277, 2279, 3, 120, 60, 
	0, 2278, 2276, 1, 0, 0, 0, 2279, 2280, 1, 0, 0, 0, 2280, 2278, 1, 0, 0, 
	0, 2280, 2281, 1, 0, 0, 0, 2281, 2282, 1, 0, 0, 0, 2282, 2283, 5, 1134, 
	0, 0, 2283, 123, 1, 0, 0, 0, 2284, 2285, 5, 641, 0, 0, 2285, 2289, 3, 592, 
	296, 0, 2286, 2288, 3, 126, 63, 0, 2287, 2286, 1, 0, 0, 0, 2288, 2291, 
	1, 0, 0, 0, 2289, 2287, 1, 0, 0, 0, 2289, 2290, 1, 0, 0, 0, 2290, 125, 
	1, 0, 0, 0, 2291, 2289, 1, 0, 0, 0, 2292, 2294, 5, 42, 0, 0, 2293, 2292, 
	1, 0, 0, 0, 2293, 2294, 1, 0, 0, 0, 2294, 2296, 1, 0, 0, 0, 2295, 2297, 
	5, 636, 0, 0, 2296, 2295, 1, 0, 0, 0, 2296, 2297, 1, 0, 0, 0, 2297, 2298, 
	1, 0, 0, 0, 2298, 2300, 5, 409, 0, 0, 2299, 2301, 5, 1124, 0, 0, 2300, 
	2299, 1, 0, 0, 0, 2300, 2301, 1, 0, 0, 0, 2301, 2302, 1, 0, 0, 0, 2302, 
	2341, 3, 580, 290, 0, 2303, 2305, 5, 368, 0, 0, 2304, 2306, 5, 1124, 0, 
	0, 2305, 2304, 1, 0, 0, 0, 2305, 2306, 1, 0, 0, 0, 2306, 2307, 1, 0, 0, 
	0, 2307, 2341, 5, 1148, 0, 0, 2308, 2309, 5, 388, 0, 0, 2309, 2311, 5, 
	395, 0, 0, 2310, 2312, 5, 1124, 0, 0, 2311, 2310, 1, 0, 0, 0, 2311, 2312, 
	1, 0, 0, 0, 2312, 2313, 1, 0, 0, 0, 2313, 2341, 5, 1148, 0, 0, 2314, 2315, 
	5, 81, 0, 0, 2315, 2317, 5, 395, 0, 0, 2316, 2318, 5, 1124, 0, 0, 2317, 
	2316, 1, 0, 0, 0, 2317, 2318, 1, 0, 0, 0, 2318, 2319, 1, 0, 0, 0, 2319, 
	2341, 5, 1148, 0, 0, 2320, 2322, 5, 500, 0, 0, 2321, 2323, 5, 1124, 0, 
	0, 2322, 2321, 1, 0, 0, 0, 2322, 2323, 1, 0, 0, 0, 2323, 2324, 1, 0, 0, 
	0, 2324, 2341, 3, 598, 299, 0, 2325, 2327, 5, 510, 0, 0, 2326, 2328, 5, 
	1124, 0, 0, 2327, 2326, 1, 0, 0, 0, 2327, 2328, 1, 0, 0, 0, 2328, 2329, 
	1, 0, 0, 0, 2329, 2341, 3, 598, 299, 0, 2330, 2332, 5, 647, 0, 0, 2331, 
	2333, 5, 1124, 0, 0, 2332, 2331, 1, 0, 0, 0, 2332, 2333, 1, 0, 0, 0, 2333, 
	2334, 1, 0, 0, 0, 2334, 2341, 3, 592, 296, 0, 2335, 2337, 5, 528, 0, 0, 
	2336, 2338, 5, 1124, 0, 0, 2337, 2336, 1, 0, 0, 0, 2337, 2338, 1, 0, 0, 
	0, 2338, 2339, 1, 0, 0, 0, 2339, 2341, 3, 592, 296, 0, 2340, 2293, 1, 0, 
	0, 0, 2340, 2303, 1, 0, 0, 0, 2340, 2308, 1, 0, 0, 0, 2340, 2314, 1, 0, 
	0, 0, 2340, 2320, 1, 0, 0, 0, 2340, 2325, 1, 0, 0, 0, 2340, 2330, 1, 0, 
	0, 0, 2340, 2335, 1, 0, 0, 0, 2341, 127, 1, 0, 0, 0, 2342, 2343, 5, 7, 
	0, 0, 2343, 2345, 7, 0, 0, 0, 2344, 2346, 3, 592, 296, 0, 2345, 2344, 1, 
	0, 0, 0, 2345, 2346, 1, 0, 0, 0, 2346, 2348, 1, 0, 0, 0, 2347, 2349, 3, 
	58, 29, 0, 2348, 2347, 1, 0, 0, 0, 2349, 2350, 1, 0, 0, 0, 2350, 2348, 
	1, 0, 0, 0, 2350, 2351, 1, 0, 0, 0, 2351, 2361, 1, 0, 0, 0, 2352, 2353, 
	5, 7, 0, 0, 2353, 2354, 7, 0, 0, 0, 2354, 2355, 3, 592, 296, 0, 2355, 2356, 
	5, 664, 0, 0, 2356, 2357, 5, 388, 0, 0, 2357, 2358, 5, 395, 0, 0, 2358, 
	2359, 5, 516, 0, 0, 2359, 2361, 1, 0, 0, 0, 2360, 2342, 1, 0, 0, 0, 2360, 
	2352, 1, 0, 0, 0, 2361, 129, 1, 0, 0, 0, 2362, 2364, 5, 7, 0, 0, 2363, 
	2365, 3, 64, 32, 0, 2364, 2363, 1, 0, 0, 0, 2364, 2365, 1, 0, 0, 0, 2365, 
	2366, 1, 0, 0, 0, 2366, 2367, 5, 415, 0, 0, 2367, 2371, 3, 558, 279, 0, 
	2368, 2369, 5, 118, 0, 0, 2369, 2370, 5, 605, 0, 0, 2370, 2372, 3, 66, 
	33, 0, 2371, 2368, 1, 0, 0, 0, 2371, 2372, 1, 0, 0, 0, 2372, 2379, 1, 0, 
	0, 0, 2373, 2374, 5, 118, 0, 0, 2374, 2376, 5, 371, 0, 0, 2375, 2377, 5, 
	114, 0, 0, 2376, 2375, 1, 0, 0, 0, 2376, 2377, 1, 0, 0, 0, 2377, 2378, 
	1, 0, 0, 0, 2378, 2380, 5, 561, 0, 0, 2379, 2373, 1, 0, 0, 0, 2379, 2380, 
	1, 0, 0, 0, 2380, 2384, 1, 0, 0, 0, 2381, 2382, 5, 139, 0, 0, 2382, 2383, 
	5, 175, 0, 0, 2383, 2385, 3, 558, 279, 0, 2384, 2381, 1, 0, 0, 0, 2384, 
	2385, 1, 0, 0, 0, 2385, 2387, 1, 0, 0, 0, 2386, 2388, 3, 74, 37, 0, 2387, 
	2386, 1, 0, 0, 0, 2387, 2388, 1, 0, 0, 0, 2388, 2391, 1, 0, 0, 0, 2389, 
	2390, 5, 368, 0, 0, 2390, 2392, 5, 1148, 0, 0, 2391, 2389, 1, 0, 0, 0, 
	2391, 2392, 1, 0, 0, 0, 2392, 2395, 1, 0, 0, 0, 2393, 2394, 5, 399, 0, 
	0, 2394, 2396, 3, 396, 198, 0, 2395, 2393, 1, 0, 0, 0, 2395, 2396, 1, 0, 
	0, 0, 2396, 131, 1, 0, 0, 0, 2397, 2398, 5, 7, 0, 0, 2398, 2399, 5, 437, 
	0, 0, 2399, 2403, 3, 558, 279, 0, 2400, 2402, 3, 84, 42, 0, 2401, 2400, 
	1, 0, 0, 0, 2402, 2405, 1, 0, 0, 0, 2403, 2401, 1, 0, 0, 0, 2403, 2404, 
	1, 0, 0, 0, 2404, 133, 1, 0, 0, 0, 2405, 2403, 1, 0, 0, 0, 2406, 2407, 
	5, 7, 0, 0, 2407, 2408, 5, 457, 0, 0, 2408, 2409, 5, 599, 0, 0, 2409, 2410, 
	5, 791, 0, 0, 2410, 2411, 5, 477, 0, 0, 2411, 2412, 5, 91, 0, 0, 2412, 
	135, 1, 0, 0, 0, 2413, 2414, 5, 7, 0, 0, 2414, 2415, 5, 475, 0, 0, 2415, 
	2416, 5, 73, 0, 0, 2416, 2417, 3, 592, 296, 0, 2417, 2418, 5, 5, 0, 0, 
	2418, 2419, 5, 659, 0, 0, 2419, 2425, 5, 1148, 0, 0, 2420, 2422, 5, 453, 
	0, 0, 2421, 2423, 5, 1124, 0, 0, 2422, 2421, 1, 0, 0, 0, 2422, 2423, 1, 
	0, 0, 0, 2423, 2424, 1, 0, 0, 0, 2424, 2426, 3, 600, 300, 0, 2425, 2420, 
	1, 0, 0, 0, 2425, 2426, 1, 0, 0, 0, 2426, 2428, 1, 0, 0, 0, 2427, 2429, 
	5, 674, 0, 0, 2428, 2427, 1, 0, 0, 0, 2428, 2429, 1, 0, 0, 0, 2429, 2430, 
	1, 0, 0, 0, 2430, 2432, 5, 409, 0, 0, 2431, 2433, 5, 1124, 0, 0, 2432, 
	2431, 1, 0, 0, 0, 2432, 2433, 1, 0, 0, 0, 2433, 2434, 1, 0, 0, 0, 2434, 
	2435, 3, 580, 290, 0, 2435, 137, 1, 0, 0, 0, 2436, 2437, 5, 7, 0, 0, 2437, 
	2438, 5, 131, 0, 0, 2438, 2442, 3, 558, 279, 0, 2439, 2441, 3, 84, 42, 
	0, 2440, 2439, 1, 0, 0, 0, 2441, 2444, 1, 0, 0, 0, 2442, 2440, 1, 0, 0, 
	0, 2442, 2443, 1, 0, 0, 0, 2443, 139, 1, 0, 0, 0, 2444, 2442, 1, 0, 0, 
	0, 2445, 2446, 5, 7, 0, 0, 2446, 2447, 5, 608, 0, 0, 2447, 2448, 3, 592, 
	296, 0, 2448, 2449, 5, 541, 0, 0, 2449, 2450, 5, 1133, 0, 0, 2450, 2455, 
	3, 86, 43, 0, 2451, 2452, 5, 1135, 0, 0, 2452, 2454, 3, 86, 43, 0, 2453, 
	2451, 1, 0, 0, 0, 2454, 2457, 1, 0, 0, 0, 2455, 2453, 1, 0, 0, 0, 2455, 
	2456, 1, 0, 0, 0, 2456, 2458, 1, 0, 0, 0, 2457, 2455, 1, 0, 0, 0, 2458, 
	2459, 5, 1134, 0, 0, 2459, 141, 1, 0, 0, 0, 2460, 2462, 5, 7, 0, 0, 2461, 
	2463, 7, 1, 0, 0, 2462, 2461, 1, 0, 0, 0, 2462, 2463, 1, 0, 0, 0, 2463, 
	2465, 1, 0, 0, 0, 2464, 2466, 5, 78, 0, 0, 2465, 2464, 1, 0, 0, 0, 2465, 
	2466, 1, 0, 0, 0, 2466, 2467, 1, 0, 0, 0, 2467, 2468, 5, 172, 0, 0, 2468, 
	2470, 3, 560, 280, 0, 2469, 2471, 3, 654, 327, 0, 2470, 2469, 1, 0, 0, 
	0, 2470, 2471, 1, 0, 0, 0, 2471, 2480, 1, 0, 0, 0, 2472, 2477, 3, 148, 
	74, 0, 2473, 2474, 5, 1135, 0, 0, 2474, 2476, 3, 148, 74, 0, 2475, 2473, 
	1, 0, 0, 0, 2476, 2479, 1, 0, 0, 0, 2477, 2475, 1, 0, 0, 0, 2477, 2478, 
	1, 0, 0, 0, 2478, 2481, 1, 0, 0, 0, 2479, 2477, 1, 0, 0, 0, 2480, 2472, 
	1, 0, 0, 0, 2480, 2481, 1, 0, 0, 0, 2481, 2483, 1, 0, 0, 0, 2482, 2484, 
	3, 112, 56, 0, 2483, 2482, 1, 0, 0, 0, 2483, 2484, 1, 0, 0, 0, 2484, 143, 
	1, 0, 0, 0, 2485, 2486, 5, 7, 0, 0, 2486, 2487, 5, 647, 0, 0, 2487, 2488, 
	3, 592, 296, 0, 2488, 2489, 7, 33, 0, 0, 2489, 2490, 5, 389, 0, 0, 2490, 
	2494, 5, 1148, 0, 0, 2491, 2492, 5, 453, 0, 0, 2492, 2493, 5, 1124, 0, 
	0, 2493, 2495, 3, 600, 300, 0, 2494, 2491, 1, 0, 0, 0, 2494, 2495, 1, 0, 
	0, 0, 2495, 2497, 1, 0, 0, 0, 2496, 2498, 5, 674, 0, 0, 2497, 2496, 1, 
	0, 0, 0, 2497, 2498, 1, 0, 0, 0, 2498, 2499, 1, 0, 0, 0, 2499, 2501, 5, 
	409, 0, 0, 2500, 2502, 5, 1124, 0, 0, 2501, 2500, 1, 0, 0, 0, 2501, 2502, 
	1, 0, 0, 0, 2502, 2503, 1, 0, 0, 0, 2503, 2504, 3, 580, 290, 0, 2504, 145, 
	1, 0, 0, 0, 2505, 2509, 5, 7, 0, 0, 2506, 2507, 5, 336, 0, 0, 2507, 2508, 
	5, 1124, 0, 0, 2508, 2510, 7, 10, 0, 0, 2509, 2506, 1, 0, 0, 0, 2509, 2510, 
	1, 0, 0, 0, 2510, 2512, 1, 0, 0, 0, 2511, 2513, 3, 64, 32, 0, 2512, 2511, 
	1, 0, 0, 0, 2512, 2513, 1, 0, 0, 0, 2513, 2517, 1, 0, 0, 0, 2514, 2515, 
	5, 160, 0, 0, 2515, 2516, 5, 606, 0, 0, 2516, 2518, 7, 11, 0, 0, 2517, 
	2514, 1, 0, 0, 0, 2517, 2518, 1, 0, 0, 0, 2518, 2519, 1, 0, 0, 0, 2519, 
	2520, 5, 671, 0, 0, 2520, 2525, 3, 558, 279, 0, 2521, 2522, 5, 1133, 0, 
	0, 2522, 2523, 3, 624, 312, 0, 2523, 2524, 5, 1134, 0, 0, 2524, 2526, 1, 
	0, 0, 0, 2525, 2521, 1, 0, 0, 0, 2525, 2526, 1, 0, 0, 0, 2526, 2527, 1, 
	0, 0, 0, 2527, 2528, 5, 12, 0, 0, 2528, 2535, 3, 200, 100, 0, 2529, 2531, 
	5, 192, 0, 0, 2530, 2532, 7, 12, 0, 0, 2531, 2530, 1, 0, 0, 0, 2531, 2532, 
	1, 0, 0, 0, 2532, 2533, 1, 0, 0, 0, 2533, 2534, 5, 26, 0, 0, 2534, 2536, 
	5, 120, 0, 0, 2535, 2529, 1, 0, 0, 0, 2535, 2536, 1, 0, 0, 0, 2536, 147, 
	1, 0, 0, 0, 2537, 2544, 3, 106, 53, 0, 2538, 2540, 5, 1135, 0, 0, 2539, 
	2538, 1, 0, 0, 0, 2539, 2540, 1, 0, 0, 0, 2540, 2541, 1, 0, 0, 0, 2541, 
	2543, 3, 106, 53, 0, 2542, 2539, 1, 0, 0, 0, 2543, 2546, 1, 0, 0, 0, 2544, 
	2542, 1, 0, 0, 0, 2544, 2545, 1, 0, 0, 0, 2545, 2889, 1, 0, 0, 0, 2546, 
	2544, 1, 0, 0, 0, 2547, 2549, 5, 5, 0, 0, 2548, 2550, 5, 28, 0, 0, 2549, 
	2548, 1, 0, 0, 0, 2549, 2550, 1, 0, 0, 0, 2550, 2551, 1, 0, 0, 0, 2551, 
	2552, 3, 592, 296, 0, 2552, 2556, 3, 92, 46, 0, 2553, 2557, 5, 430, 0, 
	0, 2554, 2555, 5, 334, 0, 0, 2555, 2557, 3, 592, 296, 0, 2556, 2553, 1, 
	0, 0, 0, 2556, 2554, 1, 0, 0, 0, 2556, 2557, 1, 0, 0, 0, 2557, 2889, 1, 
	0, 0, 0, 2558, 2560, 5, 5, 0, 0, 2559, 2561, 5, 28, 0, 0, 2560, 2559, 1, 
	0, 0, 0, 2560, 2561, 1, 0, 0, 0, 2561, 2562, 1, 0, 0, 0, 2562, 2563, 5, 
	1133, 0, 0, 2563, 2564, 3, 592, 296, 0, 2564, 2571, 3, 92, 46, 0, 2565, 
	2566, 5, 1135, 0, 0, 2566, 2567, 3, 592, 296, 0, 2567, 2568, 3, 92, 46, 
	0, 2568, 2570, 1, 0, 0, 0, 2569, 2565, 1, 0, 0, 0, 2570, 2573, 1, 0, 0, 
	0, 2571, 2569, 1, 0, 0, 0, 2571, 2572, 1, 0, 0, 0, 2572, 2574, 1, 0, 0, 
	0, 2573, 2571, 1, 0, 0, 0, 2574, 2575, 5, 1134, 0, 0, 2575, 2889, 1, 0, 
	0, 0, 2576, 2577, 5, 5, 0, 0, 2577, 2579, 7, 20, 0, 0, 2578, 2580, 3, 592, 
	296, 0, 2579, 2578, 1, 0, 0, 0, 2579, 2580, 1, 0, 0, 0, 2580, 2582, 1, 
	0, 0, 0, 2581, 2583, 3, 76, 38, 0, 2582, 2581, 1, 0, 0, 0, 2582, 2583, 
	1, 0, 0, 0, 2583, 2584, 1, 0, 0, 0, 2584, 2588, 3, 630, 315, 0, 2585, 2587, 
	3, 78, 39, 0, 2586, 2585, 1, 0, 0, 0, 2587, 2590, 1, 0, 0, 0, 2588, 2586, 
	1, 0, 0, 0, 2588, 2589, 1, 0, 0, 0, 2589, 2889, 1, 0, 0, 0, 2590, 2588, 
	1, 0, 0, 0, 2591, 2596, 5, 5, 0, 0, 2592, 2594, 5, 30, 0, 0, 2593, 2595, 
	3, 592, 296, 0, 2594, 2593, 1, 0, 0, 0, 2594, 2595, 1, 0, 0, 0, 2595, 2597, 
	1, 0, 0, 0, 2596, 2592, 1, 0, 0, 0, 2596, 2597, 1, 0, 0, 0, 2597, 2598, 
	1, 0, 0, 0, 2598, 2599, 5, 130, 0, 0, 2599, 2601, 5, 91, 0, 0, 2600, 2602, 
	3, 592, 296, 0, 2601, 2600, 1, 0, 0, 0, 2601, 2602, 1, 0, 0, 0, 2602, 2604, 
	1, 0, 0, 0, 2603, 2605, 3, 76, 38, 0, 2604, 2603, 1, 0, 0, 0, 2604, 2605, 
	1, 0, 0, 0, 2605, 2606, 1, 0, 0, 0, 2606, 2610, 3, 630, 315, 0, 2607, 2609, 
	3, 78, 39, 0, 2608, 2607, 1, 0, 0, 0, 2609, 2612, 1, 0, 0, 0, 2610, 2608, 
	1, 0, 0, 0, 2610, 2611, 1, 0, 0, 0, 2611, 2889, 1, 0, 0, 0, 2612, 2610, 
	1, 0, 0, 0, 2613, 2618, 5, 5, 0, 0, 2614, 2616, 5, 30, 0, 0, 2615, 2617, 
	3, 592, 296, 0, 2616, 2615, 1, 0, 0, 0, 2616, 2617, 1, 0, 0, 0, 2617, 2619, 
	1, 0, 0, 0, 2618, 2614, 1, 0, 0, 0, 2618, 2619, 1, 0, 0, 0, 2619, 2620, 
	1, 0, 0, 0, 2620, 2622, 5, 181, 0, 0, 2621, 2623, 7, 20, 0, 0, 2622, 2621, 
	1, 0, 0, 0, 2622, 2623, 1, 0, 0, 0, 2623, 2625, 1, 0, 0, 0, 2624, 2626, 
	3, 592, 296, 0, 2625, 2624, 1, 0, 0, 0, 2625, 2626, 1, 0, 0, 0, 2626, 2628, 
	1, 0, 0, 0, 2627, 2629, 3, 76, 38, 0, 2628, 2627, 1, 0, 0, 0, 2628, 2629, 
	1, 0, 0, 0, 2629, 2630, 1, 0, 0, 0, 2630, 2634, 3, 630, 315, 0, 2631, 2633, 
	3, 78, 39, 0, 2632, 2631, 1, 0, 0, 0, 2633, 2636, 1, 0, 0, 0, 2634, 2632, 
	1, 0, 0, 0, 2634, 2635, 1, 0, 0, 0, 2635, 2889, 1, 0, 0, 0, 2636, 2634, 
	1, 0, 0, 0, 2637, 2638, 5, 5, 0, 0, 2638, 2640, 7, 22, 0, 0, 2639, 2641, 
	7, 20, 0, 0, 2640, 2639, 1, 0, 0, 0, 2640, 2641, 1, 0, 0, 0, 2641, 2643, 
	1, 0, 0, 0, 2642, 2644, 3, 592, 296, 0, 2643, 2642, 1, 0, 0, 0, 2643, 2644, 
	1, 0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645, 2649, 3, 630, 315, 0, 2646, 2648, 
	3, 78, 39, 0, 2647, 2646, 1, 0, 0, 0, 2648, 2651, 1, 0, 0, 0, 2649, 2647, 
	1, 0, 0, 0, 2649, 2650, 1, 0, 0, 0, 2650, 2889, 1, 0, 0, 0, 2651, 2649, 
	1, 0, 0, 0, 2652, 2657, 5, 5, 0, 0, 2653, 2655, 5, 30, 0, 0, 2654, 2656, 
	3, 592, 296, 0, 2655, 2654, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656, 2658, 
	1, 0, 0, 0, 2657, 2653, 1, 0, 0, 0, 2657, 2658, 1, 0, 0, 0, 2658, 2659, 
	1, 0, 0, 0, 2659, 2660, 5, 67, 0, 0, 2660, 2662, 5, 91, 0, 0, 2661, 2663, 
	3, 592, 296, 0, 2662, 2661, 1, 0, 0, 0, 2662, 2663, 1, 0, 0, 0, 2663, 2664, 
	1, 0, 0, 0, 2664, 2665, 3, 630, 315, 0, 2665, 2666, 3, 98, 49, 0, 2666, 
	2889, 1, 0, 0, 0, 2667, 2672, 5, 5, 0, 0, 2668, 2670, 5, 30, 0, 0, 2669, 
	2671, 3, 592, 296, 0, 2670, 2669, 1, 0, 0, 0, 2670, 2671, 1, 0, 0, 0, 2671, 
	2673, 1, 0, 0, 0, 2672, 2668, 1, 0, 0, 0, 2672, 2673, 1, 0, 0, 0, 2673, 
	2674, 1, 0, 0, 0, 2674, 2681, 5, 26, 0, 0, 2675, 2682, 3, 592, 296, 0, 
	2676, 2682, 3, 602, 301, 0, 2677, 2678, 5, 1133, 0, 0, 2678, 2679, 3, 696, 
	348, 0, 2679, 2680, 5, 1134, 0, 0, 2680, 2682, 1, 0, 0, 0, 2681, 2675, 
	1, 0, 0, 0, 2681, 2676, 1, 0, 0, 0, 2681, 2677, 1, 0, 0, 0, 2682, 2684, 
	1, 0, 0, 0, 2683, 2685, 5, 114, 0, 0, 2684, 2683, 1, 0, 0, 0, 2684, 2685, 
	1, 0, 0, 0, 2685, 2687, 1, 0, 0, 0, 2686, 2688, 5, 57, 0, 0, 2687, 2686, 
	1, 0, 0, 0, 2687, 2688, 1, 0, 0, 0, 2688, 2889, 1, 0, 0, 0, 2689, 2694, 
	5, 7, 0, 0, 2690, 2692, 5, 30, 0, 0, 2691, 2693, 3, 592, 296, 0, 2692, 
	2691, 1, 0, 0, 0, 2692, 2693, 1, 0, 0, 0, 2693, 2695, 1, 0, 0, 0, 2694, 
	2690, 1, 0, 0, 0, 2694, 2695, 1, 0, 0, 0, 2695, 2696, 1, 0, 0, 0, 2696, 
	2703, 5, 26, 0, 0, 2697, 2704, 3, 592, 296, 0, 2698, 2704, 3, 602, 301, 
	0, 2699, 2700, 5, 1133, 0, 0, 2700, 2701, 3, 696, 348, 0, 2701, 2702, 5, 
	1134, 0, 0, 2702, 2704, 1, 0, 0, 0, 2703, 2697, 1, 0, 0, 0, 2703, 2698, 
	1, 0, 0, 0, 2703, 2699, 1, 0, 0, 0, 2704, 2706, 1, 0, 0, 0, 2705, 2707, 
	5, 114, 0, 0, 2706, 2705, 1, 0, 0, 0, 2706, 2707, 1, 0, 0, 0, 2707, 2709, 
	1, 0, 0, 0, 2708, 2710, 5, 57, 0, 0, 2709, 2708, 1, 0, 0, 0, 2709, 2710, 
	1, 0, 0, 0, 2710, 2889, 1, 0, 0, 0, 2711, 2716, 5, 5, 0, 0, 2712, 2714, 
	5, 30, 0, 0, 2713, 2715, 3, 592, 296, 0, 2714, 2713, 1, 0, 0, 0, 2714, 
	2715, 1, 0, 0, 0, 2715, 2717, 1, 0, 0, 0, 2716, 2712, 1, 0, 0, 0, 2716, 
	2717, 1, 0, 0, 0, 2717, 2718, 1, 0, 0, 0, 2718, 2719, 5, 26, 0, 0, 2719, 
	2720, 5, 1133, 0, 0, 2720, 2721, 3, 696, 348, 0, 2721, 2722, 5, 1134, 0, 
	0, 2722, 2889, 1, 0, 0, 0, 2723, 2725, 5, 336, 0, 0, 2724, 2726, 5, 1124, 
	0, 0, 2725, 2724, 1, 0, 0, 0, 2725, 2726, 1, 0, 0, 0, 2726, 2727, 1, 0, 
	0, 0, 2727, 2889, 7, 34, 0, 0, 2728, 2730, 5, 7, 0, 0, 2729, 2731, 5, 28, 
	0, 0, 2730, 2729, 1, 0, 0, 0, 2730, 2731, 1, 0, 0, 0, 2731, 2732, 1, 0, 
	0, 0, 2732, 2738, 3, 592, 296, 0, 2733, 2734, 5, 153, 0, 0, 2734, 2735, 
	5, 42, 0, 0, 2735, 2739, 3, 642, 321, 0, 2736, 2737, 5, 51, 0, 0, 2737, 
	2739, 5, 42, 0, 0, 2738, 2733, 1, 0, 0, 0, 2738, 2736, 1, 0, 0, 0, 2739, 
	2889, 1, 0, 0, 0, 2740, 2742, 5, 24, 0, 0, 2741, 2743, 5, 28, 0, 0, 2742, 
	2741, 1, 0, 0, 0, 2742, 2743, 1, 0, 0, 0, 2743, 2744, 1, 0, 0, 0, 2744, 
	2745, 3, 592, 296, 0, 2745, 2746, 3, 592, 296, 0, 2746, 2750, 3, 92, 46, 
	0, 2747, 2751, 5, 430, 0, 0, 2748, 2749, 5, 334, 0, 0, 2749, 2751, 3, 592, 
	296, 0, 2750, 2747, 1, 0, 0, 0, 2750, 2748, 1, 0, 0, 0, 2750, 2751, 1, 
	0, 0, 0, 2751, 2889, 1, 0, 0, 0, 2752, 2753, 5, 139, 0, 0, 2753, 2754, 
	5, 28, 0, 0, 2754, 2755, 3, 592, 296, 0, 2755, 2756, 5, 175, 0, 0, 2756, 
	2757, 3, 592, 296, 0, 2757, 2889, 1, 0, 0, 0, 2758, 2760, 5, 103, 0, 0, 
	2759, 2761, 5, 1124, 0, 0, 2760, 2759, 1, 0, 0, 0, 2760, 2761, 1, 0, 0, 
	0, 2761, 2762, 1, 0, 0, 0, 2762, 2889, 7, 4, 0, 0, 2763, 2765, 5, 512, 
	0, 0, 2764, 2766, 5, 28, 0, 0, 2765, 2764, 1, 0, 0, 0, 2765, 2766, 1, 0, 
	0, 0, 2766, 2767, 1, 0, 0, 0, 2767, 2768, 3, 592, 296, 0, 2768, 2772, 3, 
	92, 46, 0, 2769, 2773, 5, 430, 0, 0, 2770, 2771, 5, 334, 0, 0, 2771, 2773, 
	3, 592, 296, 0, 2772, 2769, 1, 0, 0, 0, 2772, 2770, 1, 0, 0, 0, 2772, 2773, 
	1, 0, 0, 0, 2773, 2889, 1, 0, 0, 0, 2774, 2776, 5, 51, 0, 0, 2775, 2777, 
	5, 28, 0, 0, 2776, 2775, 1, 0, 0, 0, 2776, 2777, 1, 0, 0, 0, 2777, 2778, 
	1, 0, 0, 0, 2778, 2780, 3, 592, 296, 0, 2779, 2781, 5, 144, 0, 0, 2780, 
	2779, 1, 0, 0, 0, 2780, 2781, 1, 0, 0, 0, 2781, 2889, 1, 0, 0, 0, 2782, 
	2783, 5, 51, 0, 0, 2783, 2784, 7, 35, 0, 0, 2784, 2889, 3, 592, 296, 0, 
	2785, 2786, 5, 51, 0, 0, 2786, 2787, 5, 130, 0, 0, 2787, 2889, 5, 91, 0, 
	0, 2788, 2789, 5, 51, 0, 0, 2789, 2790, 7, 20, 0, 0, 2790, 2889, 3, 592, 
	296, 0, 2791, 2792, 5, 139, 0, 0, 2792, 2793, 7, 20, 0, 0, 2793, 2794, 
	3, 592, 296, 0, 2794, 2795, 5, 175, 0, 0, 2795, 2796, 3, 592, 296, 0, 2796, 
	2889, 1, 0, 0, 0, 2797, 2799, 5, 7, 0, 0, 2798, 2800, 5, 28, 0, 0, 2799, 
	2798, 1, 0, 0, 0, 2799, 2800, 1, 0, 0, 0, 2800, 2801, 1, 0, 0, 0, 2801, 
	2815, 3, 592, 296, 0, 2802, 2803, 5, 153, 0, 0, 2803, 2809, 5, 42, 0, 0, 
	2804, 2810, 3, 602, 301, 0, 2805, 2806, 5, 1133, 0, 0, 2806, 2807, 3, 696, 
	348, 0, 2807, 2808, 5, 1134, 0, 0, 2808, 2810, 1, 0, 0, 0, 2809, 2804, 
	1, 0, 0, 0, 2809, 2805, 1, 0, 0, 0, 2810, 2816, 1, 0, 0, 0, 2811, 2812, 
	5, 153, 0, 0, 2812, 2816, 7, 15, 0, 0, 2813, 2814, 5, 51, 0, 0, 2814, 2816, 
	5, 42, 0, 0, 2815, 2802, 1, 0, 0, 0, 2815, 2811, 1, 0, 0, 0, 2815, 2813, 
	1, 0, 0, 0, 2816, 2889, 1, 0, 0, 0, 2817, 2818, 5, 7, 0, 0, 2818, 2819, 
	5, 81, 0, 0, 2819, 2820, 3, 592, 296, 0, 2820, 2821, 7, 15, 0, 0, 2821, 
	2889, 1, 0, 0, 0, 2822, 2823, 5, 51, 0, 0, 2823, 2824, 5, 67, 0, 0, 2824, 
	2825, 5, 91, 0, 0, 2825, 2889, 3, 592, 296, 0, 2826, 2827, 5, 396, 0, 0, 
	2827, 2889, 5, 92, 0, 0, 2828, 2829, 5, 403, 0, 0, 2829, 2889, 5, 92, 0, 
	0, 2830, 2832, 5, 139, 0, 0, 2831, 2833, 7, 36, 0, 0, 2832, 2831, 1, 0, 
	0, 0, 2832, 2833, 1, 0, 0, 0, 2833, 2836, 1, 0, 0, 0, 2834, 2837, 3, 592, 
	296, 0, 2835, 2837, 3, 558, 279, 0, 2836, 2834, 1, 0, 0, 0, 2836, 2835, 
	1, 0, 0, 0, 2837, 2889, 1, 0, 0, 0, 2838, 2839, 5, 124, 0, 0, 2839, 2840, 
	5, 19, 0, 0, 2840, 2889, 3, 624, 312, 0, 2841, 2842, 5, 32, 0, 0, 2842, 
	2846, 5, 175, 0, 0, 2843, 2847, 5, 841, 0, 0, 2844, 2845, 5, 25, 0, 0, 
	2845, 2847, 5, 153, 0, 0, 2846, 2843, 1, 0, 0, 0, 2846, 2844, 1, 0, 0, 
	0, 2847, 2848, 1, 0, 0, 0, 2848, 2851, 3, 576, 288, 0, 2849, 2850, 5, 27, 
	0, 0, 2850, 2852, 3, 578, 289, 0, 2851, 2849, 1, 0, 0, 0, 2851, 2852, 1, 
	0, 0, 0, 2852, 2889, 1, 0, 0, 0, 2853, 2855, 5, 42, 0, 0, 2854, 2853, 1, 
	0, 0, 0, 2854, 2855, 1, 0, 0, 0, 2855, 2856, 1, 0, 0, 0, 2856, 2857, 5, 
	25, 0, 0, 2857, 2858, 5, 153, 0, 0, 2858, 2859, 5, 1124, 0, 0, 2859, 2863, 
	3, 576, 288, 0, 2860, 2861, 5, 27, 0, 0, 2861, 2862, 5, 1124, 0, 0, 2862, 
	2864, 3, 578, 289, 0, 2863, 2860, 1, 0, 0, 0, 2863, 2864, 1, 0, 0, 0, 2864, 
	2889, 1, 0, 0, 0, 2865, 2866, 5, 397, 0, 0, 2866, 2889, 5, 647, 0, 0, 2867, 
	2868, 5, 450, 0, 0, 2868, 2889, 5, 647, 0, 0, 2869, 2889, 5, 66, 0, 0, 
	2870, 2871, 7, 37, 0, 0, 2871, 2889, 5, 668, 0, 0, 2872, 2874, 5, 5, 0, 
	0, 2873, 2875, 5, 28, 0, 0, 2874, 2873, 1, 0, 0, 0, 2874, 2875, 1, 0, 0, 
	0, 2875, 2876, 1, 0, 0, 0, 2876, 2877, 5, 1133, 0, 0, 2877, 2882, 3, 90, 
	45, 0, 2878, 2879, 5, 1135, 0, 0, 2879, 2881, 3, 90, 45, 0, 2880, 2878, 
	1, 0, 0, 0, 2881, 2884, 1, 0, 0, 0, 2882, 2880, 1, 0, 0, 0, 2882, 2883, 
	1, 0, 0, 0, 2883, 2885, 1, 0, 0, 0, 2884, 2882, 1, 0, 0, 0, 2885, 2886, 
	5, 1134, 0, 0, 2886, 2889, 1, 0, 0, 0, 2887, 2889, 3, 150, 75, 0, 2888, 
	2537, 1, 0, 0, 0, 2888, 2547, 1, 0, 0, 0, 2888, 2558, 1, 0, 0, 0, 2888, 
	2576, 1, 0, 0, 0, 2888, 2591, 1, 0, 0, 0, 2888, 2613, 1, 0, 0, 0, 2888, 
	2637, 1, 0, 0, 0, 2888, 2652, 1, 0, 0, 0, 2888, 2667, 1, 0, 0, 0, 2888, 
	2689, 1, 0, 0, 0, 2888, 2711, 1, 0, 0, 0, 2888, 2723, 1, 0, 0, 0, 2888, 
	2728, 1, 0, 0, 0, 2888, 2740, 1, 0, 0, 0, 2888, 2752, 1, 0, 0, 0, 2888, 
	2758, 1, 0, 0, 0, 2888, 2763, 1, 0, 0, 0, 2888, 2774, 1, 0, 0, 0, 2888, 
	2782, 1, 0, 0, 0, 2888, 2785, 1, 0, 0, 0, 2888, 2788, 1, 0, 0, 0, 2888, 
	2791, 1, 0, 0, 0, 2888, 2797, 1, 0, 0, 0, 2888, 2817, 1, 0, 0, 0, 2888, 
	2822, 1, 0, 0, 0, 2888, 2826, 1, 0, 0, 0, 2888, 2828, 1, 0, 0, 0, 2888, 
	2830, 1, 0, 0, 0, 2888, 2838, 1, 0, 0, 0, 2888, 2841, 1, 0, 0, 0, 2888, 
	2854, 1, 0, 0, 0, 2888, 2865, 1, 0, 0, 0, 2888, 2867, 1, 0, 0, 0, 2888, 
	2869, 1, 0, 0, 0, 2888, 2870, 1, 0, 0, 0, 2888, 2872, 1, 0, 0, 0, 2888, 
	2887, 1, 0, 0, 0, 2889, 149, 1, 0, 0, 0, 2890, 2891, 5, 5, 0, 0, 2891, 
	2892, 5, 129, 0, 0, 2892, 2893, 5, 1133, 0, 0, 2893, 2898, 3, 118, 59, 
	0, 2894, 2895, 5, 1135, 0, 0, 2895, 2897, 3, 118, 59, 0, 2896, 2894, 1, 
	0, 0, 0, 2897, 2900, 1, 0, 0, 0, 2898, 2896, 1, 0, 0, 0, 2898, 2899, 1, 
	0, 0, 0, 2899, 2901, 1, 0, 0, 0, 2900, 2898, 1, 0, 0, 0, 2901, 2902, 5, 
	1134, 0, 0, 2902, 2989, 1, 0, 0, 0, 2903, 2904, 5, 51, 0, 0, 2904, 2905, 
	5, 129, 0, 0, 2905, 2989, 3, 624, 312, 0, 2906, 2907, 5, 397, 0, 0, 2907, 
	2910, 5, 129, 0, 0, 2908, 2911, 3, 624, 312, 0, 2909, 2911, 5, 6, 0, 0, 
	2910, 2908, 1, 0, 0, 0, 2910, 2909, 1, 0, 0, 0, 2911, 2912, 1, 0, 0, 0, 
	2912, 2989, 5, 647, 0, 0, 2913, 2914, 5, 450, 0, 0, 2914, 2917, 5, 129, 
	0, 0, 2915, 2918, 3, 624, 312, 0, 2916, 2918, 5, 6, 0, 0, 2917, 2915, 1, 
	0, 0, 0, 2917, 2916, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919, 2989, 5, 
	647, 0, 0, 2920, 2921, 5, 656, 0, 0, 2921, 2924, 5, 129, 0, 0, 2922, 2925, 
	3, 624, 312, 0, 2923, 2925, 5, 6, 0, 0, 2924, 2922, 1, 0, 0, 0, 2924, 2923, 
	1, 0, 0, 0, 2925, 2989, 1, 0, 0, 0, 2926, 2927, 5, 363, 0, 0, 2927, 2928, 
	5, 129, 0, 0, 2928, 2989, 3, 598, 299, 0, 2929, 2930, 5, 579, 0, 0, 2930, 
	2931, 5, 129, 0, 0, 2931, 2932, 3, 624, 312, 0, 2932, 2933, 5, 87, 0, 0, 
	2933, 2934, 5, 1133, 0, 0, 2934, 2939, 3, 118, 59, 0, 2935, 2936, 5, 1135, 
	0, 0, 2936, 2938, 3, 118, 59, 0, 2937, 2935, 1, 0, 0, 0, 2938, 2941, 1, 
	0, 0, 0, 2939, 2937, 1, 0, 0, 0, 2939, 2940, 1, 0, 0, 0, 2940, 2942, 1, 
	0, 0, 0, 2941, 2939, 1, 0, 0, 0, 2942, 2943, 5, 1134, 0, 0, 2943, 2989, 
	1, 0, 0, 0, 2944, 2945, 5, 418, 0, 0, 2945, 2946, 5, 129, 0, 0, 2946, 2947, 
	3, 592, 296, 0, 2947, 2948, 5, 192, 0, 0, 2948, 2949, 5, 172, 0, 0, 2949, 
	2952, 3, 560, 280, 0, 2950, 2951, 7, 37, 0, 0, 2951, 2953, 5, 668, 0, 0, 
	2952, 2950, 1, 0, 0, 0, 2952, 2953, 1, 0, 0, 0, 2953, 2989, 1, 0, 0, 0, 
	2954, 2955, 5, 9, 0, 0, 2955, 2958, 5, 129, 0, 0, 2956, 2959, 3, 624, 312, 
	0, 2957, 2959, 5, 6, 0, 0, 2958, 2956, 1, 0, 0, 0, 2958, 2957, 1, 0, 0, 
	0, 2959, 2989, 1, 0, 0, 0, 2960, 2961, 5, 26, 0, 0, 2961, 2964, 5, 129, 
	0, 0, 2962, 2965, 3, 624, 312, 0, 2963, 2965, 5, 6, 0, 0, 2964, 2962, 1, 
	0, 0, 0, 2964, 2963, 1, 0, 0, 0, 2965, 2989, 1, 0, 0, 0, 2966, 2967, 5, 
	119, 0, 0, 2967, 2970, 5, 129, 0, 0, 2968, 2971, 3, 624, 312, 0, 2969, 
	2971, 5, 6, 0, 0, 2970, 2968, 1, 0, 0, 0, 2970, 2969, 1, 0, 0, 0, 2971, 
	2989, 1, 0, 0, 0, 2972, 2973, 5, 569, 0, 0, 2973, 2976, 5, 129, 0, 0, 2974, 
	2977, 3, 624, 312, 0, 2975, 2977, 5, 6, 0, 0, 2976, 2974, 1, 0, 0, 0, 2976, 
	2975, 1, 0, 0, 0, 2977, 2989, 1, 0, 0, 0, 2978, 2979, 5, 580, 0, 0, 2979, 
	2982, 5, 129, 0, 0, 2980, 2983, 3, 624, 312, 0, 2981, 2983, 5, 6, 0, 0, 
	2982, 2980, 1, 0, 0, 0, 2982, 2981, 1, 0, 0, 0, 2983, 2989, 1, 0, 0, 0, 
	2984, 2985, 5, 578, 0, 0, 2985, 2989, 5, 549, 0, 0, 2986, 2987, 5, 664, 
	0, 0, 2987, 2989, 5, 549, 0, 0, 2988, 2890, 1, 0, 0, 0, 2988, 2903, 1, 
	0, 0, 0, 2988, 2906, 1, 0, 0, 0, 2988, 2913, 1, 0, 0, 0, 2988, 2920, 1, 
	0, 0, 0, 2988, 2926, 1, 0, 0, 0, 2988, 2929, 1, 0, 0, 0, 2988, 2944, 1, 
	0, 0, 0, 2988, 2954, 1, 0, 0, 0, 2988, 2960, 1, 0, 0, 0, 2988, 2966, 1, 
	0, 0, 0, 2988, 2972, 1, 0, 0, 0, 2988, 2978, 1, 0, 0, 0, 2988, 2984, 1, 
	0, 0, 0, 2988, 2986, 1, 0, 0, 0, 2989, 151, 1, 0, 0, 0, 2990, 2991, 5, 
	51, 0, 0, 2991, 2993, 7, 0, 0, 0, 2992, 2994, 3, 648, 324, 0, 2993, 2992, 
	1, 0, 0, 0, 2993, 2994, 1, 0, 0, 0, 2994, 2995, 1, 0, 0, 0, 2995, 2996, 
	3, 592, 296, 0, 2996, 153, 1, 0, 0, 0, 2997, 2998, 5, 51, 0, 0, 2998, 3000, 
	5, 415, 0, 0, 2999, 3001, 3, 648, 324, 0, 3000, 2999, 1, 0, 0, 0, 3000, 
	3001, 1, 0, 0, 0, 3001, 3002, 1, 0, 0, 0, 3002, 3003, 3, 558, 279, 0, 3003, 
	155, 1, 0, 0, 0, 3004, 3005, 5, 51, 0, 0, 3005, 3007, 5, 81, 0, 0, 3006, 
	3008, 7, 1, 0, 0, 3007, 3006, 1, 0, 0, 0, 3007, 3008, 1, 0, 0, 0, 3008, 
	3009, 1, 0, 0, 0, 3009, 3010, 3, 592, 296, 0, 3010, 3011, 5, 118, 0, 0, 
	3011, 3024, 3, 560, 280, 0, 3012, 3014, 5, 336, 0, 0, 3013, 3015, 5, 1124, 
	0, 0, 3014, 3013, 1, 0, 0, 0, 3014, 3015, 1, 0, 0, 0, 3015, 3016, 1, 0, 
	0, 0, 3016, 3023, 7, 3, 0, 0, 3017, 3019, 5, 103, 0, 0, 3018, 3020, 5, 
	1124, 0, 0, 3019, 3018, 1, 0, 0, 0, 3019, 3020, 1, 0, 0, 0, 3020, 3021, 
	1, 0, 0, 0, 3021, 3023, 7, 4, 0, 0, 3022, 3012, 1, 0, 0, 0, 3022, 3017, 
	1, 0, 0, 0, 3023, 3026, 1, 0, 0, 0, 3024, 3022, 1, 0, 0, 0, 3024, 3025, 
	1, 0, 0, 0, 3025, 157, 1, 0, 0, 0, 3026, 3024, 1, 0, 0, 0, 3027, 3028, 
	5, 51, 0, 0, 3028, 3029, 5, 475, 0, 0, 3029, 3030, 5, 73, 0, 0, 3030, 3031, 
	3, 592, 296, 0, 3031, 3032, 5, 409, 0, 0, 3032, 3033, 5, 1124, 0, 0, 3033, 
	3034, 3, 580, 290, 0, 3034, 159, 1, 0, 0, 0, 3035, 3036, 5, 51, 0, 0, 3036, 
	3038, 5, 131, 0, 0, 3037, 3039, 3, 648, 324, 0, 3038, 3037, 1, 0, 0, 0, 
	3038, 3039, 1, 0, 0, 0, 3039, 3040, 1, 0, 0, 0, 3040, 3041, 3, 558, 279, 
	0, 3041, 161, 1, 0, 0, 0, 3042, 3043, 5, 51, 0, 0, 3043, 3045, 5, 437, 
	0, 0, 3044, 3046, 3, 648, 324, 0, 3045, 3044, 1, 0, 0, 0, 3045, 3046, 1, 
	0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 3048, 3, 558, 279, 0, 3048, 163, 
	1, 0, 0, 0, 3049, 3050, 5, 51, 0, 0, 3050, 3052, 5, 608, 0, 0, 3051, 3053, 
	3, 648, 324, 0, 3052, 3051, 1, 0, 0, 0, 3052, 3053, 1, 0, 0, 0, 3053, 3054, 
	1, 0, 0, 0, 3054, 3055, 3, 592, 296, 0, 3055, 165, 1, 0, 0, 0, 3056, 3058, 
	5, 51, 0, 0, 3057, 3059, 5, 649, 0, 0, 3058, 3057, 1, 0, 0, 0, 3058, 3059, 
	1, 0, 0, 0, 3059, 3060, 1, 0, 0, 0, 3060, 3062, 5, 172, 0, 0, 3061, 3063, 
	3, 648, 324, 0, 3062, 3061, 1, 0, 0, 0, 3062, 3063, 1, 0, 0, 0, 3063, 3064, 
	1, 0, 0, 0, 3064, 3066, 3, 628, 314, 0, 3065, 3067, 7, 38, 0, 0, 3066, 
	3065, 1, 0, 0, 0, 3066, 3067, 1, 0, 0, 0, 3067, 167, 1, 0, 0, 0, 3068, 
	3069, 5, 51, 0, 0, 3069, 3070, 5, 647, 0, 0, 3070, 3076, 3, 592, 296, 0, 
	3071, 3073, 5, 409, 0, 0, 3072, 3074, 5, 1124, 0, 0, 3073, 3072, 1, 0, 
	0, 0, 3073, 3074, 1, 0, 0, 0, 3074, 3075, 1, 0, 0, 0, 3075, 3077, 3, 580, 
	290, 0, 3076, 3071, 1, 0, 0, 0, 3076, 3077, 1, 0, 0, 0, 3077, 169, 1, 0, 
	0, 0, 3078, 3079, 5, 51, 0, 0, 3079, 3081, 5, 177, 0, 0, 3080, 3082, 3, 
	648, 324, 0, 3081, 3080, 1, 0, 0, 0, 3081, 3082, 1, 0, 0, 0, 3082, 3083, 
	1, 0, 0, 0, 3083, 3084, 3, 558, 279, 0, 3084, 171, 1, 0, 0, 0, 3085, 3086, 
	5, 51, 0, 0, 3086, 3088, 5, 671, 0, 0, 3087, 3089, 3, 648, 324, 0, 3088, 
	3087, 1, 0, 0, 0, 3088, 3089, 1, 0, 0, 0, 3089, 3090, 1, 0, 0, 0, 3090, 
	3095, 3, 558, 279, 0, 3091, 3092, 5, 1135, 0, 0, 3092, 3094, 3, 558, 279, 
	0, 3093, 3091, 1, 0, 0, 0, 3094, 3097, 1, 0, 0, 0, 3095, 3093, 1, 0, 0, 
	0, 3095, 3096, 1, 0, 0, 0, 3096, 3099, 1, 0, 0, 0, 3097, 3095, 1, 0, 0, 
	0, 3098, 3100, 7, 38, 0, 0, 3099, 3098, 1, 0, 0, 0, 3099, 3100, 1, 0, 0, 
	0, 3100, 173, 1, 0, 0, 0, 3101, 3102, 5, 51, 0, 0, 3102, 3104, 5, 596, 
	0, 0, 3103, 3105, 3, 648, 324, 0, 3104, 3103, 1, 0, 0, 0, 3104, 3105, 1, 
	0, 0, 0, 3105, 3106, 1, 0, 0, 0, 3106, 3111, 3, 562, 281, 0, 3107, 3108, 
	5, 1135, 0, 0, 3108, 3110, 3, 562, 281, 0, 3109, 3107, 1, 0, 0, 0, 3110, 
	3113, 1, 0, 0, 0, 3111, 3109, 1, 0, 0, 0, 3111, 3112, 1, 0, 0, 0, 3112, 
	175, 1, 0, 0, 0, 3113, 3111, 1, 0, 0, 0, 3114, 3115, 5, 153, 0, 0, 3115, 
	3116, 5, 42, 0, 0, 3116, 3127, 5, 596, 0, 0, 3117, 3128, 5, 529, 0, 0, 
	3118, 3128, 5, 6, 0, 0, 3119, 3124, 3, 562, 281, 0, 3120, 3121, 5, 1135, 
	0, 0, 3121, 3123, 3, 562, 281, 0, 3122, 3120, 1, 0, 0, 0, 3123, 3126, 1, 
	0, 0, 0, 3124, 3122, 1, 0, 0, 0, 3124, 3125, 1, 0, 0, 0, 3125, 3128, 1, 
	0, 0, 0, 3126, 3124, 1, 0, 0, 0, 3127, 3117, 1, 0, 0, 0, 3127, 3118, 1, 
	0, 0, 0, 3127, 3119, 1, 0, 0, 0, 3128, 3129, 1, 0, 0, 0, 3129, 3132, 5, 
	175, 0, 0, 3130, 3133, 3, 572, 286, 0, 3131, 3133, 3, 592, 296, 0, 3132, 
	3130, 1, 0, 0, 0, 3132, 3131, 1, 0, 0, 0, 3133, 3141, 1, 0, 0, 0, 3134, 
	3137, 5, 1135, 0, 0, 3135, 3138, 3, 572, 286, 0, 3136, 3138, 3, 592, 296, 
	0, 3137, 3135, 1, 0, 0, 0, 3137, 3136, 1, 0, 0, 0, 3138, 3140, 1, 0, 0, 
	0, 3139, 3134, 1, 0, 0, 0, 3140, 3143, 1, 0, 0, 0, 3141, 3139, 1, 0, 0, 
	0, 3141, 3142, 1, 0, 0, 0, 3142, 3148, 1, 0, 0, 0, 3143, 3141, 1, 0, 0, 
	0, 3144, 3145, 5, 153, 0, 0, 3145, 3146, 5, 596, 0, 0, 3146, 3148, 3, 442, 
	221, 0, 3147, 3114, 1, 0, 0, 0, 3147, 3144, 1, 0, 0, 0, 3148, 177, 1, 0, 
	0, 0, 3149, 3150, 5, 139, 0, 0, 3150, 3151, 5, 172, 0, 0, 3151, 3156, 3, 
	180, 90, 0, 3152, 3153, 5, 1135, 0, 0, 3153, 3155, 3, 180, 90, 0, 3154, 
	3152, 1, 0, 0, 0, 3155, 3158, 1, 0, 0, 0, 3156, 3154, 1, 0, 0, 0, 3156, 
	3157, 1, 0, 0, 0, 3157, 179, 1, 0, 0, 0, 3158, 3156, 1, 0, 0, 0, 3159, 
	3160, 3, 560, 280, 0, 3160, 3161, 5, 175, 0, 0, 3161, 3162, 3, 560, 280, 
	0, 3162, 181, 1, 0, 0, 0, 3163, 3165, 5, 656, 0, 0, 3164, 3166, 5, 172, 
	0, 0, 3165, 3164, 1, 0, 0, 0, 3165, 3166, 1, 0, 0, 0, 3166, 3167, 1, 0, 
	0, 0, 3167, 3168, 3, 560, 280, 0, 3168, 183, 1, 0, 0, 0, 3169, 3170, 5, 
	20, 0, 0, 3170, 3177, 3, 558, 279, 0, 3171, 3174, 5, 1133, 0, 0, 3172, 
	3175, 3, 636, 318, 0, 3173, 3175, 3, 632, 316, 0, 3174, 3172, 1, 0, 0, 
	0, 3174, 3173, 1, 0, 0, 0, 3174, 3175, 1, 0, 0, 0, 3175, 3176, 1, 0, 0, 
	0, 3176, 3178, 5, 1134, 0, 0, 3177, 3171, 1, 0, 0, 0, 3177, 3178, 1, 0, 
	0, 0, 3178, 185, 1, 0, 0, 0, 3179, 3182, 3, 214, 107, 0, 3180, 3182, 3, 
	216, 108, 0, 3181, 3179, 1, 0, 0, 0, 3181, 3180, 1, 0, 0, 0, 3182, 187, 
	1, 0, 0, 0, 3183, 3184, 5, 399, 0, 0, 3184, 3185, 3, 632, 316, 0, 3185, 
	189, 1, 0, 0, 0, 3186, 3191, 3, 218, 109, 0, 3187, 3191, 3, 220, 110, 0, 
	3188, 3191, 3, 222, 111, 0, 3189, 3191, 3, 224, 112, 0, 3190, 3186, 1, 
	0, 0, 0, 3190, 3187, 1, 0, 0, 0, 3190, 3188, 1, 0, 0, 0, 3190, 3189, 1, 
	0, 0, 0, 3191, 191, 1, 0, 0, 0, 3192, 3194, 5, 85, 0, 0, 3193, 3195, 3, 
	254, 127, 0, 3194, 3193, 1, 0, 0, 0, 3194, 3195, 1, 0, 0, 0, 3195, 3197, 
	1, 0, 0, 0, 3196, 3198, 7, 39, 0, 0, 3197, 3196, 1, 0, 0, 0, 3197, 3198, 
	1, 0, 0, 0, 3198, 3200, 1, 0, 0, 0, 3199, 3201, 5, 78, 0, 0, 3200, 3199, 
	1, 0, 0, 0, 3200, 3201, 1, 0, 0, 0, 3201, 3203, 1, 0, 0, 0, 3202, 3204, 
	5, 87, 0, 0, 3203, 3202, 1, 0, 0, 0, 3203, 3204, 1, 0, 0, 0, 3204, 3205, 
	1, 0, 0, 0, 3205, 3212, 3, 560, 280, 0, 3206, 3207, 5, 129, 0, 0, 3207, 
	3209, 5, 1133, 0, 0, 3208, 3210, 3, 624, 312, 0, 3209, 3208, 1, 0, 0, 0, 
	3209, 3210, 1, 0, 0, 0, 3210, 3211, 1, 0, 0, 0, 3211, 3213, 5, 1134, 0, 
	0, 3212, 3206, 1, 0, 0, 0, 3212, 3213, 1, 0, 0, 0, 3213, 3237, 1, 0, 0, 
	0, 3214, 3216, 5, 1133, 0, 0, 3215, 3217, 3, 626, 313, 0, 3216, 3215, 1, 
	0, 0, 0, 3216, 3217, 1, 0, 0, 0, 3217, 3218, 1, 0, 0, 0, 3218, 3220, 5, 
	1134, 0, 0, 3219, 3214, 1, 0, 0, 0, 3219, 3220, 1, 0, 0, 0, 3220, 3221, 
	1, 0, 0, 0, 3221, 3226, 3, 206, 103, 0, 3222, 3224, 5, 12, 0, 0, 3223, 
	3222, 1, 0, 0, 0, 3223, 3224, 1, 0, 0, 0, 3224, 3225, 1, 0, 0, 0, 3225, 
	3227, 3, 592, 296, 0, 3226, 3223, 1, 0, 0, 0, 3226, 3227, 1, 0, 0, 0, 3227, 
	3238, 1, 0, 0, 0, 3228, 3229, 5, 153, 0, 0, 3229, 3234, 3, 208, 104, 0, 
	3230, 3231, 5, 1135, 0, 0, 3231, 3233, 3, 208, 104, 0, 3232, 3230, 1, 0, 
	0, 0, 3233, 3236, 1, 0, 0, 0, 3234, 3232, 1, 0, 0, 0, 3234, 3235, 1, 0, 
	0, 0, 3235, 3238, 1, 0, 0, 0, 3236, 3234, 1, 0, 0, 0, 3237, 3219, 1, 0, 
	0, 0, 3237, 3228, 1, 0, 0, 0, 3238, 3251, 1, 0, 0, 0, 3239, 3240, 5, 118, 
	0, 0, 3240, 3241, 5, 401, 0, 0, 3241, 3242, 5, 91, 0, 0, 3242, 3243, 5, 
	184, 0, 0, 3243, 3248, 3, 208, 104, 0, 3244, 3245, 5, 1135, 0, 0, 3245, 
	3247, 3, 208, 104, 0, 3246, 3244, 1, 0, 0, 0, 3247, 3250, 1, 0, 0, 0, 3248, 
	3246, 1, 0, 0, 0, 3248, 3249, 1, 0, 0, 0, 3249, 3252, 1, 0, 0, 0, 3250, 
	3248, 1, 0, 0, 0, 3251, 3239, 1, 0, 0, 0, 3251, 3252, 1, 0, 0, 0, 3252, 
	193, 1, 0, 0, 0, 3253, 3254, 5, 102, 0, 0, 3254, 3256, 5, 388, 0, 0, 3255, 
	3257, 7, 40, 0, 0, 3256, 3255, 1, 0, 0, 0, 3256, 3257, 1, 0, 0, 0, 3257, 
	3259, 1, 0, 0, 0, 3258, 3260, 5, 474, 0, 0, 3259, 3258, 1, 0, 0, 0, 3259, 
	3260, 1, 0, 0, 0, 3260, 3261, 1, 0, 0, 0, 3261, 3262, 5, 82, 0, 0, 3262, 
	3264, 5, 1148, 0, 0, 3263, 3265, 7, 6, 0, 0, 3264, 3263, 1, 0, 0, 0, 3264, 
	3265, 1, 0, 0, 0, 3265, 3266, 1, 0, 0, 0, 3266, 3267, 5, 87, 0, 0, 3267, 
	3268, 5, 172, 0, 0, 3268, 3274, 3, 560, 280, 0, 3269, 3270, 5, 129, 0, 
	0, 3270, 3271, 5, 1133, 0, 0, 3271, 3272, 3, 624, 312, 0, 3272, 3273, 5, 
	1134, 0, 0, 3273, 3275, 1, 0, 0, 0, 3274, 3269, 1, 0, 0, 0, 3274, 3275, 
	1, 0, 0, 0, 3275, 3279, 1, 0, 0, 0, 3276, 3277, 5, 25, 0, 0, 3277, 3278, 
	5, 153, 0, 0, 3278, 3280, 3, 576, 288, 0, 3279, 3276, 1, 0, 0, 0, 3279, 
	3280, 1, 0, 0, 0, 3280, 3287, 1, 0, 0, 0, 3281, 3283, 7, 41, 0, 0, 3282, 
	3284, 3, 288, 144, 0, 3283, 3282, 1, 0, 0, 0, 3284, 3285, 1, 0, 0, 0, 3285, 
	3283, 1, 0, 0, 0, 3285, 3286, 1, 0, 0, 0, 3286, 3288, 1, 0, 0, 0, 3287, 
	3281, 1, 0, 0, 0, 3287, 3288, 1, 0, 0, 0, 3288, 3295, 1, 0, 0, 0, 3289, 
	3291, 5, 101, 0, 0, 3290, 3292, 3, 290, 145, 0, 3291, 3290, 1, 0, 0, 0, 
	3292, 3293, 1, 0, 0, 0, 3293, 3291, 1, 0, 0, 0, 3293, 3294, 1, 0, 0, 0, 
	3294, 3296, 1, 0, 0, 0, 3295, 3289, 1, 0, 0, 0, 3295, 3296, 1, 0, 0, 0, 
	3296, 3301, 1, 0, 0, 0, 3297, 3298, 5, 78, 0, 0, 3298, 3299, 3, 598, 299, 
	0, 3299, 3300, 7, 42, 0, 0, 3300, 3302, 1, 0, 0, 0, 3301, 3297, 1, 0, 0, 
	0, 3301, 3302, 1, 0, 0, 0, 3302, 3314, 1, 0, 0, 0, 3303, 3304, 5, 1133, 
	0, 0, 3304, 3309, 3, 210, 105, 0, 3305, 3306, 5, 1135, 0, 0, 3306, 3308, 
	3, 210, 105, 0, 3307, 3305, 1, 0, 0, 0, 3308, 3311, 1, 0, 0, 0, 3309, 3307, 
	1, 0, 0, 0, 3309, 3310, 1, 0, 0, 0, 3310, 3312, 1, 0, 0, 0, 3311, 3309, 
	1, 0, 0, 0, 3312, 3313, 5, 1134, 0, 0, 3313, 3315, 1, 0, 0, 0, 3314, 3303, 
	1, 0, 0, 0, 3314, 3315, 1, 0, 0, 0, 3315, 3325, 1, 0, 0, 0, 3316, 3317, 
	5, 153, 0, 0, 3317, 3322, 3, 208, 104, 0, 3318, 3319, 5, 1135, 0, 0, 3319, 
	3321, 3, 208, 104, 0, 3320, 3318, 1, 0, 0, 0, 3321, 3324, 1, 0, 0, 0, 3322, 
	3320, 1, 0, 0, 0, 3322, 3323, 1, 0, 0, 0, 3323, 3326, 1, 0, 0, 0, 3324, 
	3322, 1, 0, 0, 0, 3325, 3316, 1, 0, 0, 0, 3325, 3326, 1, 0, 0, 0, 3326, 
	195, 1, 0, 0, 0, 3327, 3328, 5, 102, 0, 0, 3328, 3330, 5, 682, 0, 0, 3329, 
	3331, 7, 40, 0, 0, 3330, 3329, 1, 0, 0, 0, 3330, 3331, 1, 0, 0, 0, 3331, 
	3333, 1, 0, 0, 0, 3332, 3334, 5, 474, 0, 0, 3333, 3332, 1, 0, 0, 0, 3333, 
	3334, 1, 0, 0, 0, 3334, 3335, 1, 0, 0, 0, 3335, 3336, 5, 82, 0, 0, 3336, 
	3338, 5, 1148, 0, 0, 3337, 3339, 7, 6, 0, 0, 3338, 3337, 1, 0, 0, 0, 3338, 
	3339, 1, 0, 0, 0, 3339, 3340, 1, 0, 0, 0, 3340, 3341, 5, 87, 0, 0, 3341, 
	3342, 5, 172, 0, 0, 3342, 3346, 3, 560, 280, 0, 3343, 3344, 5, 25, 0, 0, 
	3344, 3345, 5, 153, 0, 0, 3345, 3347, 3, 576, 288, 0, 3346, 3343, 1, 0, 
	0, 0, 3346, 3347, 1, 0, 0, 0, 3347, 3354, 1, 0, 0, 0, 3348, 3349, 5, 601, 
	0, 0, 3349, 3350, 5, 448, 0, 0, 3350, 3351, 5, 19, 0, 0, 3351, 3352, 5, 
	1126, 0, 0, 3352, 3353, 5, 1148, 0, 0, 3353, 3355, 5, 1125, 0, 0, 3354, 
	3348, 1, 0, 0, 0, 3354, 3355, 1, 0, 0, 0, 3355, 3360, 1, 0, 0, 0, 3356, 
	3357, 5, 78, 0, 0, 3357, 3358, 3, 598, 299, 0, 3358, 3359, 7, 42, 0, 0, 
	3359, 3361, 1, 0, 0, 0, 3360, 3356, 1, 0, 0, 0, 3360, 3361, 1, 0, 0, 0, 
	3361, 3373, 1, 0, 0, 0, 3362, 3363, 5, 1133, 0, 0, 3363, 3368, 3, 210, 
	105, 0, 3364, 3365, 5, 1135, 0, 0, 3365, 3367, 3, 210, 105, 0, 3366, 3364, 
	1, 0, 0, 0, 3367, 3370, 1, 0, 0, 0, 3368, 3366, 1, 0, 0, 0, 3368, 3369, 
	1, 0, 0, 0, 3369, 3371, 1, 0, 0, 0, 3370, 3368, 1, 0, 0, 0, 3371, 3372, 
	5, 1134, 0, 0, 3372, 3374, 1, 0, 0, 0, 3373, 3362, 1, 0, 0, 0, 3373, 3374, 
	1, 0, 0, 0, 3374, 3384, 1, 0, 0, 0, 3375, 3376, 5, 153, 0, 0, 3376, 3381, 
	3, 208, 104, 0, 3377, 3378, 5, 1135, 0, 0, 3378, 3380, 3, 208, 104, 0, 
	3379, 3377, 1, 0, 0, 0, 3380, 3383, 1, 0, 0, 0, 3381, 3379, 1, 0, 0, 0, 
	3381, 3382, 1, 0, 0, 0, 3382, 3385, 1, 0, 0, 0, 3383, 3381, 1, 0, 0, 0, 
	3384, 3375, 1, 0, 0, 0, 3384, 3385, 1, 0, 0, 0, 3385, 197, 1, 0, 0, 0, 
	3386, 3388, 5, 141, 0, 0, 3387, 3389, 7, 43, 0, 0, 3388, 3387, 1, 0, 0, 
	0, 3388, 3389, 1, 0, 0, 0, 3389, 3391, 1, 0, 0, 0, 3390, 3392, 5, 87, 0, 
	0, 3391, 3390, 1, 0, 0, 0, 3391, 3392, 1, 0, 0, 0, 3392, 3393, 1, 0, 0, 
	0, 3393, 3399, 3, 560, 280, 0, 3394, 3395, 5, 129, 0, 0, 3395, 3396, 5, 
	1133, 0, 0, 3396, 3397, 3, 624, 312, 0, 3397, 3398, 5, 1134, 0, 0, 3398, 
	3400, 1, 0, 0, 0, 3399, 3394, 1, 0, 0, 0, 3399, 3400, 1, 0, 0, 0, 3400, 
	3417, 1, 0, 0, 0, 3401, 3402, 5, 1133, 0, 0, 3402, 3403, 3, 624, 312, 0, 
	3403, 3404, 5, 1134, 0, 0, 3404, 3406, 1, 0, 0, 0, 3405, 3401, 1, 0, 0, 
	0, 3405, 3406, 1, 0, 0, 0, 3406, 3407, 1, 0, 0, 0, 3407, 3418, 3, 206, 
	103, 0, 3408, 3409, 5, 153, 0, 0, 3409, 3414, 3, 208, 104, 0, 3410, 3411, 
	5, 1135, 0, 0, 3411, 3413, 3, 208, 104, 0, 3412, 3410, 1, 0, 0, 0, 3413, 
	3416, 1, 0, 0, 0, 3414, 3412, 1, 0, 0, 0, 3414, 3415, 1, 0, 0, 0, 3415, 
	3418, 1, 0, 0, 0, 3416, 3414, 1, 0, 0, 0, 3417, 3405, 1, 0, 0, 0, 3417, 
	3408, 1, 0, 0, 0, 3418, 199, 1, 0, 0, 0, 3419, 3421, 3, 252, 126, 0, 3420, 
	3422, 3, 212, 106, 0, 3421, 3420, 1, 0, 0, 0, 3421, 3422, 1, 0, 0, 0, 3422, 
	3485, 1, 0, 0, 0, 3423, 3425, 3, 248, 124, 0, 3424, 3426, 3, 212, 106, 
	0, 3425, 3424, 1, 0, 0, 0, 3425, 3426, 1, 0, 0, 0, 3426, 3485, 1, 0, 0, 
	0, 3427, 3430, 3, 262, 131, 0, 3428, 3430, 3, 250, 125, 0, 3429, 3427, 
	1, 0, 0, 0, 3429, 3428, 1, 0, 0, 0, 3430, 3432, 1, 0, 0, 0, 3431, 3433, 
	3, 266, 133, 0, 3432, 3431, 1, 0, 0, 0, 3433, 3434, 1, 0, 0, 0, 3434, 3432, 
	1, 0, 0, 0, 3434, 3435, 1, 0, 0, 0, 3435, 3444, 1, 0, 0, 0, 3436, 3438, 
	5, 180, 0, 0, 3437, 3439, 7, 44, 0, 0, 3438, 3437, 1, 0, 0, 0, 3438, 3439, 
	1, 0, 0, 0, 3439, 3442, 1, 0, 0, 0, 3440, 3443, 3, 252, 126, 0, 3441, 3443, 
	3, 248, 124, 0, 3442, 3440, 1, 0, 0, 0, 3442, 3441, 1, 0, 0, 0, 3443, 3445, 
	1, 0, 0, 0, 3444, 3436, 1, 0, 0, 0, 3444, 3445, 1, 0, 0, 0, 3445, 3447, 
	1, 0, 0, 0, 3446, 3448, 3, 230, 115, 0, 3447, 3446, 1, 0, 0, 0, 3447, 3448, 
	1, 0, 0, 0, 3448, 3450, 1, 0, 0, 0, 3449, 3451, 3, 302, 151, 0, 3450, 3449, 
	1, 0, 0, 0, 3450, 3451, 1, 0, 0, 0, 3451, 3453, 1, 0, 0, 0, 3452, 3454, 
	3, 212, 106, 0, 3453, 3452, 1, 0, 0, 0, 3453, 3454, 1, 0, 0, 0, 3454, 3485, 
	1, 0, 0, 0, 3455, 3457, 3, 250, 125, 0, 3456, 3458, 3, 264, 132, 0, 3457, 
	3456, 1, 0, 0, 0, 3458, 3459, 1, 0, 0, 0, 3459, 3457, 1, 0, 0, 0, 3459, 
	3460, 1, 0, 0, 0, 3460, 3466, 1, 0, 0, 0, 3461, 3463, 5, 180, 0, 0, 3462, 
	3464, 7, 44, 0, 0, 3463, 3462, 1, 0, 0, 0, 3463, 3464, 1, 0, 0, 0, 3464, 
	3465, 1, 0, 0, 0, 3465, 3467, 3, 248, 124, 0, 3466, 3461, 1, 0, 0, 0, 3466, 
	3467, 1, 0, 0, 0, 3467, 3469, 1, 0, 0, 0, 3468, 3470, 3, 230, 115, 0, 3469, 
	3468, 1, 0, 0, 0, 3469, 3470, 1, 0, 0, 0, 3470, 3472, 1, 0, 0, 0, 3471, 
	3473, 3, 302, 151, 0, 3472, 3471, 1, 0, 0, 0, 3472, 3473, 1, 0, 0, 0, 3473, 
	3475, 1, 0, 0, 0, 3474, 3476, 3, 212, 106, 0, 3475, 3474, 1, 0, 0, 0, 3475, 
	3476, 1, 0, 0, 0, 3476, 3485, 1, 0, 0, 0, 3477, 3480, 3, 262, 131, 0, 3478, 
	3479, 5, 1135, 0, 0, 3479, 3481, 3, 268, 134, 0, 3480, 3478, 1, 0, 0, 0, 
	3481, 3482, 1, 0, 0, 0, 3482, 3480, 1, 0, 0, 0, 3482, 3483, 1, 0, 0, 0, 
	3483, 3485, 1, 0, 0, 0, 3484, 3419, 1, 0, 0, 0, 3484, 3423, 1, 0, 0, 0, 
	3484, 3429, 1, 0, 0, 0, 3484, 3455, 1, 0, 0, 0, 3484, 3477, 1, 0, 0, 0, 
	3485, 201, 1, 0, 0, 0, 3486, 3489, 3, 226, 113, 0, 3487, 3489, 3, 228, 
	114, 0, 3488, 3486, 1, 0, 0, 0, 3488, 3487, 1, 0, 0, 0, 3489, 203, 1, 0, 
	0, 0, 3490, 3491, 5, 188, 0, 0, 3491, 3493, 5, 1133, 0, 0, 3492, 3494, 
	3, 634, 317, 0, 3493, 3492, 1, 0, 0, 0, 3493, 3494, 1, 0, 0, 0, 3494, 3495, 
	1, 0, 0, 0, 3495, 3504, 5, 1134, 0, 0, 3496, 3497, 5, 1135, 0, 0, 3497, 
	3499, 5, 1133, 0, 0, 3498, 3500, 3, 634, 317, 0, 3499, 3498, 1, 0, 0, 0, 
	3499, 3500, 1, 0, 0, 0, 3500, 3501, 1, 0, 0, 0, 3501, 3503, 5, 1134, 0, 
	0, 3502, 3496, 1, 0, 0, 0, 3503, 3506, 1, 0, 0, 0, 3504, 3502, 1, 0, 0, 
	0, 3504, 3505, 1, 0, 0, 0, 3505, 205, 1, 0, 0, 0, 3506, 3504, 1, 0, 0, 
	0, 3507, 3526, 3, 200, 100, 0, 3508, 3509, 7, 45, 0, 0, 3509, 3511, 5, 
	1133, 0, 0, 3510, 3512, 3, 634, 317, 0, 3511, 3510, 1, 0, 0, 0, 3511, 3512, 
	1, 0, 0, 0, 3512, 3513, 1, 0, 0, 0, 3513, 3522, 5, 1134, 0, 0, 3514, 3515, 
	5, 1135, 0, 0, 3515, 3517, 5, 1133, 0, 0, 3516, 3518, 3, 634, 317, 0, 3517, 
	3516, 1, 0, 0, 0, 3517, 3518, 1, 0, 0, 0, 3518, 3519, 1, 0, 0, 0, 3519, 
	3521, 5, 1134, 0, 0, 3520, 3514, 1, 0, 0, 0, 3521, 3524, 1, 0, 0, 0, 3522, 
	3520, 1, 0, 0, 0, 3522, 3523, 1, 0, 0, 0, 3523, 3526, 1, 0, 0, 0, 3524, 
	3522, 1, 0, 0, 0, 3525, 3507, 1, 0, 0, 0, 3525, 3508, 1, 0, 0, 0, 3526, 
	207, 1, 0, 0, 0, 3527, 3528, 3, 564, 282, 0, 3528, 3531, 5, 1124, 0, 0, 
	3529, 3532, 3, 696, 348, 0, 3530, 3532, 5, 42, 0, 0, 3531, 3529, 1, 0, 
	0, 0, 3531, 3530, 1, 0, 0, 0, 3532, 209, 1, 0, 0, 0, 3533, 3536, 3, 592, 
	296, 0, 3534, 3536, 5, 1159, 0, 0, 3535, 3533, 1, 0, 0, 0, 3535, 3534, 
	1, 0, 0, 0, 3536, 211, 1, 0, 0, 0, 3537, 3538, 5, 65, 0, 0, 3538, 3544, 
	5, 184, 0, 0, 3539, 3540, 5, 103, 0, 0, 3540, 3541, 5, 80, 0, 0, 3541, 
	3542, 5, 610, 0, 0, 3542, 3544, 5, 511, 0, 0, 3543, 3537, 1, 0, 0, 0, 3543, 
	3539, 1, 0, 0, 0, 3544, 213, 1, 0, 0, 0, 3545, 3547, 5, 44, 0, 0, 3546, 
	3548, 3, 254, 127, 0, 3547, 3546, 1, 0, 0, 0, 3547, 3548, 1, 0, 0, 0, 3548, 
	3550, 1, 0, 0, 0, 3549, 3551, 5, 106, 0, 0, 3550, 3549, 1, 0, 0, 0, 3550, 
	3551, 1, 0, 0, 0, 3551, 3553, 1, 0, 0, 0, 3552, 3554, 5, 568, 0, 0, 3553, 
	3552, 1, 0, 0, 0, 3553, 3554, 1, 0, 0, 0, 3554, 3556, 1, 0, 0, 0, 3555, 
	3557, 5, 78, 0, 0, 3556, 3555, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557, 
	3558, 1, 0, 0, 0, 3558, 3559, 5, 68, 0, 0, 3559, 3564, 3, 560, 280, 0, 
	3560, 3562, 5, 12, 0, 0, 3561, 3560, 1, 0, 0, 0, 3561, 3562, 1, 0, 0, 0, 
	3562, 3563, 1, 0, 0, 0, 3563, 3565, 3, 592, 296, 0, 3564, 3561, 1, 0, 0, 
	0, 3564, 3565, 1, 0, 0, 0, 3565, 3571, 1, 0, 0, 0, 3566, 3567, 5, 129, 
	0, 0, 3567, 3568, 5, 1133, 0, 0, 3568, 3569, 3, 624, 312, 0, 3569, 3570, 
	5, 1134, 0, 0, 3570, 3572, 1, 0, 0, 0, 3571, 3566, 1, 0, 0, 0, 3571, 3572, 
	1, 0, 0, 0, 3572, 3575, 1, 0, 0, 0, 3573, 3574, 5, 190, 0, 0, 3574, 3576, 
	3, 696, 348, 0, 3575, 3573, 1, 0, 0, 0, 3575, 3576, 1, 0, 0, 0, 3576, 3578, 
	1, 0, 0, 0, 3577, 3579, 3, 230, 115, 0, 3578, 3577, 1, 0, 0, 0, 3578, 3579, 
	1, 0, 0, 0, 3579, 3582, 1, 0, 0, 0, 3580, 3581, 5, 99, 0, 0, 3581, 3583, 
	3, 304, 152, 0, 3582, 3580, 1, 0, 0, 0, 3582, 3583, 1, 0, 0, 0, 3583, 215, 
	1, 0, 0, 0, 3584, 3586, 5, 44, 0, 0, 3585, 3587, 3, 254, 127, 0, 3586, 
	3585, 1, 0, 0, 0, 3586, 3587, 1, 0, 0, 0, 3587, 3589, 1, 0, 0, 0, 3588, 
	3590, 5, 106, 0, 0, 3589, 3588, 1, 0, 0, 0, 3589, 3590, 1, 0, 0, 0, 3590, 
	3592, 1, 0, 0, 0, 3591, 3593, 5, 568, 0, 0, 3592, 3591, 1, 0, 0, 0, 3592, 
	3593, 1, 0, 0, 0, 3593, 3595, 1, 0, 0, 0, 3594, 3596, 5, 78, 0, 0, 3595, 
	3594, 1, 0, 0, 0, 3595, 3596, 1, 0, 0, 0, 3596, 3636, 1, 0, 0, 0, 3597, 
	3600, 3, 560, 280, 0, 3598, 3599, 5, 1132, 0, 0, 3599, 3601, 5, 1117, 0, 
	0, 3600, 3598, 1, 0, 0, 0, 3600, 3601, 1, 0, 0, 0, 3601, 3610, 1, 0, 0, 
	0, 3602, 3603, 5, 1135, 0, 0, 3603, 3606, 3, 560, 280, 0, 3604, 3605, 5, 
	1132, 0, 0, 3605, 3607, 5, 1117, 0, 0, 3606, 3604, 1, 0, 0, 0, 3606, 3607, 
	1, 0, 0, 0, 3607, 3609, 1, 0, 0, 0, 3608, 3602, 1, 0, 0, 0, 3609, 3612, 
	1, 0, 0, 0, 3610, 3608, 1, 0, 0, 0, 3610, 3611, 1, 0, 0, 0, 3611, 3613, 
	1, 0, 0, 0, 3612, 3610, 1, 0, 0, 0, 3613, 3614, 5, 68, 0, 0, 3614, 3615, 
	3, 234, 117, 0, 3615, 3637, 1, 0, 0, 0, 3616, 3617, 5, 68, 0, 0, 3617, 
	3620, 3, 560, 280, 0, 3618, 3619, 5, 1132, 0, 0, 3619, 3621, 5, 1117, 0, 
	0, 3620, 3618, 1, 0, 0, 0, 3620, 3621, 1, 0, 0, 0, 3621, 3630, 1, 0, 0, 
	0, 3622, 3623, 5, 1135, 0, 0, 3623, 3626, 3, 560, 280, 0, 3624, 3625, 5, 
	1132, 0, 0, 3625, 3627, 5, 1117, 0, 0, 3626, 3624, 1, 0, 0, 0, 3626, 3627, 
	1, 0, 0, 0, 3627, 3629, 1, 0, 0, 0, 3628, 3622, 1, 0, 0, 0, 3629, 3632, 
	1, 0, 0, 0, 3630, 3628, 1, 0, 0, 0, 3630, 3631, 1, 0, 0, 0, 3631, 3633, 
	1, 0, 0, 0, 3632, 3630, 1, 0, 0, 0, 3633, 3634, 5, 187, 0, 0, 3634, 3635, 
	3, 234, 117, 0, 3635, 3637, 1, 0, 0, 0, 3636, 3597, 1, 0, 0, 0, 3636, 3616, 
	1, 0, 0, 0, 3637, 3640, 1, 0, 0, 0, 3638, 3639, 5, 190, 0, 0, 3639, 3641, 
	3, 696, 348, 0, 3640, 3638, 1, 0, 0, 0, 3640, 3641, 1, 0, 0, 0, 3641, 217, 
	1, 0, 0, 0, 3642, 3643, 5, 442, 0, 0, 3643, 3644, 3, 560, 280, 0, 3644, 
	3649, 5, 539, 0, 0, 3645, 3647, 5, 12, 0, 0, 3646, 3645, 1, 0, 0, 0, 3646, 
	3647, 1, 0, 0, 0, 3647, 3648, 1, 0, 0, 0, 3648, 3650, 3, 592, 296, 0, 3649, 
	3646, 1, 0, 0, 0, 3649, 3650, 1, 0, 0, 0, 3650, 219, 1, 0, 0, 0, 3651, 
	3652, 5, 442, 0, 0, 3652, 3653, 3, 560, 280, 0, 3653, 3654, 5, 134, 0, 
	0, 3654, 3661, 3, 592, 296, 0, 3655, 3656, 3, 704, 352, 0, 3656, 3657, 
	5, 1133, 0, 0, 3657, 3658, 3, 636, 318, 0, 3658, 3659, 5, 1134, 0, 0, 3659, 
	3662, 1, 0, 0, 0, 3660, 3662, 7, 46, 0, 0, 3661, 3655, 1, 0, 0, 0, 3661, 
	3660, 1, 0, 0, 0, 3662, 3665, 1, 0, 0, 0, 3663, 3664, 5, 190, 0, 0, 3664, 
	3666, 3, 696, 348, 0, 3665, 3663, 1, 0, 0, 0, 3665, 3666, 1, 0, 0, 0, 3666, 
	3669, 1, 0, 0, 0, 3667, 3668, 5, 99, 0, 0, 3668, 3670, 3, 304, 152, 0, 
	3669, 3667, 1, 0, 0, 0, 3669, 3670, 1, 0, 0, 0, 3670, 221, 1, 0, 0, 0, 
	3671, 3672, 5, 442, 0, 0, 3672, 3673, 3, 560, 280, 0, 3673, 3674, 5, 134, 
	0, 0, 3674, 3677, 7, 47, 0, 0, 3675, 3676, 5, 190, 0, 0, 3676, 3678, 3, 
	696, 348, 0, 3677, 3675, 1, 0, 0, 0, 3677, 3678, 1, 0, 0, 0, 3678, 3681, 
	1, 0, 0, 0, 3679, 3680, 5, 99, 0, 0, 3680, 3682, 3, 304, 152, 0, 3681, 
	3679, 1, 0, 0, 0, 3681, 3682, 1, 0, 0, 0, 3682, 223, 1, 0, 0, 0, 3683, 
	3684, 5, 442, 0, 0, 3684, 3685, 3, 560, 280, 0, 3685, 3686, 5, 361, 0, 
	0, 3686, 225, 1, 0, 0, 0, 3687, 3689, 5, 184, 0, 0, 3688, 3690, 3, 254, 
	127, 0, 3689, 3688, 1, 0, 0, 0, 3689, 3690, 1, 0, 0, 0, 3690, 3692, 1, 
	0, 0, 0, 3691, 3693, 5, 106, 0, 0, 3692, 3691, 1, 0, 0, 0, 3692, 3693, 
	1, 0, 0, 0, 3693, 3695, 1, 0, 0, 0, 3694, 3696, 5, 78, 0, 0, 3695, 3694, 
	1, 0, 0, 0, 3695, 3696, 1, 0, 0, 0, 3696, 3697, 1, 0, 0, 0, 3697, 3702, 
	3, 560, 280, 0, 3698, 3700, 5, 12, 0, 0, 3699, 3698, 1, 0, 0, 0, 3699, 
	3700, 1, 0, 0, 0, 3700, 3701, 1, 0, 0, 0, 3701, 3703, 3, 592, 296, 0, 3702, 
	3699, 1, 0, 0, 0, 3702, 3703, 1, 0, 0, 0, 3703, 3704, 1, 0, 0, 0, 3704, 
	3705, 5, 153, 0, 0, 3705, 3710, 3, 208, 104, 0, 3706, 3707, 5, 1135, 0, 
	0, 3707, 3709, 3, 208, 104, 0, 3708, 3706, 1, 0, 0, 0, 3709, 3712, 1, 0, 
	0, 0, 3710, 3708, 1, 0, 0, 0, 3710, 3711, 1, 0, 0, 0, 3711, 3715, 1, 0, 
	0, 0, 3712, 3710, 1, 0, 0, 0, 3713, 3714, 5, 190, 0, 0, 3714, 3716, 3, 
	696, 348, 0, 3715, 3713, 1, 0, 0, 0, 3715, 3716, 1, 0, 0, 0, 3716, 3718, 
	1, 0, 0, 0, 3717, 3719, 3, 230, 115, 0, 3718, 3717, 1, 0, 0, 0, 3718, 3719, 
	1, 0, 0, 0, 3719, 3721, 1, 0, 0, 0, 3720, 3722, 3, 302, 151, 0, 3721, 3720, 
	1, 0, 0, 0, 3721, 3722, 1, 0, 0, 0, 3722, 227, 1, 0, 0, 0, 3723, 3725, 
	5, 184, 0, 0, 3724, 3726, 3, 254, 127, 0, 3725, 3724, 1, 0, 0, 0, 3725, 
	3726, 1, 0, 0, 0, 3726, 3728, 1, 0, 0, 0, 3727, 3729, 5, 106, 0, 0, 3728, 
	3727, 1, 0, 0, 0, 3728, 3729, 1, 0, 0, 0, 3729, 3731, 1, 0, 0, 0, 3730, 
	3732, 5, 78, 0, 0, 3731, 3730, 1, 0, 0, 0, 3731, 3732, 1, 0, 0, 0, 3732, 
	3733, 1, 0, 0, 0, 3733, 3734, 3, 234, 117, 0, 3734, 3735, 5, 153, 0, 0, 
	3735, 3740, 3, 208, 104, 0, 3736, 3737, 5, 1135, 0, 0, 3737, 3739, 3, 208, 
	104, 0, 3738, 3736, 1, 0, 0, 0, 3739, 3742, 1, 0, 0, 0, 3740, 3738, 1, 
	0, 0, 0, 3740, 3741, 1, 0, 0, 0, 3741, 3745, 1, 0, 0, 0, 3742, 3740, 1, 
	0, 0, 0, 3743, 3744, 5, 190, 0, 0, 3744, 3746, 3, 696, 348, 0, 3745, 3743, 
	1, 0, 0, 0, 3745, 3746, 1, 0, 0, 0, 3746, 229, 1, 0, 0, 0, 3747, 3748, 
	5, 124, 0, 0, 3748, 3749, 5, 19, 0, 0, 3749, 3754, 3, 232, 116, 0, 3750, 
	3751, 5, 1135, 0, 0, 3751, 3753, 3, 232, 116, 0, 3752, 3750, 1, 0, 0, 0, 
	3753, 3756, 1, 0, 0, 0, 3754, 3752, 1, 0, 0, 0, 3754, 3755, 1, 0, 0, 0, 
	3755, 231, 1, 0, 0, 0, 3756, 3754, 1, 0, 0, 0, 3757, 3759, 3, 696, 348, 
	0, 3758, 3760, 7, 48, 0, 0, 3759, 3758, 1, 0, 0, 0, 3759, 3760, 1, 0, 0, 
	0, 3760, 233, 1, 0, 0, 0, 3761, 3766, 3, 236, 118, 0, 3762, 3763, 5, 1135, 
	0, 0, 3763, 3765, 3, 236, 118, 0, 3764, 3762, 1, 0, 0, 0, 3765, 3768, 1, 
	0, 0, 0, 3766, 3764, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 235, 1, 
	0, 0, 0, 3768, 3766, 1, 0, 0, 0, 3769, 3773, 3, 238, 119, 0, 3770, 3772, 
	3, 244, 122, 0, 3771, 3770, 1, 0, 0, 0, 3772, 3775, 1, 0, 0, 0, 3773, 3771, 
	1, 0, 0, 0, 3773, 3774, 1, 0, 0, 0, 3774, 3788, 1, 0, 0, 0, 3775, 3773, 
	1, 0, 0, 0, 3776, 3777, 5, 1133, 0, 0, 3777, 3781, 3, 238, 119, 0, 3778, 
	3780, 3, 244, 122, 0, 3779, 3778, 1, 0, 0, 0, 3780, 3783, 1, 0, 0, 0, 3781, 
	3779, 1, 0, 0, 0, 3781, 3782, 1, 0, 0, 0, 3782, 3784, 1, 0, 0, 0, 3783, 
	3781, 1, 0, 0, 0, 3784, 3785, 5, 1134, 0, 0, 3785, 3788, 1, 0, 0, 0, 3786, 
	3788, 3, 270, 135, 0, 3787, 3769, 1, 0, 0, 0, 3787, 3776, 1, 0, 0, 0, 3787, 
	3786, 1, 0, 0, 0, 3788, 237, 1, 0, 0, 0, 3789, 3795, 3, 560, 280, 0, 3790, 
	3791, 5, 129, 0, 0, 3791, 3792, 5, 1133, 0, 0, 3792, 3793, 3, 624, 312, 
	0, 3793, 3794, 5, 1134, 0, 0, 3794, 3796, 1, 0, 0, 0, 3795, 3790, 1, 0, 
	0, 0, 3795, 3796, 1, 0, 0, 0, 3796, 3801, 1, 0, 0, 0, 3797, 3799, 5, 12, 
	0, 0, 3798, 3797, 1, 0, 0, 0, 3798, 3799, 1, 0, 0, 0, 3799, 3800, 1, 0, 
	0, 0, 3800, 3802, 3, 592, 296, 0, 3801, 3798, 1, 0, 0, 0, 3801, 3802, 1, 
	0, 0, 0, 3802, 3811, 1, 0, 0, 0, 3803, 3808, 3, 240, 120, 0, 3804, 3805, 
	5, 1135, 0, 0, 3805, 3807, 3, 240, 120, 0, 3806, 3804, 1, 0, 0, 0, 3807, 
	3810, 1, 0, 0, 0, 3808, 3806, 1, 0, 0, 0, 3808, 3809, 1, 0, 0, 0, 3809, 
	3812, 1, 0, 0, 0, 3810, 3808, 1, 0, 0, 0, 3811, 3803, 1, 0, 0, 0, 3811, 
	3812, 1, 0, 0, 0, 3812, 3830, 1, 0, 0, 0, 3813, 3819, 3, 200, 100, 0, 3814, 
	3815, 5, 1133, 0, 0, 3815, 3816, 3, 200, 100, 0, 3816, 3817, 5, 1134, 0, 
	0, 3817, 3819, 1, 0, 0, 0, 3818, 3813, 1, 0, 0, 0, 3818, 3814, 1, 0, 0, 
	0, 3819, 3821, 1, 0, 0, 0, 3820, 3822, 5, 12, 0, 0, 3821, 3820, 1, 0, 0, 
	0, 3821, 3822, 1, 0, 0, 0, 3822, 3823, 1, 0, 0, 0, 3823, 3824, 3, 592, 
	296, 0, 3824, 3830, 1, 0, 0, 0, 3825, 3826, 5, 1133, 0, 0, 3826, 3827, 
	3, 234, 117, 0, 3827, 3828, 5, 1134, 0, 0, 3828, 3830, 1, 0, 0, 0, 3829, 
	3789, 1, 0, 0, 0, 3829, 3818, 1, 0, 0, 0, 3829, 3825, 1, 0, 0, 0, 3830, 
	239, 1, 0, 0, 0, 3831, 3832, 7, 49, 0, 0, 3832, 3835, 7, 20, 0, 0, 3833, 
	3834, 5, 65, 0, 0, 3834, 3836, 3, 242, 121, 0, 3835, 3833, 1, 0, 0, 0, 
	3835, 3836, 1, 0, 0, 0, 3836, 3837, 1, 0, 0, 0, 3837, 3838, 5, 1133, 0, 
	0, 3838, 3839, 3, 624, 312, 0, 3839, 3840, 5, 1134, 0, 0, 3840, 241, 1, 
	0, 0, 0, 3841, 3847, 5, 90, 0, 0, 3842, 3843, 5, 124, 0, 0, 3843, 3847, 
	5, 19, 0, 0, 3844, 3845, 5, 73, 0, 0, 3845, 3847, 5, 19, 0, 0, 3846, 3841, 
	1, 0, 0, 0, 3846, 3842, 1, 0, 0, 0, 3846, 3844, 1, 0, 0, 0, 3847, 243, 
	1, 0, 0, 0, 3848, 3850, 7, 50, 0, 0, 3849, 3848, 1, 0, 0, 0, 3849, 3850, 
	1, 0, 0, 0, 3850, 3851, 1, 0, 0, 0, 3851, 3853, 5, 90, 0, 0, 3852, 3854, 
	5, 94, 0, 0, 3853, 3852, 1, 0, 0, 0, 3853, 3854, 1, 0, 0, 0, 3854, 3855, 
	1, 0, 0, 0, 3855, 3859, 3, 238, 119, 0, 3856, 3858, 3, 246, 123, 0, 3857, 
	3856, 1, 0, 0, 0, 3858, 3861, 1, 0, 0, 0, 3859, 3857, 1, 0, 0, 0, 3859, 
	3860, 1, 0, 0, 0, 3860, 3896, 1, 0, 0, 0, 3861, 3859, 1, 0, 0, 0, 3862, 
	3863, 5, 171, 0, 0, 3863, 3868, 3, 238, 119, 0, 3864, 3865, 5, 118, 0, 
	0, 3865, 3867, 3, 696, 348, 0, 3866, 3864, 1, 0, 0, 0, 3867, 3870, 1, 0, 
	0, 0, 3868, 3866, 1, 0, 0, 0, 3868, 3869, 1, 0, 0, 0, 3869, 3896, 1, 0, 
	0, 0, 3870, 3868, 1, 0, 0, 0, 3871, 3873, 7, 51, 0, 0, 3872, 3874, 5, 126, 
	0, 0, 3873, 3872, 1, 0, 0, 0, 3873, 3874, 1, 0, 0, 0, 3874, 3875, 1, 0, 
	0, 0, 3875, 3877, 5, 90, 0, 0, 3876, 3878, 5, 94, 0, 0, 3877, 3876, 1, 
	0, 0, 0, 3877, 3878, 1, 0, 0, 0, 3878, 3879, 1, 0, 0, 0, 3879, 3883, 3, 
	238, 119, 0, 3880, 3882, 3, 246, 123, 0, 3881, 3880, 1, 0, 0, 0, 3882, 
	3885, 1, 0, 0, 0, 3883, 3881, 1, 0, 0, 0, 3883, 3884, 1, 0, 0, 0, 3884, 
	3896, 1, 0, 0, 0, 3885, 3883, 1, 0, 0, 0, 3886, 3891, 5, 113, 0, 0, 3887, 
	3889, 7, 51, 0, 0, 3888, 3890, 5, 126, 0, 0, 3889, 3888, 1, 0, 0, 0, 3889, 
	3890, 1, 0, 0, 0, 3890, 3892, 1, 0, 0, 0, 3891, 3887, 1, 0, 0, 0, 3891, 
	3892, 1, 0, 0, 0, 3892, 3893, 1, 0, 0, 0, 3893, 3894, 5, 90, 0, 0, 3894, 
	3896, 3, 238, 119, 0, 3895, 3849, 1, 0, 0, 0, 3895, 3862, 1, 0, 0, 0, 3895, 
	3871, 1, 0, 0, 0, 3895, 3886, 1, 0, 0, 0, 3896, 245, 1, 0, 0, 0, 3897, 
	3898, 5, 118, 0, 0, 3898, 3905, 3, 696, 348, 0, 3899, 3900, 5, 187, 0, 
	0, 3900, 3901, 5, 1133, 0, 0, 3901, 3902, 3, 624, 312, 0, 3902, 3903, 5, 
	1134, 0, 0, 3903, 3905, 1, 0, 0, 0, 3904, 3897, 1, 0, 0, 0, 3904, 3899, 
	1, 0, 0, 0, 3905, 247, 1, 0, 0, 0, 3906, 3907, 5, 1133, 0, 0, 3907, 3908, 
	3, 252, 126, 0, 3908, 3909, 5, 1134, 0, 0, 3909, 3915, 1, 0, 0, 0, 3910, 
	3911, 5, 1133, 0, 0, 3911, 3912, 3, 248, 124, 0, 3912, 3913, 5, 1134, 0, 
	0, 3913, 3915, 1, 0, 0, 0, 3914, 3906, 1, 0, 0, 0, 3914, 3910, 1, 0, 0, 
	0, 3915, 249, 1, 0, 0, 0, 3916, 3917, 5, 1133, 0, 0, 3917, 3918, 3, 262, 
	131, 0, 3918, 3919, 5, 1134, 0, 0, 3919, 3925, 1, 0, 0, 0, 3920, 3921, 
	5, 1133, 0, 0, 3921, 3922, 3, 250, 125, 0, 3922, 3923, 5, 1134, 0, 0, 3923, 
	3925, 1, 0, 0, 0, 3924, 3916, 1, 0, 0, 0, 3924, 3920, 1, 0, 0, 0, 3925, 
	251, 1, 0, 0, 0, 3926, 3928, 5, 152, 0, 0, 3927, 3929, 3, 254, 127, 0, 
	3928, 3927, 1, 0, 0, 0, 3928, 3929, 1, 0, 0, 0, 3929, 3933, 1, 0, 0, 0, 
	3930, 3932, 3, 280, 140, 0, 3931, 3930, 1, 0, 0, 0, 3932, 3935, 1, 0, 0, 
	0, 3933, 3931, 1, 0, 0, 0, 3933, 3934, 1, 0, 0, 0, 3934, 3936, 1, 0, 0, 
	0, 3935, 3933, 1, 0, 0, 0, 3936, 3938, 3, 282, 141, 0, 3937, 3939, 3, 286, 
	143, 0, 3938, 3937, 1, 0, 0, 0, 3938, 3939, 1, 0, 0, 0, 3939, 3940, 1, 
	0, 0, 0, 3940, 3942, 3, 292, 146, 0, 3941, 3943, 3, 294, 147, 0, 3942, 
	3941, 1, 0, 0, 0, 3942, 3943, 1, 0, 0, 0, 3943, 3945, 1, 0, 0, 0, 3944, 
	3946, 3, 296, 148, 0, 3945, 3944, 1, 0, 0, 0, 3945, 3946, 1, 0, 0, 0, 3946, 
	3948, 1, 0, 0, 0, 3947, 3949, 3, 298, 149, 0, 3948, 3947, 1, 0, 0, 0, 3948, 
	3949, 1, 0, 0, 0, 3949, 3951, 1, 0, 0, 0, 3950, 3952, 3, 230, 115, 0, 3951, 
	3950, 1, 0, 0, 0, 3951, 3952, 1, 0, 0, 0, 3952, 3954, 1, 0, 0, 0, 3953, 
	3955, 3, 302, 151, 0, 3954, 3953, 1, 0, 0, 0, 3954, 3955, 1, 0, 0, 0, 3955, 
	3987, 1, 0, 0, 0, 3956, 3958, 5, 152, 0, 0, 3957, 3959, 3, 254, 127, 0, 
	3958, 3957, 1, 0, 0, 0, 3958, 3959, 1, 0, 0, 0, 3959, 3963, 1, 0, 0, 0, 
	3960, 3962, 3, 280, 140, 0, 3961, 3960, 1, 0, 0, 0, 3962, 3965, 1, 0, 0, 
	0, 3963, 3961, 1, 0, 0, 0, 3963, 3964, 1, 0, 0, 0, 3964, 3966, 1, 0, 0, 
	0, 3965, 3963, 1, 0, 0, 0, 3966, 3967, 3, 282, 141, 0, 3967, 3969, 3, 292, 
	146, 0, 3968, 3970, 3, 294, 147, 0, 3969, 3968, 1, 0, 0, 0, 3969, 3970, 
	1, 0, 0, 0, 3970, 3972, 1, 0, 0, 0, 3971, 3973, 3, 296, 148, 0, 3972, 3971, 
	1, 0, 0, 0, 3972, 3973, 1, 0, 0, 0, 3973, 3975, 1, 0, 0, 0, 3974, 3976, 
	3, 298, 149, 0, 3975, 3974, 1, 0, 0, 0, 3975, 3976, 1, 0, 0, 0, 3976, 3978, 
	1, 0, 0, 0, 3977, 3979, 3, 230, 115, 0, 3978, 3977, 1, 0, 0, 0, 3978, 3979, 
	1, 0, 0, 0, 3979, 3981, 1, 0, 0, 0, 3980, 3982, 3, 302, 151, 0, 3981, 3980, 
	1, 0, 0, 0, 3981, 3982, 1, 0, 0, 0, 3982, 3984, 1, 0, 0, 0, 3983, 3985, 
	3, 286, 143, 0, 3984, 3983, 1, 0, 0, 0, 3984, 3985, 1, 0, 0, 0, 3985, 3987, 
	1, 0, 0, 0, 3986, 3926, 1, 0, 0, 0, 3986, 3956, 1, 0, 0, 0, 3987, 253, 
	1, 0, 0, 0, 3988, 3990, 5, 1, 0, 0, 3989, 3991, 3, 256, 128, 0, 3990, 3989, 
	1, 0, 0, 0, 3991, 3992, 1, 0, 0, 0, 3992, 3990, 1, 0, 0, 0, 3992, 3993, 
	1, 0, 0, 0, 3993, 3994, 1, 0, 0, 0, 3994, 3995, 5, 2, 0, 0, 3995, 255, 
	1, 0, 0, 0, 3996, 3997, 3, 258, 129, 0, 3997, 3998, 5, 1124, 0, 0, 3998, 
	4000, 3, 260, 130, 0, 3999, 4001, 5, 1136, 0, 0, 4000, 3999, 1, 0, 0, 0, 
	4000, 4001, 1, 0, 0, 0, 4001, 257, 1, 0, 0, 0, 4002, 4012, 5, 1156, 0, 
	0, 4003, 4012, 3, 716, 358, 0, 4004, 4012, 3, 718, 359, 0, 4005, 4012, 
	3, 582, 291, 0, 4006, 4012, 3, 720, 360, 0, 4007, 4012, 3, 722, 361, 0, 
	4008, 4012, 3, 724, 362, 0, 4009, 4012, 3, 726, 363, 0, 4010, 4012, 3, 
	688, 344, 0, 4011, 4002, 1, 0, 0, 0, 4011, 4003, 1, 0, 0, 0, 4011, 4004, 
	1, 0, 0, 0, 4011, 4005, 1, 0, 0, 0, 4011, 4006, 1, 0, 0, 0, 4011, 4007, 
	1, 0, 0, 0, 4011, 4008, 1, 0, 0, 0, 4011, 4009, 1, 0, 0, 0, 4011, 4010, 
	1, 0, 0, 0, 4012, 259, 1, 0, 0, 0, 4013, 4014, 3, 610, 305, 0, 4014, 261, 
	1, 0, 0, 0, 4015, 4019, 5, 152, 0, 0, 4016, 4018, 3, 280, 140, 0, 4017, 
	4016, 1, 0, 0, 0, 4018, 4021, 1, 0, 0, 0, 4019, 4017, 1, 0, 0, 0, 4019, 
	4020, 1, 0, 0, 0, 4020, 4022, 1, 0, 0, 0, 4021, 4019, 1, 0, 0, 0, 4022, 
	4023, 3, 282, 141, 0, 4023, 4025, 3, 292, 146, 0, 4024, 4026, 3, 294, 147, 
	0, 4025, 4024, 1, 0, 0, 0, 4025, 4026, 1, 0, 0, 0, 4026, 4028, 1, 0, 0, 
	0, 4027, 4029, 3, 296, 148, 0, 4028, 4027, 1, 0, 0, 0, 4028, 4029, 1, 0, 
	0, 0, 4029, 4031, 1, 0, 0, 0, 4030, 4032, 3, 298, 149, 0, 4031, 4030, 1, 
	0, 0, 0, 4031, 4032, 1, 0, 0, 0, 4032, 4034, 1, 0, 0, 0, 4033, 4035, 3, 
	230, 115, 0, 4034, 4033, 1, 0, 0, 0, 4034, 4035, 1, 0, 0, 0, 4035, 4037, 
	1, 0, 0, 0, 4036, 4038, 3, 302, 151, 0, 4037, 4036, 1, 0, 0, 0, 4037, 4038, 
	1, 0, 0, 0, 4038, 4040, 1, 0, 0, 0, 4039, 4041, 3, 266, 133, 0, 4040, 4039, 
	1, 0, 0, 0, 4040, 4041, 1, 0, 0, 0, 4041, 263, 1, 0, 0, 0, 4042, 4044, 
	5, 180, 0, 0, 4043, 4045, 7, 44, 0, 0, 4044, 4043, 1, 0, 0, 0, 4044, 4045, 
	1, 0, 0, 0, 4045, 4046, 1, 0, 0, 0, 4046, 4047, 3, 250, 125, 0, 4047, 265, 
	1, 0, 0, 0, 4048, 4050, 5, 180, 0, 0, 4049, 4051, 7, 44, 0, 0, 4050, 4049, 
	1, 0, 0, 0, 4050, 4051, 1, 0, 0, 0, 4051, 4054, 1, 0, 0, 0, 4052, 4055, 
	3, 262, 131, 0, 4053, 4055, 3, 250, 125, 0, 4054, 4052, 1, 0, 0, 0, 4054, 
	4053, 1, 0, 0, 0, 4055, 267, 1, 0, 0, 0, 4056, 4071, 5, 94, 0, 0, 4057, 
	4072, 3, 262, 131, 0, 4058, 4072, 3, 250, 125, 0, 4059, 4062, 5, 1133, 
	0, 0, 4060, 4063, 3, 262, 131, 0, 4061, 4063, 3, 250, 125, 0, 4062, 4060, 
	1, 0, 0, 0, 4062, 4061, 1, 0, 0, 0, 4063, 4064, 1, 0, 0, 0, 4064, 4069, 
	5, 1134, 0, 0, 4065, 4067, 5, 12, 0, 0, 4066, 4065, 1, 0, 0, 0, 4066, 4067, 
	1, 0, 0, 0, 4067, 4068, 1, 0, 0, 0, 4068, 4070, 3, 592, 296, 0, 4069, 4066, 
	1, 0, 0, 0, 4069, 4070, 1, 0, 0, 0, 4070, 4072, 1, 0, 0, 0, 4071, 4057, 
	1, 0, 0, 0, 4071, 4058, 1, 0, 0, 0, 4071, 4059, 1, 0, 0, 0, 4072, 269, 
	1, 0, 0, 0, 4073, 4074, 5, 278, 0, 0, 4074, 4075, 5, 1133, 0, 0, 4075, 
	4076, 5, 1148, 0, 0, 4076, 4077, 5, 1135, 0, 0, 4077, 4078, 5, 1148, 0, 
	0, 4078, 4079, 5, 365, 0, 0, 4079, 4080, 5, 1133, 0, 0, 4080, 4081, 3, 
	272, 136, 0, 4081, 4082, 5, 1134, 0, 0, 4082, 4087, 5, 1134, 0, 0, 4083, 
	4085, 5, 12, 0, 0, 4084, 4083, 1, 0, 0, 0, 4084, 4085, 1, 0, 0, 0, 4085, 
	4086, 1, 0, 0, 0, 4086, 4088, 3, 592, 296, 0, 4087, 4084, 1, 0, 0, 0, 4087, 
	4088, 1, 0, 0, 0, 4088, 271, 1, 0, 0, 0, 4089, 4094, 3, 274, 137, 0, 4090, 
	4091, 5, 1135, 0, 0, 4091, 4093, 3, 274, 137, 0, 4092, 4090, 1, 0, 0, 0, 
	4093, 4096, 1, 0, 0, 0, 4094, 4092, 1, 0, 0, 0, 4094, 4095, 1, 0, 0, 0, 
	4095, 273, 1, 0, 0, 0, 4096, 4094, 1, 0, 0, 0, 4097, 4114, 3, 564, 282, 
	0, 4098, 4099, 5, 65, 0, 0, 4099, 4115, 5, 284, 0, 0, 4100, 4112, 3, 612, 
	306, 0, 4101, 4102, 5, 285, 0, 0, 4102, 4104, 5, 1148, 0, 0, 4103, 4105, 
	3, 276, 138, 0, 4104, 4103, 1, 0, 0, 0, 4104, 4105, 1, 0, 0, 0, 4105, 4107, 
	1, 0, 0, 0, 4106, 4108, 3, 278, 139, 0, 4107, 4106, 1, 0, 0, 0, 4107, 4108, 
	1, 0, 0, 0, 4108, 4113, 1, 0, 0, 0, 4109, 4110, 5, 60, 0, 0, 4110, 4111, 
	5, 285, 0, 0, 4111, 4113, 5, 1148, 0, 0, 4112, 4101, 1, 0, 0, 0, 4112, 
	4109, 1, 0, 0, 0, 4113, 4115, 1, 0, 0, 0, 4114, 4098, 1, 0, 0, 0, 4114, 
	4100, 1, 0, 0, 0, 4115, 4127, 1, 0, 0, 0, 4116, 4118, 5, 283, 0, 0, 4117, 
	4119, 5, 285, 0, 0, 4118, 4117, 1, 0, 0, 0, 4118, 4119, 1, 0, 0, 0, 4119, 
	4120, 1, 0, 0, 0, 4120, 4121, 5, 1148, 0, 0, 4121, 4122, 5, 365, 0, 0, 
	4122, 4123, 5, 1133, 0, 0, 4123, 4124, 3, 272, 136, 0, 4124, 4125, 5, 1134, 
	0, 0, 4125, 4127, 1, 0, 0, 0, 4126, 4097, 1, 0, 0, 0, 4126, 4116, 1, 0, 
	0, 0, 4127, 275, 1, 0, 0, 0, 4128, 4133, 5, 116, 0, 0, 4129, 4133, 5, 411, 
	0, 0, 4130, 4131, 5, 42, 0, 0, 4131, 4133, 3, 642, 321, 0, 4132, 4128, 
	1, 0, 0, 0, 4132, 4129, 1, 0, 0, 0, 4132, 4130, 1, 0, 0, 0, 4133, 4134, 
	1, 0, 0, 0, 4134, 4135, 5, 118, 0, 0, 4135, 4136, 5, 55, 0, 0, 4136, 277, 
	1, 0, 0, 0, 4137, 4142, 5, 116, 0, 0, 4138, 4142, 5, 411, 0, 0, 4139, 4140, 
	5, 42, 0, 0, 4140, 4142, 3, 642, 321, 0, 4141, 4137, 1, 0, 0, 0, 4141, 
	4138, 1, 0, 0, 0, 4141, 4139, 1, 0, 0, 0, 4142, 4143, 1, 0, 0, 0, 4143, 
	4144, 5, 118, 0, 0, 4144, 4145, 5, 411, 0, 0, 4145, 279, 1, 0, 0, 0, 4146, 
	4155, 7, 52, 0, 0, 4147, 4155, 5, 75, 0, 0, 4148, 4155, 5, 171, 0, 0, 4149, 
	4155, 5, 166, 0, 0, 4150, 4155, 5, 164, 0, 0, 4151, 4155, 5, 625, 0, 0, 
	4152, 4155, 7, 53, 0, 0, 4153, 4155, 5, 165, 0, 0, 4154, 4146, 1, 0, 0, 
	0, 4154, 4147, 1, 0, 0, 0, 4154, 4148, 1, 0, 0, 0, 4154, 4149, 1, 0, 0, 
	0, 4154, 4150, 1, 0, 0, 0, 4154, 4151, 1, 0, 0, 0, 4154, 4152, 1, 0, 0, 
	0, 4154, 4153, 1, 0, 0, 0, 4155, 281, 1, 0, 0, 0, 4156, 4159, 5, 1117, 
	0, 0, 4157, 4159, 3, 284, 142, 0, 4158, 4156, 1, 0, 0, 0, 4158, 4157, 1, 
	0, 0, 0, 4159, 4164, 1, 0, 0, 0, 4160, 4161, 5, 1135, 0, 0, 4161, 4163, 
	3, 284, 142, 0, 4162, 4160, 1, 0, 0, 0, 4163, 4166, 1, 0, 0, 0, 4164, 4162, 
	1, 0, 0, 0, 4164, 4165, 1, 0, 0, 0, 4165, 283, 1, 0, 0, 0, 4166, 4164, 
	1, 0, 0, 0, 4167, 4168, 3, 558, 279, 0, 4168, 4169, 5, 1132, 0, 0, 4169, 
	4170, 5, 1117, 0, 0, 4170, 4197, 1, 0, 0, 0, 4171, 4176, 3, 564, 282, 0, 
	4172, 4174, 5, 12, 0, 0, 4173, 4172, 1, 0, 0, 0, 4173, 4174, 1, 0, 0, 0, 
	4174, 4175, 1, 0, 0, 0, 4175, 4177, 3, 592, 296, 0, 4176, 4173, 1, 0, 0, 
	0, 4176, 4177, 1, 0, 0, 0, 4177, 4197, 1, 0, 0, 0, 4178, 4183, 3, 656, 
	328, 0, 4179, 4181, 5, 12, 0, 0, 4180, 4179, 1, 0, 0, 0, 4180, 4181, 1, 
	0, 0, 0, 4181, 4182, 1, 0, 0, 0, 4182, 4184, 3, 592, 296, 0, 4183, 4180, 
	1, 0, 0, 0, 4183, 4184, 1, 0, 0, 0, 4184, 4197, 1, 0, 0, 0, 4185, 4186, 
	5, 1159, 0, 0, 4186, 4188, 5, 1108, 0, 0, 4187, 4185, 1, 0, 0, 0, 4187, 
	4188, 1, 0, 0, 0, 4188, 4189, 1, 0, 0, 0, 4189, 4194, 3, 696, 348, 0, 4190, 
	4192, 5, 12, 0, 0, 4191, 4190, 1, 0, 0, 0, 4191, 4192, 1, 0, 0, 0, 4192, 
	4193, 1, 0, 0, 0, 4193, 4195, 3, 592, 296, 0, 4194, 4191, 1, 0, 0, 0, 4194, 
	4195, 1, 0, 0, 0, 4195, 4197, 1, 0, 0, 0, 4196, 4167, 1, 0, 0, 0, 4196, 
	4171, 1, 0, 0, 0, 4196, 4178, 1, 0, 0, 0, 4196, 4187, 1, 0, 0, 0, 4197, 
	285, 1, 0, 0, 0, 4198, 4199, 5, 87, 0, 0, 4199, 4204, 3, 210, 105, 0, 4200, 
	4201, 5, 1135, 0, 0, 4201, 4203, 3, 210, 105, 0, 4202, 4200, 1, 0, 0, 0, 
	4203, 4206, 1, 0, 0, 0, 4204, 4202, 1, 0, 0, 0, 4204, 4205, 1, 0, 0, 0, 
	4205, 4235, 1, 0, 0, 0, 4206, 4204, 1, 0, 0, 0, 4207, 4208, 5, 87, 0, 0, 
	4208, 4209, 5, 400, 0, 0, 4209, 4235, 5, 1148, 0, 0, 4210, 4211, 5, 87, 
	0, 0, 4211, 4212, 5, 127, 0, 0, 4212, 4216, 5, 1148, 0, 0, 4213, 4214, 
	5, 25, 0, 0, 4214, 4215, 5, 153, 0, 0, 4215, 4217, 3, 576, 288, 0, 4216, 
	4213, 1, 0, 0, 0, 4216, 4217, 1, 0, 0, 0, 4217, 4224, 1, 0, 0, 0, 4218, 
	4220, 7, 41, 0, 0, 4219, 4221, 3, 288, 144, 0, 4220, 4219, 1, 0, 0, 0, 
	4221, 4222, 1, 0, 0, 0, 4222, 4220, 1, 0, 0, 0, 4222, 4223, 1, 0, 0, 0, 
	4223, 4225, 1, 0, 0, 0, 4224, 4218, 1, 0, 0, 0, 4224, 4225, 1, 0, 0, 0, 
	4225, 4232, 1, 0, 0, 0, 4226, 4228, 5, 101, 0, 0, 4227, 4229, 3, 290, 145, 
	0, 4228, 4227, 1, 0, 0, 0, 4229, 4230, 1, 0, 0, 0, 4230, 4228, 1, 0, 0, 
	0, 4230, 4231, 1, 0, 0, 0, 4231, 4233, 1, 0, 0, 0, 4232, 4226, 1, 0, 0, 
	0, 4232, 4233, 1, 0, 0, 0, 4233, 4235, 1, 0, 0, 0, 4234, 4198, 1, 0, 0, 
	0, 4234, 4207, 1, 0, 0, 0, 4234, 4210, 1, 0, 0, 0, 4235, 287, 1, 0, 0, 
	0, 4236, 4237, 5, 173, 0, 0, 4237, 4238, 5, 19, 0, 0, 4238, 4249, 5, 1148, 
	0, 0, 4239, 4241, 5, 122, 0, 0, 4240, 4239, 1, 0, 0, 0, 4240, 4241, 1, 
	0, 0, 0, 4241, 4242, 1, 0, 0, 0, 4242, 4243, 5, 56, 0, 0, 4243, 4244, 5, 
	19, 0, 0, 4244, 4249, 5, 1148, 0, 0, 4245, 4246, 5, 58, 0, 0, 4246, 4247, 
	5, 19, 0, 0, 4247, 4249, 5, 1148, 0, 0, 4248, 4236, 1, 0, 0, 0, 4248, 4240, 
	1, 0, 0, 0, 4248, 4245, 1, 0, 0, 0, 4249, 289, 1, 0, 0, 0, 4250, 4251, 
	5, 169, 0, 0, 4251, 4252, 5, 19, 0, 0, 4252, 4257, 5, 1148, 0, 0, 4253, 
	4254, 5, 173, 0, 0, 4254, 4255, 5, 19, 0, 0, 4255, 4257, 5, 1148, 0, 0, 
	4256, 4250, 1, 0, 0, 0, 4256, 4253, 1, 0, 0, 0, 4257, 291, 1, 0, 0, 0, 
	4258, 4259, 5, 68, 0, 0, 4259, 4261, 3, 234, 117, 0, 4260, 4258, 1, 0, 
	0, 0, 4260, 4261, 1, 0, 0, 0, 4261, 4264, 1, 0, 0, 0, 4262, 4263, 5, 190, 
	0, 0, 4263, 4265, 3, 696, 348, 0, 4264, 4262, 1, 0, 0, 0, 4264, 4265, 1, 
	0, 0, 0, 4265, 293, 1, 0, 0, 0, 4266, 4267, 5, 73, 0, 0, 4267, 4268, 5, 
	19, 0, 0, 4268, 4273, 3, 300, 150, 0, 4269, 4270, 5, 1135, 0, 0, 4270, 
	4272, 3, 300, 150, 0, 4271, 4269, 1, 0, 0, 0, 4272, 4275, 1, 0, 0, 0, 4273, 
	4271, 1, 0, 0, 0, 4273, 4274, 1, 0, 0, 0, 4274, 4278, 1, 0, 0, 0, 4275, 
	4273, 1, 0, 0, 0, 4276, 4277, 5, 192, 0, 0, 4277, 4279, 5, 598, 0, 0, 4278, 
	4276, 1, 0, 0, 0, 4278, 4279, 1, 0, 0, 0, 4279, 295, 1, 0, 0, 0, 4280, 
	4281, 5, 74, 0, 0, 4281, 4282, 3, 696, 348, 0, 4282, 297, 1, 0, 0, 0, 4283, 
	4284, 5, 676, 0, 0, 4284, 4285, 3, 674, 337, 0, 4285, 4286, 5, 12, 0, 0, 
	4286, 4287, 5, 1133, 0, 0, 4287, 4288, 3, 672, 336, 0, 4288, 4298, 5, 1134, 
	0, 0, 4289, 4290, 5, 1135, 0, 0, 4290, 4291, 3, 674, 337, 0, 4291, 4292, 
	5, 12, 0, 0, 4292, 4293, 5, 1133, 0, 0, 4293, 4294, 3, 672, 336, 0, 4294, 
	4295, 5, 1134, 0, 0, 4295, 4297, 1, 0, 0, 0, 4296, 4289, 1, 0, 0, 0, 4297, 
	4300, 1, 0, 0, 0, 4298, 4296, 1, 0, 0, 0, 4298, 4299, 1, 0, 0, 0, 4299, 
	299, 1, 0, 0, 0, 4300, 4298, 1, 0, 0, 0, 4301, 4303, 3, 696, 348, 0, 4302, 
	4304, 7, 48, 0, 0, 4303, 4302, 1, 0, 0, 0, 4303, 4304, 1, 0, 0, 0, 4304, 
	301, 1, 0, 0, 0, 4305, 4316, 5, 99, 0, 0, 4306, 4307, 3, 304, 152, 0, 4307, 
	4308, 5, 1135, 0, 0, 4308, 4310, 1, 0, 0, 0, 4309, 4306, 1, 0, 0, 0, 4309, 
	4310, 1, 0, 0, 0, 4310, 4311, 1, 0, 0, 0, 4311, 4317, 3, 304, 152, 0, 4312, 
	4313, 3, 304, 152, 0, 4313, 4314, 5, 532, 0, 0, 4314, 4315, 3, 304, 152, 
	0, 4315, 4317, 1, 0, 0, 0, 4316, 4309, 1, 0, 0, 0, 4316, 4312, 1, 0, 0, 
	0, 4317, 303, 1, 0, 0, 0, 4318, 4322, 3, 598, 299, 0, 4319, 4322, 3, 574, 
	287, 0, 4320, 4322, 3, 594, 297, 0, 4321, 4318, 1, 0, 0, 0, 4321, 4319, 
	1, 0, 0, 0, 4321, 4320, 1, 0, 0, 0, 4322, 305, 1, 0, 0, 0, 4323, 4324, 
	5, 629, 0, 0, 4324, 4333, 5, 653, 0, 0, 4325, 4330, 3, 328, 164, 0, 4326, 
	4327, 5, 1135, 0, 0, 4327, 4329, 3, 328, 164, 0, 4328, 4326, 1, 0, 0, 0, 
	4329, 4332, 1, 0, 0, 0, 4330, 4328, 1, 0, 0, 0, 4330, 4331, 1, 0, 0, 0, 
	4331, 4334, 1, 0, 0, 0, 4332, 4330, 1, 0, 0, 0, 4333, 4325, 1, 0, 0, 0, 
	4333, 4334, 1, 0, 0, 0, 4334, 307, 1, 0, 0, 0, 4335, 4337, 5, 344, 0, 0, 
	4336, 4338, 5, 678, 0, 0, 4337, 4336, 1, 0, 0, 0, 4337, 4338, 1, 0, 0, 
	0, 4338, 4340, 1, 0, 0, 0, 4339, 4341, 3, 254, 127, 0, 4340, 4339, 1, 0, 
	0, 0, 4340, 4341, 1, 0, 0, 0, 4341, 309, 1, 0, 0, 0, 4342, 4344, 5, 369, 
	0, 0, 4343, 4345, 5, 678, 0, 0, 4344, 4343, 1, 0, 0, 0, 4344, 4345, 1, 
	0, 0, 0, 4345, 4351, 1, 0, 0, 0, 4346, 4348, 5, 10, 0, 0, 4347, 4349, 5, 
	521, 0, 0, 4348, 4347, 1, 0, 0, 0, 4348, 4349, 1, 0, 0, 0, 4349, 4350, 
	1, 0, 0, 0, 4350, 4352, 5, 353, 0, 0, 4351, 4346, 1, 0, 0, 0, 4351, 4352, 
	1, 0, 0, 0, 4352, 4357, 1, 0, 0, 0, 4353, 4355, 5, 521, 0, 0, 4354, 4353, 
	1, 0, 0, 0, 4354, 4355, 1, 0, 0, 0, 4355, 4356, 1, 0, 0, 0, 4356, 4358, 
	5, 138, 0, 0, 4357, 4354, 1, 0, 0, 0, 4357, 4358, 1, 0, 0, 0, 4358, 4360, 
	1, 0, 0, 0, 4359, 4361, 3, 254, 127, 0, 4360, 4359, 1, 0, 0, 0, 4360, 4361, 
	1, 0, 0, 0, 4361, 311, 1, 0, 0, 0, 4362, 4364, 5, 597, 0, 0, 4363, 4365, 
	5, 678, 0, 0, 4364, 4363, 1, 0, 0, 0, 4364, 4365, 1, 0, 0, 0, 4365, 4371, 
	1, 0, 0, 0, 4366, 4368, 5, 10, 0, 0, 4367, 4369, 5, 521, 0, 0, 4368, 4367, 
	1, 0, 0, 0, 4368, 4369, 1, 0, 0, 0, 4369, 4370, 1, 0, 0, 0, 4370, 4372, 
	5, 353, 0, 0, 4371, 4366, 1, 0, 0, 0, 4371, 4372, 1, 0, 0, 0, 4372, 4377, 
	1, 0, 0, 0, 4373, 4375, 5, 521, 0, 0, 4374, 4373, 1, 0, 0, 0, 4374, 4375, 
	1, 0, 0, 0, 4375, 4376, 1, 0, 0, 0, 4376, 4378, 5, 138, 0, 0, 4377, 4374, 
	1, 0, 0, 0, 4377, 4378, 1, 0, 0, 0, 4378, 4380, 1, 0, 0, 0, 4379, 4381, 
	3, 254, 127, 0, 4380, 4379, 1, 0, 0, 0, 4380, 4381, 1, 0, 0, 0, 4381, 313, 
	1, 0, 0, 0, 4382, 4383, 5, 604, 0, 0, 4383, 4384, 3, 592, 296, 0, 4384, 
	315, 1, 0, 0, 0, 4385, 4387, 5, 597, 0, 0, 4386, 4388, 5, 678, 0, 0, 4387, 
	4386, 1, 0, 0, 0, 4387, 4388, 1, 0, 0, 0, 4388, 4389, 1, 0, 0, 0, 4389, 
	4391, 5, 175, 0, 0, 4390, 4392, 5, 604, 0, 0, 4391, 4390, 1, 0, 0, 0, 4391, 
	4392, 1, 0, 0, 0, 4392, 4393, 1, 0, 0, 0, 4393, 4394, 3, 592, 296, 0, 4394, 
	317, 1, 0, 0, 0, 4395, 4396, 5, 138, 0, 0, 4396, 4397, 5, 604, 0, 0, 4397, 
	4398, 3, 592, 296, 0, 4398, 319, 1, 0, 0, 0, 4399, 4400, 5, 103, 0, 0, 
	4400, 4401, 7, 54, 0, 0, 4401, 4406, 3, 330, 165, 0, 4402, 4403, 5, 1135, 
	0, 0, 4403, 4405, 3, 330, 165, 0, 4404, 4402, 1, 0, 0, 0, 4405, 4408, 1, 
	0, 0, 0, 4406, 4404, 1, 0, 0, 0, 4406, 4407, 1, 0, 0, 0, 4407, 4410, 1, 
	0, 0, 0, 4408, 4406, 1, 0, 0, 0, 4409, 4411, 3, 654, 327, 0, 4410, 4409, 
	1, 0, 0, 0, 4410, 4411, 1, 0, 0, 0, 4411, 321, 1, 0, 0, 0, 4412, 4413, 
	5, 182, 0, 0, 4413, 4414, 5, 742, 0, 0, 4414, 323, 1, 0, 0, 0, 4415, 4416, 
	5, 153, 0, 0, 4416, 4417, 5, 340, 0, 0, 4417, 4418, 5, 1124, 0, 0, 4418, 
	4419, 7, 24, 0, 0, 4419, 325, 1, 0, 0, 0, 4420, 4422, 5, 153, 0, 0, 4421, 
	4423, 7, 55, 0, 0, 4422, 4421, 1, 0, 0, 0, 4422, 4423, 1, 0, 0, 0, 4423, 
	4424, 1, 0, 0, 0, 4424, 4425, 5, 653, 0, 0, 4425, 4430, 3, 334, 167, 0, 
	4426, 4427, 5, 1135, 0, 0, 4427, 4429, 3, 334, 167, 0, 4428, 4426, 1, 0, 
	0, 0, 4429, 4432, 1, 0, 0, 0, 4430, 4428, 1, 0, 0, 0, 4430, 4431, 1, 0, 
	0, 0, 4431, 327, 1, 0, 0, 0, 4432, 4430, 1, 0, 0, 0, 4433, 4434, 5, 192, 
	0, 0, 4434, 4435, 5, 377, 0, 0, 4435, 4441, 5, 616, 0, 0, 4436, 4437, 5, 
	134, 0, 0, 4437, 4441, 5, 193, 0, 0, 4438, 4439, 5, 134, 0, 0, 4439, 4441, 
	5, 538, 0, 0, 4440, 4433, 1, 0, 0, 0, 4440, 4436, 1, 0, 0, 0, 4440, 4438, 
	1, 0, 0, 0, 4441, 329, 1, 0, 0, 0, 4442, 4447, 3, 560, 280, 0, 4443, 4445, 
	5, 12, 0, 0, 4444, 4443, 1, 0, 0, 0, 4444, 4445, 1, 0, 0, 0, 4445, 4446, 
	1, 0, 0, 0, 4446, 4448, 3, 592, 296, 0, 4447, 4444, 1, 0, 0, 0, 4447, 4448, 
	1, 0, 0, 0, 4448, 4449, 1, 0, 0, 0, 4449, 4450, 3, 332, 166, 0, 4450, 331, 
	1, 0, 0, 0, 4451, 4453, 5, 134, 0, 0, 4452, 4454, 5, 474, 0, 0, 4453, 4452, 
	1, 0, 0, 0, 4453, 4454, 1, 0, 0, 0, 4454, 4460, 1, 0, 0, 0, 4455, 4457, 
	5, 106, 0, 0, 4456, 4455, 1, 0, 0, 0, 4456, 4457, 1, 0, 0, 0, 4457, 4458, 
	1, 0, 0, 0, 4458, 4460, 5, 193, 0, 0, 4459, 4451, 1, 0, 0, 0, 4459, 4456, 
	1, 0, 0, 0, 4460, 333, 1, 0, 0, 0, 4461, 4462, 5, 464, 0, 0, 4462, 4463, 
	5, 472, 0, 0, 4463, 4469, 3, 336, 168, 0, 4464, 4465, 5, 134, 0, 0, 4465, 
	4469, 5, 193, 0, 0, 4466, 4467, 5, 134, 0, 0, 4467, 4469, 5, 538, 0, 0, 
	4468, 4461, 1, 0, 0, 0, 4468, 4464, 1, 0, 0, 0, 4468, 4466, 1, 0, 0, 0, 
	4469, 335, 1, 0, 0, 0, 4470, 4471, 5, 799, 0, 0, 4471, 4478, 5, 134, 0, 
	0, 4472, 4473, 5, 134, 0, 0, 4473, 4478, 5, 800, 0, 0, 4474, 4475, 5, 134, 
	0, 0, 4475, 4478, 5, 801, 0, 0, 4476, 4478, 5, 802, 0, 0, 4477, 4470, 1, 
	0, 0, 0, 4477, 4472, 1, 0, 0, 0, 4477, 4474, 1, 0, 0, 0, 4477, 4476, 1, 
	0, 0, 0, 4478, 337, 1, 0, 0, 0, 4479, 4480, 5, 24, 0, 0, 4480, 4481, 5, 
	477, 0, 0, 4481, 4482, 5, 175, 0, 0, 4482, 4487, 3, 356, 178, 0, 4483, 
	4484, 5, 1135, 0, 0, 4484, 4486, 3, 356, 178, 0, 4485, 4483, 1, 0, 0, 0, 
	4486, 4489, 1, 0, 0, 0, 4487, 4485, 1, 0, 0, 0, 4487, 4488, 1, 0, 0, 0, 
	4488, 4491, 1, 0, 0, 0, 4489, 4487, 1, 0, 0, 0, 4490, 4492, 3, 364, 182, 
	0, 4491, 4490, 1, 0, 0, 0, 4491, 4492, 1, 0, 0, 0, 4492, 339, 1, 0, 0, 
	0, 4493, 4494, 5, 24, 0, 0, 4494, 4495, 5, 588, 0, 0, 4495, 4496, 5, 429, 
	0, 0, 4496, 4501, 3, 366, 183, 0, 4497, 4498, 5, 1135, 0, 0, 4498, 4500, 
	3, 366, 183, 0, 4499, 4497, 1, 0, 0, 0, 4500, 4503, 1, 0, 0, 0, 4501, 4499, 
	1, 0, 0, 0, 4501, 4502, 1, 0, 0, 0, 4502, 341, 1, 0, 0, 0, 4503, 4501, 
	1, 0, 0, 0, 4504, 4505, 5, 132, 0, 0, 4505, 4506, 7, 56, 0, 0, 4506, 4511, 
	5, 476, 0, 0, 4507, 4508, 5, 175, 0, 0, 4508, 4512, 5, 1148, 0, 0, 4509, 
	4510, 5, 15, 0, 0, 4510, 4512, 5, 1148, 0, 0, 4511, 4507, 1, 0, 0, 0, 4511, 
	4509, 1, 0, 0, 0, 4512, 343, 1, 0, 0, 0, 4513, 4514, 5, 589, 0, 0, 4514, 
	4515, 5, 477, 0, 0, 4515, 345, 1, 0, 0, 0, 4516, 4517, 5, 589, 0, 0, 4517, 
	4519, 5, 614, 0, 0, 4518, 4520, 5, 6, 0, 0, 4519, 4518, 1, 0, 0, 0, 4519, 
	4520, 1, 0, 0, 0, 4520, 4522, 1, 0, 0, 0, 4521, 4523, 3, 364, 182, 0, 4522, 
	4521, 1, 0, 0, 0, 4522, 4523, 1, 0, 0, 0, 4523, 347, 1, 0, 0, 0, 4524, 
	4525, 5, 629, 0, 0, 4525, 4534, 5, 614, 0, 0, 4526, 4531, 3, 370, 185, 
	0, 4527, 4528, 5, 1135, 0, 0, 4528, 4530, 3, 370, 185, 0, 4529, 4527, 1, 
	0, 0, 0, 4530, 4533, 1, 0, 0, 0, 4531, 4529, 1, 0, 0, 0, 4531, 4532, 1, 
	0, 0, 0, 4532, 4535, 1, 0, 0, 0, 4533, 4531, 1, 0, 0, 0, 4534, 4526, 1, 
	0, 0, 0, 4534, 4535, 1, 0, 0, 0, 4535, 4538, 1, 0, 0, 0, 4536, 4537, 5, 
	663, 0, 0, 4537, 4539, 3, 372, 186, 0, 4538, 4536, 1, 0, 0, 0, 4538, 4539, 
	1, 0, 0, 0, 4539, 4543, 1, 0, 0, 0, 4540, 4542, 3, 374, 187, 0, 4541, 4540, 
	1, 0, 0, 0, 4542, 4545, 1, 0, 0, 0, 4543, 4541, 1, 0, 0, 0, 4543, 4544, 
	1, 0, 0, 0, 4544, 4547, 1, 0, 0, 0, 4545, 4543, 1, 0, 0, 0, 4546, 4548, 
	3, 364, 182, 0, 4547, 4546, 1, 0, 0, 0, 4547, 4548, 1, 0, 0, 0, 4548, 349, 
	1, 0, 0, 0, 4549, 4550, 5, 635, 0, 0, 4550, 4559, 5, 614, 0, 0, 4551, 4556, 
	3, 370, 185, 0, 4552, 4553, 5, 1135, 0, 0, 4553, 4555, 3, 370, 185, 0, 
	4554, 4552, 1, 0, 0, 0, 4555, 4558, 1, 0, 0, 0, 4556, 4554, 1, 0, 0, 0, 
	4556, 4557, 1, 0, 0, 0, 4557, 4560, 1, 0, 0, 0, 4558, 4556, 1, 0, 0, 0, 
	4559, 4551, 1, 0, 0, 0, 4559, 4560, 1, 0, 0, 0, 4560, 351, 1, 0, 0, 0, 
	4561, 4562, 5, 629, 0, 0, 4562, 4563, 5, 441, 0, 0, 4563, 353, 1, 0, 0, 
	0, 4564, 4565, 5, 635, 0, 0, 4565, 4566, 5, 441, 0, 0, 4566, 355, 1, 0, 
	0, 0, 4567, 4568, 3, 358, 179, 0, 4568, 4569, 5, 1124, 0, 0, 4569, 4570, 
	5, 1148, 0, 0, 4570, 4597, 1, 0, 0, 0, 4571, 4572, 3, 360, 180, 0, 4572, 
	4573, 5, 1124, 0, 0, 4573, 4574, 3, 598, 299, 0, 4574, 4597, 1, 0, 0, 0, 
	4575, 4576, 3, 362, 181, 0, 4576, 4577, 5, 1124, 0, 0, 4577, 4578, 7, 24, 
	0, 0, 4578, 4597, 1, 0, 0, 0, 4579, 4580, 5, 481, 0, 0, 4580, 4581, 5, 
	1124, 0, 0, 4581, 4597, 5, 1151, 0, 0, 4582, 4583, 5, 449, 0, 0, 4583, 
	4584, 5, 1124, 0, 0, 4584, 4593, 5, 1133, 0, 0, 4585, 4590, 3, 592, 296, 
	0, 4586, 4587, 5, 1135, 0, 0, 4587, 4589, 3, 592, 296, 0, 4588, 4586, 1, 
	0, 0, 0, 4589, 4592, 1, 0, 0, 0, 4590, 4588, 1, 0, 0, 0, 4590, 4591, 1, 
	0, 0, 0, 4591, 4594, 1, 0, 0, 0, 4592, 4590, 1, 0, 0, 0, 4593, 4585, 1, 
	0, 0, 0, 4593, 4594, 1, 0, 0, 0, 4594, 4595, 1, 0, 0, 0, 4595, 4597, 5, 
	1134, 0, 0, 4596, 4567, 1, 0, 0, 0, 4596, 4571, 1, 0, 0, 0, 4596, 4575, 
	1, 0, 0, 0, 4596, 4579, 1, 0, 0, 0, 4596, 4582, 1, 0, 0, 0, 4597, 357, 
	1, 0, 0, 0, 4598, 4599, 7, 57, 0, 0, 4599, 359, 1, 0, 0, 0, 4600, 4601, 
	7, 58, 0, 0, 4601, 361, 1, 0, 0, 0, 4602, 4603, 7, 59, 0, 0, 4603, 363, 
	1, 0, 0, 0, 4604, 4605, 5, 65, 0, 0, 4605, 4606, 5, 355, 0, 0, 4606, 4607, 
	5, 1148, 0, 0, 4607, 365, 1, 0, 0, 0, 4608, 4609, 5, 581, 0, 0, 4609, 4610, 
	5, 1124, 0, 0, 4610, 4611, 5, 1133, 0, 0, 4611, 4612, 3, 624, 312, 0, 4612, 
	4613, 5, 1134, 0, 0, 4613, 4658, 1, 0, 0, 0, 4614, 4615, 5, 583, 0, 0, 
	4615, 4616, 5, 1124, 0, 0, 4616, 4617, 5, 1133, 0, 0, 4617, 4618, 3, 624, 
	312, 0, 4618, 4619, 5, 1134, 0, 0, 4619, 4658, 1, 0, 0, 0, 4620, 4621, 
	5, 582, 0, 0, 4621, 4622, 5, 1124, 0, 0, 4622, 4623, 5, 1133, 0, 0, 4623, 
	4624, 3, 628, 314, 0, 4624, 4625, 5, 1134, 0, 0, 4625, 4658, 1, 0, 0, 0, 
	4626, 4627, 5, 584, 0, 0, 4627, 4628, 5, 1124, 0, 0, 4628, 4629, 5, 1133, 
	0, 0, 4629, 4630, 3, 628, 314, 0, 4630, 4631, 5, 1134, 0, 0, 4631, 4658, 
	1, 0, 0, 0, 4632, 4633, 5, 586, 0, 0, 4633, 4634, 5, 1124, 0, 0, 4634, 
	4635, 5, 1133, 0, 0, 4635, 4636, 3, 638, 319, 0, 4636, 4637, 5, 1134, 0, 
	0, 4637, 4658, 1, 0, 0, 0, 4638, 4639, 5, 587, 0, 0, 4639, 4640, 5, 1124, 
	0, 0, 4640, 4641, 5, 1133, 0, 0, 4641, 4642, 3, 638, 319, 0, 4642, 4643, 
	5, 1134, 0, 0, 4643, 4658, 1, 0, 0, 0, 4644, 4645, 5, 585, 0, 0, 4645, 
	4646, 5, 1124, 0, 0, 4646, 4647, 5, 1133, 0, 0, 4647, 4652, 3, 368, 184, 
	0, 4648, 4649, 5, 1135, 0, 0, 4649, 4651, 3, 368, 184, 0, 4650, 4648, 1, 
	0, 0, 0, 4651, 4654, 1, 0, 0, 0, 4652, 4650, 1, 0, 0, 0, 4652, 4653, 1, 
	0, 0, 0, 4653, 4655, 1, 0, 0, 0, 4654, 4652, 1, 0, 0, 0, 4655, 4656, 5, 
	1134, 0, 0, 4656, 4658, 1, 0, 0, 0, 4657, 4608, 1, 0, 0, 0, 4657, 4614, 
	1, 0, 0, 0, 4657, 4620, 1, 0, 0, 0, 4657, 4626, 1, 0, 0, 0, 4657, 4632, 
	1, 0, 0, 0, 4657, 4638, 1, 0, 0, 0, 4657, 4644, 1, 0, 0, 0, 4658, 367, 
	1, 0, 0, 0, 4659, 4660, 5, 1133, 0, 0, 4660, 4661, 3, 560, 280, 0, 4661, 
	4662, 5, 1135, 0, 0, 4662, 4663, 3, 560, 280, 0, 4663, 4664, 5, 1134, 0, 
	0, 4664, 369, 1, 0, 0, 0, 4665, 4666, 7, 60, 0, 0, 4666, 371, 1, 0, 0, 
	0, 4667, 4668, 7, 61, 0, 0, 4668, 4669, 5, 1124, 0, 0, 4669, 4686, 3, 376, 
	188, 0, 4670, 4671, 5, 483, 0, 0, 4671, 4672, 5, 1124, 0, 0, 4672, 4673, 
	5, 1148, 0, 0, 4673, 4674, 5, 1135, 0, 0, 4674, 4675, 5, 484, 0, 0, 4675, 
	4676, 5, 1124, 0, 0, 4676, 4686, 3, 598, 299, 0, 4677, 4678, 5, 575, 0, 
	0, 4678, 4679, 5, 1124, 0, 0, 4679, 4680, 5, 1148, 0, 0, 4680, 4681, 5, 
	1135, 0, 0, 4681, 4682, 5, 576, 0, 0, 4682, 4683, 5, 1124, 0, 0, 4683, 
	4686, 3, 598, 299, 0, 4684, 4686, 5, 623, 0, 0, 4685, 4667, 1, 0, 0, 0, 
	4685, 4670, 1, 0, 0, 0, 4685, 4677, 1, 0, 0, 0, 4685, 4684, 1, 0, 0, 0, 
	4686, 373, 1, 0, 0, 0, 4687, 4688, 5, 665, 0, 0, 4688, 4689, 5, 1124, 0, 
	0, 4689, 4700, 5, 1148, 0, 0, 4690, 4691, 5, 551, 0, 0, 4691, 4692, 5, 
	1124, 0, 0, 4692, 4700, 5, 1148, 0, 0, 4693, 4694, 5, 391, 0, 0, 4694, 
	4695, 5, 1124, 0, 0, 4695, 4700, 5, 1148, 0, 0, 4696, 4697, 5, 555, 0, 
	0, 4697, 4698, 5, 1124, 0, 0, 4698, 4700, 5, 1148, 0, 0, 4699, 4687, 1, 
	0, 0, 0, 4699, 4690, 1, 0, 0, 0, 4699, 4693, 1, 0, 0, 0, 4699, 4696, 1, 
	0, 0, 0, 4700, 375, 1, 0, 0, 0, 4701, 4706, 3, 584, 292, 0, 4702, 4703, 
	5, 1135, 0, 0, 4703, 4705, 3, 584, 292, 0, 4704, 4702, 1, 0, 0, 0, 4705, 
	4708, 1, 0, 0, 0, 4706, 4704, 1, 0, 0, 0, 4706, 4707, 1, 0, 0, 0, 4707, 
	4711, 1, 0, 0, 0, 4708, 4706, 1, 0, 0, 0, 4709, 4711, 5, 1148, 0, 0, 4710, 
	4701, 1, 0, 0, 0, 4710, 4709, 1, 0, 0, 0, 4711, 377, 1, 0, 0, 0, 4712, 
	4713, 5, 681, 0, 0, 4713, 4714, 7, 62, 0, 0, 4714, 4716, 3, 586, 293, 0, 
	4715, 4717, 7, 63, 0, 0, 4716, 4715, 1, 0, 0, 0, 4716, 4717, 1, 0, 0, 0, 
	4717, 379, 1, 0, 0, 0, 4718, 4719, 5, 681, 0, 0, 4719, 4720, 5, 407, 0, 
	0, 4720, 4726, 3, 586, 293, 0, 4721, 4724, 5, 643, 0, 0, 4722, 4723, 5, 
	65, 0, 0, 4723, 4725, 5, 509, 0, 0, 4724, 4722, 1, 0, 0, 0, 4724, 4725, 
	1, 0, 0, 0, 4725, 4727, 1, 0, 0, 0, 4726, 4721, 1, 0, 0, 0, 4726, 4727, 
	1, 0, 0, 0, 4727, 381, 1, 0, 0, 0, 4728, 4729, 5, 681, 0, 0, 4729, 4730, 
	5, 560, 0, 0, 4730, 4731, 3, 586, 293, 0, 4731, 383, 1, 0, 0, 0, 4732, 
	4733, 5, 681, 0, 0, 4733, 4734, 5, 369, 0, 0, 4734, 4737, 3, 586, 293, 
	0, 4735, 4736, 5, 536, 0, 0, 4736, 4738, 5, 553, 0, 0, 4737, 4735, 1, 0, 
	0, 0, 4737, 4738, 1, 0, 0, 0, 4738, 385, 1, 0, 0, 0, 4739, 4740, 5, 681, 
	0, 0, 4740, 4741, 5, 597, 0, 0, 4741, 4742, 3, 586, 293, 0, 4742, 387, 
	1, 0, 0, 0, 4743, 4744, 5, 681, 0, 0, 4744, 4747, 5, 570, 0, 0, 4745, 4746, 
	5, 32, 0, 0, 4746, 4748, 3, 586, 293, 0, 4747, 4745, 1, 0, 0, 0, 4747, 
	4748, 1, 0, 0, 0, 4748, 389, 1, 0, 0, 0, 4749, 4750, 5, 560, 0, 0, 4750, 
	4751, 3, 592, 296, 0, 4751, 4754, 5, 68, 0, 0, 4752, 4755, 5, 1148, 0, 
	0, 4753, 4755, 5, 1159, 0, 0, 4754, 4752, 1, 0, 0, 0, 4754, 4753, 1, 0, 
	0, 0, 4755, 391, 1, 0, 0, 0, 4756, 4757, 5, 708, 0, 0, 4757, 4760, 3, 592, 
	296, 0, 4758, 4759, 5, 187, 0, 0, 4759, 4761, 3, 640, 320, 0, 4760, 4758, 
	1, 0, 0, 0, 4760, 4761, 1, 0, 0, 0, 4761, 393, 1, 0, 0, 0, 4762, 4763, 
	7, 64, 0, 0, 4763, 4764, 5, 560, 0, 0, 4764, 4765, 3, 592, 296, 0, 4765, 
	395, 1, 0, 0, 0, 4766, 4769, 3, 398, 199, 0, 4767, 4769, 3, 4, 2, 0, 4768, 
	4766, 1, 0, 0, 0, 4768, 4767, 1, 0, 0, 0, 4769, 397, 1, 0, 0, 0, 4770, 
	4771, 3, 592, 296, 0, 4771, 4772, 5, 1144, 0, 0, 4772, 4774, 1, 0, 0, 0, 
	4773, 4770, 1, 0, 0, 0, 4773, 4774, 1, 0, 0, 0, 4774, 4775, 1, 0, 0, 0, 
	4775, 4781, 5, 344, 0, 0, 4776, 4777, 3, 418, 209, 0, 4777, 4778, 5, 1136, 
	0, 0, 4778, 4780, 1, 0, 0, 0, 4779, 4776, 1, 0, 0, 0, 4780, 4783, 1, 0, 
	0, 0, 4781, 4779, 1, 0, 0, 0, 4781, 4782, 1, 0, 0, 0, 4782, 4789, 1, 0, 
	0, 0, 4783, 4781, 1, 0, 0, 0, 4784, 4785, 3, 420, 210, 0, 4785, 4786, 5, 
	1136, 0, 0, 4786, 4788, 1, 0, 0, 0, 4787, 4784, 1, 0, 0, 0, 4788, 4791, 
	1, 0, 0, 0, 4789, 4787, 1, 0, 0, 0, 4789, 4790, 1, 0, 0, 0, 4790, 4797, 
	1, 0, 0, 0, 4791, 4789, 1, 0, 0, 0, 4792, 4793, 3, 422, 211, 0, 4793, 4794, 
	5, 1136, 0, 0, 4794, 4796, 1, 0, 0, 0, 4795, 4792, 1, 0, 0, 0, 4796, 4799, 
	1, 0, 0, 0, 4797, 4795, 1, 0, 0, 0, 4797, 4798, 1, 0, 0, 0, 4798, 4805, 
	1, 0, 0, 0, 4799, 4797, 1, 0, 0, 0, 4800, 4801, 3, 424, 212, 0, 4801, 4802, 
	5, 1136, 0, 0, 4802, 4804, 1, 0, 0, 0, 4803, 4800, 1, 0, 0, 0, 4804, 4807, 
	1, 0, 0, 0, 4805, 4803, 1, 0, 0, 0, 4805, 4806, 1, 0, 0, 0, 4806, 4811, 
	1, 0, 0, 0, 4807, 4805, 1, 0, 0, 0, 4808, 4810, 3, 428, 214, 0, 4809, 4808, 
	1, 0, 0, 0, 4810, 4813, 1, 0, 0, 0, 4811, 4809, 1, 0, 0, 0, 4811, 4812, 
	1, 0, 0, 0, 4812, 4814, 1, 0, 0, 0, 4813, 4811, 1, 0, 0, 0, 4814, 4816, 
	5, 407, 0, 0, 4815, 4817, 3, 592, 296, 0, 4816, 4815, 1, 0, 0, 0, 4816, 
	4817, 1, 0, 0, 0, 4817, 399, 1, 0, 0, 0, 4818, 4821, 5, 22, 0, 0, 4819, 
	4822, 3, 592, 296, 0, 4820, 4822, 3, 696, 348, 0, 4821, 4819, 1, 0, 0, 
	0, 4821, 4820, 1, 0, 0, 0, 4821, 4822, 1, 0, 0, 0, 4822, 4824, 1, 0, 0, 
	0, 4823, 4825, 3, 430, 215, 0, 4824, 4823, 1, 0, 0, 0, 4825, 4826, 1, 0, 
	0, 0, 4826, 4824, 1, 0, 0, 0, 4826, 4827, 1, 0, 0, 0, 4827, 4834, 1, 0, 
	0, 0, 4828, 4830, 5, 53, 0, 0, 4829, 4831, 3, 428, 214, 0, 4830, 4829, 
	1, 0, 0, 0, 4831, 4832, 1, 0, 0, 0, 4832, 4830, 1, 0, 0, 0, 4832, 4833, 
	1, 0, 0, 0, 4833, 4835, 1, 0, 0, 0, 4834, 4828, 1, 0, 0, 0, 4834, 4835, 
	1, 0, 0, 0, 4835, 4836, 1, 0, 0, 0, 4836, 4837, 5, 407, 0, 0, 4837, 4838, 
	5, 22, 0, 0, 4838, 401, 1, 0, 0, 0, 4839, 4840, 5, 77, 0, 0, 4840, 4841, 
	3, 696, 348, 0, 4841, 4843, 5, 174, 0, 0, 4842, 4844, 3, 428, 214, 0, 4843, 
	4842, 1, 0, 0, 0, 4844, 4845, 1, 0, 0, 0, 4845, 4843, 1, 0, 0, 0, 4845, 
	4846, 1, 0, 0, 0, 4846, 4850, 1, 0, 0, 0, 4847, 4849, 3, 432, 216, 0, 4848, 
	4847, 1, 0, 0, 0, 4849, 4852, 1, 0, 0, 0, 4850, 4848, 1, 0, 0, 0, 4850, 
	4851, 1, 0, 0, 0, 4851, 4859, 1, 0, 0, 0, 4852, 4850, 1, 0, 0, 0, 4853, 
	4855, 5, 53, 0, 0, 4854, 4856, 3, 428, 214, 0, 4855, 4854, 1, 0, 0, 0, 
	4856, 4857, 1, 0, 0, 0, 4857, 4855, 1, 0, 0, 0, 4857, 4858, 1, 0, 0, 0, 
	4858, 4860, 1, 0, 0, 0, 4859, 4853, 1, 0, 0, 0, 4859, 4860, 1, 0, 0, 0, 
	4860, 4861, 1, 0, 0, 0, 4861, 4862, 5, 407, 0, 0, 4862, 4863, 5, 77, 0, 
	0, 4863, 403, 1, 0, 0, 0, 4864, 4865, 5, 89, 0, 0, 4865, 4866, 3, 592, 
	296, 0, 4866, 405, 1, 0, 0, 0, 4867, 4868, 5, 96, 0, 0, 4868, 4869, 3, 
	592, 296, 0, 4869, 407, 1, 0, 0, 0, 4870, 4871, 3, 592, 296, 0, 4871, 4872, 
	5, 1144, 0, 0, 4872, 4874, 1, 0, 0, 0, 4873, 4870, 1, 0, 0, 0, 4873, 4874, 
	1, 0, 0, 0, 4874, 4875, 1, 0, 0, 0, 4875, 4877, 5, 105, 0, 0, 4876, 4878, 
	3, 428, 214, 0, 4877, 4876, 1, 0, 0, 0, 4878, 4879, 1, 0, 0, 0, 4879, 4877, 
	1, 0, 0, 0, 4879, 4880, 1, 0, 0, 0, 4880, 4881, 1, 0, 0, 0, 4881, 4882, 
	5, 407, 0, 0, 4882, 4884, 5, 105, 0, 0, 4883, 4885, 3, 592, 296, 0, 4884, 
	4883, 1, 0, 0, 0, 4884, 4885, 1, 0, 0, 0, 4885, 409, 1, 0, 0, 0, 4886, 
	4887, 3, 592, 296, 0, 4887, 4888, 5, 1144, 0, 0, 4888, 4890, 1, 0, 0, 0, 
	4889, 4886, 1, 0, 0, 0, 4889, 4890, 1, 0, 0, 0, 4890, 4891, 1, 0, 0, 0, 
	4891, 4893, 5, 140, 0, 0, 4892, 4894, 3, 428, 214, 0, 4893, 4892, 1, 0, 
	0, 0, 4894, 4895, 1, 0, 0, 0, 4895, 4893, 1, 0, 0, 0, 4895, 4896, 1, 0, 
	0, 0, 4896, 4897, 1, 0, 0, 0, 4897, 4898, 5, 663, 0, 0, 4898, 4899, 3, 
	696, 348, 0, 4899, 4900, 5, 407, 0, 0, 4900, 4902, 5, 140, 0, 0, 4901, 
	4903, 3, 592, 296, 0, 4902, 4901, 1, 0, 0, 0, 4902, 4903, 1, 0, 0, 0, 4903, 
	411, 1, 0, 0, 0, 4904, 4905, 5, 146, 0, 0, 4905, 4906, 3, 696, 348, 0, 
	4906, 413, 1, 0, 0, 0, 4907, 4908, 3, 592, 296, 0, 4908, 4909, 5, 1144, 
	0, 0, 4909, 4911, 1, 0, 0, 0, 4910, 4907, 1, 0, 0, 0, 4910, 4911, 1, 0, 
	0, 0, 4911, 4912, 1, 0, 0, 0, 4912, 4913, 5, 191, 0, 0, 4913, 4914, 3, 
	696, 348, 0, 4914, 4916, 5, 399, 0, 0, 4915, 4917, 3, 428, 214, 0, 4916, 
	4915, 1, 0, 0, 0, 4917, 4918, 1, 0, 0, 0, 4918, 4916, 1, 0, 0, 0, 4918, 
	4919, 1, 0, 0, 0, 4919, 4920, 1, 0, 0, 0, 4920, 4921, 5, 407, 0, 0, 4921, 
	4923, 5, 191, 0, 0, 4922, 4924, 3, 592, 296, 0, 4923, 4922, 1, 0, 0, 0, 
	4923, 4924, 1, 0, 0, 0, 4924, 415, 1, 0, 0, 0, 4925, 4926, 5, 361, 0, 0, 
	4926, 4941, 3, 592, 296, 0, 4927, 4932, 5, 64, 0, 0, 4928, 4930, 5, 520, 
	0, 0, 4929, 4928, 1, 0, 0, 0, 4929, 4930, 1, 0, 0, 0, 4930, 4931, 1, 0, 
	0, 0, 4931, 4933, 5, 68, 0, 0, 4932, 4929, 1, 0, 0, 0, 4932, 4933, 1, 0, 
	0, 0, 4933, 4934, 1, 0, 0, 0, 4934, 4935, 3, 592, 296, 0, 4935, 4936, 5, 
	87, 0, 0, 4936, 4937, 3, 624, 312, 0, 4937, 4941, 1, 0, 0, 0, 4938, 4939, 
	5, 539, 0, 0, 4939, 4941, 3, 592, 296, 0, 4940, 4925, 1, 0, 0, 0, 4940, 
	4927, 1, 0, 0, 0, 4940, 4938, 1, 0, 0, 0, 4941, 417, 1, 0, 0, 0, 4942, 
	4943, 5, 41, 0, 0, 4943, 4944, 3, 624, 312, 0, 4944, 4947, 3, 612, 306, 
	0, 4945, 4946, 5, 42, 0, 0, 4946, 4948, 3, 696, 348, 0, 4947, 4945, 1, 
	0, 0, 0, 4947, 4948, 1, 0, 0, 0, 4948, 419, 1, 0, 0, 0, 4949, 4950, 5, 
	41, 0, 0, 4950, 4951, 3, 592, 296, 0, 4951, 4952, 5, 29, 0, 0, 4952, 4959, 
	5, 65, 0, 0, 4953, 4960, 3, 598, 299, 0, 4954, 4956, 5, 162, 0, 0, 4955, 
	4957, 5, 669, 0, 0, 4956, 4955, 1, 0, 0, 0, 4956, 4957, 1, 0, 0, 0, 4957, 
	4958, 1, 0, 0, 0, 4958, 4960, 5, 1148, 0, 0, 4959, 4953, 1, 0, 0, 0, 4959, 
	4954, 1, 0, 0, 0, 4960, 421, 1, 0, 0, 0, 4961, 4962, 5, 41, 0, 0, 4962, 
	4963, 3, 592, 296, 0, 4963, 4964, 5, 38, 0, 0, 4964, 4965, 5, 65, 0, 0, 
	4965, 4966, 3, 200, 100, 0, 4966, 423, 1, 0, 0, 0, 4967, 4968, 5, 41, 0, 
	0, 4968, 4969, 7, 65, 0, 0, 4969, 4970, 5, 442, 0, 0, 4970, 4971, 5, 65, 
	0, 0, 4971, 4976, 3, 426, 213, 0, 4972, 4973, 5, 1135, 0, 0, 4973, 4975, 
	3, 426, 213, 0, 4974, 4972, 1, 0, 0, 0, 4975, 4978, 1, 0, 0, 0, 4976, 4974, 
	1, 0, 0, 0, 4976, 4977, 1, 0, 0, 0, 4977, 4979, 1, 0, 0, 0, 4978, 4976, 
	1, 0, 0, 0, 4979, 4980, 3, 396, 198, 0, 4980, 425, 1, 0, 0, 0, 4981, 4993, 
	3, 598, 299, 0, 4982, 4984, 5, 162, 0, 0, 4983, 4985, 5, 669, 0, 0, 4984, 
	4983, 1, 0, 0, 0, 4984, 4985, 1, 0, 0, 0, 4985, 4986, 1, 0, 0, 0, 4986, 
	4993, 5, 1148, 0, 0, 4987, 4993, 3, 592, 296, 0, 4988, 4993, 5, 163, 0, 
	0, 4989, 4990, 5, 114, 0, 0, 4990, 4993, 5, 435, 0, 0, 4991, 4993, 5, 161, 
	0, 0, 4992, 4981, 1, 0, 0, 0, 4992, 4982, 1, 0, 0, 0, 4992, 4987, 1, 0, 
	0, 0, 4992, 4988, 1, 0, 0, 0, 4992, 4989, 1, 0, 0, 0, 4992, 4991, 1, 0, 
	0, 0, 4993, 427, 1, 0, 0, 0, 4994, 4997, 3, 18, 9, 0, 4995, 4997, 3, 4, 
	2, 0, 4996, 4994, 1, 0, 0, 0, 4996, 4995, 1, 0, 0, 0, 4997, 4998, 1, 0, 
	0, 0, 4998, 4999, 5, 1136, 0, 0, 4999, 429, 1, 0, 0, 0, 5000, 5003, 5, 
	189, 0, 0, 5001, 5004, 3, 610, 305, 0, 5002, 5004, 3, 696, 348, 0, 5003, 
	5001, 1, 0, 0, 0, 5003, 5002, 1, 0, 0, 0, 5004, 5005, 1, 0, 0, 0, 5005, 
	5007, 5, 174, 0, 0, 5006, 5008, 3, 428, 214, 0, 5007, 5006, 1, 0, 0, 0, 
	5008, 5009, 1, 0, 0, 0, 5009, 5007, 1, 0, 0, 0, 5009, 5010, 1, 0, 0, 0, 
	5010, 431, 1, 0, 0, 0, 5011, 5012, 5, 54, 0, 0, 5012, 5013, 3, 696, 348, 
	0, 5013, 5015, 5, 174, 0, 0, 5014, 5016, 3, 428, 214, 0, 5015, 5014, 1, 
	0, 0, 0, 5016, 5017, 1, 0, 0, 0, 5017, 5015, 1, 0, 0, 0, 5017, 5018, 1, 
	0, 0, 0, 5018, 433, 1, 0, 0, 0, 5019, 5020, 5, 7, 0, 0, 5020, 5021, 5, 
	665, 0, 0, 5021, 5026, 3, 454, 227, 0, 5022, 5023, 5, 1135, 0, 0, 5023, 
	5025, 3, 454, 227, 0, 5024, 5022, 1, 0, 0, 0, 5025, 5028, 1, 0, 0, 0, 5026, 
	5024, 1, 0, 0, 0, 5026, 5027, 1, 0, 0, 0, 5027, 5093, 1, 0, 0, 0, 5028, 
	5026, 1, 0, 0, 0, 5029, 5030, 5, 7, 0, 0, 5030, 5032, 5, 665, 0, 0, 5031, 
	5033, 3, 648, 324, 0, 5032, 5031, 1, 0, 0, 0, 5032, 5033, 1, 0, 0, 0, 5033, 
	5034, 1, 0, 0, 0, 5034, 5039, 3, 456, 228, 0, 5035, 5036, 5, 1135, 0, 0, 
	5036, 5038, 3, 456, 228, 0, 5037, 5035, 1, 0, 0, 0, 5038, 5041, 1, 0, 0, 
	0, 5039, 5037, 1, 0, 0, 0, 5039, 5040, 1, 0, 0, 0, 5040, 5056, 1, 0, 0, 
	0, 5041, 5039, 1, 0, 0, 0, 5042, 5054, 5, 142, 0, 0, 5043, 5055, 5, 529, 
	0, 0, 5044, 5051, 3, 462, 231, 0, 5045, 5047, 5, 10, 0, 0, 5046, 5045, 
	1, 0, 0, 0, 5046, 5047, 1, 0, 0, 0, 5047, 5048, 1, 0, 0, 0, 5048, 5050, 
	3, 462, 231, 0, 5049, 5046, 1, 0, 0, 0, 5050, 5053, 1, 0, 0, 0, 5051, 5049, 
	1, 0, 0, 0, 5051, 5052, 1, 0, 0, 0, 5052, 5055, 1, 0, 0, 0, 5053, 5051, 
	1, 0, 0, 0, 5054, 5043, 1, 0, 0, 0, 5054, 5044, 1, 0, 0, 0, 5055, 5057, 
	1, 0, 0, 0, 5056, 5042, 1, 0, 0, 0, 5056, 5057, 1, 0, 0, 0, 5057, 5064, 
	1, 0, 0, 0, 5058, 5060, 5, 192, 0, 0, 5059, 5061, 3, 464, 232, 0, 5060, 
	5059, 1, 0, 0, 0, 5061, 5062, 1, 0, 0, 0, 5062, 5060, 1, 0, 0, 0, 5062, 
	5063, 1, 0, 0, 0, 5063, 5065, 1, 0, 0, 0, 5064, 5058, 1, 0, 0, 0, 5064, 
	5065, 1, 0, 0, 0, 5065, 5070, 1, 0, 0, 0, 5066, 5069, 3, 466, 233, 0, 5067, 
	5069, 3, 468, 234, 0, 5068, 5066, 1, 0, 0, 0, 5068, 5067, 1, 0, 0, 0, 5069, 
	5072, 1, 0, 0, 0, 5070, 5068, 1, 0, 0, 0, 5070, 5071, 1, 0, 0, 0, 5071, 
	5077, 1, 0, 0, 0, 5072, 5070, 1, 0, 0, 0, 5073, 5074, 5, 368, 0, 0, 5074, 
	5078, 5, 1148, 0, 0, 5075, 5076, 5, 14, 0, 0, 5076, 5078, 5, 1148, 0, 0, 
	5077, 5073, 1, 0, 0, 0, 5077, 5075, 1, 0, 0, 0, 5077, 5078, 1, 0, 0, 0, 
	5078, 5093, 1, 0, 0, 0, 5079, 5080, 5, 7, 0, 0, 5080, 5082, 5, 665, 0, 
	0, 5081, 5083, 3, 648, 324, 0, 5082, 5081, 1, 0, 0, 0, 5082, 5083, 1, 0, 
	0, 0, 5083, 5086, 1, 0, 0, 0, 5084, 5087, 3, 572, 286, 0, 5085, 5087, 3, 
	592, 296, 0, 5086, 5084, 1, 0, 0, 0, 5086, 5085, 1, 0, 0, 0, 5087, 5088, 
	1, 0, 0, 0, 5088, 5089, 5, 42, 0, 0, 5089, 5090, 5, 596, 0, 0, 5090, 5091, 
	3, 442, 221, 0, 5091, 5093, 1, 0, 0, 0, 5092, 5019, 1, 0, 0, 0, 5092, 5029, 
	1, 0, 0, 0, 5092, 5079, 1, 0, 0, 0, 5093, 435, 1, 0, 0, 0, 5094, 5095, 
	5, 33, 0, 0, 5095, 5096, 5, 665, 0, 0, 5096, 5101, 3, 456, 228, 0, 5097, 
	5098, 5, 1135, 0, 0, 5098, 5100, 3, 456, 228, 0, 5099, 5097, 1, 0, 0, 0, 
	5100, 5103, 1, 0, 0, 0, 5101, 5099, 1, 0, 0, 0, 5101, 5102, 1, 0, 0, 0, 
	5102, 5160, 1, 0, 0, 0, 5103, 5101, 1, 0, 0, 0, 5104, 5105, 5, 33, 0, 0, 
	5105, 5107, 5, 665, 0, 0, 5106, 5108, 3, 650, 325, 0, 5107, 5106, 1, 0, 
	0, 0, 5107, 5108, 1, 0, 0, 0, 5108, 5109, 1, 0, 0, 0, 5109, 5114, 3, 456, 
	228, 0, 5110, 5111, 5, 1135, 0, 0, 5111, 5113, 3, 456, 228, 0, 5112, 5110, 
	1, 0, 0, 0, 5113, 5116, 1, 0, 0, 0, 5114, 5112, 1, 0, 0, 0, 5114, 5115, 
	1, 0, 0, 0, 5115, 5120, 1, 0, 0, 0, 5116, 5114, 1, 0, 0, 0, 5117, 5118, 
	5, 42, 0, 0, 5118, 5119, 5, 596, 0, 0, 5119, 5121, 3, 442, 221, 0, 5120, 
	5117, 1, 0, 0, 0, 5120, 5121, 1, 0, 0, 0, 5121, 5136, 1, 0, 0, 0, 5122, 
	5134, 5, 142, 0, 0, 5123, 5135, 5, 529, 0, 0, 5124, 5131, 3, 462, 231, 
	0, 5125, 5127, 5, 10, 0, 0, 5126, 5125, 1, 0, 0, 0, 5126, 5127, 1, 0, 0, 
	0, 5127, 5128, 1, 0, 0, 0, 5128, 5130, 3, 462, 231, 0, 5129, 5126, 1, 0, 
	0, 0, 5130, 5133, 1, 0, 0, 0, 5131, 5129, 1, 0, 0, 0, 5131, 5132, 1, 0, 
	0, 0, 5132, 5135, 1, 0, 0, 0, 5133, 5131, 1, 0, 0, 0, 5134, 5123, 1, 0, 
	0, 0, 5134, 5124, 1, 0, 0, 0, 5135, 5137, 1, 0, 0, 0, 5136, 5122, 1, 0, 
	0, 0, 5136, 5137, 1, 0, 0, 0, 5137, 5144, 1, 0, 0, 0, 5138, 5140, 5, 192, 
	0, 0, 5139, 5141, 3, 464, 232, 0, 5140, 5139, 1, 0, 0, 0, 5141, 5142, 1, 
	0, 0, 0, 5142, 5140, 1, 0, 0, 0, 5142, 5143, 1, 0, 0, 0, 5143, 5145, 1, 
	0, 0, 0, 5144, 5138, 1, 0, 0, 0, 5144, 5145, 1, 0, 0, 0, 5145, 5150, 1, 
	0, 0, 0, 5146, 5149, 3, 466, 233, 0, 5147, 5149, 3, 468, 234, 0, 5148, 
	5146, 1, 0, 0, 0, 5148, 5147, 1, 0, 0, 0, 5149, 5152, 1, 0, 0, 0, 5150, 
	5148, 1, 0, 0, 0, 5150, 5151, 1, 0, 0, 0, 5151, 5157, 1, 0, 0, 0, 5152, 
	5150, 1, 0, 0, 0, 5153, 5154, 5, 368, 0, 0, 5154, 5158, 5, 1148, 0, 0, 
	5155, 5156, 5, 14, 0, 0, 5156, 5158, 5, 1148, 0, 0, 5157, 5153, 1, 0, 0, 
	0, 5157, 5155, 1, 0, 0, 0, 5157, 5158, 1, 0, 0, 0, 5158, 5160, 1, 0, 0, 
	0, 5159, 5094, 1, 0, 0, 0, 5159, 5104, 1, 0, 0, 0, 5160, 437, 1, 0, 0, 
	0, 5161, 5162, 5, 51, 0, 0, 5162, 5164, 5, 665, 0, 0, 5163, 5165, 3, 648, 
	324, 0, 5164, 5163, 1, 0, 0, 0, 5164, 5165, 1, 0, 0, 0, 5165, 5166, 1, 
	0, 0, 0, 5166, 5171, 3, 572, 286, 0, 5167, 5168, 5, 1135, 0, 0, 5168, 5170, 
	3, 572, 286, 0, 5169, 5167, 1, 0, 0, 0, 5170, 5173, 1, 0, 0, 0, 5171, 5169, 
	1, 0, 0, 0, 5171, 5172, 1, 0, 0, 0, 5172, 439, 1, 0, 0, 0, 5173, 5171, 
	1, 0, 0, 0, 5174, 5175, 5, 72, 0, 0, 5175, 5180, 3, 470, 235, 0, 5176, 
	5177, 5, 1135, 0, 0, 5177, 5179, 3, 470, 235, 0, 5178, 5176, 1, 0, 0, 0, 
	5179, 5182, 1, 0, 0, 0, 5180, 5178, 1, 0, 0, 0, 5180, 5181, 1, 0, 0, 0, 
	5181, 5183, 1, 0, 0, 0, 5182, 5180, 1, 0, 0, 0, 5183, 5185, 5, 118, 0, 
	0, 5184, 5186, 7, 66, 0, 0, 5185, 5184, 1, 0, 0, 0, 5185, 5186, 1, 0, 0, 
	0, 5186, 5187, 1, 0, 0, 0, 5187, 5188, 3, 474, 237, 0, 5188, 5189, 5, 175, 
	0, 0, 5189, 5194, 3, 456, 228, 0, 5190, 5191, 5, 1135, 0, 0, 5191, 5193, 
	3, 456, 228, 0, 5192, 5190, 1, 0, 0, 0, 5193, 5196, 1, 0, 0, 0, 5194, 5192, 
	1, 0, 0, 0, 5194, 5195, 1, 0, 0, 0, 5195, 5211, 1, 0, 0, 0, 5196, 5194, 
	1, 0, 0, 0, 5197, 5209, 5, 142, 0, 0, 5198, 5210, 5, 529, 0, 0, 5199, 5206, 
	3, 462, 231, 0, 5200, 5202, 5, 10, 0, 0, 5201, 5200, 1, 0, 0, 0, 5201, 
	5202, 1, 0, 0, 0, 5202, 5203, 1, 0, 0, 0, 5203, 5205, 3, 462, 231, 0, 5204, 
	5201, 1, 0, 0, 0, 5205, 5208, 1, 0, 0, 0, 5206, 5204, 1, 0, 0, 0, 5206, 
	5207, 1, 0, 0, 0, 5207, 5210, 1, 0, 0, 0, 5208, 5206, 1, 0, 0, 0, 5209, 
	5198, 1, 0, 0, 0, 5209, 5199, 1, 0, 0, 0, 5210, 5212, 1, 0, 0, 0, 5211, 
	5197, 1, 0, 0, 0, 5211, 5212, 1, 0, 0, 0, 5212, 5222, 1, 0, 0, 0, 5213, 
	5219, 5, 192, 0, 0, 5214, 5215, 5, 72, 0, 0, 5215, 5218, 5, 120, 0, 0, 
	5216, 5218, 3, 464, 232, 0, 5217, 5214, 1, 0, 0, 0, 5217, 5216, 1, 0, 0, 
	0, 5218, 5221, 1, 0, 0, 0, 5219, 5217, 1, 0, 0, 0, 5219, 5220, 1, 0, 0, 
	0, 5220, 5223, 1, 0, 0, 0, 5221, 5219, 1, 0, 0, 0, 5222, 5213, 1, 0, 0, 
	0, 5222, 5223, 1, 0, 0, 0, 5223, 5230, 1, 0, 0, 0, 5224, 5225, 5, 12, 0, 
	0, 5225, 5226, 3, 572, 286, 0, 5226, 5227, 5, 192, 0, 0, 5227, 5228, 5, 
	596, 0, 0, 5228, 5229, 3, 442, 221, 0, 5229, 5231, 1, 0, 0, 0, 5230, 5224, 
	1, 0, 0, 0, 5230, 5231, 1, 0, 0, 0, 5231, 5268, 1, 0, 0, 0, 5232, 5235, 
	5, 72, 0, 0, 5233, 5236, 3, 572, 286, 0, 5234, 5236, 3, 592, 296, 0, 5235, 
	5233, 1, 0, 0, 0, 5235, 5234, 1, 0, 0, 0, 5236, 5244, 1, 0, 0, 0, 5237, 
	5240, 5, 1135, 0, 0, 5238, 5241, 3, 572, 286, 0, 5239, 5241, 3, 592, 296, 
	0, 5240, 5238, 1, 0, 0, 0, 5240, 5239, 1, 0, 0, 0, 5241, 5243, 1, 0, 0, 
	0, 5242, 5237, 1, 0, 0, 0, 5243, 5246, 1, 0, 0, 0, 5244, 5242, 1, 0, 0, 
	0, 5244, 5245, 1, 0, 0, 0, 5245, 5247, 1, 0, 0, 0, 5246, 5244, 1, 0, 0, 
	0, 5247, 5250, 5, 175, 0, 0, 5248, 5251, 3, 572, 286, 0, 5249, 5251, 3, 
	592, 296, 0, 5250, 5248, 1, 0, 0, 0, 5250, 5249, 1, 0, 0, 0, 5251, 5259, 
	1, 0, 0, 0, 5252, 5255, 5, 1135, 0, 0, 5253, 5256, 3, 572, 286, 0, 5254, 
	5256, 3, 592, 296, 0, 5255, 5253, 1, 0, 0, 0, 5255, 5254, 1, 0, 0, 0, 5256, 
	5258, 1, 0, 0, 0, 5257, 5252, 1, 0, 0, 0, 5258, 5261, 1, 0, 0, 0, 5259, 
	5257, 1, 0, 0, 0, 5259, 5260, 1, 0, 0, 0, 5260, 5265, 1, 0, 0, 0, 5261, 
	5259, 1, 0, 0, 0, 5262, 5263, 5, 192, 0, 0, 5263, 5264, 5, 697, 0, 0, 5264, 
	5266, 5, 120, 0, 0, 5265, 5262, 1, 0, 0, 0, 5265, 5266, 1, 0, 0, 0, 5266, 
	5268, 1, 0, 0, 0, 5267, 5174, 1, 0, 0, 0, 5267, 5232, 1, 0, 0, 0, 5268, 
	441, 1, 0, 0, 0, 5269, 5292, 5, 42, 0, 0, 5270, 5292, 5, 529, 0, 0, 5271, 
	5281, 5, 6, 0, 0, 5272, 5273, 5, 59, 0, 0, 5273, 5278, 3, 572, 286, 0, 
	5274, 5275, 5, 1135, 0, 0, 5275, 5277, 3, 572, 286, 0, 5276, 5274, 1, 0, 
	0, 0, 5277, 5280, 1, 0, 0, 0, 5278, 5276, 1, 0, 0, 0, 5278, 5279, 1, 0, 
	0, 0, 5279, 5282, 1, 0, 0, 0, 5280, 5278, 1, 0, 0, 0, 5281, 5272, 1, 0, 
	0, 0, 5281, 5282, 1, 0, 0, 0, 5282, 5292, 1, 0, 0, 0, 5283, 5288, 3, 572, 
	286, 0, 5284, 5285, 5, 1135, 0, 0, 5285, 5287, 3, 572, 286, 0, 5286, 5284, 
	1, 0, 0, 0, 5287, 5290, 1, 0, 0, 0, 5288, 5286, 1, 0, 0, 0, 5288, 5289, 
	1, 0, 0, 0, 5289, 5292, 1, 0, 0, 0, 5290, 5288, 1, 0, 0, 0, 5291, 5269, 
	1, 0, 0, 0, 5291, 5270, 1, 0, 0, 0, 5291, 5271, 1, 0, 0, 0, 5291, 5283, 
	1, 0, 0, 0, 5292, 443, 1, 0, 0, 0, 5293, 5294, 5, 72, 0, 0, 5294, 5295, 
	5, 566, 0, 0, 5295, 5296, 5, 118, 0, 0, 5296, 5297, 3, 572, 286, 0, 5297, 
	5298, 5, 175, 0, 0, 5298, 5303, 3, 572, 286, 0, 5299, 5300, 5, 1135, 0, 
	0, 5300, 5302, 3, 572, 286, 0, 5301, 5299, 1, 0, 0, 0, 5302, 5305, 1, 0, 
	0, 0, 5303, 5301, 1, 0, 0, 0, 5303, 5304, 1, 0, 0, 0, 5304, 5309, 1, 0, 
	0, 0, 5305, 5303, 1, 0, 0, 0, 5306, 5307, 5, 192, 0, 0, 5307, 5308, 5, 
	72, 0, 0, 5308, 5310, 5, 120, 0, 0, 5309, 5306, 1, 0, 0, 0, 5309, 5310, 
	1, 0, 0, 0, 5310, 445, 1, 0, 0, 0, 5311, 5312, 5, 139, 0, 0, 5312, 5313, 
	5, 665, 0, 0, 5313, 5318, 3, 476, 238, 0, 5314, 5315, 5, 1135, 0, 0, 5315, 
	5317, 3, 476, 238, 0, 5316, 5314, 1, 0, 0, 0, 5317, 5320, 1, 0, 0, 0, 5318, 
	5316, 1, 0, 0, 0, 5318, 5319, 1, 0, 0, 0, 5319, 447, 1, 0, 0, 0, 5320, 
	5318, 1, 0, 0, 0, 5321, 5322, 5, 147, 0, 0, 5322, 5327, 3, 470, 235, 0, 
	5323, 5324, 5, 1135, 0, 0, 5324, 5326, 3, 470, 235, 0, 5325, 5323, 1, 0, 
	0, 0, 5326, 5329, 1, 0, 0, 0, 5327, 5325, 1, 0, 0, 0, 5327, 5328, 1, 0, 
	0, 0, 5328, 5330, 1, 0, 0, 0, 5329, 5327, 1, 0, 0, 0, 5330, 5332, 5, 118, 
	0, 0, 5331, 5333, 7, 66, 0, 0, 5332, 5331, 1, 0, 0, 0, 5332, 5333, 1, 0, 
	0, 0, 5333, 5334, 1, 0, 0, 0, 5334, 5335, 3, 474, 237, 0, 5335, 5336, 5, 
	68, 0, 0, 5336, 5341, 3, 572, 286, 0, 5337, 5338, 5, 1135, 0, 0, 5338, 
	5340, 3, 572, 286, 0, 5339, 5337, 1, 0, 0, 0, 5340, 5343, 1, 0, 0, 0, 5341, 
	5339, 1, 0, 0, 0, 5341, 5342, 1, 0, 0, 0, 5342, 5392, 1, 0, 0, 0, 5343, 
	5341, 1, 0, 0, 0, 5344, 5345, 5, 147, 0, 0, 5345, 5347, 5, 6, 0, 0, 5346, 
	5348, 5, 725, 0, 0, 5347, 5346, 1, 0, 0, 0, 5347, 5348, 1, 0, 0, 0, 5348, 
	5349, 1, 0, 0, 0, 5349, 5350, 5, 1135, 0, 0, 5350, 5351, 5, 72, 0, 0, 5351, 
	5352, 5, 120, 0, 0, 5352, 5353, 5, 68, 0, 0, 5353, 5358, 3, 572, 286, 0, 
	5354, 5355, 5, 1135, 0, 0, 5355, 5357, 3, 572, 286, 0, 5356, 5354, 1, 0, 
	0, 0, 5357, 5360, 1, 0, 0, 0, 5358, 5356, 1, 0, 0, 0, 5358, 5359, 1, 0, 
	0, 0, 5359, 5392, 1, 0, 0, 0, 5360, 5358, 1, 0, 0, 0, 5361, 5364, 5, 147, 
	0, 0, 5362, 5365, 3, 572, 286, 0, 5363, 5365, 3, 592, 296, 0, 5364, 5362, 
	1, 0, 0, 0, 5364, 5363, 1, 0, 0, 0, 5365, 5373, 1, 0, 0, 0, 5366, 5369, 
	5, 1135, 0, 0, 5367, 5370, 3, 572, 286, 0, 5368, 5370, 3, 592, 296, 0, 
	5369, 5367, 1, 0, 0, 0, 5369, 5368, 1, 0, 0, 0, 5370, 5372, 1, 0, 0, 0, 
	5371, 5366, 1, 0, 0, 0, 5372, 5375, 1, 0, 0, 0, 5373, 5371, 1, 0, 0, 0, 
	5373, 5374, 1, 0, 0, 0, 5374, 5376, 1, 0, 0, 0, 5375, 5373, 1, 0, 0, 0, 
	5376, 5379, 5, 68, 0, 0, 5377, 5380, 3, 572, 286, 0, 5378, 5380, 3, 592, 
	296, 0, 5379, 5377, 1, 0, 0, 0, 5379, 5378, 1, 0, 0, 0, 5380, 5388, 1, 
	0, 0, 0, 5381, 5384, 5, 1135, 0, 0, 5382, 5385, 3, 572, 286, 0, 5383, 5385, 
	3, 592, 296, 0, 5384, 5382, 1, 0, 0, 0, 5384, 5383, 1, 0, 0, 0, 5385, 5387, 
	1, 0, 0, 0, 5386, 5381, 1, 0, 0, 0, 5387, 5390, 1, 0, 0, 0, 5388, 5386, 
	1, 0, 0, 0, 5388, 5389, 1, 0, 0, 0, 5389, 5392, 1, 0, 0, 0, 5390, 5388, 
	1, 0, 0, 0, 5391, 5321, 1, 0, 0, 0, 5391, 5344, 1, 0, 0, 0, 5391, 5361, 
	1, 0, 0, 0, 5392, 449, 1, 0, 0, 0, 5393, 5394, 5, 147, 0, 0, 5394, 5395, 
	5, 566, 0, 0, 5395, 5396, 5, 118, 0, 0, 5396, 5397, 3, 572, 286, 0, 5397, 
	5398, 5, 68, 0, 0, 5398, 5403, 3, 572, 286, 0, 5399, 5400, 5, 1135, 0, 
	0, 5400, 5402, 3, 572, 286, 0, 5401, 5399, 1, 0, 0, 0, 5402, 5405, 1, 0, 
	0, 0, 5403, 5401, 1, 0, 0, 0, 5403, 5404, 1, 0, 0, 0, 5404, 451, 1, 0, 
	0, 0, 5405, 5403, 1, 0, 0, 0, 5406, 5407, 5, 153, 0, 0, 5407, 5410, 5, 
	551, 0, 0, 5408, 5409, 5, 65, 0, 0, 5409, 5411, 3, 572, 286, 0, 5410, 5408, 
	1, 0, 0, 0, 5410, 5411, 1, 0, 0, 0, 5411, 5412, 1, 0, 0, 0, 5412, 5415, 
	5, 1124, 0, 0, 5413, 5416, 3, 690, 345, 0, 5414, 5416, 5, 1148, 0, 0, 5415, 
	5413, 1, 0, 0, 0, 5415, 5414, 1, 0, 0, 0, 5416, 453, 1, 0, 0, 0, 5417, 
	5418, 3, 572, 286, 0, 5418, 5419, 3, 466, 233, 0, 5419, 455, 1, 0, 0, 0, 
	5420, 5421, 3, 572, 286, 0, 5421, 5422, 5, 448, 0, 0, 5422, 5423, 5, 19, 
	0, 0, 5423, 5424, 5, 551, 0, 0, 5424, 5425, 5, 1148, 0, 0, 5425, 5446, 
	1, 0, 0, 0, 5426, 5427, 3, 572, 286, 0, 5427, 5428, 5, 448, 0, 0, 5428, 
	5429, 5, 19, 0, 0, 5429, 5430, 5, 991, 0, 0, 5430, 5431, 5, 551, 0, 0, 
	5431, 5432, 3, 458, 229, 0, 5432, 5446, 1, 0, 0, 0, 5433, 5434, 3, 572, 
	286, 0, 5434, 5435, 5, 448, 0, 0, 5435, 5436, 5, 19, 0, 0, 5436, 5437, 
	5, 1148, 0, 0, 5437, 5438, 3, 458, 229, 0, 5438, 5446, 1, 0, 0, 0, 5439, 
	5440, 3, 572, 286, 0, 5440, 5441, 5, 448, 0, 0, 5441, 5442, 5, 192, 0, 
	0, 5442, 5443, 3, 460, 230, 0, 5443, 5446, 1, 0, 0, 0, 5444, 5446, 3, 572, 
	286, 0, 5445, 5420, 1, 0, 0, 0, 5445, 5426, 1, 0, 0, 0, 5445, 5433, 1, 
	0, 0, 0, 5445, 5439, 1, 0, 0, 0, 5445, 5444, 1, 0, 0, 0, 5446, 457, 1, 
	0, 0, 0, 5447, 5448, 5, 141, 0, 0, 5448, 5450, 5, 1148, 0, 0, 5449, 5447, 
	1, 0, 0, 0, 5449, 5450, 1, 0, 0, 0, 5450, 5454, 1, 0, 0, 0, 5451, 5452, 
	5, 145, 0, 0, 5452, 5453, 5, 35, 0, 0, 5453, 5455, 5, 551, 0, 0, 5454, 
	5451, 1, 0, 0, 0, 5454, 5455, 1, 0, 0, 0, 5455, 459, 1, 0, 0, 0, 5456, 
	5464, 3, 590, 295, 0, 5457, 5461, 7, 67, 0, 0, 5458, 5462, 5, 1148, 0, 
	0, 5459, 5460, 5, 991, 0, 0, 5460, 5462, 5, 551, 0, 0, 5461, 5458, 1, 0, 
	0, 0, 5461, 5459, 1, 0, 0, 0, 5462, 5463, 1, 0, 0, 0, 5463, 5465, 3, 458, 
	229, 0, 5464, 5457, 1, 0, 0, 0, 5464, 5465, 1, 0, 0, 0, 5465, 5471, 1, 
	0, 0, 0, 5466, 5467, 3, 590, 295, 0, 5467, 5468, 5, 187, 0, 0, 5468, 5469, 
	3, 690, 345, 0, 5469, 5471, 1, 0, 0, 0, 5470, 5456, 1, 0, 0, 0, 5470, 5466, 
	1, 0, 0, 0, 5471, 461, 1, 0, 0, 0, 5472, 5481, 5, 167, 0, 0, 5473, 5481, 
	5, 680, 0, 0, 5474, 5475, 5, 358, 0, 0, 5475, 5481, 5, 1148, 0, 0, 5476, 
	5477, 5, 465, 0, 0, 5477, 5481, 5, 1148, 0, 0, 5478, 5479, 5, 640, 0, 0, 
	5479, 5481, 5, 1148, 0, 0, 5480, 5472, 1, 0, 0, 0, 5480, 5473, 1, 0, 0, 
	0, 5480, 5474, 1, 0, 0, 0, 5480, 5476, 1, 0, 0, 0, 5480, 5478, 1, 0, 0, 
	0, 5481, 463, 1, 0, 0, 0, 5482, 5483, 5, 499, 0, 0, 5483, 5491, 3, 598, 
	299, 0, 5484, 5485, 5, 502, 0, 0, 5485, 5491, 3, 598, 299, 0, 5486, 5487, 
	5, 498, 0, 0, 5487, 5491, 3, 598, 299, 0, 5488, 5489, 5, 503, 0, 0, 5489, 
	5491, 3, 598, 299, 0, 5490, 5482, 1, 0, 0, 0, 5490, 5484, 1, 0, 0, 0, 5490, 
	5486, 1, 0, 0, 0, 5490, 5488, 1, 0, 0, 0, 5491, 465, 1, 0, 0, 0, 5492, 
	5493, 5, 551, 0, 0, 5493, 5500, 5, 420, 0, 0, 5494, 5501, 5, 42, 0, 0, 
	5495, 5501, 5, 519, 0, 0, 5496, 5497, 5, 86, 0, 0, 5497, 5498, 3, 598, 
	299, 0, 5498, 5499, 5, 691, 0, 0, 5499, 5501, 1, 0, 0, 0, 5500, 5494, 1, 
	0, 0, 0, 5500, 5495, 1, 0, 0, 0, 5500, 5496, 1, 0, 0, 0, 5500, 5501, 1, 
	0, 0, 0, 5501, 5531, 1, 0, 0, 0, 5502, 5503, 5, 551, 0, 0, 5503, 5506, 
	5, 445, 0, 0, 5504, 5507, 5, 42, 0, 0, 5505, 5507, 3, 598, 299, 0, 5506, 
	5504, 1, 0, 0, 0, 5506, 5505, 1, 0, 0, 0, 5507, 5531, 1, 0, 0, 0, 5508, 
	5509, 5, 551, 0, 0, 5509, 5510, 5, 595, 0, 0, 5510, 5515, 5, 86, 0, 0, 
	5511, 5516, 5, 42, 0, 0, 5512, 5513, 3, 598, 299, 0, 5513, 5514, 5, 691, 
	0, 0, 5514, 5516, 1, 0, 0, 0, 5515, 5511, 1, 0, 0, 0, 5515, 5512, 1, 0, 
	0, 0, 5516, 5531, 1, 0, 0, 0, 5517, 5518, 5, 551, 0, 0, 5518, 5519, 5, 
	142, 0, 0, 5519, 5521, 5, 35, 0, 0, 5520, 5522, 7, 68, 0, 0, 5521, 5520, 
	1, 0, 0, 0, 5521, 5522, 1, 0, 0, 0, 5522, 5531, 1, 0, 0, 0, 5523, 5524, 
	5, 424, 0, 0, 5524, 5531, 3, 598, 299, 0, 5525, 5528, 5, 552, 0, 0, 5526, 
	5529, 3, 598, 299, 0, 5527, 5529, 5, 657, 0, 0, 5528, 5526, 1, 0, 0, 0, 
	5528, 5527, 1, 0, 0, 0, 5529, 5531, 1, 0, 0, 0, 5530, 5492, 1, 0, 0, 0, 
	5530, 5502, 1, 0, 0, 0, 5530, 5508, 1, 0, 0, 0, 5530, 5517, 1, 0, 0, 0, 
	5530, 5523, 1, 0, 0, 0, 5530, 5525, 1, 0, 0, 0, 5531, 467, 1, 0, 0, 0, 
	5532, 5533, 5, 332, 0, 0, 5533, 5534, 7, 69, 0, 0, 5534, 469, 1, 0, 0, 
	0, 5535, 5540, 3, 472, 236, 0, 5536, 5537, 5, 1133, 0, 0, 5537, 5538, 3, 
	624, 312, 0, 5538, 5539, 5, 1134, 0, 0, 5539, 5541, 1, 0, 0, 0, 5540, 5536, 
	1, 0, 0, 0, 5540, 5541, 1, 0, 0, 0, 5541, 471, 1, 0, 0, 0, 5542, 5544, 
	5, 6, 0, 0, 5543, 5545, 5, 725, 0, 0, 5544, 5543, 1, 0, 0, 0, 5544, 5545, 
	1, 0, 0, 0, 5545, 5636, 1, 0, 0, 0, 5546, 5548, 5, 7, 0, 0, 5547, 5549, 
	5, 733, 0, 0, 5548, 5547, 1, 0, 0, 0, 5548, 5549, 1, 0, 0, 0, 5549, 5636, 
	1, 0, 0, 0, 5550, 5558, 5, 33, 0, 0, 5551, 5552, 5, 649, 0, 0, 5552, 5559, 
	5, 742, 0, 0, 5553, 5559, 5, 733, 0, 0, 5554, 5559, 5, 671, 0, 0, 5555, 
	5559, 5, 665, 0, 0, 5556, 5559, 5, 647, 0, 0, 5557, 5559, 5, 596, 0, 0, 
	5558, 5551, 1, 0, 0, 0, 5558, 5553, 1, 0, 0, 0, 5558, 5554, 1, 0, 0, 0, 
	5558, 5555, 1, 0, 0, 0, 5558, 5556, 1, 0, 0, 0, 5558, 5557, 1, 0, 0, 0, 
	5558, 5559, 1, 0, 0, 0, 5559, 5636, 1, 0, 0, 0, 5560, 5636, 5, 44, 0, 0, 
	5561, 5563, 5, 51, 0, 0, 5562, 5564, 5, 596, 0, 0, 5563, 5562, 1, 0, 0, 
	0, 5563, 5564, 1, 0, 0, 0, 5564, 5636, 1, 0, 0, 0, 5565, 5636, 5, 415, 
	0, 0, 5566, 5636, 5, 708, 0, 0, 5567, 5636, 5, 709, 0, 0, 5568, 5569, 5, 
	72, 0, 0, 5569, 5636, 5, 120, 0, 0, 5570, 5636, 5, 81, 0, 0, 5571, 5636, 
	5, 85, 0, 0, 5572, 5573, 5, 103, 0, 0, 5573, 5636, 5, 742, 0, 0, 5574, 
	5636, 5, 726, 0, 0, 5575, 5636, 5, 566, 0, 0, 5576, 5636, 5, 136, 0, 0, 
	5577, 5636, 5, 727, 0, 0, 5578, 5579, 5, 588, 0, 0, 5579, 5636, 7, 70, 
	0, 0, 5580, 5636, 5, 152, 0, 0, 5581, 5582, 5, 155, 0, 0, 5582, 5636, 7, 
	71, 0, 0, 5583, 5636, 5, 739, 0, 0, 5584, 5636, 5, 740, 0, 0, 5585, 5636, 
	5, 177, 0, 0, 5586, 5636, 5, 184, 0, 0, 5587, 5636, 5, 185, 0, 0, 5588, 
	5636, 5, 698, 0, 0, 5589, 5636, 5, 699, 0, 0, 5590, 5636, 5, 700, 0, 0, 
	5591, 5636, 5, 701, 0, 0, 5592, 5636, 5, 702, 0, 0, 5593, 5636, 5, 703, 
	0, 0, 5594, 5636, 5, 704, 0, 0, 5595, 5636, 5, 705, 0, 0, 5596, 5636, 5, 
	706, 0, 0, 5597, 5636, 5, 707, 0, 0, 5598, 5636, 5, 710, 0, 0, 5599, 5636, 
	5, 711, 0, 0, 5600, 5636, 5, 712, 0, 0, 5601, 5636, 5, 713, 0, 0, 5602, 
	5636, 5, 714, 0, 0, 5603, 5636, 5, 715, 0, 0, 5604, 5636, 5, 716, 0, 0, 
	5605, 5636, 5, 717, 0, 0, 5606, 5636, 5, 718, 0, 0, 5607, 5636, 5, 719, 
	0, 0, 5608, 5636, 5, 722, 0, 0, 5609, 5636, 5, 723, 0, 0, 5610, 5636, 5, 
	724, 0, 0, 5611, 5636, 5, 728, 0, 0, 5612, 5636, 5, 729, 0, 0, 5613, 5636, 
	5, 730, 0, 0, 5614, 5636, 5, 731, 0, 0, 5615, 5636, 5, 732, 0, 0, 5616, 
	5636, 5, 735, 0, 0, 5617, 5636, 5, 736, 0, 0, 5618, 5636, 5, 737, 0, 0, 
	5619, 5636, 5, 158, 0, 0, 5620, 5636, 5, 738, 0, 0, 5621, 5636, 5, 1077, 
	0, 0, 5622, 5636, 5, 741, 0, 0, 5623, 5636, 5, 743, 0, 0, 5624, 5636, 5, 
	1088, 0, 0, 5625, 5636, 5, 744, 0, 0, 5626, 5636, 5, 745, 0, 0, 5627, 5628, 
	5, 102, 0, 0, 5628, 5629, 5, 68, 0, 0, 5629, 5636, 5, 734, 0, 0, 5630, 
	5631, 5, 152, 0, 0, 5631, 5632, 5, 87, 0, 0, 5632, 5636, 5, 734, 0, 0, 
	5633, 5634, 5, 720, 0, 0, 5634, 5636, 5, 721, 0, 0, 5635, 5542, 1, 0, 0, 
	0, 5635, 5546, 1, 0, 0, 0, 5635, 5550, 1, 0, 0, 0, 5635, 5560, 1, 0, 0, 
	0, 5635, 5561, 1, 0, 0, 0, 5635, 5565, 1, 0, 0, 0, 5635, 5566, 1, 0, 0, 
	0, 5635, 5567, 1, 0, 0, 0, 5635, 5568, 1, 0, 0, 0, 5635, 5570, 1, 0, 0, 
	0, 5635, 5571, 1, 0, 0, 0, 5635, 5572, 1, 0, 0, 0, 5635, 5574, 1, 0, 0, 
	0, 5635, 5575, 1, 0, 0, 0, 5635, 5576, 1, 0, 0, 0, 5635, 5577, 1, 0, 0, 
	0, 5635, 5578, 1, 0, 0, 0, 5635, 5580, 1, 0, 0, 0, 5635, 5581, 1, 0, 0, 
	0, 5635, 5583, 1, 0, 0, 0, 5635, 5584, 1, 0, 0, 0, 5635, 5585, 1, 0, 0, 
	0, 5635, 5586, 1, 0, 0, 0, 5635, 5587, 1, 0, 0, 0, 5635, 5588, 1, 0, 0, 
	0, 5635, 5589, 1, 0, 0, 0, 5635, 5590, 1, 0, 0, 0, 5635, 5591, 1, 0, 0, 
	0, 5635, 5592, 1, 0, 0, 0, 5635, 5593, 1, 0, 0, 0, 5635, 5594, 1, 0, 0, 
	0, 5635, 5595, 1, 0, 0, 0, 5635, 5596, 1, 0, 0, 0, 5635, 5597, 1, 0, 0, 
	0, 5635, 5598, 1, 0, 0, 0, 5635, 5599, 1, 0, 0, 0, 5635, 5600, 1, 0, 0, 
	0, 5635, 5601, 1, 0, 0, 0, 5635, 5602, 1, 0, 0, 0, 5635, 5603, 1, 0, 0, 
	0, 5635, 5604, 1, 0, 0, 0, 5635, 5605, 1, 0, 0, 0, 5635, 5606, 1, 0, 0, 
	0, 5635, 5607, 1, 0, 0, 0, 5635, 5608, 1, 0, 0, 0, 5635, 5609, 1, 0, 0, 
	0, 5635, 5610, 1, 0, 0, 0, 5635, 5611, 1, 0, 0, 0, 5635, 5612, 1, 0, 0, 
	0, 5635, 5613, 1, 0, 0, 0, 5635, 5614, 1, 0, 0, 0, 5635, 5615, 1, 0, 0, 
	0, 5635, 5616, 1, 0, 0, 0, 5635, 5617, 1, 0, 0, 0, 5635, 5618, 1, 0, 0, 
	0, 5635, 5619, 1, 0, 0, 0, 5635, 5620, 1, 0, 0, 0, 5635, 5621, 1, 0, 0, 
	0, 5635, 5622, 1, 0, 0, 0, 5635, 5623, 1, 0, 0, 0, 5635, 5624, 1, 0, 0, 
	0, 5635, 5625, 1, 0, 0, 0, 5635, 5626, 1, 0, 0, 0, 5635, 5627, 1, 0, 0, 
	0, 5635, 5630, 1, 0, 0, 0, 5635, 5633, 1, 0, 0, 0, 5636, 473, 1, 0, 0, 
	0, 5637, 5654, 5, 1117, 0, 0, 5638, 5639, 5, 1117, 0, 0, 5639, 5640, 5, 
	1132, 0, 0, 5640, 5654, 5, 1117, 0, 0, 5641, 5642, 3, 592, 296, 0, 5642, 
	5643, 5, 1132, 0, 0, 5643, 5644, 5, 1117, 0, 0, 5644, 5654, 1, 0, 0, 0, 
	5645, 5646, 3, 592, 296, 0, 5646, 5647, 5, 1132, 0, 0, 5647, 5648, 3, 592, 
	296, 0, 5648, 5654, 1, 0, 0, 0, 5649, 5650, 3, 592, 296, 0, 5650, 5651, 
	3, 596, 298, 0, 5651, 5654, 1, 0, 0, 0, 5652, 5654, 3, 592, 296, 0, 5653, 
	5637, 1, 0, 0, 0, 5653, 5638, 1, 0, 0, 0, 5653, 5641, 1, 0, 0, 0, 5653, 
	5645, 1, 0, 0, 0, 5653, 5649, 1, 0, 0, 0, 5653, 5652, 1, 0, 0, 0, 5654, 
	475, 1, 0, 0, 0, 5655, 5656, 3, 572, 286, 0, 5656, 5657, 5, 175, 0, 0, 
	5657, 5658, 3, 572, 286, 0, 5658, 477, 1, 0, 0, 0, 5659, 5661, 5, 9, 0, 
	0, 5660, 5662, 7, 72, 0, 0, 5661, 5660, 1, 0, 0, 0, 5661, 5662, 1, 0, 0, 
	0, 5662, 5663, 1, 0, 0, 0, 5663, 5664, 7, 54, 0, 0, 5664, 5682, 3, 628, 
	314, 0, 5665, 5666, 5, 184, 0, 0, 5666, 5667, 5, 76, 0, 0, 5667, 5668, 
	5, 118, 0, 0, 5668, 5673, 3, 564, 282, 0, 5669, 5670, 5, 1135, 0, 0, 5670, 
	5672, 3, 564, 282, 0, 5671, 5669, 1, 0, 0, 0, 5672, 5675, 1, 0, 0, 0, 5673, 
	5671, 1, 0, 0, 0, 5673, 5674, 1, 0, 0, 0, 5674, 5680, 1, 0, 0, 0, 5675, 
	5673, 1, 0, 0, 0, 5676, 5677, 5, 192, 0, 0, 5677, 5678, 3, 598, 299, 0, 
	5678, 5679, 5, 18, 0, 0, 5679, 5681, 1, 0, 0, 0, 5680, 5676, 1, 0, 0, 0, 
	5680, 5681, 1, 0, 0, 0, 5681, 5683, 1, 0, 0, 0, 5682, 5665, 1, 0, 0, 0, 
	5682, 5683, 1, 0, 0, 0, 5683, 5695, 1, 0, 0, 0, 5684, 5685, 5, 51, 0, 0, 
	5685, 5686, 5, 76, 0, 0, 5686, 5687, 5, 118, 0, 0, 5687, 5692, 3, 564, 
	282, 0, 5688, 5689, 5, 1135, 0, 0, 5689, 5691, 3, 564, 282, 0, 5690, 5688, 
	1, 0, 0, 0, 5691, 5694, 1, 0, 0, 0, 5692, 5690, 1, 0, 0, 0, 5692, 5693, 
	1, 0, 0, 0, 5693, 5696, 1, 0, 0, 0, 5694, 5692, 1, 0, 0, 0, 5695, 5684, 
	1, 0, 0, 0, 5695, 5696, 1, 0, 0, 0, 5696, 479, 1, 0, 0, 0, 5697, 5698, 
	5, 26, 0, 0, 5698, 5699, 5, 172, 0, 0, 5699, 5703, 3, 628, 314, 0, 5700, 
	5702, 3, 488, 244, 0, 5701, 5700, 1, 0, 0, 0, 5702, 5705, 1, 0, 0, 0, 5703, 
	5701, 1, 0, 0, 0, 5703, 5704, 1, 0, 0, 0, 5704, 481, 1, 0, 0, 0, 5705, 
	5703, 1, 0, 0, 0, 5706, 5707, 5, 356, 0, 0, 5707, 5708, 5, 172, 0, 0, 5708, 
	5710, 3, 628, 314, 0, 5709, 5711, 7, 73, 0, 0, 5710, 5709, 1, 0, 0, 0, 
	5710, 5711, 1, 0, 0, 0, 5711, 483, 1, 0, 0, 0, 5712, 5714, 5, 119, 0, 0, 
	5713, 5715, 7, 72, 0, 0, 5714, 5713, 1, 0, 0, 0, 5714, 5715, 1, 0, 0, 0, 
	5715, 5716, 1, 0, 0, 0, 5716, 5717, 7, 54, 0, 0, 5717, 5718, 3, 628, 314, 
	0, 5718, 485, 1, 0, 0, 0, 5719, 5721, 5, 580, 0, 0, 5720, 5722, 7, 72, 
	0, 0, 5721, 5720, 1, 0, 0, 0, 5721, 5722, 1, 0, 0, 0, 5722, 5723, 1, 0, 
	0, 0, 5723, 5724, 5, 172, 0, 0, 5724, 5726, 3, 628, 314, 0, 5725, 5727, 
	5, 568, 0, 0, 5726, 5725, 1, 0, 0, 0, 5726, 5727, 1, 0, 0, 0, 5727, 5729, 
	1, 0, 0, 0, 5728, 5730, 5, 422, 0, 0, 5729, 5728, 1, 0, 0, 0, 5729, 5730, 
	1, 0, 0, 0, 5730, 5732, 1, 0, 0, 0, 5731, 5733, 5, 666, 0, 0, 5732, 5731, 
	1, 0, 0, 0, 5732, 5733, 1, 0, 0, 0, 5733, 487, 1, 0, 0, 0, 5734, 5735, 
	5, 65, 0, 0, 5735, 5742, 5, 664, 0, 0, 5736, 5742, 5, 568, 0, 0, 5737, 
	5742, 5, 425, 0, 0, 5738, 5742, 5, 504, 0, 0, 5739, 5742, 5, 422, 0, 0, 
	5740, 5742, 5, 354, 0, 0, 5741, 5734, 1, 0, 0, 0, 5741, 5736, 1, 0, 0, 
	0, 5741, 5737, 1, 0, 0, 0, 5741, 5738, 1, 0, 0, 0, 5741, 5739, 1, 0, 0, 
	0, 5741, 5740, 1, 0, 0, 0, 5742, 489, 1, 0, 0, 0, 5743, 5745, 5, 33, 0, 
	0, 5744, 5746, 5, 335, 0, 0, 5745, 5744, 1, 0, 0, 0, 5745, 5746, 1, 0, 
	0, 0, 5746, 5747, 1, 0, 0, 0, 5747, 5749, 5, 437, 0, 0, 5748, 5750, 3, 
	650, 325, 0, 5749, 5748, 1, 0, 0, 0, 5749, 5750, 1, 0, 0, 0, 5750, 5751, 
	1, 0, 0, 0, 5751, 5752, 3, 592, 296, 0, 5752, 5753, 5, 594, 0, 0, 5753, 
	5754, 7, 74, 0, 0, 5754, 5755, 5, 619, 0, 0, 5755, 5756, 5, 1148, 0, 0, 
	5756, 491, 1, 0, 0, 0, 5757, 5758, 5, 456, 0, 0, 5758, 5759, 5, 554, 0, 
	0, 5759, 5760, 3, 592, 296, 0, 5760, 5761, 5, 619, 0, 0, 5761, 5762, 5, 
	1148, 0, 0, 5762, 493, 1, 0, 0, 0, 5763, 5764, 5, 661, 0, 0, 5764, 5765, 
	5, 554, 0, 0, 5765, 5766, 3, 592, 296, 0, 5766, 495, 1, 0, 0, 0, 5767, 
	5768, 5, 153, 0, 0, 5768, 5769, 3, 500, 250, 0, 5769, 5772, 7, 75, 0, 0, 
	5770, 5773, 3, 696, 348, 0, 5771, 5773, 5, 118, 0, 0, 5772, 5770, 1, 0, 
	0, 0, 5772, 5771, 1, 0, 0, 0, 5773, 5783, 1, 0, 0, 0, 5774, 5775, 5, 1135, 
	0, 0, 5775, 5776, 3, 500, 250, 0, 5776, 5779, 7, 75, 0, 0, 5777, 5780, 
	3, 696, 348, 0, 5778, 5780, 5, 118, 0, 0, 5779, 5777, 1, 0, 0, 0, 5779, 
	5778, 1, 0, 0, 0, 5780, 5782, 1, 0, 0, 0, 5781, 5774, 1, 0, 0, 0, 5782, 
	5785, 1, 0, 0, 0, 5783, 5781, 1, 0, 0, 0, 5783, 5784, 1, 0, 0, 0, 5784, 
	5820, 1, 0, 0, 0, 5785, 5783, 1, 0, 0, 0, 5786, 5787, 5, 153, 0, 0, 5787, 
	5790, 3, 60, 30, 0, 5788, 5791, 3, 576, 288, 0, 5789, 5791, 5, 42, 0, 0, 
	5790, 5788, 1, 0, 0, 0, 5790, 5789, 1, 0, 0, 0, 5791, 5820, 1, 0, 0, 0, 
	5792, 5793, 5, 153, 0, 0, 5793, 5800, 5, 517, 0, 0, 5794, 5797, 3, 576, 
	288, 0, 5795, 5796, 5, 27, 0, 0, 5796, 5798, 3, 578, 289, 0, 5797, 5795, 
	1, 0, 0, 0, 5797, 5798, 1, 0, 0, 0, 5798, 5801, 1, 0, 0, 0, 5799, 5801, 
	5, 42, 0, 0, 5800, 5794, 1, 0, 0, 0, 5800, 5799, 1, 0, 0, 0, 5801, 5820, 
	1, 0, 0, 0, 5802, 5820, 3, 452, 226, 0, 5803, 5820, 3, 326, 163, 0, 5804, 
	5820, 3, 324, 162, 0, 5805, 5806, 5, 153, 0, 0, 5806, 5807, 3, 558, 279, 
	0, 5807, 5808, 7, 75, 0, 0, 5808, 5816, 3, 696, 348, 0, 5809, 5810, 5, 
	1135, 0, 0, 5810, 5811, 3, 558, 279, 0, 5811, 5812, 7, 75, 0, 0, 5812, 
	5813, 3, 696, 348, 0, 5813, 5815, 1, 0, 0, 0, 5814, 5809, 1, 0, 0, 0, 5815, 
	5818, 1, 0, 0, 0, 5816, 5814, 1, 0, 0, 0, 5816, 5817, 1, 0, 0, 0, 5817, 
	5820, 1, 0, 0, 0, 5818, 5816, 1, 0, 0, 0, 5819, 5767, 1, 0, 0, 0, 5819, 
	5786, 1, 0, 0, 0, 5819, 5792, 1, 0, 0, 0, 5819, 5802, 1, 0, 0, 0, 5819, 
	5803, 1, 0, 0, 0, 5819, 5804, 1, 0, 0, 0, 5819, 5805, 1, 0, 0, 0, 5820, 
	497, 1, 0, 0, 0, 5821, 5822, 5, 155, 0, 0, 5822, 5823, 7, 56, 0, 0, 5823, 
	5975, 5, 476, 0, 0, 5824, 5825, 5, 155, 0, 0, 5825, 5826, 7, 76, 0, 0, 
	5826, 5829, 5, 416, 0, 0, 5827, 5828, 5, 80, 0, 0, 5828, 5830, 5, 1148, 
	0, 0, 5829, 5827, 1, 0, 0, 0, 5829, 5830, 1, 0, 0, 0, 5830, 5833, 1, 0, 
	0, 0, 5831, 5832, 5, 68, 0, 0, 5832, 5834, 3, 598, 299, 0, 5833, 5831, 
	1, 0, 0, 0, 5833, 5834, 1, 0, 0, 0, 5834, 5842, 1, 0, 0, 0, 5835, 5839, 
	5, 99, 0, 0, 5836, 5837, 3, 598, 299, 0, 5837, 5838, 5, 1135, 0, 0, 5838, 
	5840, 1, 0, 0, 0, 5839, 5836, 1, 0, 0, 0, 5839, 5840, 1, 0, 0, 0, 5840, 
	5841, 1, 0, 0, 0, 5841, 5843, 3, 598, 299, 0, 5842, 5835, 1, 0, 0, 0, 5842, 
	5843, 1, 0, 0, 0, 5843, 5975, 1, 0, 0, 0, 5844, 5845, 5, 155, 0, 0, 5845, 
	5847, 3, 502, 251, 0, 5846, 5848, 3, 504, 252, 0, 5847, 5846, 1, 0, 0, 
	0, 5847, 5848, 1, 0, 0, 0, 5848, 5975, 1, 0, 0, 0, 5849, 5851, 5, 155, 
	0, 0, 5850, 5852, 5, 436, 0, 0, 5851, 5850, 1, 0, 0, 0, 5851, 5852, 1, 
	0, 0, 0, 5852, 5853, 1, 0, 0, 0, 5853, 5854, 7, 41, 0, 0, 5854, 5855, 7, 
	77, 0, 0, 5855, 5858, 3, 560, 280, 0, 5856, 5857, 7, 77, 0, 0, 5857, 5859, 
	3, 592, 296, 0, 5858, 5856, 1, 0, 0, 0, 5858, 5859, 1, 0, 0, 0, 5859, 5861, 
	1, 0, 0, 0, 5860, 5862, 3, 504, 252, 0, 5861, 5860, 1, 0, 0, 0, 5861, 5862, 
	1, 0, 0, 0, 5862, 5975, 1, 0, 0, 0, 5863, 5864, 5, 155, 0, 0, 5864, 5865, 
	5, 33, 0, 0, 5865, 5867, 7, 0, 0, 0, 5866, 5868, 3, 650, 325, 0, 5867, 
	5866, 1, 0, 0, 0, 5867, 5868, 1, 0, 0, 0, 5868, 5869, 1, 0, 0, 0, 5869, 
	5975, 3, 592, 296, 0, 5870, 5871, 5, 155, 0, 0, 5871, 5872, 5, 33, 0, 0, 
	5872, 5873, 7, 78, 0, 0, 5873, 5975, 3, 558, 279, 0, 5874, 5875, 5, 155, 
	0, 0, 5875, 5876, 5, 33, 0, 0, 5876, 5877, 5, 665, 0, 0, 5877, 5975, 3, 
	572, 286, 0, 5878, 5879, 5, 155, 0, 0, 5879, 5880, 5, 409, 0, 0, 5880, 
	5881, 3, 580, 290, 0, 5881, 5882, 7, 79, 0, 0, 5882, 5975, 1, 0, 0, 0, 
	5883, 5884, 5, 155, 0, 0, 5884, 5975, 3, 506, 253, 0, 5885, 5886, 5, 155, 
	0, 0, 5886, 5894, 7, 80, 0, 0, 5887, 5891, 5, 99, 0, 0, 5888, 5889, 3, 
	598, 299, 0, 5889, 5890, 5, 1135, 0, 0, 5890, 5892, 1, 0, 0, 0, 5891, 5888, 
	1, 0, 0, 0, 5891, 5892, 1, 0, 0, 0, 5892, 5893, 1, 0, 0, 0, 5893, 5895, 
	3, 598, 299, 0, 5894, 5887, 1, 0, 0, 0, 5894, 5895, 1, 0, 0, 0, 5895, 5975, 
	1, 0, 0, 0, 5896, 5897, 5, 155, 0, 0, 5897, 5898, 5, 290, 0, 0, 5898, 5899, 
	5, 1133, 0, 0, 5899, 5900, 5, 1117, 0, 0, 5900, 5901, 5, 1134, 0, 0, 5901, 
	5975, 7, 80, 0, 0, 5902, 5903, 5, 155, 0, 0, 5903, 5906, 3, 508, 254, 0, 
	5904, 5905, 7, 77, 0, 0, 5905, 5907, 3, 592, 296, 0, 5906, 5904, 1, 0, 
	0, 0, 5906, 5907, 1, 0, 0, 0, 5907, 5909, 1, 0, 0, 0, 5908, 5910, 3, 504, 
	252, 0, 5909, 5908, 1, 0, 0, 0, 5909, 5910, 1, 0, 0, 0, 5910, 5975, 1, 
	0, 0, 0, 5911, 5912, 5, 155, 0, 0, 5912, 5913, 7, 81, 0, 0, 5913, 5914, 
	5, 364, 0, 0, 5914, 5975, 3, 558, 279, 0, 5915, 5916, 5, 155, 0, 0, 5916, 
	5919, 5, 440, 0, 0, 5917, 5918, 5, 65, 0, 0, 5918, 5920, 3, 572, 286, 0, 
	5919, 5917, 1, 0, 0, 0, 5919, 5920, 1, 0, 0, 0, 5920, 5975, 1, 0, 0, 0, 
	5921, 5922, 5, 155, 0, 0, 5922, 5923, 7, 82, 0, 0, 5923, 5924, 7, 77, 0, 
	0, 5924, 5927, 3, 560, 280, 0, 5925, 5926, 7, 77, 0, 0, 5926, 5928, 3, 
	592, 296, 0, 5927, 5925, 1, 0, 0, 0, 5927, 5928, 1, 0, 0, 0, 5928, 5931, 
	1, 0, 0, 0, 5929, 5930, 5, 190, 0, 0, 5930, 5932, 3, 696, 348, 0, 5931, 
	5929, 1, 0, 0, 0, 5931, 5932, 1, 0, 0, 0, 5932, 5975, 1, 0, 0, 0, 5933, 
	5934, 5, 155, 0, 0, 5934, 5935, 5, 539, 0, 0, 5935, 5938, 5, 742, 0, 0, 
	5936, 5937, 7, 77, 0, 0, 5937, 5939, 3, 592, 296, 0, 5938, 5936, 1, 0, 
	0, 0, 5938, 5939, 1, 0, 0, 0, 5939, 5941, 1, 0, 0, 0, 5940, 5942, 3, 504, 
	252, 0, 5941, 5940, 1, 0, 0, 0, 5941, 5942, 1, 0, 0, 0, 5942, 5975, 1, 
	0, 0, 0, 5943, 5944, 5, 155, 0, 0, 5944, 5945, 5, 564, 0, 0, 5945, 5950, 
	3, 510, 255, 0, 5946, 5947, 5, 1135, 0, 0, 5947, 5949, 3, 510, 255, 0, 
	5948, 5946, 1, 0, 0, 0, 5949, 5952, 1, 0, 0, 0, 5950, 5948, 1, 0, 0, 0, 
	5950, 5951, 1, 0, 0, 0, 5951, 5956, 1, 0, 0, 0, 5952, 5950, 1, 0, 0, 0, 
	5953, 5954, 5, 65, 0, 0, 5954, 5955, 5, 567, 0, 0, 5955, 5957, 3, 598, 
	299, 0, 5956, 5953, 1, 0, 0, 0, 5956, 5957, 1, 0, 0, 0, 5957, 5958, 1, 
	0, 0, 0, 5958, 5962, 5, 99, 0, 0, 5959, 5960, 3, 598, 299, 0, 5960, 5961, 
	5, 1135, 0, 0, 5961, 5963, 1, 0, 0, 0, 5962, 5959, 1, 0, 0, 0, 5962, 5963, 
	1, 0, 0, 0, 5963, 5964, 1, 0, 0, 0, 5964, 5965, 3, 598, 299, 0, 5965, 5975, 
	1, 0, 0, 0, 5966, 5967, 5, 155, 0, 0, 5967, 5968, 5, 614, 0, 0, 5968, 5972, 
	5, 634, 0, 0, 5969, 5970, 5, 65, 0, 0, 5970, 5971, 5, 355, 0, 0, 5971, 
	5973, 5, 1148, 0, 0, 5972, 5969, 1, 0, 0, 0, 5972, 5973, 1, 0, 0, 0, 5973, 
	5975, 1, 0, 0, 0, 5974, 5821, 1, 0, 0, 0, 5974, 5824, 1, 0, 0, 0, 5974, 
	5844, 1, 0, 0, 0, 5974, 5849, 1, 0, 0, 0, 5974, 5863, 1, 0, 0, 0, 5974, 
	5870, 1, 0, 0, 0, 5974, 5874, 1, 0, 0, 0, 5974, 5878, 1, 0, 0, 0, 5974, 
	5883, 1, 0, 0, 0, 5974, 5885, 1, 0, 0, 0, 5974, 5896, 1, 0, 0, 0, 5974, 
	5902, 1, 0, 0, 0, 5974, 5911, 1, 0, 0, 0, 5974, 5915, 1, 0, 0, 0, 5974, 
	5921, 1, 0, 0, 0, 5974, 5933, 1, 0, 0, 0, 5974, 5943, 1, 0, 0, 0, 5974, 
	5966, 1, 0, 0, 0, 5975, 499, 1, 0, 0, 0, 5976, 5987, 5, 1159, 0, 0, 5977, 
	5987, 5, 1160, 0, 0, 5978, 5979, 5, 1137, 0, 0, 5979, 5981, 5, 1137, 0, 
	0, 5980, 5978, 1, 0, 0, 0, 5980, 5981, 1, 0, 0, 0, 5981, 5982, 1, 0, 0, 
	0, 5982, 5984, 7, 83, 0, 0, 5983, 5980, 1, 0, 0, 0, 5983, 5984, 1, 0, 0, 
	0, 5984, 5985, 1, 0, 0, 0, 5985, 5987, 3, 592, 296, 0, 5986, 5976, 1, 0, 
	0, 0, 5986, 5977, 1, 0, 0, 0, 5986, 5983, 1, 0, 0, 0, 5987, 501, 1, 0, 
	0, 0, 5988, 5989, 5, 25, 0, 0, 5989, 6002, 5, 153, 0, 0, 5990, 6002, 5, 
	844, 0, 0, 5991, 6002, 5, 40, 0, 0, 5992, 6002, 5, 151, 0, 0, 5993, 5994, 
	5, 437, 0, 0, 5994, 6002, 5, 634, 0, 0, 5995, 5996, 5, 131, 0, 0, 5996, 
	6002, 5, 634, 0, 0, 5997, 5999, 7, 55, 0, 0, 5998, 5997, 1, 0, 0, 0, 5998, 
	5999, 1, 0, 0, 0, 5999, 6000, 1, 0, 0, 0, 6000, 6002, 7, 84, 0, 0, 6001, 
	5988, 1, 0, 0, 0, 6001, 5990, 1, 0, 0, 0, 6001, 5991, 1, 0, 0, 0, 6001, 
	5992, 1, 0, 0, 0, 6001, 5993, 1, 0, 0, 0, 6001, 5995, 1, 0, 0, 0, 6001, 
	5998, 1, 0, 0, 0, 6002, 503, 1, 0, 0, 0, 6003, 6004, 5, 98, 0, 0, 6004, 
	6008, 5, 1148, 0, 0, 6005, 6006, 5, 190, 0, 0, 6006, 6008, 3, 696, 348, 
	0, 6007, 6003, 1, 0, 0, 0, 6007, 6005, 1, 0, 0, 0, 6008, 505, 1, 0, 0, 
	0, 6009, 6011, 5, 636, 0, 0, 6010, 6009, 1, 0, 0, 0, 6010, 6011, 1, 0, 
	0, 0, 6011, 6012, 1, 0, 0, 0, 6012, 6027, 5, 410, 0, 0, 6013, 6014, 5, 
	477, 0, 0, 6014, 6027, 5, 634, 0, 0, 6015, 6027, 5, 556, 0, 0, 6016, 6027, 
	5, 725, 0, 0, 6017, 6019, 5, 436, 0, 0, 6018, 6017, 1, 0, 0, 0, 6018, 6019, 
	1, 0, 0, 0, 6019, 6020, 1, 0, 0, 0, 6020, 6027, 5, 563, 0, 0, 6021, 6027, 
	5, 565, 0, 0, 6022, 6023, 5, 614, 0, 0, 6023, 6027, 5, 447, 0, 0, 6024, 
	6027, 5, 339, 0, 0, 6025, 6027, 5, 383, 0, 0, 6026, 6010, 1, 0, 0, 0, 6026, 
	6013, 1, 0, 0, 0, 6026, 6015, 1, 0, 0, 0, 6026, 6016, 1, 0, 0, 0, 6026, 
	6018, 1, 0, 0, 0, 6026, 6021, 1, 0, 0, 0, 6026, 6022, 1, 0, 0, 0, 6026, 
	6024, 1, 0, 0, 0, 6026, 6025, 1, 0, 0, 0, 6027, 507, 1, 0, 0, 0, 6028, 
	6037, 5, 416, 0, 0, 6029, 6030, 5, 172, 0, 0, 6030, 6037, 5, 634, 0, 0, 
	6031, 6033, 5, 436, 0, 0, 6032, 6031, 1, 0, 0, 0, 6032, 6033, 1, 0, 0, 
	0, 6033, 6034, 1, 0, 0, 0, 6034, 6037, 5, 742, 0, 0, 6035, 6037, 5, 655, 
	0, 0, 6036, 6028, 1, 0, 0, 0, 6036, 6029, 1, 0, 0, 0, 6036, 6032, 1, 0, 
	0, 0, 6036, 6035, 1, 0, 0, 0, 6037, 509, 1, 0, 0, 0, 6038, 6051, 5, 6, 
	0, 0, 6039, 6040, 5, 347, 0, 0, 6040, 6051, 5, 461, 0, 0, 6041, 6042, 5, 
	382, 0, 0, 6042, 6051, 5, 645, 0, 0, 6043, 6051, 5, 385, 0, 0, 6044, 6051, 
	5, 463, 0, 0, 6045, 6051, 5, 792, 0, 0, 6046, 6047, 5, 544, 0, 0, 6047, 
	6051, 5, 426, 0, 0, 6048, 6051, 5, 621, 0, 0, 6049, 6051, 5, 644, 0, 0, 
	6050, 6038, 1, 0, 0, 0, 6050, 6039, 1, 0, 0, 0, 6050, 6041, 1, 0, 0, 0, 
	6050, 6043, 1, 0, 0, 0, 6050, 6044, 1, 0, 0, 0, 6050, 6045, 1, 0, 0, 0, 
	6050, 6046, 1, 0, 0, 0, 6050, 6048, 1, 0, 0, 0, 6050, 6049, 1, 0, 0, 0, 
	6051, 511, 1, 0, 0, 0, 6052, 6053, 5, 345, 0, 0, 6053, 6054, 5, 1148, 0, 
	0, 6054, 513, 1, 0, 0, 0, 6055, 6056, 5, 351, 0, 0, 6056, 6057, 5, 81, 
	0, 0, 6057, 6062, 3, 526, 263, 0, 6058, 6059, 5, 1135, 0, 0, 6059, 6061, 
	3, 526, 263, 0, 6060, 6058, 1, 0, 0, 0, 6061, 6064, 1, 0, 0, 0, 6062, 6060, 
	1, 0, 0, 0, 6062, 6063, 1, 0, 0, 0, 6063, 6072, 1, 0, 0, 0, 6064, 6062, 
	1, 0, 0, 0, 6065, 6066, 5, 129, 0, 0, 6066, 6069, 5, 1133, 0, 0, 6067, 
	6070, 3, 624, 312, 0, 6068, 6070, 5, 6, 0, 0, 6069, 6067, 1, 0, 0, 0, 6069, 
	6068, 1, 0, 0, 0, 6070, 6071, 1, 0, 0, 0, 6071, 6073, 5, 1134, 0, 0, 6072, 
	6065, 1, 0, 0, 0, 6072, 6073, 1, 0, 0, 0, 6073, 6074, 1, 0, 0, 0, 6074, 
	6075, 5, 80, 0, 0, 6075, 6076, 3, 592, 296, 0, 6076, 515, 1, 0, 0, 0, 6077, 
	6079, 5, 432, 0, 0, 6078, 6080, 7, 72, 0, 0, 6079, 6078, 1, 0, 0, 0, 6079, 
	6080, 1, 0, 0, 0, 6080, 6081, 1, 0, 0, 0, 6081, 6086, 3, 528, 264, 0, 6082, 
	6083, 5, 1135, 0, 0, 6083, 6085, 3, 528, 264, 0, 6084, 6082, 1, 0, 0, 0, 
	6085, 6088, 1, 0, 0, 0, 6086, 6084, 1, 0, 0, 0, 6086, 6087, 1, 0, 0, 0, 
	6087, 517, 1, 0, 0, 0, 6088, 6086, 1, 0, 0, 0, 6089, 6091, 5, 93, 0, 0, 
	6090, 6092, 7, 85, 0, 0, 6091, 6090, 1, 0, 0, 0, 6091, 6092, 1, 0, 0, 0, 
	6092, 6093, 1, 0, 0, 0, 6093, 6094, 3, 696, 348, 0, 6094, 519, 1, 0, 0, 
	0, 6095, 6096, 5, 102, 0, 0, 6096, 6097, 5, 81, 0, 0, 6097, 6098, 5, 87, 
	0, 0, 6098, 6099, 5, 351, 0, 0, 6099, 6104, 3, 532, 266, 0, 6100, 6101, 
	5, 1135, 0, 0, 6101, 6103, 3, 532, 266, 0, 6102, 6100, 1, 0, 0, 0, 6103, 
	6106, 1, 0, 0, 0, 6104, 6102, 1, 0, 0, 0, 6104, 6105, 1, 0, 0, 0, 6105, 
	521, 1, 0, 0, 0, 6106, 6104, 1, 0, 0, 0, 6107, 6108, 5, 589, 0, 0, 6108, 
	6109, 5, 567, 0, 0, 6109, 6110, 5, 351, 0, 0, 6110, 523, 1, 0, 0, 0, 6111, 
	6112, 5, 739, 0, 0, 6112, 525, 1, 0, 0, 0, 6113, 6121, 3, 560, 280, 0, 
	6114, 6116, 7, 20, 0, 0, 6115, 6114, 1, 0, 0, 0, 6115, 6116, 1, 0, 0, 0, 
	6116, 6117, 1, 0, 0, 0, 6117, 6118, 5, 1133, 0, 0, 6118, 6119, 3, 624, 
	312, 0, 6119, 6120, 5, 1134, 0, 0, 6120, 6122, 1, 0, 0, 0, 6121, 6115, 
	1, 0, 0, 0, 6121, 6122, 1, 0, 0, 0, 6122, 527, 1, 0, 0, 0, 6123, 6142, 
	5, 394, 0, 0, 6124, 6142, 5, 447, 0, 0, 6125, 6127, 7, 86, 0, 0, 6126, 
	6125, 1, 0, 0, 0, 6126, 6127, 1, 0, 0, 0, 6127, 6128, 1, 0, 0, 0, 6128, 
	6142, 5, 476, 0, 0, 6129, 6142, 5, 540, 0, 0, 6130, 6142, 5, 725, 0, 0, 
	6131, 6132, 5, 567, 0, 0, 6132, 6142, 5, 351, 0, 0, 6133, 6142, 5, 634, 
	0, 0, 6134, 6142, 5, 667, 0, 0, 6135, 6139, 5, 742, 0, 0, 6136, 6137, 5, 
	192, 0, 0, 6137, 6138, 5, 134, 0, 0, 6138, 6140, 5, 103, 0, 0, 6139, 6136, 
	1, 0, 0, 0, 6139, 6140, 1, 0, 0, 0, 6140, 6142, 1, 0, 0, 0, 6141, 6123, 
	1, 0, 0, 0, 6141, 6124, 1, 0, 0, 0, 6141, 6126, 1, 0, 0, 0, 6141, 6129, 
	1, 0, 0, 0, 6141, 6130, 1, 0, 0, 0, 6141, 6131, 1, 0, 0, 0, 6141, 6133, 
	1, 0, 0, 0, 6141, 6134, 1, 0, 0, 0, 6141, 6135, 1, 0, 0, 0, 6142, 6156, 
	1, 0, 0, 0, 6143, 6144, 5, 574, 0, 0, 6144, 6146, 5, 476, 0, 0, 6145, 6147, 
	3, 364, 182, 0, 6146, 6145, 1, 0, 0, 0, 6146, 6147, 1, 0, 0, 0, 6147, 6156, 
	1, 0, 0, 0, 6148, 6150, 7, 54, 0, 0, 6149, 6151, 3, 628, 314, 0, 6150, 
	6149, 1, 0, 0, 0, 6150, 6151, 1, 0, 0, 0, 6151, 6153, 1, 0, 0, 0, 6152, 
	6154, 3, 530, 265, 0, 6153, 6152, 1, 0, 0, 0, 6153, 6154, 1, 0, 0, 0, 6154, 
	6156, 1, 0, 0, 0, 6155, 6141, 1, 0, 0, 0, 6155, 6143, 1, 0, 0, 0, 6155, 
	6148, 1, 0, 0, 0, 6156, 529, 1, 0, 0, 0, 6157, 6158, 5, 192, 0, 0, 6158, 
	6159, 5, 134, 0, 0, 6159, 6163, 5, 103, 0, 0, 6160, 6161, 5, 65, 0, 0, 
	6161, 6163, 5, 421, 0, 0, 6162, 6157, 1, 0, 0, 0, 6162, 6160, 1, 0, 0, 
	0, 6163, 531, 1, 0, 0, 0, 6164, 6172, 3, 560, 280, 0, 6165, 6166, 5, 129, 
	0, 0, 6166, 6169, 5, 1133, 0, 0, 6167, 6170, 3, 624, 312, 0, 6168, 6170, 
	5, 6, 0, 0, 6169, 6167, 1, 0, 0, 0, 6169, 6168, 1, 0, 0, 0, 6170, 6171, 
	1, 0, 0, 0, 6171, 6173, 5, 1134, 0, 0, 6172, 6165, 1, 0, 0, 0, 6172, 6173, 
	1, 0, 0, 0, 6173, 6181, 1, 0, 0, 0, 6174, 6176, 7, 20, 0, 0, 6175, 6174, 
	1, 0, 0, 0, 6175, 6176, 1, 0, 0, 0, 6176, 6177, 1, 0, 0, 0, 6177, 6178, 
	5, 1133, 0, 0, 6178, 6179, 3, 624, 312, 0, 6179, 6180, 5, 1134, 0, 0, 6180, 
	6182, 1, 0, 0, 0, 6181, 6175, 1, 0, 0, 0, 6181, 6182, 1, 0, 0, 0, 6182, 
	6185, 1, 0, 0, 0, 6183, 6184, 5, 78, 0, 0, 6184, 6186, 5, 470, 0, 0, 6185, 
	6183, 1, 0, 0, 0, 6185, 6186, 1, 0, 0, 0, 6186, 533, 1, 0, 0, 0, 6187, 
	6188, 7, 87, 0, 0, 6188, 6191, 3, 560, 280, 0, 6189, 6192, 3, 592, 296, 
	0, 6190, 6192, 5, 1148, 0, 0, 6191, 6189, 1, 0, 0, 0, 6191, 6190, 1, 0, 
	0, 0, 6191, 6192, 1, 0, 0, 0, 6192, 535, 1, 0, 0, 0, 6193, 6197, 7, 87, 
	0, 0, 6194, 6195, 7, 88, 0, 0, 6195, 6196, 5, 1124, 0, 0, 6196, 6198, 7, 
	89, 0, 0, 6197, 6194, 1, 0, 0, 0, 6197, 6198, 1, 0, 0, 0, 6198, 6199, 1, 
	0, 0, 0, 6199, 6200, 3, 556, 278, 0, 6200, 537, 1, 0, 0, 0, 6201, 6202, 
	5, 444, 0, 0, 6202, 6203, 5, 1148, 0, 0, 6203, 539, 1, 0, 0, 0, 6204, 6205, 
	5, 186, 0, 0, 6205, 6206, 3, 592, 296, 0, 6206, 541, 1, 0, 0, 0, 6207, 
	6215, 5, 156, 0, 0, 6208, 6210, 5, 162, 0, 0, 6209, 6211, 5, 669, 0, 0, 
	6210, 6209, 1, 0, 0, 0, 6210, 6211, 1, 0, 0, 0, 6211, 6212, 1, 0, 0, 0, 
	6212, 6216, 3, 602, 301, 0, 6213, 6216, 5, 1156, 0, 0, 6214, 6216, 5, 1157, 
	0, 0, 6215, 6208, 1, 0, 0, 0, 6215, 6213, 1, 0, 0, 0, 6215, 6214, 1, 0, 
	0, 0, 6216, 6226, 1, 0, 0, 0, 6217, 6218, 5, 153, 0, 0, 6218, 6223, 3, 
	546, 273, 0, 6219, 6220, 5, 1135, 0, 0, 6220, 6222, 3, 546, 273, 0, 6221, 
	6219, 1, 0, 0, 0, 6222, 6225, 1, 0, 0, 0, 6223, 6221, 1, 0, 0, 0, 6223, 
	6224, 1, 0, 0, 0, 6224, 6227, 1, 0, 0, 0, 6225, 6223, 1, 0, 0, 0, 6226, 
	6217, 1, 0, 0, 0, 6226, 6227, 1, 0, 0, 0, 6227, 543, 1, 0, 0, 0, 6228, 
	6236, 5, 143, 0, 0, 6229, 6231, 5, 162, 0, 0, 6230, 6232, 5, 669, 0, 0, 
	6231, 6230, 1, 0, 0, 0, 6231, 6232, 1, 0, 0, 0, 6232, 6233, 1, 0, 0, 0, 
	6233, 6237, 3, 602, 301, 0, 6234, 6237, 5, 1156, 0, 0, 6235, 6237, 5, 1157, 
	0, 0, 6236, 6229, 1, 0, 0, 0, 6236, 6234, 1, 0, 0, 0, 6236, 6235, 1, 0, 
	0, 0, 6236, 6237, 1, 0, 0, 0, 6237, 6247, 1, 0, 0, 0, 6238, 6239, 5, 153, 
	0, 0, 6239, 6244, 3, 546, 273, 0, 6240, 6241, 5, 1135, 0, 0, 6241, 6243, 
	3, 546, 273, 0, 6242, 6240, 1, 0, 0, 0, 6243, 6246, 1, 0, 0, 0, 6244, 6242, 
	1, 0, 0, 0, 6244, 6245, 1, 0, 0, 0, 6245, 6248, 1, 0, 0, 0, 6246, 6244, 
	1, 0, 0, 0, 6247, 6238, 1, 0, 0, 0, 6247, 6248, 1, 0, 0, 0, 6248, 545, 
	1, 0, 0, 0, 6249, 6250, 7, 90, 0, 0, 6250, 6255, 5, 1124, 0, 0, 6251, 6256, 
	3, 602, 301, 0, 6252, 6256, 5, 1149, 0, 0, 6253, 6256, 3, 574, 287, 0, 
	6254, 6256, 3, 594, 297, 0, 6255, 6251, 1, 0, 0, 0, 6255, 6252, 1, 0, 0, 
	0, 6255, 6253, 1, 0, 0, 0, 6255, 6254, 1, 0, 0, 0, 6256, 547, 1, 0, 0, 
	0, 6257, 6259, 5, 192, 0, 0, 6258, 6260, 5, 571, 0, 0, 6259, 6258, 1, 0, 
	0, 0, 6259, 6260, 1, 0, 0, 0, 6260, 6261, 1, 0, 0, 0, 6261, 6266, 3, 50, 
	25, 0, 6262, 6263, 5, 1135, 0, 0, 6263, 6265, 3, 50, 25, 0, 6264, 6262, 
	1, 0, 0, 0, 6265, 6268, 1, 0, 0, 0, 6266, 6264, 1, 0, 0, 0, 6266, 6267, 
	1, 0, 0, 0, 6267, 549, 1, 0, 0, 0, 6268, 6266, 1, 0, 0, 0, 6269, 6270, 
	5, 172, 0, 0, 6270, 6272, 3, 560, 280, 0, 6271, 6273, 3, 230, 115, 0, 6272, 
	6271, 1, 0, 0, 0, 6272, 6273, 1, 0, 0, 0, 6273, 6275, 1, 0, 0, 0, 6274, 
	6276, 3, 302, 151, 0, 6275, 6274, 1, 0, 0, 0, 6275, 6276, 1, 0, 0, 0, 6276, 
	551, 1, 0, 0, 0, 6277, 6279, 5, 71, 0, 0, 6278, 6280, 7, 91, 0, 0, 6279, 
	6278, 1, 0, 0, 0, 6279, 6280, 1, 0, 0, 0, 6280, 6281, 1, 0, 0, 0, 6281, 
	6313, 5, 48, 0, 0, 6282, 6283, 3, 500, 250, 0, 6283, 6284, 5, 1124, 0, 
	0, 6284, 6292, 7, 92, 0, 0, 6285, 6286, 5, 1135, 0, 0, 6286, 6287, 3, 500, 
	250, 0, 6287, 6288, 5, 1124, 0, 0, 6288, 6289, 7, 92, 0, 0, 6289, 6291, 
	1, 0, 0, 0, 6290, 6285, 1, 0, 0, 0, 6291, 6294, 1, 0, 0, 0, 6292, 6290, 
	1, 0, 0, 0, 6292, 6293, 1, 0, 0, 0, 6293, 6314, 1, 0, 0, 0, 6294, 6292, 
	1, 0, 0, 0, 6295, 6298, 5, 29, 0, 0, 6296, 6299, 3, 598, 299, 0, 6297, 
	6299, 3, 500, 250, 0, 6298, 6296, 1, 0, 0, 0, 6298, 6297, 1, 0, 0, 0, 6299, 
	6300, 1, 0, 0, 0, 6300, 6301, 3, 500, 250, 0, 6301, 6302, 5, 1124, 0, 0, 
	6302, 6310, 3, 554, 277, 0, 6303, 6304, 5, 1135, 0, 0, 6304, 6305, 3, 500, 
	250, 0, 6305, 6306, 5, 1124, 0, 0, 6306, 6307, 3, 554, 277, 0, 6307, 6309, 
	1, 0, 0, 0, 6308, 6303, 1, 0, 0, 0, 6309, 6312, 1, 0, 0, 0, 6310, 6308, 
	1, 0, 0, 0, 6310, 6311, 1, 0, 0, 0, 6311, 6314, 1, 0, 0, 0, 6312, 6310, 
	1, 0, 0, 0, 6313, 6282, 1, 0, 0, 0, 6313, 6295, 1, 0, 0, 0, 6314, 553, 
	1, 0, 0, 0, 6315, 6316, 7, 93, 0, 0, 6316, 555, 1, 0, 0, 0, 6317, 6323, 
	3, 200, 100, 0, 6318, 6323, 3, 186, 93, 0, 6319, 6323, 3, 192, 96, 0, 6320, 
	6323, 3, 198, 99, 0, 6321, 6323, 3, 202, 101, 0, 6322, 6317, 1, 0, 0, 0, 
	6322, 6318, 1, 0, 0, 0, 6322, 6319, 1, 0, 0, 0, 6322, 6320, 1, 0, 0, 0, 
	6322, 6321, 1, 0, 0, 0, 6323, 6328, 1, 0, 0, 0, 6324, 6325, 5, 65, 0, 0, 
	6325, 6326, 5, 376, 0, 0, 6326, 6328, 3, 592, 296, 0, 6327, 6322, 1, 0, 
	0, 0, 6327, 6324, 1, 0, 0, 0, 6328, 557, 1, 0, 0, 0, 6329, 6333, 3, 592, 
	296, 0, 6330, 6334, 5, 1155, 0, 0, 6331, 6332, 5, 1132, 0, 0, 6332, 6334, 
	3, 592, 296, 0, 6333, 6330, 1, 0, 0, 0, 6333, 6331, 1, 0, 0, 0, 6333, 6334, 
	1, 0, 0, 0, 6334, 559, 1, 0, 0, 0, 6335, 6336, 3, 558, 279, 0, 6336, 561, 
	1, 0, 0, 0, 6337, 6340, 3, 572, 286, 0, 6338, 6340, 3, 592, 296, 0, 6339, 
	6337, 1, 0, 0, 0, 6339, 6338, 1, 0, 0, 0, 6340, 563, 1, 0, 0, 0, 6341, 
	6346, 3, 592, 296, 0, 6342, 6344, 3, 596, 298, 0, 6343, 6345, 3, 596, 298, 
	0, 6344, 6343, 1, 0, 0, 0, 6344, 6345, 1, 0, 0, 0, 6345, 6347, 1, 0, 0, 
	0, 6346, 6342, 1, 0, 0, 0, 6346, 6347, 1, 0, 0, 0, 6347, 6356, 1, 0, 0, 
	0, 6348, 6350, 9, 0, 0, 0, 6349, 6348, 1, 0, 0, 0, 6349, 6350, 1, 0, 0, 
	0, 6350, 6351, 1, 0, 0, 0, 6351, 6353, 3, 596, 298, 0, 6352, 6354, 3, 596, 
	298, 0, 6353, 6352, 1, 0, 0, 0, 6353, 6354, 1, 0, 0, 0, 6354, 6356, 1, 
	0, 0, 0, 6355, 6341, 1, 0, 0, 0, 6355, 6349, 1, 0, 0, 0, 6356, 565, 1, 
	0, 0, 0, 6357, 6360, 3, 592, 296, 0, 6358, 6360, 5, 1148, 0, 0, 6359, 6357, 
	1, 0, 0, 0, 6359, 6358, 1, 0, 0, 0, 6360, 6365, 1, 0, 0, 0, 6361, 6362, 
	5, 1133, 0, 0, 6362, 6363, 3, 598, 299, 0, 6363, 6364, 5, 1134, 0, 0, 6364, 
	6366, 1, 0, 0, 0, 6365, 6361, 1, 0, 0, 0, 6365, 6366, 1, 0, 0, 0, 6366, 
	6369, 1, 0, 0, 0, 6367, 6369, 3, 696, 348, 0, 6368, 6359, 1, 0, 0, 0, 6368, 
	6367, 1, 0, 0, 0, 6369, 6371, 1, 0, 0, 0, 6370, 6372, 7, 48, 0, 0, 6371, 
	6370, 1, 0, 0, 0, 6371, 6372, 1, 0, 0, 0, 6372, 567, 1, 0, 0, 0, 6373, 
	6378, 5, 1148, 0, 0, 6374, 6378, 5, 1156, 0, 0, 6375, 6378, 5, 697, 0, 
	0, 6376, 6378, 3, 726, 363, 0, 6377, 6373, 1, 0, 0, 0, 6377, 6374, 1, 0, 
	0, 0, 6377, 6375, 1, 0, 0, 0, 6377, 6376, 1, 0, 0, 0, 6378, 569, 1, 0, 
	0, 0, 6379, 6380, 7, 94, 0, 0, 6380, 571, 1, 0, 0, 0, 6381, 6387, 3, 568, 
	284, 0, 6382, 6383, 3, 568, 284, 0, 6383, 6384, 3, 570, 285, 0, 6384, 6387, 
	1, 0, 0, 0, 6385, 6387, 3, 62, 31, 0, 6386, 6381, 1, 0, 0, 0, 6386, 6382, 
	1, 0, 0, 0, 6386, 6385, 1, 0, 0, 0, 6387, 573, 1, 0, 0, 0, 6388, 6389, 
	7, 95, 0, 0, 6389, 575, 1, 0, 0, 0, 6390, 6395, 5, 226, 0, 0, 6391, 6395, 
	3, 716, 358, 0, 6392, 6395, 5, 1148, 0, 0, 6393, 6395, 5, 1145, 0, 0, 6394, 
	6390, 1, 0, 0, 0, 6394, 6391, 1, 0, 0, 0, 6394, 6392, 1, 0, 0, 0, 6394, 
	6393, 1, 0, 0, 0, 6395, 577, 1, 0, 0, 0, 6396, 6399, 3, 592, 296, 0, 6397, 
	6399, 5, 1148, 0, 0, 6398, 6396, 1, 0, 0, 0, 6398, 6397, 1, 0, 0, 0, 6399, 
	579, 1, 0, 0, 0, 6400, 6404, 3, 582, 291, 0, 6401, 6404, 5, 1156, 0, 0, 
	6402, 6404, 5, 1148, 0, 0, 6403, 6400, 1, 0, 0, 0, 6403, 6401, 1, 0, 0, 
	0, 6403, 6402, 1, 0, 0, 0, 6404, 581, 1, 0, 0, 0, 6405, 6406, 7, 96, 0, 
	0, 6406, 583, 1, 0, 0, 0, 6407, 6408, 3, 598, 299, 0, 6408, 6409, 5, 1121, 
	0, 0, 6409, 6410, 3, 598, 299, 0, 6410, 6411, 5, 1121, 0, 0, 6411, 6412, 
	3, 598, 299, 0, 6412, 6413, 5, 1121, 0, 0, 6413, 6414, 3, 598, 299, 0, 
	6414, 6415, 5, 1121, 0, 0, 6415, 6421, 3, 598, 299, 0, 6416, 6417, 5, 1144, 
	0, 0, 6417, 6418, 3, 598, 299, 0, 6418, 6419, 5, 1121, 0, 0, 6419, 6420, 
	3, 598, 299, 0, 6420, 6422, 1, 0, 0, 0, 6421, 6416, 1, 0, 0, 0, 6422, 6423, 
	1, 0, 0, 0, 6423, 6421, 1, 0, 0, 0, 6423, 6424, 1, 0, 0, 0, 6424, 585, 
	1, 0, 0, 0, 6425, 6432, 3, 588, 294, 0, 6426, 6427, 5, 1135, 0, 0, 6427, 
	6430, 3, 588, 294, 0, 6428, 6429, 5, 1135, 0, 0, 6429, 6431, 3, 598, 299, 
	0, 6430, 6428, 1, 0, 0, 0, 6430, 6431, 1, 0, 0, 0, 6431, 6433, 1, 0, 0, 
	0, 6432, 6426, 1, 0, 0, 0, 6432, 6433, 1, 0, 0, 0, 6433, 587, 1, 0, 0, 
	0, 6434, 6442, 5, 1148, 0, 0, 6435, 6442, 5, 1153, 0, 0, 6436, 6438, 5, 
	1150, 0, 0, 6437, 6436, 1, 0, 0, 0, 6438, 6439, 1, 0, 0, 0, 6439, 6437, 
	1, 0, 0, 0, 6439, 6440, 1, 0, 0, 0, 6440, 6442, 1, 0, 0, 0, 6441, 6434, 
	1, 0, 0, 0, 6441, 6435, 1, 0, 0, 0, 6441, 6437, 1, 0, 0, 0, 6442, 589, 
	1, 0, 0, 0, 6443, 6446, 3, 592, 296, 0, 6444, 6446, 5, 1148, 0, 0, 6445, 
	6443, 1, 0, 0, 0, 6445, 6444, 1, 0, 0, 0, 6446, 591, 1, 0, 0, 0, 6447, 
	6451, 3, 594, 297, 0, 6448, 6451, 5, 1145, 0, 0, 6449, 6451, 5, 1148, 0, 
	0, 6450, 6447, 1, 0, 0, 0, 6450, 6448, 1, 0, 0, 0, 6450, 6449, 1, 0, 0, 
	0, 6451, 593, 1, 0, 0, 0, 6452, 6462, 5, 1156, 0, 0, 6453, 6462, 3, 716, 
	358, 0, 6454, 6462, 3, 718, 359, 0, 6455, 6462, 3, 582, 291, 0, 6456, 6462, 
	3, 720, 360, 0, 6457, 6462, 3, 722, 361, 0, 6458, 6462, 3, 724, 362, 0, 
	6459, 6462, 3, 726, 363, 0, 6460, 6462, 3, 688, 344, 0, 6461, 6452, 1, 
	0, 0, 0, 6461, 6453, 1, 0, 0, 0, 6461, 6454, 1, 0, 0, 0, 6461, 6455, 1, 
	0, 0, 0, 6461, 6456, 1, 0, 0, 0, 6461, 6457, 1, 0, 0, 0, 6461, 6458, 1, 
	0, 0, 0, 6461, 6459, 1, 0, 0, 0, 6461, 6460, 1, 0, 0, 0, 6462, 595, 1, 
	0, 0, 0, 6463, 6467, 5, 1155, 0, 0, 6464, 6465, 5, 1132, 0, 0, 6465, 6467, 
	3, 592, 296, 0, 6466, 6463, 1, 0, 0, 0, 6466, 6464, 1, 0, 0, 0, 6467, 597, 
	1, 0, 0, 0, 6468, 6469, 7, 97, 0, 0, 6469, 599, 1, 0, 0, 0, 6470, 6473, 
	5, 1146, 0, 0, 6471, 6473, 3, 598, 299, 0, 6472, 6470, 1, 0, 0, 0, 6472, 
	6471, 1, 0, 0, 0, 6473, 601, 1, 0, 0, 0, 6474, 6476, 5, 1154, 0, 0, 6475, 
	6474, 1, 0, 0, 0, 6475, 6476, 1, 0, 0, 0, 6476, 6477, 1, 0, 0, 0, 6477, 
	6480, 5, 1148, 0, 0, 6478, 6480, 5, 1147, 0, 0, 6479, 6475, 1, 0, 0, 0, 
	6479, 6478, 1, 0, 0, 0, 6480, 6482, 1, 0, 0, 0, 6481, 6483, 5, 1148, 0, 
	0, 6482, 6481, 1, 0, 0, 0, 6483, 6484, 1, 0, 0, 0, 6484, 6482, 1, 0, 0, 
	0, 6484, 6485, 1, 0, 0, 0, 6485, 6498, 1, 0, 0, 0, 6486, 6488, 5, 1154, 
	0, 0, 6487, 6486, 1, 0, 0, 0, 6487, 6488, 1, 0, 0, 0, 6488, 6489, 1, 0, 
	0, 0, 6489, 6492, 5, 1148, 0, 0, 6490, 6492, 5, 1147, 0, 0, 6491, 6487, 
	1, 0, 0, 0, 6491, 6490, 1, 0, 0, 0, 6492, 6495, 1, 0, 0, 0, 6493, 6494, 
	5, 27, 0, 0, 6494, 6496, 3, 578, 289, 0, 6495, 6493, 1, 0, 0, 0, 6495, 
	6496, 1, 0, 0, 0, 6496, 6498, 1, 0, 0, 0, 6497, 6479, 1, 0, 0, 0, 6497, 
	6491, 1, 0, 0, 0, 6498, 603, 1, 0, 0, 0, 6499, 6500, 7, 98, 0, 0, 6500, 
	605, 1, 0, 0, 0, 6501, 6503, 5, 1154, 0, 0, 6502, 6501, 1, 0, 0, 0, 6502, 
	6503, 1, 0, 0, 0, 6503, 6504, 1, 0, 0, 0, 6504, 6505, 5, 1150, 0, 0, 6505, 
	607, 1, 0, 0, 0, 6506, 6508, 5, 114, 0, 0, 6507, 6506, 1, 0, 0, 0, 6507, 
	6508, 1, 0, 0, 0, 6508, 6509, 1, 0, 0, 0, 6509, 6510, 7, 99, 0, 0, 6510, 
	609, 1, 0, 0, 0, 6511, 6524, 3, 602, 301, 0, 6512, 6524, 3, 598, 299, 0, 
	6513, 6514, 5, 1121, 0, 0, 6514, 6524, 3, 598, 299, 0, 6515, 6524, 3, 606, 
	303, 0, 6516, 6524, 3, 604, 302, 0, 6517, 6524, 5, 1151, 0, 0, 6518, 6524, 
	5, 1153, 0, 0, 6519, 6521, 5, 114, 0, 0, 6520, 6519, 1, 0, 0, 0, 6520, 
	6521, 1, 0, 0, 0, 6521, 6522, 1, 0, 0, 0, 6522, 6524, 7, 99, 0, 0, 6523, 
	6511, 1, 0, 0, 0, 6523, 6512, 1, 0, 0, 0, 6523, 6513, 1, 0, 0, 0, 6523, 
	6515, 1, 0, 0, 0, 6523, 6516, 1, 0, 0, 0, 6523, 6517, 1, 0, 0, 0, 6523, 
	6518, 1, 0, 0, 0, 6523, 6520, 1, 0, 0, 0, 6524, 611, 1, 0, 0, 0, 6525, 
	6527, 7, 100, 0, 0, 6526, 6528, 5, 238, 0, 0, 6527, 6526, 1, 0, 0, 0, 6527, 
	6528, 1, 0, 0, 0, 6528, 6530, 1, 0, 0, 0, 6529, 6531, 3, 618, 309, 0, 6530, 
	6529, 1, 0, 0, 0, 6530, 6531, 1, 0, 0, 0, 6531, 6533, 1, 0, 0, 0, 6532, 
	6534, 5, 226, 0, 0, 6533, 6532, 1, 0, 0, 0, 6533, 6534, 1, 0, 0, 0, 6534, 
	6538, 1, 0, 0, 0, 6535, 6536, 3, 60, 30, 0, 6536, 6537, 3, 576, 288, 0, 
	6537, 6539, 1, 0, 0, 0, 6538, 6535, 1, 0, 0, 0, 6538, 6539, 1, 0, 0, 0, 
	6539, 6543, 1, 0, 0, 0, 6540, 6541, 5, 27, 0, 0, 6541, 6544, 3, 578, 289, 
	0, 6542, 6544, 5, 226, 0, 0, 6543, 6540, 1, 0, 0, 0, 6543, 6542, 1, 0, 
	0, 0, 6543, 6544, 1, 0, 0, 0, 6544, 6652, 1, 0, 0, 0, 6545, 6546, 5, 225, 
	0, 0, 6546, 6547, 7, 101, 0, 0, 6547, 6549, 5, 238, 0, 0, 6548, 6550, 3, 
	618, 309, 0, 6549, 6548, 1, 0, 0, 0, 6549, 6550, 1, 0, 0, 0, 6550, 6552, 
	1, 0, 0, 0, 6551, 6553, 5, 226, 0, 0, 6552, 6551, 1, 0, 0, 0, 6552, 6553, 
	1, 0, 0, 0, 6553, 6652, 1, 0, 0, 0, 6554, 6555, 5, 225, 0, 0, 6555, 6557, 
	7, 102, 0, 0, 6556, 6558, 3, 618, 309, 0, 6557, 6556, 1, 0, 0, 0, 6557, 
	6558, 1, 0, 0, 0, 6558, 6560, 1, 0, 0, 0, 6559, 6561, 5, 226, 0, 0, 6560, 
	6559, 1, 0, 0, 0, 6560, 6561, 1, 0, 0, 0, 6561, 6652, 1, 0, 0, 0, 6562, 
	6563, 5, 518, 0, 0, 6563, 6565, 5, 223, 0, 0, 6564, 6566, 3, 618, 309, 
	0, 6565, 6564, 1, 0, 0, 0, 6565, 6566, 1, 0, 0, 0, 6566, 6568, 1, 0, 0, 
	0, 6567, 6569, 5, 226, 0, 0, 6568, 6567, 1, 0, 0, 0, 6568, 6569, 1, 0, 
	0, 0, 6569, 6652, 1, 0, 0, 0, 6570, 6572, 7, 103, 0, 0, 6571, 6573, 3, 
	618, 309, 0, 6572, 6571, 1, 0, 0, 0, 6572, 6573, 1, 0, 0, 0, 6573, 6577, 
	1, 0, 0, 0, 6574, 6576, 7, 104, 0, 0, 6575, 6574, 1, 0, 0, 0, 6576, 6579, 
	1, 0, 0, 0, 6577, 6575, 1, 0, 0, 0, 6577, 6578, 1, 0, 0, 0, 6578, 6652, 
	1, 0, 0, 0, 6579, 6577, 1, 0, 0, 0, 6580, 6582, 5, 208, 0, 0, 6581, 6583, 
	3, 620, 310, 0, 6582, 6581, 1, 0, 0, 0, 6582, 6583, 1, 0, 0, 0, 6583, 6587, 
	1, 0, 0, 0, 6584, 6586, 7, 104, 0, 0, 6585, 6584, 1, 0, 0, 0, 6586, 6589, 
	1, 0, 0, 0, 6587, 6585, 1, 0, 0, 0, 6587, 6588, 1, 0, 0, 0, 6588, 6652, 
	1, 0, 0, 0, 6589, 6587, 1, 0, 0, 0, 6590, 6592, 5, 209, 0, 0, 6591, 6593, 
	5, 210, 0, 0, 6592, 6591, 1, 0, 0, 0, 6592, 6593, 1, 0, 0, 0, 6593, 6595, 
	1, 0, 0, 0, 6594, 6596, 3, 620, 310, 0, 6595, 6594, 1, 0, 0, 0, 6595, 6596, 
	1, 0, 0, 0, 6596, 6600, 1, 0, 0, 0, 6597, 6599, 7, 104, 0, 0, 6598, 6597, 
	1, 0, 0, 0, 6599, 6602, 1, 0, 0, 0, 6600, 6598, 1, 0, 0, 0, 6600, 6601, 
	1, 0, 0, 0, 6601, 6652, 1, 0, 0, 0, 6602, 6600, 1, 0, 0, 0, 6603, 6605, 
	7, 105, 0, 0, 6604, 6606, 3, 622, 311, 0, 6605, 6604, 1, 0, 0, 0, 6605, 
	6606, 1, 0, 0, 0, 6606, 6610, 1, 0, 0, 0, 6607, 6609, 7, 104, 0, 0, 6608, 
	6607, 1, 0, 0, 0, 6609, 6612, 1, 0, 0, 0, 6610, 6608, 1, 0, 0, 0, 6610, 
	6611, 1, 0, 0, 0, 6611, 6652, 1, 0, 0, 0, 6612, 6610, 1, 0, 0, 0, 6613, 
	6652, 7, 106, 0, 0, 6614, 6616, 7, 107, 0, 0, 6615, 6617, 3, 618, 309, 
	0, 6616, 6615, 1, 0, 0, 0, 6616, 6617, 1, 0, 0, 0, 6617, 6652, 1, 0, 0, 
	0, 6618, 6619, 7, 108, 0, 0, 6619, 6621, 3, 614, 307, 0, 6620, 6622, 5, 
	226, 0, 0, 6621, 6620, 1, 0, 0, 0, 6621, 6622, 1, 0, 0, 0, 6622, 6626, 
	1, 0, 0, 0, 6623, 6624, 3, 60, 30, 0, 6624, 6625, 3, 576, 288, 0, 6625, 
	6627, 1, 0, 0, 0, 6626, 6623, 1, 0, 0, 0, 6626, 6627, 1, 0, 0, 0, 6627, 
	6652, 1, 0, 0, 0, 6628, 6631, 7, 109, 0, 0, 6629, 6630, 5, 1012, 0, 0, 
	6630, 6632, 3, 598, 299, 0, 6631, 6629, 1, 0, 0, 0, 6631, 6632, 1, 0, 0, 
	0, 6632, 6652, 1, 0, 0, 0, 6633, 6635, 5, 231, 0, 0, 6634, 6636, 5, 223, 
	0, 0, 6635, 6634, 1, 0, 0, 0, 6635, 6636, 1, 0, 0, 0, 6636, 6638, 1, 0, 
	0, 0, 6637, 6639, 5, 226, 0, 0, 6638, 6637, 1, 0, 0, 0, 6638, 6639, 1, 
	0, 0, 0, 6639, 6643, 1, 0, 0, 0, 6640, 6641, 3, 60, 30, 0, 6641, 6642, 
	3, 576, 288, 0, 6642, 6644, 1, 0, 0, 0, 6643, 6640, 1, 0, 0, 0, 6643, 6644, 
	1, 0, 0, 0, 6644, 6647, 1, 0, 0, 0, 6645, 6646, 5, 27, 0, 0, 6646, 6648, 
	3, 578, 289, 0, 6647, 6645, 1, 0, 0, 0, 6647, 6648, 1, 0, 0, 0, 6648, 6652, 
	1, 0, 0, 0, 6649, 6650, 5, 231, 0, 0, 6650, 6652, 5, 227, 0, 0, 6651, 6525, 
	1, 0, 0, 0, 6651, 6545, 1, 0, 0, 0, 6651, 6554, 1, 0, 0, 0, 6651, 6562, 
	1, 0, 0, 0, 6651, 6570, 1, 0, 0, 0, 6651, 6580, 1, 0, 0, 0, 6651, 6590, 
	1, 0, 0, 0, 6651, 6603, 1, 0, 0, 0, 6651, 6613, 1, 0, 0, 0, 6651, 6614, 
	1, 0, 0, 0, 6651, 6618, 1, 0, 0, 0, 6651, 6628, 1, 0, 0, 0, 6651, 6633, 
	1, 0, 0, 0, 6651, 6649, 1, 0, 0, 0, 6652, 613, 1, 0, 0, 0, 6653, 6654, 
	5, 1133, 0, 0, 6654, 6659, 5, 1148, 0, 0, 6655, 6656, 5, 1135, 0, 0, 6656, 
	6658, 5, 1148, 0, 0, 6657, 6655, 1, 0, 0, 0, 6658, 6661, 1, 0, 0, 0, 6659, 
	6657, 1, 0, 0, 0, 6659, 6660, 1, 0, 0, 0, 6660, 6662, 1, 0, 0, 0, 6661, 
	6659, 1, 0, 0, 0, 6662, 6663, 5, 1134, 0, 0, 6663, 615, 1, 0, 0, 0, 6664, 
	6666, 7, 110, 0, 0, 6665, 6667, 3, 618, 309, 0, 6666, 6665, 1, 0, 0, 0, 
	6666, 6667, 1, 0, 0, 0, 6667, 6687, 1, 0, 0, 0, 6668, 6670, 5, 222, 0, 
	0, 6669, 6671, 3, 618, 309, 0, 6670, 6669, 1, 0, 0, 0, 6670, 6671, 1, 0, 
	0, 0, 6671, 6675, 1, 0, 0, 0, 6672, 6673, 3, 60, 30, 0, 6673, 6674, 3, 
	576, 288, 0, 6674, 6676, 1, 0, 0, 0, 6675, 6672, 1, 0, 0, 0, 6675, 6676, 
	1, 0, 0, 0, 6676, 6687, 1, 0, 0, 0, 6677, 6687, 7, 111, 0, 0, 6678, 6680, 
	7, 112, 0, 0, 6679, 6681, 3, 622, 311, 0, 6680, 6679, 1, 0, 0, 0, 6680, 
	6681, 1, 0, 0, 0, 6681, 6687, 1, 0, 0, 0, 6682, 6684, 7, 113, 0, 0, 6683, 
	6685, 7, 114, 0, 0, 6684, 6683, 1, 0, 0, 0, 6684, 6685, 1, 0, 0, 0, 6685, 
	6687, 1, 0, 0, 0, 6686, 6664, 1, 0, 0, 0, 6686, 6668, 1, 0, 0, 0, 6686, 
	6677, 1, 0, 0, 0, 6686, 6678, 1, 0, 0, 0, 6686, 6682, 1, 0, 0, 0, 6687, 
	6689, 1, 0, 0, 0, 6688, 6690, 5, 11, 0, 0, 6689, 6688, 1, 0, 0, 0, 6689, 
	6690, 1, 0, 0, 0, 6690, 617, 1, 0, 0, 0, 6691, 6692, 5, 1133, 0, 0, 6692, 
	6693, 3, 598, 299, 0, 6693, 6694, 5, 1134, 0, 0, 6694, 619, 1, 0, 0, 0, 
	6695, 6696, 5, 1133, 0, 0, 6696, 6697, 3, 598, 299, 0, 6697, 6698, 5, 1135, 
	0, 0, 6698, 6699, 3, 598, 299, 0, 6699, 6700, 5, 1134, 0, 0, 6700, 621, 
	1, 0, 0, 0, 6701, 6702, 5, 1133, 0, 0, 6702, 6705, 3, 598, 299, 0, 6703, 
	6704, 5, 1135, 0, 0, 6704, 6706, 3, 598, 299, 0, 6705, 6703, 1, 0, 0, 0, 
	6705, 6706, 1, 0, 0, 0, 6706, 6707, 1, 0, 0, 0, 6707, 6708, 5, 1134, 0, 
	0, 6708, 623, 1, 0, 0, 0, 6709, 6714, 3, 592, 296, 0, 6710, 6711, 5, 1135, 
	0, 0, 6711, 6713, 3, 592, 296, 0, 6712, 6710, 1, 0, 0, 0, 6713, 6716, 1, 
	0, 0, 0, 6714, 6712, 1, 0, 0, 0, 6714, 6715, 1, 0, 0, 0, 6715, 625, 1, 
	0, 0, 0, 6716, 6714, 1, 0, 0, 0, 6717, 6722, 3, 564, 282, 0, 6718, 6719, 
	5, 1135, 0, 0, 6719, 6721, 3, 564, 282, 0, 6720, 6718, 1, 0, 0, 0, 6721, 
	6724, 1, 0, 0, 0, 6722, 6720, 1, 0, 0, 0, 6722, 6723, 1, 0, 0, 0, 6723, 
	627, 1, 0, 0, 0, 6724, 6722, 1, 0, 0, 0, 6725, 6730, 3, 560, 280, 0, 6726, 
	6727, 5, 1135, 0, 0, 6727, 6729, 3, 560, 280, 0, 6728, 6726, 1, 0, 0, 0, 
	6729, 6732, 1, 0, 0, 0, 6730, 6728, 1, 0, 0, 0, 6730, 6731, 1, 0, 0, 0, 
	6731, 629, 1, 0, 0, 0, 6732, 6730, 1, 0, 0, 0, 6733, 6734, 5, 1133, 0, 
	0, 6734, 6739, 3, 566, 283, 0, 6735, 6736, 5, 1135, 0, 0, 6736, 6738, 3, 
	566, 283, 0, 6737, 6735, 1, 0, 0, 0, 6738, 6741, 1, 0, 0, 0, 6739, 6737, 
	1, 0, 0, 0, 6739, 6740, 1, 0, 0, 0, 6740, 6742, 1, 0, 0, 0, 6741, 6739, 
	1, 0, 0, 0, 6742, 6743, 5, 1134, 0, 0, 6743, 631, 1, 0, 0, 0, 6744, 6749, 
	3, 696, 348, 0, 6745, 6746, 5, 1135, 0, 0, 6746, 6748, 3, 696, 348, 0, 
	6747, 6745, 1, 0, 0, 0, 6748, 6751, 1, 0, 0, 0, 6749, 6747, 1, 0, 0, 0, 
	6749, 6750, 1, 0, 0, 0, 6750, 633, 1, 0, 0, 0, 6751, 6749, 1, 0, 0, 0, 
	6752, 6757, 3, 646, 323, 0, 6753, 6754, 5, 1135, 0, 0, 6754, 6756, 3, 646, 
	323, 0, 6755, 6753, 1, 0, 0, 0, 6756, 6759, 1, 0, 0, 0, 6757, 6755, 1, 
	0, 0, 0, 6757, 6758, 1, 0, 0, 0, 6758, 635, 1, 0, 0, 0, 6759, 6757, 1, 
	0, 0, 0, 6760, 6765, 3, 610, 305, 0, 6761, 6762, 5, 1135, 0, 0, 6762, 6764, 
	3, 610, 305, 0, 6763, 6761, 1, 0, 0, 0, 6764, 6767, 1, 0, 0, 0, 6765, 6763, 
	1, 0, 0, 0, 6765, 6766, 1, 0, 0, 0, 6766, 637, 1, 0, 0, 0, 6767, 6765, 
	1, 0, 0, 0, 6768, 6773, 5, 1148, 0, 0, 6769, 6770, 5, 1135, 0, 0, 6770, 
	6772, 5, 1148, 0, 0, 6771, 6769, 1, 0, 0, 0, 6772, 6775, 1, 0, 0, 0, 6773, 
	6771, 1, 0, 0, 0, 6773, 6774, 1, 0, 0, 0, 6774, 639, 1, 0, 0, 0, 6775, 
	6773, 1, 0, 0, 0, 6776, 6781, 5, 1159, 0, 0, 6777, 6778, 5, 1135, 0, 0, 
	6778, 6780, 5, 1159, 0, 0, 6779, 6777, 1, 0, 0, 0, 6780, 6783, 1, 0, 0, 
	0, 6781, 6779, 1, 0, 0, 0, 6781, 6782, 1, 0, 0, 0, 6782, 641, 1, 0, 0, 
	0, 6783, 6781, 1, 0, 0, 0, 6784, 6811, 5, 116, 0, 0, 6785, 6786, 5, 23, 
	0, 0, 6786, 6787, 5, 1133, 0, 0, 6787, 6788, 3, 696, 348, 0, 6788, 6789, 
	5, 12, 0, 0, 6789, 6790, 3, 616, 308, 0, 6790, 6791, 5, 1134, 0, 0, 6791, 
	6811, 1, 0, 0, 0, 6792, 6794, 3, 702, 351, 0, 6793, 6792, 1, 0, 0, 0, 6793, 
	6794, 1, 0, 0, 0, 6794, 6795, 1, 0, 0, 0, 6795, 6811, 3, 610, 305, 0, 6796, 
	6800, 3, 644, 322, 0, 6797, 6798, 5, 118, 0, 0, 6798, 6799, 5, 184, 0, 
	0, 6799, 6801, 3, 644, 322, 0, 6800, 6797, 1, 0, 0, 0, 6800, 6801, 1, 0, 
	0, 0, 6801, 6811, 1, 0, 0, 0, 6802, 6803, 5, 1133, 0, 0, 6803, 6804, 3, 
	696, 348, 0, 6804, 6805, 5, 1134, 0, 0, 6805, 6811, 1, 0, 0, 0, 6806, 6807, 
	5, 1133, 0, 0, 6807, 6808, 3, 558, 279, 0, 6808, 6809, 5, 1134, 0, 0, 6809, 
	6811, 1, 0, 0, 0, 6810, 6784, 1, 0, 0, 0, 6810, 6785, 1, 0, 0, 0, 6810, 
	6793, 1, 0, 0, 0, 6810, 6796, 1, 0, 0, 0, 6810, 6802, 1, 0, 0, 0, 6810, 
	6806, 1, 0, 0, 0, 6811, 643, 1, 0, 0, 0, 6812, 6818, 7, 115, 0, 0, 6813, 
	6815, 5, 1133, 0, 0, 6814, 6816, 3, 598, 299, 0, 6815, 6814, 1, 0, 0, 0, 
	6815, 6816, 1, 0, 0, 0, 6816, 6817, 1, 0, 0, 0, 6817, 6819, 5, 1134, 0, 
	0, 6818, 6813, 1, 0, 0, 0, 6818, 6819, 1, 0, 0, 0, 6819, 6827, 1, 0, 0, 
	0, 6820, 6821, 5, 323, 0, 0, 6821, 6823, 5, 1133, 0, 0, 6822, 6824, 3, 
	598, 299, 0, 6823, 6822, 1, 0, 0, 0, 6823, 6824, 1, 0, 0, 0, 6824, 6825, 
	1, 0, 0, 0, 6825, 6827, 5, 1134, 0, 0, 6826, 6812, 1, 0, 0, 0, 6826, 6820, 
	1, 0, 0, 0, 6827, 645, 1, 0, 0, 0, 6828, 6831, 3, 696, 348, 0, 6829, 6831, 
	5, 42, 0, 0, 6830, 6828, 1, 0, 0, 0, 6830, 6829, 1, 0, 0, 0, 6831, 647, 
	1, 0, 0, 0, 6832, 6833, 5, 77, 0, 0, 6833, 6834, 5, 60, 0, 0, 6834, 649, 
	1, 0, 0, 0, 6835, 6836, 5, 77, 0, 0, 6836, 6837, 5, 114, 0, 0, 6837, 6838, 
	5, 60, 0, 0, 6838, 651, 1, 0, 0, 0, 6839, 6840, 5, 123, 0, 0, 6840, 6841, 
	5, 141, 0, 0, 6841, 653, 1, 0, 0, 0, 6842, 6843, 5, 674, 0, 0, 6843, 6846, 
	3, 598, 299, 0, 6844, 6846, 5, 527, 0, 0, 6845, 6842, 1, 0, 0, 0, 6845, 
	6844, 1, 0, 0, 0, 6846, 655, 1, 0, 0, 0, 6847, 6866, 3, 658, 329, 0, 6848, 
	6866, 3, 666, 333, 0, 6849, 6866, 3, 668, 334, 0, 6850, 6851, 3, 688, 344, 
	0, 6851, 6853, 5, 1133, 0, 0, 6852, 6854, 3, 692, 346, 0, 6853, 6852, 1, 
	0, 0, 0, 6853, 6854, 1, 0, 0, 0, 6854, 6855, 1, 0, 0, 0, 6855, 6856, 5, 
	1134, 0, 0, 6856, 6866, 1, 0, 0, 0, 6857, 6858, 3, 558, 279, 0, 6858, 6860, 
	5, 1133, 0, 0, 6859, 6861, 3, 692, 346, 0, 6860, 6859, 1, 0, 0, 0, 6860, 
	6861, 1, 0, 0, 0, 6861, 6862, 1, 0, 0, 0, 6862, 6863, 5, 1134, 0, 0, 6863, 
	6866, 1, 0, 0, 0, 6864, 6866, 3, 690, 345, 0, 6865, 6847, 1, 0, 0, 0, 6865, 
	6848, 1, 0, 0, 0, 6865, 6849, 1, 0, 0, 0, 6865, 6850, 1, 0, 0, 0, 6865, 
	6857, 1, 0, 0, 0, 6865, 6864, 1, 0, 0, 0, 6866, 657, 1, 0, 0, 0, 6867, 
	6870, 7, 116, 0, 0, 6868, 6869, 5, 1133, 0, 0, 6869, 6871, 5, 1134, 0, 
	0, 6870, 6868, 1, 0, 0, 0, 6870, 6871, 1, 0, 0, 0, 6871, 7047, 1, 0, 0, 
	0, 6872, 7047, 3, 62, 31, 0, 6873, 6874, 5, 32, 0, 0, 6874, 6875, 5, 1133, 
	0, 0, 6875, 6876, 3, 696, 348, 0, 6876, 6877, 5, 1135, 0, 0, 6877, 6878, 
	3, 616, 308, 0, 6878, 6879, 5, 1134, 0, 0, 6879, 7047, 1, 0, 0, 0, 6880, 
	6881, 5, 32, 0, 0, 6881, 6882, 5, 1133, 0, 0, 6882, 6883, 3, 696, 348, 
	0, 6883, 6884, 5, 187, 0, 0, 6884, 6885, 3, 576, 288, 0, 6885, 6886, 5, 
	1134, 0, 0, 6886, 7047, 1, 0, 0, 0, 6887, 6888, 5, 23, 0, 0, 6888, 6889, 
	5, 1133, 0, 0, 6889, 6890, 3, 696, 348, 0, 6890, 6891, 5, 12, 0, 0, 6891, 
	6892, 3, 616, 308, 0, 6892, 6893, 5, 1134, 0, 0, 6893, 7047, 1, 0, 0, 0, 
	6894, 6895, 5, 188, 0, 0, 6895, 6896, 5, 1133, 0, 0, 6896, 6897, 3, 564, 
	282, 0, 6897, 6898, 5, 1134, 0, 0, 6898, 7047, 1, 0, 0, 0, 6899, 6900, 
	5, 22, 0, 0, 6900, 6902, 3, 696, 348, 0, 6901, 6903, 3, 660, 330, 0, 6902, 
	6901, 1, 0, 0, 0, 6903, 6904, 1, 0, 0, 0, 6904, 6902, 1, 0, 0, 0, 6904, 
	6905, 1, 0, 0, 0, 6905, 6908, 1, 0, 0, 0, 6906, 6907, 5, 53, 0, 0, 6907, 
	6909, 3, 694, 347, 0, 6908, 6906, 1, 0, 0, 0, 6908, 6909, 1, 0, 0, 0, 6909, 
	6910, 1, 0, 0, 0, 6910, 6911, 5, 407, 0, 0, 6911, 7047, 1, 0, 0, 0, 6912, 
	6914, 5, 22, 0, 0, 6913, 6915, 3, 660, 330, 0, 6914, 6913, 1, 0, 0, 0, 
	6915, 6916, 1, 0, 0, 0, 6916, 6914, 1, 0, 0, 0, 6916, 6917, 1, 0, 0, 0, 
	6917, 6920, 1, 0, 0, 0, 6918, 6919, 5, 53, 0, 0, 6919, 6921, 3, 694, 347, 
	0, 6920, 6918, 1, 0, 0, 0, 6920, 6921, 1, 0, 0, 0, 6921, 6922, 1, 0, 0, 
	0, 6922, 6923, 5, 407, 0, 0, 6923, 7047, 1, 0, 0, 0, 6924, 6925, 5, 222, 
	0, 0, 6925, 6926, 5, 1133, 0, 0, 6926, 6929, 3, 692, 346, 0, 6927, 6928, 
	5, 187, 0, 0, 6928, 6930, 3, 576, 288, 0, 6929, 6927, 1, 0, 0, 0, 6929, 
	6930, 1, 0, 0, 0, 6930, 6931, 1, 0, 0, 0, 6931, 6932, 5, 1134, 0, 0, 6932, 
	7047, 1, 0, 0, 0, 6933, 6934, 5, 324, 0, 0, 6934, 6937, 5, 1133, 0, 0, 
	6935, 6938, 3, 602, 301, 0, 6936, 6938, 3, 696, 348, 0, 6937, 6935, 1, 
	0, 0, 0, 6937, 6936, 1, 0, 0, 0, 6938, 6939, 1, 0, 0, 0, 6939, 6942, 5, 
	80, 0, 0, 6940, 6943, 3, 602, 301, 0, 6941, 6943, 3, 696, 348, 0, 6942, 
	6940, 1, 0, 0, 0, 6942, 6941, 1, 0, 0, 0, 6943, 6944, 1, 0, 0, 0, 6944, 
	6945, 5, 1134, 0, 0, 6945, 7047, 1, 0, 0, 0, 6946, 6947, 7, 117, 0, 0, 
	6947, 6950, 5, 1133, 0, 0, 6948, 6951, 3, 602, 301, 0, 6949, 6951, 3, 696, 
	348, 0, 6950, 6948, 1, 0, 0, 0, 6950, 6949, 1, 0, 0, 0, 6951, 6952, 1, 
	0, 0, 0, 6952, 6955, 5, 68, 0, 0, 6953, 6956, 3, 598, 299, 0, 6954, 6956, 
	3, 696, 348, 0, 6955, 6953, 1, 0, 0, 0, 6955, 6954, 1, 0, 0, 0, 6956, 6962, 
	1, 0, 0, 0, 6957, 6960, 5, 65, 0, 0, 6958, 6961, 3, 598, 299, 0, 6959, 
	6961, 3, 696, 348, 0, 6960, 6958, 1, 0, 0, 0, 6960, 6959, 1, 0, 0, 0, 6961, 
	6963, 1, 0, 0, 0, 6962, 6957, 1, 0, 0, 0, 6962, 6963, 1, 0, 0, 0, 6963, 
	6964, 1, 0, 0, 0, 6964, 6965, 5, 1134, 0, 0, 6965, 7047, 1, 0, 0, 0, 6966, 
	6967, 5, 328, 0, 0, 6967, 6968, 5, 1133, 0, 0, 6968, 6971, 7, 118, 0, 0, 
	6969, 6972, 3, 602, 301, 0, 6970, 6972, 3, 696, 348, 0, 6971, 6969, 1, 
	0, 0, 0, 6971, 6970, 1, 0, 0, 0, 6971, 6972, 1, 0, 0, 0, 6972, 6973, 1, 
	0, 0, 0, 6973, 6976, 5, 68, 0, 0, 6974, 6977, 3, 602, 301, 0, 6975, 6977, 
	3, 696, 348, 0, 6976, 6974, 1, 0, 0, 0, 6976, 6975, 1, 0, 0, 0, 6977, 6978, 
	1, 0, 0, 0, 6978, 6979, 5, 1134, 0, 0, 6979, 7047, 1, 0, 0, 0, 6980, 6981, 
	5, 328, 0, 0, 6981, 6984, 5, 1133, 0, 0, 6982, 6985, 3, 602, 301, 0, 6983, 
	6985, 3, 696, 348, 0, 6984, 6982, 1, 0, 0, 0, 6984, 6983, 1, 0, 0, 0, 6985, 
	6986, 1, 0, 0, 0, 6986, 6989, 5, 68, 0, 0, 6987, 6990, 3, 602, 301, 0, 
	6988, 6990, 3, 696, 348, 0, 6989, 6987, 1, 0, 0, 0, 6989, 6988, 1, 0, 0, 
	0, 6990, 6991, 1, 0, 0, 0, 6991, 6992, 5, 1134, 0, 0, 6992, 7047, 1, 0, 
	0, 0, 6993, 6994, 5, 1103, 0, 0, 6994, 6997, 5, 1133, 0, 0, 6995, 6998, 
	3, 602, 301, 0, 6996, 6998, 3, 696, 348, 0, 6997, 6995, 1, 0, 0, 0, 6997, 
	6996, 1, 0, 0, 0, 6998, 7005, 1, 0, 0, 0, 6999, 7000, 5, 12, 0, 0, 7000, 
	7001, 7, 119, 0, 0, 7001, 7002, 5, 1133, 0, 0, 7002, 7003, 3, 598, 299, 
	0, 7003, 7004, 5, 1134, 0, 0, 7004, 7006, 1, 0, 0, 0, 7005, 6999, 1, 0, 
	0, 0, 7005, 7006, 1, 0, 0, 0, 7006, 7008, 1, 0, 0, 0, 7007, 7009, 3, 662, 
	331, 0, 7008, 7007, 1, 0, 0, 0, 7008, 7009, 1, 0, 0, 0, 7009, 7010, 1, 
	0, 0, 0, 7010, 7011, 5, 1134, 0, 0, 7011, 7047, 1, 0, 0, 0, 7012, 7013, 
	5, 321, 0, 0, 7013, 7014, 5, 1133, 0, 0, 7014, 7015, 3, 72, 36, 0, 7015, 
	7018, 5, 68, 0, 0, 7016, 7019, 3, 602, 301, 0, 7017, 7019, 3, 696, 348, 
	0, 7018, 7016, 1, 0, 0, 0, 7018, 7017, 1, 0, 0, 0, 7019, 7020, 1, 0, 0, 
	0, 7020, 7021, 5, 1134, 0, 0, 7021, 7047, 1, 0, 0, 0, 7022, 7023, 5, 900, 
	0, 0, 7023, 7024, 5, 1133, 0, 0, 7024, 7025, 7, 120, 0, 0, 7025, 7026, 
	5, 1135, 0, 0, 7026, 7027, 3, 602, 301, 0, 7027, 7028, 5, 1134, 0, 0, 7028, 
	7047, 1, 0, 0, 0, 7029, 7030, 5, 282, 0, 0, 7030, 7031, 5, 1133, 0, 0, 
	7031, 7032, 3, 696, 348, 0, 7032, 7033, 5, 1135, 0, 0, 7033, 7036, 3, 696, 
	348, 0, 7034, 7035, 5, 593, 0, 0, 7035, 7037, 3, 616, 308, 0, 7036, 7034, 
	1, 0, 0, 0, 7036, 7037, 1, 0, 0, 0, 7037, 7039, 1, 0, 0, 0, 7038, 7040, 
	3, 276, 138, 0, 7039, 7038, 1, 0, 0, 0, 7039, 7040, 1, 0, 0, 0, 7040, 7042, 
	1, 0, 0, 0, 7041, 7043, 3, 278, 139, 0, 7042, 7041, 1, 0, 0, 0, 7042, 7043, 
	1, 0, 0, 0, 7043, 7044, 1, 0, 0, 0, 7044, 7045, 5, 1134, 0, 0, 7045, 7047, 
	1, 0, 0, 0, 7046, 6867, 1, 0, 0, 0, 7046, 6872, 1, 0, 0, 0, 7046, 6873, 
	1, 0, 0, 0, 7046, 6880, 1, 0, 0, 0, 7046, 6887, 1, 0, 0, 0, 7046, 6894, 
	1, 0, 0, 0, 7046, 6899, 1, 0, 0, 0, 7046, 6912, 1, 0, 0, 0, 7046, 6924, 
	1, 0, 0, 0, 7046, 6933, 1, 0, 0, 0, 7046, 6946, 1, 0, 0, 0, 7046, 6966, 
	1, 0, 0, 0, 7046, 6980, 1, 0, 0, 0, 7046, 6993, 1, 0, 0, 0, 7046, 7012, 
	1, 0, 0, 0, 7046, 7022, 1, 0, 0, 0, 7046, 7029, 1, 0, 0, 0, 7047, 659, 
	1, 0, 0, 0, 7048, 7049, 5, 189, 0, 0, 7049, 7050, 3, 694, 347, 0, 7050, 
	7051, 5, 174, 0, 0, 7051, 7052, 3, 694, 347, 0, 7052, 661, 1, 0, 0, 0, 
	7053, 7054, 5, 472, 0, 0, 7054, 7059, 3, 664, 332, 0, 7055, 7056, 5, 1135, 
	0, 0, 7056, 7058, 3, 664, 332, 0, 7057, 7055, 1, 0, 0, 0, 7058, 7061, 1, 
	0, 0, 0, 7059, 7057, 1, 0, 0, 0, 7059, 7060, 1, 0, 0, 0, 7060, 7068, 1, 
	0, 0, 0, 7061, 7059, 1, 0, 0, 0, 7062, 7063, 5, 472, 0, 0, 7063, 7064, 
	3, 598, 299, 0, 7064, 7065, 5, 1121, 0, 0, 7065, 7066, 3, 598, 299, 0, 
	7066, 7068, 1, 0, 0, 0, 7067, 7053, 1, 0, 0, 0, 7067, 7062, 1, 0, 0, 0, 
	7068, 663, 1, 0, 0, 0, 7069, 7071, 3, 598, 299, 0, 7070, 7072, 7, 121, 
	0, 0, 7071, 7070, 1, 0, 0, 0, 7071, 7072, 1, 0, 0, 0, 7072, 665, 1, 0, 
	0, 0, 7073, 7074, 7, 122, 0, 0, 7074, 7076, 5, 1133, 0, 0, 7075, 7077, 
	7, 44, 0, 0, 7076, 7075, 1, 0, 0, 0, 7076, 7077, 1, 0, 0, 0, 7077, 7078, 
	1, 0, 0, 0, 7078, 7079, 3, 694, 347, 0, 7079, 7081, 5, 1134, 0, 0, 7080, 
	7082, 3, 670, 335, 0, 7081, 7080, 1, 0, 0, 0, 7081, 7082, 1, 0, 0, 0, 7082, 
	7133, 1, 0, 0, 0, 7083, 7084, 5, 290, 0, 0, 7084, 7092, 5, 1133, 0, 0, 
	7085, 7093, 5, 1117, 0, 0, 7086, 7088, 5, 6, 0, 0, 7087, 7086, 1, 0, 0, 
	0, 7087, 7088, 1, 0, 0, 0, 7088, 7089, 1, 0, 0, 0, 7089, 7093, 3, 694, 
	347, 0, 7090, 7091, 5, 49, 0, 0, 7091, 7093, 3, 692, 346, 0, 7092, 7085, 
	1, 0, 0, 0, 7092, 7087, 1, 0, 0, 0, 7092, 7090, 1, 0, 0, 0, 7093, 7094, 
	1, 0, 0, 0, 7094, 7096, 5, 1134, 0, 0, 7095, 7097, 3, 670, 335, 0, 7096, 
	7095, 1, 0, 0, 0, 7096, 7097, 1, 0, 0, 0, 7097, 7133, 1, 0, 0, 0, 7098, 
	7099, 7, 123, 0, 0, 7099, 7101, 5, 1133, 0, 0, 7100, 7102, 5, 6, 0, 0, 
	7101, 7100, 1, 0, 0, 0, 7101, 7102, 1, 0, 0, 0, 7102, 7103, 1, 0, 0, 0, 
	7103, 7104, 3, 694, 347, 0, 7104, 7106, 5, 1134, 0, 0, 7105, 7107, 3, 670, 
	335, 0, 7106, 7105, 1, 0, 0, 0, 7106, 7107, 1, 0, 0, 0, 7107, 7133, 1, 
	0, 0, 0, 7108, 7109, 5, 294, 0, 0, 7109, 7111, 5, 1133, 0, 0, 7110, 7112, 
	5, 49, 0, 0, 7111, 7110, 1, 0, 0, 0, 7111, 7112, 1, 0, 0, 0, 7112, 7113, 
	1, 0, 0, 0, 7113, 7124, 3, 692, 346, 0, 7114, 7115, 5, 124, 0, 0, 7115, 
	7116, 5, 19, 0, 0, 7116, 7121, 3, 232, 116, 0, 7117, 7118, 5, 1135, 0, 
	0, 7118, 7120, 3, 232, 116, 0, 7119, 7117, 1, 0, 0, 0, 7120, 7123, 1, 0, 
	0, 0, 7121, 7119, 1, 0, 0, 0, 7121, 7122, 1, 0, 0, 0, 7122, 7125, 1, 0, 
	0, 0, 7123, 7121, 1, 0, 0, 0, 7124, 7114, 1, 0, 0, 0, 7124, 7125, 1, 0, 
	0, 0, 7125, 7128, 1, 0, 0, 0, 7126, 7127, 5, 154, 0, 0, 7127, 7129, 5, 
	1148, 0, 0, 7128, 7126, 1, 0, 0, 0, 7128, 7129, 1, 0, 0, 0, 7129, 7130, 
	1, 0, 0, 0, 7130, 7131, 5, 1134, 0, 0, 7131, 7133, 1, 0, 0, 0, 7132, 7073, 
	1, 0, 0, 0, 7132, 7083, 1, 0, 0, 0, 7132, 7098, 1, 0, 0, 0, 7132, 7108, 
	1, 0, 0, 0, 7133, 667, 1, 0, 0, 0, 7134, 7135, 7, 124, 0, 0, 7135, 7136, 
	5, 1133, 0, 0, 7136, 7139, 3, 696, 348, 0, 7137, 7138, 5, 1135, 0, 0, 7138, 
	7140, 3, 598, 299, 0, 7139, 7137, 1, 0, 0, 0, 7139, 7140, 1, 0, 0, 0, 7140, 
	7143, 1, 0, 0, 0, 7141, 7142, 5, 1135, 0, 0, 7142, 7144, 3, 598, 299, 0, 
	7143, 7141, 1, 0, 0, 0, 7143, 7144, 1, 0, 0, 0, 7144, 7145, 1, 0, 0, 0, 
	7145, 7146, 5, 1134, 0, 0, 7146, 7147, 3, 670, 335, 0, 7147, 7173, 1, 0, 
	0, 0, 7148, 7149, 7, 125, 0, 0, 7149, 7150, 5, 1133, 0, 0, 7150, 7151, 
	3, 696, 348, 0, 7151, 7152, 5, 1134, 0, 0, 7152, 7153, 3, 670, 335, 0, 
	7153, 7173, 1, 0, 0, 0, 7154, 7155, 7, 126, 0, 0, 7155, 7156, 5, 1133, 
	0, 0, 7156, 7157, 5, 1134, 0, 0, 7157, 7173, 3, 670, 335, 0, 7158, 7159, 
	5, 301, 0, 0, 7159, 7160, 5, 1133, 0, 0, 7160, 7161, 3, 696, 348, 0, 7161, 
	7162, 5, 1135, 0, 0, 7162, 7163, 3, 598, 299, 0, 7163, 7164, 5, 1134, 0, 
	0, 7164, 7165, 3, 670, 335, 0, 7165, 7173, 1, 0, 0, 0, 7166, 7167, 5, 300, 
	0, 0, 7167, 7168, 5, 1133, 0, 0, 7168, 7169, 3, 598, 299, 0, 7169, 7170, 
	5, 1134, 0, 0, 7170, 7171, 3, 670, 335, 0, 7171, 7173, 1, 0, 0, 0, 7172, 
	7134, 1, 0, 0, 0, 7172, 7148, 1, 0, 0, 0, 7172, 7154, 1, 0, 0, 0, 7172, 
	7158, 1, 0, 0, 0, 7172, 7166, 1, 0, 0, 0, 7173, 669, 1, 0, 0, 0, 7174, 
	7180, 5, 128, 0, 0, 7175, 7176, 5, 1133, 0, 0, 7176, 7177, 3, 672, 336, 
	0, 7177, 7178, 5, 1134, 0, 0, 7178, 7181, 1, 0, 0, 0, 7179, 7181, 3, 674, 
	337, 0, 7180, 7175, 1, 0, 0, 0, 7180, 7179, 1, 0, 0, 0, 7181, 671, 1, 0, 
	0, 0, 7182, 7184, 3, 674, 337, 0, 7183, 7182, 1, 0, 0, 0, 7183, 7184, 1, 
	0, 0, 0, 7184, 7186, 1, 0, 0, 0, 7185, 7187, 3, 686, 343, 0, 7186, 7185, 
	1, 0, 0, 0, 7186, 7187, 1, 0, 0, 0, 7187, 7189, 1, 0, 0, 0, 7188, 7190, 
	3, 230, 115, 0, 7189, 7188, 1, 0, 0, 0, 7189, 7190, 1, 0, 0, 0, 7190, 7192, 
	1, 0, 0, 0, 7191, 7193, 3, 676, 338, 0, 7192, 7191, 1, 0, 0, 0, 7192, 7193, 
	1, 0, 0, 0, 7193, 673, 1, 0, 0, 0, 7194, 7195, 3, 592, 296, 0, 7195, 675, 
	1, 0, 0, 0, 7196, 7197, 3, 678, 339, 0, 7197, 7198, 3, 680, 340, 0, 7198, 
	677, 1, 0, 0, 0, 7199, 7200, 7, 127, 0, 0, 7200, 679, 1, 0, 0, 0, 7201, 
	7204, 3, 684, 342, 0, 7202, 7204, 3, 682, 341, 0, 7203, 7201, 1, 0, 0, 
	0, 7203, 7202, 1, 0, 0, 0, 7204, 681, 1, 0, 0, 0, 7205, 7206, 5, 16, 0, 
	0, 7206, 7207, 3, 684, 342, 0, 7207, 7208, 5, 10, 0, 0, 7208, 7209, 3, 
	684, 342, 0, 7209, 683, 1, 0, 0, 0, 7210, 7211, 5, 35, 0, 0, 7211, 7218, 
	5, 600, 0, 0, 7212, 7213, 5, 657, 0, 0, 7213, 7218, 7, 128, 0, 0, 7214, 
	7215, 3, 696, 348, 0, 7215, 7216, 7, 128, 0, 0, 7216, 7218, 1, 0, 0, 0, 
	7217, 7210, 1, 0, 0, 0, 7217, 7212, 1, 0, 0, 0, 7217, 7214, 1, 0, 0, 0, 
	7218, 685, 1, 0, 0, 0, 7219, 7220, 5, 129, 0, 0, 7220, 7221, 5, 19, 0, 
	0, 7221, 7226, 3, 696, 348, 0, 7222, 7223, 5, 1135, 0, 0, 7223, 7225, 3, 
	696, 348, 0, 7224, 7222, 1, 0, 0, 0, 7225, 7228, 1, 0, 0, 0, 7226, 7224, 
	1, 0, 0, 0, 7226, 7227, 1, 0, 0, 0, 7227, 687, 1, 0, 0, 0, 7228, 7226, 
	1, 0, 0, 0, 7229, 7254, 3, 728, 364, 0, 7230, 7254, 5, 747, 0, 0, 7231, 
	7254, 5, 317, 0, 0, 7232, 7254, 5, 313, 0, 0, 7233, 7254, 5, 314, 0, 0, 
	7234, 7254, 5, 315, 0, 0, 7235, 7254, 5, 318, 0, 0, 7236, 7254, 5, 319, 
	0, 0, 7237, 7254, 5, 320, 0, 0, 7238, 7254, 5, 77, 0, 0, 7239, 7254, 5, 
	85, 0, 0, 7240, 7254, 5, 316, 0, 0, 7241, 7254, 5, 322, 0, 0, 7242, 7254, 
	5, 508, 0, 0, 7243, 7254, 5, 323, 0, 0, 7244, 7254, 5, 140, 0, 0, 7245, 
	7254, 5, 141, 0, 0, 7246, 7254, 5, 325, 0, 0, 7247, 7254, 5, 326, 0, 0, 
	7248, 7254, 5, 327, 0, 0, 7249, 7254, 5, 328, 0, 0, 7250, 7254, 5, 329, 
	0, 0, 7251, 7254, 5, 330, 0, 0, 7252, 7254, 5, 331, 0, 0, 7253, 7229, 1, 
	0, 0, 0, 7253, 7230, 1, 0, 0, 0, 7253, 7231, 1, 0, 0, 0, 7253, 7232, 1, 
	0, 0, 0, 7253, 7233, 1, 0, 0, 0, 7253, 7234, 1, 0, 0, 0, 7253, 7235, 1, 
	0, 0, 0, 7253, 7236, 1, 0, 0, 0, 7253, 7237, 1, 0, 0, 0, 7253, 7238, 1, 
	0, 0, 0, 7253, 7239, 1, 0, 0, 0, 7253, 7240, 1, 0, 0, 0, 7253, 7241, 1, 
	0, 0, 0, 7253, 7242, 1, 0, 0, 0, 7253, 7243, 1, 0, 0, 0, 7253, 7244, 1, 
	0, 0, 0, 7253, 7245, 1, 0, 0, 0, 7253, 7246, 1, 0, 0, 0, 7253, 7247, 1, 
	0, 0, 0, 7253, 7248, 1, 0, 0, 0, 7253, 7249, 1, 0, 0, 0, 7253, 7250, 1, 
	0, 0, 0, 7253, 7251, 1, 0, 0, 0, 7253, 7252, 1, 0, 0, 0, 7254, 689, 1, 
	0, 0, 0, 7255, 7256, 7, 129, 0, 0, 7256, 7257, 5, 1133, 0, 0, 7257, 7258, 
	3, 694, 347, 0, 7258, 7259, 5, 1134, 0, 0, 7259, 691, 1, 0, 0, 0, 7260, 
	7265, 3, 610, 305, 0, 7261, 7265, 3, 564, 282, 0, 7262, 7265, 3, 656, 328, 
	0, 7263, 7265, 3, 696, 348, 0, 7264, 7260, 1, 0, 0, 0, 7264, 7261, 1, 0, 
	0, 0, 7264, 7262, 1, 0, 0, 0, 7264, 7263, 1, 0, 0, 0, 7265, 7275, 1, 0, 
	0, 0, 7266, 7271, 5, 1135, 0, 0, 7267, 7272, 3, 610, 305, 0, 7268, 7272, 
	3, 564, 282, 0, 7269, 7272, 3, 656, 328, 0, 7270, 7272, 3, 696, 348, 0, 
	7271, 7267, 1, 0, 0, 0, 7271, 7268, 1, 0, 0, 0, 7271, 7269, 1, 0, 0, 0, 
	7271, 7270, 1, 0, 0, 0, 7272, 7274, 1, 0, 0, 0, 7273, 7266, 1, 0, 0, 0, 
	7274, 7277, 1, 0, 0, 0, 7275, 7273, 1, 0, 0, 0, 7275, 7276, 1, 0, 0, 0, 
	7276, 693, 1, 0, 0, 0, 7277, 7275, 1, 0, 0, 0, 7278, 7283, 3, 610, 305, 
	0, 7279, 7283, 3, 564, 282, 0, 7280, 7283, 3, 656, 328, 0, 7281, 7283, 
	3, 696, 348, 0, 7282, 7278, 1, 0, 0, 0, 7282, 7279, 1, 0, 0, 0, 7282, 7280, 
	1, 0, 0, 0, 7282, 7281, 1, 0, 0, 0, 7283, 695, 1, 0, 0, 0, 7284, 7285, 
	6, 348, -1, 0, 7285, 7286, 7, 130, 0, 0, 7286, 7296, 3, 696, 348, 4, 7287, 
	7288, 3, 698, 349, 0, 7288, 7290, 5, 88, 0, 0, 7289, 7291, 5, 114, 0, 0, 
	7290, 7289, 1, 0, 0, 0, 7290, 7291, 1, 0, 0, 0, 7291, 7292, 1, 0, 0, 0, 
	7292, 7293, 7, 131, 0, 0, 7293, 7296, 1, 0, 0, 0, 7294, 7296, 3, 698, 349, 
	0, 7295, 7284, 1, 0, 0, 0, 7295, 7287, 1, 0, 0, 0, 7295, 7294, 1, 0, 0, 
	0, 7296, 7303, 1, 0, 0, 0, 7297, 7298, 10, 3, 0, 0, 7298, 7299, 3, 706, 
	353, 0, 7299, 7300, 3, 696, 348, 4, 7300, 7302, 1, 0, 0, 0, 7301, 7297, 
	1, 0, 0, 0, 7302, 7305, 1, 0, 0, 0, 7303, 7301, 1, 0, 0, 0, 7303, 7304, 
	1, 0, 0, 0, 7304, 697, 1, 0, 0, 0, 7305, 7303, 1, 0, 0, 0, 7306, 7307, 
	6, 349, -1, 0, 7307, 7308, 3, 700, 350, 0, 7308, 7373, 1, 0, 0, 0, 7309, 
	7310, 10, 8, 0, 0, 7310, 7311, 3, 704, 352, 0, 7311, 7312, 3, 698, 349, 
	9, 7312, 7372, 1, 0, 0, 0, 7313, 7315, 10, 6, 0, 0, 7314, 7316, 5, 114, 
	0, 0, 7315, 7314, 1, 0, 0, 0, 7315, 7316, 1, 0, 0, 0, 7316, 7317, 1, 0, 
	0, 0, 7317, 7318, 5, 16, 0, 0, 7318, 7319, 3, 698, 349, 0, 7319, 7320, 
	5, 10, 0, 0, 7320, 7321, 3, 698, 349, 7, 7321, 7372, 1, 0, 0, 0, 7322, 
	7323, 10, 5, 0, 0, 7323, 7324, 5, 620, 0, 0, 7324, 7325, 5, 98, 0, 0, 7325, 
	7372, 3, 698, 349, 6, 7326, 7328, 10, 3, 0, 0, 7327, 7329, 5, 114, 0, 0, 
	7328, 7327, 1, 0, 0, 0, 7328, 7329, 1, 0, 0, 0, 7329, 7330, 1, 0, 0, 0, 
	7330, 7331, 7, 132, 0, 0, 7331, 7372, 3, 698, 349, 4, 7332, 7334, 10, 10, 
	0, 0, 7333, 7335, 5, 114, 0, 0, 7334, 7333, 1, 0, 0, 0, 7334, 7335, 1, 
	0, 0, 0, 7335, 7336, 1, 0, 0, 0, 7336, 7337, 5, 80, 0, 0, 7337, 7340, 5, 
	1133, 0, 0, 7338, 7341, 3, 200, 100, 0, 7339, 7341, 3, 632, 316, 0, 7340, 
	7338, 1, 0, 0, 0, 7340, 7339, 1, 0, 0, 0, 7341, 7342, 1, 0, 0, 0, 7342, 
	7343, 5, 1134, 0, 0, 7343, 7372, 1, 0, 0, 0, 7344, 7345, 10, 9, 0, 0, 7345, 
	7346, 5, 88, 0, 0, 7346, 7372, 3, 608, 304, 0, 7347, 7348, 10, 7, 0, 0, 
	7348, 7349, 3, 704, 352, 0, 7349, 7350, 7, 133, 0, 0, 7350, 7351, 5, 1133, 
	0, 0, 7351, 7352, 3, 200, 100, 0, 7352, 7353, 5, 1134, 0, 0, 7353, 7372, 
	1, 0, 0, 0, 7354, 7356, 10, 4, 0, 0, 7355, 7357, 5, 114, 0, 0, 7356, 7355, 
	1, 0, 0, 0, 7356, 7357, 1, 0, 0, 0, 7357, 7358, 1, 0, 0, 0, 7358, 7359, 
	5, 98, 0, 0, 7359, 7362, 3, 698, 349, 0, 7360, 7361, 5, 413, 0, 0, 7361, 
	7363, 5, 1148, 0, 0, 7362, 7360, 1, 0, 0, 0, 7362, 7363, 1, 0, 0, 0, 7363, 
	7372, 1, 0, 0, 0, 7364, 7365, 10, 2, 0, 0, 7365, 7366, 5, 505, 0, 0, 7366, 
	7367, 5, 533, 0, 0, 7367, 7368, 5, 1133, 0, 0, 7368, 7369, 3, 698, 349, 
	0, 7369, 7370, 5, 1134, 0, 0, 7370, 7372, 1, 0, 0, 0, 7371, 7309, 1, 0, 
	0, 0, 7371, 7313, 1, 0, 0, 0, 7371, 7322, 1, 0, 0, 0, 7371, 7326, 1, 0, 
	0, 0, 7371, 7332, 1, 0, 0, 0, 7371, 7344, 1, 0, 0, 0, 7371, 7347, 1, 0, 
	0, 0, 7371, 7354, 1, 0, 0, 0, 7371, 7364, 1, 0, 0, 0, 7372, 7375, 1, 0, 
	0, 0, 7373, 7371, 1, 0, 0, 0, 7373, 7374, 1, 0, 0, 0, 7374, 699, 1, 0, 
	0, 0, 7375, 7373, 1, 0, 0, 0, 7376, 7377, 6, 350, -1, 0, 7377, 7425, 3, 
	610, 305, 0, 7378, 7425, 3, 564, 282, 0, 7379, 7425, 3, 656, 328, 0, 7380, 
	7425, 3, 574, 287, 0, 7381, 7382, 3, 702, 351, 0, 7382, 7383, 3, 700, 350, 
	12, 7383, 7425, 1, 0, 0, 0, 7384, 7385, 5, 226, 0, 0, 7385, 7425, 3, 700, 
	350, 11, 7386, 7387, 5, 1159, 0, 0, 7387, 7388, 5, 1108, 0, 0, 7388, 7425, 
	3, 700, 350, 10, 7389, 7390, 5, 1133, 0, 0, 7390, 7395, 3, 696, 348, 0, 
	7391, 7392, 5, 1135, 0, 0, 7392, 7394, 3, 696, 348, 0, 7393, 7391, 1, 0, 
	0, 0, 7394, 7397, 1, 0, 0, 0, 7395, 7393, 1, 0, 0, 0, 7395, 7396, 1, 0, 
	0, 0, 7396, 7398, 1, 0, 0, 0, 7397, 7395, 1, 0, 0, 0, 7398, 7399, 5, 1134, 
	0, 0, 7399, 7425, 1, 0, 0, 0, 7400, 7401, 5, 600, 0, 0, 7401, 7402, 5, 
	1133, 0, 0, 7402, 7405, 3, 696, 348, 0, 7403, 7404, 5, 1135, 0, 0, 7404, 
	7406, 3, 696, 348, 0, 7405, 7403, 1, 0, 0, 0, 7406, 7407, 1, 0, 0, 0, 7407, 
	7405, 1, 0, 0, 0, 7407, 7408, 1, 0, 0, 0, 7408, 7409, 1, 0, 0, 0, 7409, 
	7410, 5, 1134, 0, 0, 7410, 7425, 1, 0, 0, 0, 7411, 7412, 5, 60, 0, 0, 7412, 
	7413, 5, 1133, 0, 0, 7413, 7414, 3, 200, 100, 0, 7414, 7415, 5, 1134, 0, 
	0, 7415, 7425, 1, 0, 0, 0, 7416, 7417, 5, 1133, 0, 0, 7417, 7418, 3, 200, 
	100, 0, 7418, 7419, 5, 1134, 0, 0, 7419, 7425, 1, 0, 0, 0, 7420, 7421, 
	5, 86, 0, 0, 7421, 7422, 3, 696, 348, 0, 7422, 7423, 3, 72, 36, 0, 7423, 
	7425, 1, 0, 0, 0, 7424, 7376, 1, 0, 0, 0, 7424, 7378, 1, 0, 0, 0, 7424, 
	7379, 1, 0, 0, 0, 7424, 7380, 1, 0, 0, 0, 7424, 7381, 1, 0, 0, 0, 7424, 
	7384, 1, 0, 0, 0, 7424, 7386, 1, 0, 0, 0, 7424, 7389, 1, 0, 0, 0, 7424, 
	7400, 1, 0, 0, 0, 7424, 7411, 1, 0, 0, 0, 7424, 7416, 1, 0, 0, 0, 7424, 
	7420, 1, 0, 0, 0, 7425, 7447, 1, 0, 0, 0, 7426, 7427, 10, 4, 0, 0, 7427, 
	7428, 3, 708, 354, 0, 7428, 7429, 3, 700, 350, 5, 7429, 7446, 1, 0, 0, 
	0, 7430, 7431, 10, 3, 0, 0, 7431, 7432, 3, 710, 355, 0, 7432, 7433, 3, 
	700, 350, 4, 7433, 7446, 1, 0, 0, 0, 7434, 7435, 10, 2, 0, 0, 7435, 7436, 
	3, 712, 356, 0, 7436, 7437, 3, 700, 350, 3, 7437, 7446, 1, 0, 0, 0, 7438, 
	7439, 10, 1, 0, 0, 7439, 7440, 3, 714, 357, 0, 7440, 7441, 3, 700, 350, 
	2, 7441, 7446, 1, 0, 0, 0, 7442, 7443, 10, 14, 0, 0, 7443, 7444, 5, 27, 
	0, 0, 7444, 7446, 3, 578, 289, 0, 7445, 7426, 1, 0, 0, 0, 7445, 7430, 1, 
	0, 0, 0, 7445, 7434, 1, 0, 0, 0, 7445, 7438, 1, 0, 0, 0, 7445, 7442, 1, 
	0, 0, 0, 7446, 7449, 1, 0, 0, 0, 7447, 7445, 1, 0, 0, 0, 7447, 7448, 1, 
	0, 0, 0, 7448, 701, 1, 0, 0, 0, 7449, 7447, 1, 0, 0, 0, 7450, 7451, 7, 
	134, 0, 0, 7451, 703, 1, 0, 0, 0, 7452, 7467, 5, 1124, 0, 0, 7453, 7467, 
	5, 1125, 0, 0, 7454, 7467, 5, 1126, 0, 0, 7455, 7456, 5, 1126, 0, 0, 7456, 
	7467, 5, 1124, 0, 0, 7457, 7458, 5, 1125, 0, 0, 7458, 7467, 5, 1124, 0, 
	0, 7459, 7460, 5, 1126, 0, 0, 7460, 7467, 5, 1125, 0, 0, 7461, 7462, 5, 
	1127, 0, 0, 7462, 7467, 5, 1124, 0, 0, 7463, 7464, 5, 1126, 0, 0, 7464, 
	7465, 5, 1124, 0, 0, 7465, 7467, 5, 1125, 0, 0, 7466, 7452, 1, 0, 0, 0, 
	7466, 7453, 1, 0, 0, 0, 7466, 7454, 1, 0, 0, 0, 7466, 7455, 1, 0, 0, 0, 
	7466, 7457, 1, 0, 0, 0, 7466, 7459, 1, 0, 0, 0, 7466, 7461, 1, 0, 0, 0, 
	7466, 7463, 1, 0, 0, 0, 7467, 705, 1, 0, 0, 0, 7468, 7476, 5, 10, 0, 0, 
	7469, 7470, 5, 1130, 0, 0, 7470, 7476, 5, 1130, 0, 0, 7471, 7476, 5, 194, 
	0, 0, 7472, 7476, 5, 123, 0, 0, 7473, 7474, 5, 1129, 0, 0, 7474, 7476, 
	5, 1129, 0, 0, 7475, 7468, 1, 0, 0, 0, 7475, 7469, 1, 0, 0, 0, 7475, 7471, 
	1, 0, 0, 0, 7475, 7472, 1, 0, 0, 0, 7475, 7473, 1, 0, 0, 0, 7476, 707, 
	1, 0, 0, 0, 7477, 7478, 5, 1126, 0, 0, 7478, 7485, 5, 1126, 0, 0, 7479, 
	7480, 5, 1125, 0, 0, 7480, 7485, 5, 1125, 0, 0, 7481, 7485, 5, 1130, 0, 
	0, 7482, 7485, 5, 1131, 0, 0, 7483, 7485, 5, 1129, 0, 0, 7484, 7477, 1, 
	0, 0, 0, 7484, 7479, 1, 0, 0, 0, 7484, 7481, 1, 0, 0, 0, 7484, 7482, 1, 
	0, 0, 0, 7484, 7483, 1, 0, 0, 0, 7485, 709, 1, 0, 0, 0, 7486, 7487, 7, 
	135, 0, 0, 7487, 711, 1, 0, 0, 0, 7488, 7489, 7, 136, 0, 0, 7489, 713, 
	1, 0, 0, 0, 7490, 7491, 5, 1121, 0, 0, 7491, 7496, 5, 1125, 0, 0, 7492, 
	7493, 5, 1121, 0, 0, 7493, 7494, 5, 1125, 0, 0, 7494, 7496, 5, 1125, 0, 
	0, 7495, 7490, 1, 0, 0, 0, 7495, 7492, 1, 0, 0, 0, 7496, 715, 1, 0, 0, 
	0, 7497, 7498, 7, 137, 0, 0, 7498, 717, 1, 0, 0, 0, 7499, 7500, 7, 138, 
	0, 0, 7500, 719, 1, 0, 0, 0, 7501, 7502, 7, 139, 0, 0, 7502, 721, 1, 0, 
	0, 0, 7503, 7504, 7, 140, 0, 0, 7504, 723, 1, 0, 0, 0, 7505, 7506, 7, 141, 
	0, 0, 7506, 725, 1, 0, 0, 0, 7507, 7508, 7, 142, 0, 0, 7508, 727, 1, 0, 
	0, 0, 7509, 7510, 7, 143, 0, 0, 7510, 729, 1, 0, 0, 0, 1099, 731, 735, 
	742, 745, 748, 750, 756, 759, 762, 771, 813, 828, 839, 856, 861, 876, 903, 
	912, 917, 923, 928, 932, 941, 944, 947, 951, 958, 961, 966, 974, 979, 984, 
	987, 989, 1001, 1004, 1008, 1011, 1015, 1018, 1022, 1025, 1028, 1032, 1035, 
	1039, 1045, 1051, 1057, 1064, 1071, 1074, 1078, 1083, 1089, 1098, 1103, 
	1108, 1115, 1132, 1139, 1143, 1153, 1157, 1161, 1165, 1169, 1174, 1177, 
	1180, 1183, 1186, 1192, 1196, 1202, 1207, 1210, 1213, 1215, 1226, 1230, 
	1233, 1247, 1250, 1254, 1257, 1261, 1264, 1268, 1271, 1275, 1278, 1281, 
	1285, 1288, 1292, 1298, 1311, 1317, 1328, 1333, 1341, 1349, 1354, 1357, 
	1362, 1370, 1375, 1381, 1386, 1390, 1392, 1395, 1399, 1403, 1406, 1410, 
	1414, 1418, 1424, 1427, 1434, 1439, 1445, 1452, 1458, 1466, 1469, 1476, 
	1479, 1481, 1487, 1493, 1510, 1517, 1524, 1536, 1541, 1544, 1547, 1560, 
	1573, 1578, 1594, 1602, 1612, 1615, 1618, 1624, 1628, 1631, 1642, 1645, 
	1650, 1663, 1670, 1677, 1679, 1686, 1690, 1692, 1697, 1700, 1706, 1711, 
	1713, 1717, 1720, 1723, 1729, 1734, 1736, 1741, 1748, 1750, 1757, 1762, 
	1766, 1769, 1777, 1785, 1787, 1797, 1801, 1804, 1810, 1815, 1818, 1824, 
	1827, 1831, 1834, 1838, 1843, 1848, 1853, 1857, 1861, 1865, 1869, 1873, 
	1877, 1882, 1887, 1892, 1898, 1903, 1908, 1913, 1918, 1923, 1929, 1934, 
	1939, 1944, 1949, 1954, 1959, 1964, 1971, 1976, 1981, 1986, 1990, 1995, 
	2003, 2008, 2014, 2026, 2033, 2035, 2043, 2048, 2051, 2059, 2065, 2069, 
	2082, 2094, 2096, 2099, 2107, 2113, 2119, 2132, 2139, 2148, 2153, 2164, 
	2173, 2178, 2190, 2197, 2206, 2211, 2223, 2230, 2239, 2244, 2251, 2260, 
	2265, 2267, 2272, 2280, 2289, 2293, 2296, 2300, 2305, 2311, 2317, 2322, 
	2327, 2332, 2337, 2340, 2345, 2350, 2360, 2364, 2371, 2376, 2379, 2384, 
	2387, 2391, 2395, 2403, 2422, 2425, 2428, 2432, 2442, 2455, 2462, 2465, 
	2470, 2477, 2480, 2483, 2494, 2497, 2501, 2509, 2512, 2517, 2525, 2531, 
	2535, 2539, 2544, 2549, 2556, 2560, 2571, 2579, 2582, 2588, 2594, 2596, 
	2601, 2604, 2610, 2616, 2618, 2622, 2625, 2628, 2634, 2640, 2643, 2649, 
	2655, 2657, 2662, 2670, 2672, 2681, 2684, 2687, 2692, 2694, 2703, 2706, 
	2709, 2714, 2716, 2725, 2730, 2738, 2742, 2750, 2760, 2765, 2772, 2776, 
	2780, 2799, 2809, 2815, 2832, 2836, 2846, 2851, 2854, 2863, 2874, 2882, 
	2888, 2898, 2910, 2917, 2924, 2939, 2952, 2958, 2964, 2970, 2976, 2982, 
	2988, 2993, 3000, 3007, 3014, 3019, 3022, 3024, 3038, 3045, 3052, 3058, 
	3062, 3066, 3073, 3076, 3081, 3088, 3095, 3099, 3104, 3111, 3124, 3127, 
	3132, 3137, 3141, 3147, 3156, 3165, 3174, 3177, 3181, 3190, 3194, 3197, 
	3200, 3203, 3209, 3212, 3216, 3219, 3223, 3226, 3234, 3237, 3248, 3251, 
	3256, 3259, 3264, 3274, 3279, 3285, 3287, 3293, 3295, 3301, 3309, 3314, 
	3322, 3325, 3330, 3333, 3338, 3346, 3354, 3360, 3368, 3373, 3381, 3384, 
	3388, 3391, 3399, 3405, 3414, 3417, 3421, 3425, 3429, 3434, 3438, 3442, 
	3444, 3447, 3450, 3453, 3459, 3463, 3466, 3469, 3472, 3475, 3482, 3484, 
	3488, 3493, 3499, 3504, 3511, 3517, 3522, 3525, 3531, 3535, 3543, 3547, 
	3550, 3553, 3556, 3561, 3564, 3571, 3575, 3578, 3582, 3586, 3589, 3592, 
	3595, 3600, 3606, 3610, 3620, 3626, 3630, 3636, 3640, 3646, 3649, 3661, 
	3665, 3669, 3677, 3681, 3689, 3692, 3695, 3699, 3702, 3710, 3715, 3718, 
	3721, 3725, 3728, 3731, 3740, 3745, 3754, 3759, 3766, 3773, 3781, 3787, 
	3795, 3798, 3801, 3808, 3811, 3818, 3821, 3829, 3835, 3846, 3849, 3853, 
	3859, 3868, 3873, 3877, 3883, 3889, 3891, 3895, 3904, 3914, 3924, 3928, 
	3933, 3938, 3942, 3945, 3948, 3951, 3954, 3958, 3963, 3969, 3972, 3975, 
	3978, 3981, 3984, 3986, 3992, 4000, 4011, 4019, 4025, 4028, 4031, 4034, 
	4037, 4040, 4044, 4050, 4054, 4062, 4066, 4069, 4071, 4084, 4087, 4094, 
	4104, 4107, 4112, 4114, 4118, 4126, 4132, 4141, 4154, 4158, 4164, 4173, 
	4176, 4180, 4183, 4187, 4191, 4194, 4196, 4204, 4216, 4222, 4224, 4230, 
	4232, 4234, 4240, 4248, 4256, 4260, 4264, 4273, 4278, 4298, 4303, 4309, 
	4316, 4321, 4330, 4333, 4337, 4340, 4344, 4348, 4351, 4354, 4357, 4360, 
	4364, 4368, 4371, 4374, 4377, 4380, 4387, 4391, 4406, 4410, 4422, 4430, 
	4440, 4444, 4447, 4453, 4456, 4459, 4468, 4477, 4487, 4491, 4501, 4511, 
	4519, 4522, 4531, 4534, 4538, 4543, 4547, 4556, 4559, 4590, 4593, 4596, 
	4652, 4657, 4685, 4699, 4706, 4710, 4716, 4724, 4726, 4737, 4747, 4754, 
	4760, 4768, 4773, 4781, 4789, 4797, 4805, 4811, 4816, 4821, 4826, 4832, 
	4834, 4845, 4850, 4857, 4859, 4873, 4879, 4884, 4889, 4895, 4902, 4910, 
	4918, 4923, 4929, 4932, 4940, 4947, 4956, 4959, 4976, 4984, 4992, 4996, 
	5003, 5009, 5017, 5026, 5032, 5039, 5046, 5051, 5054, 5056, 5062, 5064, 
	5068, 5070, 5077, 5082, 5086, 5092, 5101, 5107, 5114, 5120, 5126, 5131, 
	5134, 5136, 5142, 5144, 5148, 5150, 5157, 5159, 5164, 5171, 5180, 5185, 
	5194, 5201, 5206, 5209, 5211, 5217, 5219, 5222, 5230, 5235, 5240, 5244, 
	5250, 5255, 5259, 5265, 5267, 5278, 5281, 5288, 5291, 5303, 5309, 5318, 
	5327, 5332, 5341, 5347, 5358, 5364, 5369, 5373, 5379, 5384, 5388, 5391, 
	5403, 5410, 5415, 5445, 5449, 5454, 5461, 5464, 5470, 5480, 5490, 5500, 
	5506, 5515, 5521, 5528, 5530, 5540, 5544, 5548, 5558, 5563, 5635, 5653, 
	5661, 5673, 5680, 5682, 5692, 5695, 5703, 5710, 5714, 5721, 5726, 5729, 
	5732, 5741, 5745, 5749, 5772, 5779, 5783, 5790, 5797, 5800, 5816, 5819, 
	5829, 5833, 5839, 5842, 5847, 5851, 5858, 5861, 5867, 5891, 5894, 5906, 
	5909, 5919, 5927, 5931, 5938, 5941, 5950, 5956, 5962, 5972, 5974, 5980, 
	5983, 5986, 5998, 6001, 6007, 6010, 6018, 6026, 6032, 6036, 6050, 6062, 
	6069, 6072, 6079, 6086, 6091, 6104, 6115, 6121, 6126, 6139, 6141, 6146, 
	6150, 6153, 6155, 6162, 6169, 6172, 6175, 6181, 6185, 6191, 6197, 6210, 
	6215, 6223, 6226, 6231, 6236, 6244, 6247, 6255, 6259, 6266, 6272, 6275, 
	6279, 6292, 6298, 6310, 6313, 6322, 6327, 6333, 6339, 6344, 6346, 6349, 
	6353, 6355, 6359, 6365, 6368, 6371, 6377, 6386, 6394, 6398, 6403, 6423, 
	6430, 6432, 6439, 6441, 6445, 6450, 6461, 6466, 6472, 6475, 6479, 6484, 
	6487, 6491, 6495, 6497, 6502, 6507, 6520, 6523, 6527, 6530, 6533, 6538, 
	6543, 6549, 6552, 6557, 6560, 6565, 6568, 6572, 6577, 6582, 6587, 6592, 
	6595, 6600, 6605, 6610, 6616, 6621, 6626, 6631, 6635, 6638, 6643, 6647, 
	6651, 6659, 6666, 6670, 6675, 6680, 6684, 6686, 6689, 6705, 6714, 6722, 
	6730, 6739, 6749, 6757, 6765, 6773, 6781, 6793, 6800, 6810, 6815, 6818, 
	6823, 6826, 6830, 6845, 6853, 6860, 6865, 6870, 6904, 6908, 6916, 6920, 
	6929, 6937, 6942, 6950, 6955, 6960, 6962, 6971, 6976, 6984, 6989, 6997, 
	7005, 7008, 7018, 7036, 7039, 7042, 7046, 7059, 7067, 7071, 7076, 7081, 
	7087, 7092, 7096, 7101, 7106, 7111, 7121, 7124, 7128, 7132, 7139, 7143, 
	7172, 7180, 7183, 7186, 7189, 7192, 7203, 7217, 7226, 7253, 7264, 7271, 
	7275, 7282, 7290, 7295, 7303, 7315, 7328, 7334, 7340, 7356, 7362, 7371, 
	7373, 7395, 7407, 7424, 7445, 7447, 7466, 7475, 7484, 7495,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// MySqlParserInit initializes any static state used to implement MySqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMySqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MySqlParserInit() {
  staticData := &MySqlParserParserStaticData
  staticData.once.Do(mysqlparserParserInit)
}

// NewMySqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMySqlParser(input antlr.TokenStream) *MySqlParser {
	MySqlParserInit()
	this := new(MySqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &MySqlParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "MySqlParser.g4"

	return this
}


// MySqlParser tokens.
const (
	MySqlParserEOF = antlr.TokenEOF
	MySqlParserCOMMENT_START = 1
	MySqlParserCOMMENT_END = 2
	MySqlParserSPACE = 3
	MySqlParserLINE_COMMENT = 4
	MySqlParserADD = 5
	MySqlParserALL = 6
	MySqlParserALTER = 7
	MySqlParserALWAYS = 8
	MySqlParserANALYZE = 9
	MySqlParserAND = 10
	MySqlParserARRAY = 11
	MySqlParserAS = 12
	MySqlParserASC = 13
	MySqlParserATTRIBUTE = 14
	MySqlParserBEFORE = 15
	MySqlParserBETWEEN = 16
	MySqlParserBOTH = 17
	MySqlParserBUCKETS = 18
	MySqlParserBY = 19
	MySqlParserCALL = 20
	MySqlParserCASCADE = 21
	MySqlParserCASE = 22
	MySqlParserCAST = 23
	MySqlParserCHANGE = 24
	MySqlParserCHARACTER = 25
	MySqlParserCHECK = 26
	MySqlParserCOLLATE = 27
	MySqlParserCOLUMN = 28
	MySqlParserCONDITION = 29
	MySqlParserCONSTRAINT = 30
	MySqlParserCONTINUE = 31
	MySqlParserCONVERT = 32
	MySqlParserCREATE = 33
	MySqlParserCROSS = 34
	MySqlParserCURRENT = 35
	MySqlParserCURRENT_ROLE = 36
	MySqlParserCURRENT_USER = 37
	MySqlParserCURSOR = 38
	MySqlParserDATABASE = 39
	MySqlParserDATABASES = 40
	MySqlParserDECLARE = 41
	MySqlParserDEFAULT = 42
	MySqlParserDELAYED = 43
	MySqlParserDELETE = 44
	MySqlParserDESC = 45
	MySqlParserDESCRIBE = 46
	MySqlParserDETERMINISTIC = 47
	MySqlParserDIAGNOSTICS = 48
	MySqlParserDISTINCT = 49
	MySqlParserDISTINCTROW = 50
	MySqlParserDROP = 51
	MySqlParserEACH = 52
	MySqlParserELSE = 53
	MySqlParserELSEIF = 54
	MySqlParserEMPTY = 55
	MySqlParserENCLOSED = 56
	MySqlParserENFORCED = 57
	MySqlParserESCAPED = 58
	MySqlParserEXCEPT = 59
	MySqlParserEXISTS = 60
	MySqlParserEXIT = 61
	MySqlParserEXPLAIN = 62
	MySqlParserFALSE = 63
	MySqlParserFETCH = 64
	MySqlParserFOR = 65
	MySqlParserFORCE = 66
	MySqlParserFOREIGN = 67
	MySqlParserFROM = 68
	MySqlParserFULLTEXT = 69
	MySqlParserGENERATED = 70
	MySqlParserGET = 71
	MySqlParserGRANT = 72
	MySqlParserGROUP = 73
	MySqlParserHAVING = 74
	MySqlParserHIGH_PRIORITY = 75
	MySqlParserHISTOGRAM = 76
	MySqlParserIF = 77
	MySqlParserIGNORE = 78
	MySqlParserIGNORED = 79
	MySqlParserIN = 80
	MySqlParserINDEX = 81
	MySqlParserINFILE = 82
	MySqlParserINNER = 83
	MySqlParserINOUT = 84
	MySqlParserINSERT = 85
	MySqlParserINTERVAL = 86
	MySqlParserINTO = 87
	MySqlParserIS = 88
	MySqlParserITERATE = 89
	MySqlParserJOIN = 90
	MySqlParserKEY = 91
	MySqlParserKEYS = 92
	MySqlParserKILL = 93
	MySqlParserLATERAL = 94
	MySqlParserLEADING = 95
	MySqlParserLEAVE = 96
	MySqlParserLEFT = 97
	MySqlParserLIKE = 98
	MySqlParserLIMIT = 99
	MySqlParserLINEAR = 100
	MySqlParserLINES = 101
	MySqlParserLOAD = 102
	MySqlParserLOCK = 103
	MySqlParserLOCKED = 104
	MySqlParserLOOP = 105
	MySqlParserLOW_PRIORITY = 106
	MySqlParserMASTER_BIND = 107
	MySqlParserMASTER_SSL_VERIFY_SERVER_CERT = 108
	MySqlParserMATCH = 109
	MySqlParserMAXVALUE = 110
	MySqlParserMINVALUE = 111
	MySqlParserMODIFIES = 112
	MySqlParserNATURAL = 113
	MySqlParserNOT = 114
	MySqlParserNO_WRITE_TO_BINLOG = 115
	MySqlParserNULL_LITERAL = 116
	MySqlParserNUMBER = 117
	MySqlParserON = 118
	MySqlParserOPTIMIZE = 119
	MySqlParserOPTION = 120
	MySqlParserOPTIONAL = 121
	MySqlParserOPTIONALLY = 122
	MySqlParserOR = 123
	MySqlParserORDER = 124
	MySqlParserOUT = 125
	MySqlParserOUTER = 126
	MySqlParserOUTFILE = 127
	MySqlParserOVER = 128
	MySqlParserPARTITION = 129
	MySqlParserPRIMARY = 130
	MySqlParserPROCEDURE = 131
	MySqlParserPURGE = 132
	MySqlParserRANGE = 133
	MySqlParserREAD = 134
	MySqlParserREADS = 135
	MySqlParserREFERENCES = 136
	MySqlParserREGEXP = 137
	MySqlParserRELEASE = 138
	MySqlParserRENAME = 139
	MySqlParserREPEAT = 140
	MySqlParserREPLACE = 141
	MySqlParserREQUIRE = 142
	MySqlParserRESIGNAL = 143
	MySqlParserRESTRICT = 144
	MySqlParserRETAIN = 145
	MySqlParserRETURN = 146
	MySqlParserREVOKE = 147
	MySqlParserRIGHT = 148
	MySqlParserRLIKE = 149
	MySqlParserSCHEMA = 150
	MySqlParserSCHEMAS = 151
	MySqlParserSELECT = 152
	MySqlParserSET = 153
	MySqlParserSEPARATOR = 154
	MySqlParserSHOW = 155
	MySqlParserSIGNAL = 156
	MySqlParserSKIP_ = 157
	MySqlParserSKIP_QUERY_REWRITE = 158
	MySqlParserSPATIAL = 159
	MySqlParserSQL = 160
	MySqlParserSQLEXCEPTION = 161
	MySqlParserSQLSTATE = 162
	MySqlParserSQLWARNING = 163
	MySqlParserSQL_BIG_RESULT = 164
	MySqlParserSQL_CALC_FOUND_ROWS = 165
	MySqlParserSQL_SMALL_RESULT = 166
	MySqlParserSSL = 167
	MySqlParserSTACKED = 168
	MySqlParserSTARTING = 169
	MySqlParserSTATEMENT = 170
	MySqlParserSTRAIGHT_JOIN = 171
	MySqlParserTABLE = 172
	MySqlParserTERMINATED = 173
	MySqlParserTHEN = 174
	MySqlParserTO = 175
	MySqlParserTRAILING = 176
	MySqlParserTRIGGER = 177
	MySqlParserTRUE = 178
	MySqlParserUNDO = 179
	MySqlParserUNION = 180
	MySqlParserUNIQUE = 181
	MySqlParserUNLOCK = 182
	MySqlParserUNSIGNED = 183
	MySqlParserUPDATE = 184
	MySqlParserUSAGE = 185
	MySqlParserUSE = 186
	MySqlParserUSING = 187
	MySqlParserVALUES = 188
	MySqlParserWHEN = 189
	MySqlParserWHERE = 190
	MySqlParserWHILE = 191
	MySqlParserWITH = 192
	MySqlParserWRITE = 193
	MySqlParserXOR = 194
	MySqlParserZEROFILL = 195
	MySqlParserTINYINT = 196
	MySqlParserSMALLINT = 197
	MySqlParserMEDIUMINT = 198
	MySqlParserMIDDLEINT = 199
	MySqlParserINT = 200
	MySqlParserINT1 = 201
	MySqlParserINT2 = 202
	MySqlParserINT3 = 203
	MySqlParserINT4 = 204
	MySqlParserINT8 = 205
	MySqlParserINTEGER = 206
	MySqlParserBIGINT = 207
	MySqlParserREAL = 208
	MySqlParserDOUBLE = 209
	MySqlParserPRECISION = 210
	MySqlParserFLOAT = 211
	MySqlParserFLOAT4 = 212
	MySqlParserFLOAT8 = 213
	MySqlParserDECIMAL = 214
	MySqlParserDEC = 215
	MySqlParserNUMERIC = 216
	MySqlParserDATE = 217
	MySqlParserTIME = 218
	MySqlParserTIMESTAMP = 219
	MySqlParserDATETIME = 220
	MySqlParserYEAR = 221
	MySqlParserCHAR = 222
	MySqlParserVARCHAR = 223
	MySqlParserNVARCHAR = 224
	MySqlParserNATIONAL = 225
	MySqlParserBINARY = 226
	MySqlParserVARBINARY = 227
	MySqlParserTINYBLOB = 228
	MySqlParserBLOB = 229
	MySqlParserMEDIUMBLOB = 230
	MySqlParserLONG = 231
	MySqlParserLONGBLOB = 232
	MySqlParserTINYTEXT = 233
	MySqlParserTEXT = 234
	MySqlParserMEDIUMTEXT = 235
	MySqlParserLONGTEXT = 236
	MySqlParserENUM = 237
	MySqlParserVARYING = 238
	MySqlParserSERIAL = 239
	MySqlParserYEAR_MONTH = 240
	MySqlParserDAY_HOUR = 241
	MySqlParserDAY_MINUTE = 242
	MySqlParserDAY_SECOND = 243
	MySqlParserHOUR_MINUTE = 244
	MySqlParserHOUR_SECOND = 245
	MySqlParserMINUTE_SECOND = 246
	MySqlParserSECOND_MICROSECOND = 247
	MySqlParserMINUTE_MICROSECOND = 248
	MySqlParserHOUR_MICROSECOND = 249
	MySqlParserDAY_MICROSECOND = 250
	MySqlParserJSON_ARRAY = 251
	MySqlParserJSON_ARRAYAGG = 252
	MySqlParserJSON_ARRAY_APPEND = 253
	MySqlParserJSON_ARRAY_INSERT = 254
	MySqlParserJSON_CONTAINS = 255
	MySqlParserJSON_CONTAINS_PATH = 256
	MySqlParserJSON_DEPTH = 257
	MySqlParserJSON_EXTRACT = 258
	MySqlParserJSON_INSERT = 259
	MySqlParserJSON_KEYS = 260
	MySqlParserJSON_LENGTH = 261
	MySqlParserJSON_MERGE = 262
	MySqlParserJSON_MERGE_PATCH = 263
	MySqlParserJSON_MERGE_PRESERVE = 264
	MySqlParserJSON_OBJECT = 265
	MySqlParserJSON_OBJECTAGG = 266
	MySqlParserJSON_OVERLAPS = 267
	MySqlParserJSON_PRETTY = 268
	MySqlParserJSON_QUOTE = 269
	MySqlParserJSON_REMOVE = 270
	MySqlParserJSON_REPLACE = 271
	MySqlParserJSON_SCHEMA_VALID = 272
	MySqlParserJSON_SCHEMA_VALIDATION_REPORT = 273
	MySqlParserJSON_SEARCH = 274
	MySqlParserJSON_SET = 275
	MySqlParserJSON_STORAGE_FREE = 276
	MySqlParserJSON_STORAGE_SIZE = 277
	MySqlParserJSON_TABLE = 278
	MySqlParserJSON_TYPE = 279
	MySqlParserJSON_UNQUOTE = 280
	MySqlParserJSON_VALID = 281
	MySqlParserJSON_VALUE = 282
	MySqlParserNESTED = 283
	MySqlParserORDINALITY = 284
	MySqlParserPATH = 285
	MySqlParserAVG = 286
	MySqlParserBIT_AND = 287
	MySqlParserBIT_OR = 288
	MySqlParserBIT_XOR = 289
	MySqlParserCOUNT = 290
	MySqlParserCUME_DIST = 291
	MySqlParserDENSE_RANK = 292
	MySqlParserFIRST_VALUE = 293
	MySqlParserGROUP_CONCAT = 294
	MySqlParserLAG = 295
	MySqlParserLAST_VALUE = 296
	MySqlParserLEAD = 297
	MySqlParserMAX = 298
	MySqlParserMIN = 299
	MySqlParserNTILE = 300
	MySqlParserNTH_VALUE = 301
	MySqlParserPERCENT_RANK = 302
	MySqlParserRANK = 303
	MySqlParserROW_NUMBER = 304
	MySqlParserSTD = 305
	MySqlParserSTDDEV = 306
	MySqlParserSTDDEV_POP = 307
	MySqlParserSTDDEV_SAMP = 308
	MySqlParserSUM = 309
	MySqlParserVAR_POP = 310
	MySqlParserVAR_SAMP = 311
	MySqlParserVARIANCE = 312
	MySqlParserCURRENT_DATE = 313
	MySqlParserCURRENT_TIME = 314
	MySqlParserCURRENT_TIMESTAMP = 315
	MySqlParserLOCALTIME = 316
	MySqlParserCURDATE = 317
	MySqlParserCURTIME = 318
	MySqlParserDATE_ADD = 319
	MySqlParserDATE_SUB = 320
	MySqlParserEXTRACT = 321
	MySqlParserLOCALTIMESTAMP = 322
	MySqlParserNOW = 323
	MySqlParserPOSITION = 324
	MySqlParserSUBSTR = 325
	MySqlParserSUBSTRING = 326
	MySqlParserSYSDATE = 327
	MySqlParserTRIM = 328
	MySqlParserUTC_DATE = 329
	MySqlParserUTC_TIME = 330
	MySqlParserUTC_TIMESTAMP = 331
	MySqlParserACCOUNT = 332
	MySqlParserACTION = 333
	MySqlParserAFTER = 334
	MySqlParserAGGREGATE = 335
	MySqlParserALGORITHM = 336
	MySqlParserANY = 337
	MySqlParserAT = 338
	MySqlParserAUTHORS = 339
	MySqlParserAUTOCOMMIT = 340
	MySqlParserAUTOEXTEND_SIZE = 341
	MySqlParserAUTO_INCREMENT = 342
	MySqlParserAVG_ROW_LENGTH = 343
	MySqlParserBEGIN = 344
	MySqlParserBINLOG = 345
	MySqlParserBIT = 346
	MySqlParserBLOCK = 347
	MySqlParserBOOL = 348
	MySqlParserBOOLEAN = 349
	MySqlParserBTREE = 350
	MySqlParserCACHE = 351
	MySqlParserCASCADED = 352
	MySqlParserCHAIN = 353
	MySqlParserCHANGED = 354
	MySqlParserCHANNEL = 355
	MySqlParserCHECKSUM = 356
	MySqlParserPAGE_CHECKSUM = 357
	MySqlParserCIPHER = 358
	MySqlParserCLASS_ORIGIN = 359
	MySqlParserCLIENT = 360
	MySqlParserCLOSE = 361
	MySqlParserCLUSTERING = 362
	MySqlParserCOALESCE = 363
	MySqlParserCODE = 364
	MySqlParserCOLUMNS = 365
	MySqlParserCOLUMN_FORMAT = 366
	MySqlParserCOLUMN_NAME = 367
	MySqlParserCOMMENT = 368
	MySqlParserCOMMIT = 369
	MySqlParserCOMPACT = 370
	MySqlParserCOMPLETION = 371
	MySqlParserCOMPRESSED = 372
	MySqlParserCOMPRESSION = 373
	MySqlParserCONCURRENT = 374
	MySqlParserCONNECT = 375
	MySqlParserCONNECTION = 376
	MySqlParserCONSISTENT = 377
	MySqlParserCONSTRAINT_CATALOG = 378
	MySqlParserCONSTRAINT_SCHEMA = 379
	MySqlParserCONSTRAINT_NAME = 380
	MySqlParserCONTAINS = 381
	MySqlParserCONTEXT = 382
	MySqlParserCONTRIBUTORS = 383
	MySqlParserCOPY = 384
	MySqlParserCPU = 385
	MySqlParserCYCLE = 386
	MySqlParserCURSOR_NAME = 387
	MySqlParserDATA = 388
	MySqlParserDATAFILE = 389
	MySqlParserDEALLOCATE = 390
	MySqlParserDEFAULT_AUTH = 391
	MySqlParserDEFINER = 392
	MySqlParserDELAY_KEY_WRITE = 393
	MySqlParserDES_KEY_FILE = 394
	MySqlParserDIRECTORY = 395
	MySqlParserDISABLE = 396
	MySqlParserDISCARD = 397
	MySqlParserDISK = 398
	MySqlParserDO = 399
	MySqlParserDUMPFILE = 400
	MySqlParserDUPLICATE = 401
	MySqlParserDYNAMIC = 402
	MySqlParserENABLE = 403
	MySqlParserENCRYPTED = 404
	MySqlParserENCRYPTION = 405
	MySqlParserENCRYPTION_KEY_ID = 406
	MySqlParserEND = 407
	MySqlParserENDS = 408
	MySqlParserENGINE = 409
	MySqlParserENGINES = 410
	MySqlParserERROR = 411
	MySqlParserERRORS = 412
	MySqlParserESCAPE = 413
	MySqlParserEVEN = 414
	MySqlParserEVENT = 415
	MySqlParserEVENTS = 416
	MySqlParserEVERY = 417
	MySqlParserEXCHANGE = 418
	MySqlParserEXCLUSIVE = 419
	MySqlParserEXPIRE = 420
	MySqlParserEXPORT = 421
	MySqlParserEXTENDED = 422
	MySqlParserEXTENT_SIZE = 423
	MySqlParserFAILED_LOGIN_ATTEMPTS = 424
	MySqlParserFAST = 425
	MySqlParserFAULTS = 426
	MySqlParserFIELDS = 427
	MySqlParserFILE_BLOCK_SIZE = 428
	MySqlParserFILTER = 429
	MySqlParserFIRST = 430
	MySqlParserFIXED = 431
	MySqlParserFLUSH = 432
	MySqlParserFOLLOWING = 433
	MySqlParserFOLLOWS = 434
	MySqlParserFOUND = 435
	MySqlParserFULL = 436
	MySqlParserFUNCTION = 437
	MySqlParserGENERAL = 438
	MySqlParserGLOBAL = 439
	MySqlParserGRANTS = 440
	MySqlParserGROUP_REPLICATION = 441
	MySqlParserHANDLER = 442
	MySqlParserHASH = 443
	MySqlParserHELP = 444
	MySqlParserHISTORY = 445
	MySqlParserHOST = 446
	MySqlParserHOSTS = 447
	MySqlParserIDENTIFIED = 448
	MySqlParserIGNORE_SERVER_IDS = 449
	MySqlParserIMPORT = 450
	MySqlParserINCREMENT = 451
	MySqlParserINDEXES = 452
	MySqlParserINITIAL_SIZE = 453
	MySqlParserINPLACE = 454
	MySqlParserINSERT_METHOD = 455
	MySqlParserINSTALL = 456
	MySqlParserINSTANCE = 457
	MySqlParserINSTANT = 458
	MySqlParserINVISIBLE = 459
	MySqlParserINVOKER = 460
	MySqlParserIO = 461
	MySqlParserIO_THREAD = 462
	MySqlParserIPC = 463
	MySqlParserISOLATION = 464
	MySqlParserISSUER = 465
	MySqlParserJSON = 466
	MySqlParserKEY_BLOCK_SIZE = 467
	MySqlParserLANGUAGE = 468
	MySqlParserLAST = 469
	MySqlParserLEAVES = 470
	MySqlParserLESS = 471
	MySqlParserLEVEL = 472
	MySqlParserLIST = 473
	MySqlParserLOCAL = 474
	MySqlParserLOGFILE = 475
	MySqlParserLOGS = 476
	MySqlParserMASTER = 477
	MySqlParserMASTER_AUTO_POSITION = 478
	MySqlParserMASTER_CONNECT_RETRY = 479
	MySqlParserMASTER_DELAY = 480
	MySqlParserMASTER_HEARTBEAT_PERIOD = 481
	MySqlParserMASTER_HOST = 482
	MySqlParserMASTER_LOG_FILE = 483
	MySqlParserMASTER_LOG_POS = 484
	MySqlParserMASTER_PASSWORD = 485
	MySqlParserMASTER_PORT = 486
	MySqlParserMASTER_RETRY_COUNT = 487
	MySqlParserMASTER_SSL = 488
	MySqlParserMASTER_SSL_CA = 489
	MySqlParserMASTER_SSL_CAPATH = 490
	MySqlParserMASTER_SSL_CERT = 491
	MySqlParserMASTER_SSL_CIPHER = 492
	MySqlParserMASTER_SSL_CRL = 493
	MySqlParserMASTER_SSL_CRLPATH = 494
	MySqlParserMASTER_SSL_KEY = 495
	MySqlParserMASTER_TLS_VERSION = 496
	MySqlParserMASTER_USER = 497
	MySqlParserMAX_CONNECTIONS_PER_HOUR = 498
	MySqlParserMAX_QUERIES_PER_HOUR = 499
	MySqlParserMAX_ROWS = 500
	MySqlParserMAX_SIZE = 501
	MySqlParserMAX_UPDATES_PER_HOUR = 502
	MySqlParserMAX_USER_CONNECTIONS = 503
	MySqlParserMEDIUM = 504
	MySqlParserMEMBER = 505
	MySqlParserMERGE = 506
	MySqlParserMESSAGE_TEXT = 507
	MySqlParserMID = 508
	MySqlParserMIGRATE = 509
	MySqlParserMIN_ROWS = 510
	MySqlParserMODE = 511
	MySqlParserMODIFY = 512
	MySqlParserMUTEX = 513
	MySqlParserMYSQL = 514
	MySqlParserMYSQL_ERRNO = 515
	MySqlParserNAME = 516
	MySqlParserNAMES = 517
	MySqlParserNCHAR = 518
	MySqlParserNEVER = 519
	MySqlParserNEXT = 520
	MySqlParserNO = 521
	MySqlParserNOCACHE = 522
	MySqlParserNOCOPY = 523
	MySqlParserNOCYCLE = 524
	MySqlParserNOMAXVALUE = 525
	MySqlParserNOMINVALUE = 526
	MySqlParserNOWAIT = 527
	MySqlParserNODEGROUP = 528
	MySqlParserNONE = 529
	MySqlParserODBC = 530
	MySqlParserOFFLINE = 531
	MySqlParserOFFSET = 532
	MySqlParserOF = 533
	MySqlParserOJ = 534
	MySqlParserOLD_PASSWORD = 535
	MySqlParserONE = 536
	MySqlParserONLINE = 537
	MySqlParserONLY = 538
	MySqlParserOPEN = 539
	MySqlParserOPTIMIZER_COSTS = 540
	MySqlParserOPTIONS = 541
	MySqlParserOWNER = 542
	MySqlParserPACK_KEYS = 543
	MySqlParserPAGE = 544
	MySqlParserPAGE_COMPRESSED = 545
	MySqlParserPAGE_COMPRESSION_LEVEL = 546
	MySqlParserPARSER = 547
	MySqlParserPARTIAL = 548
	MySqlParserPARTITIONING = 549
	MySqlParserPARTITIONS = 550
	MySqlParserPASSWORD = 551
	MySqlParserPASSWORD_LOCK_TIME = 552
	MySqlParserPHASE = 553
	MySqlParserPLUGIN = 554
	MySqlParserPLUGIN_DIR = 555
	MySqlParserPLUGINS = 556
	MySqlParserPORT = 557
	MySqlParserPRECEDES = 558
	MySqlParserPRECEDING = 559
	MySqlParserPREPARE = 560
	MySqlParserPRESERVE = 561
	MySqlParserPREV = 562
	MySqlParserPROCESSLIST = 563
	MySqlParserPROFILE = 564
	MySqlParserPROFILES = 565
	MySqlParserPROXY = 566
	MySqlParserQUERY = 567
	MySqlParserQUICK = 568
	MySqlParserREBUILD = 569
	MySqlParserRECOVER = 570
	MySqlParserRECURSIVE = 571
	MySqlParserREDO_BUFFER_SIZE = 572
	MySqlParserREDUNDANT = 573
	MySqlParserRELAY = 574
	MySqlParserRELAY_LOG_FILE = 575
	MySqlParserRELAY_LOG_POS = 576
	MySqlParserRELAYLOG = 577
	MySqlParserREMOVE = 578
	MySqlParserREORGANIZE = 579
	MySqlParserREPAIR = 580
	MySqlParserREPLICATE_DO_DB = 581
	MySqlParserREPLICATE_DO_TABLE = 582
	MySqlParserREPLICATE_IGNORE_DB = 583
	MySqlParserREPLICATE_IGNORE_TABLE = 584
	MySqlParserREPLICATE_REWRITE_DB = 585
	MySqlParserREPLICATE_WILD_DO_TABLE = 586
	MySqlParserREPLICATE_WILD_IGNORE_TABLE = 587
	MySqlParserREPLICATION = 588
	MySqlParserRESET = 589
	MySqlParserRESTART = 590
	MySqlParserRESUME = 591
	MySqlParserRETURNED_SQLSTATE = 592
	MySqlParserRETURNING = 593
	MySqlParserRETURNS = 594
	MySqlParserREUSE = 595
	MySqlParserROLE = 596
	MySqlParserROLLBACK = 597
	MySqlParserROLLUP = 598
	MySqlParserROTATE = 599
	MySqlParserROW = 600
	MySqlParserROWS = 601
	MySqlParserROW_FORMAT = 602
	MySqlParserRTREE = 603
	MySqlParserSAVEPOINT = 604
	MySqlParserSCHEDULE = 605
	MySqlParserSECURITY = 606
	MySqlParserSEQUENCE = 607
	MySqlParserSERVER = 608
	MySqlParserSESSION = 609
	MySqlParserSHARE = 610
	MySqlParserSHARED = 611
	MySqlParserSIGNED = 612
	MySqlParserSIMPLE = 613
	MySqlParserSLAVE = 614
	MySqlParserSLOW = 615
	MySqlParserSNAPSHOT = 616
	MySqlParserSOCKET = 617
	MySqlParserSOME = 618
	MySqlParserSONAME = 619
	MySqlParserSOUNDS = 620
	MySqlParserSOURCE = 621
	MySqlParserSQL_AFTER_GTIDS = 622
	MySqlParserSQL_AFTER_MTS_GAPS = 623
	MySqlParserSQL_BEFORE_GTIDS = 624
	MySqlParserSQL_BUFFER_RESULT = 625
	MySqlParserSQL_CACHE = 626
	MySqlParserSQL_NO_CACHE = 627
	MySqlParserSQL_THREAD = 628
	MySqlParserSTART = 629
	MySqlParserSTARTS = 630
	MySqlParserSTATS_AUTO_RECALC = 631
	MySqlParserSTATS_PERSISTENT = 632
	MySqlParserSTATS_SAMPLE_PAGES = 633
	MySqlParserSTATUS = 634
	MySqlParserSTOP = 635
	MySqlParserSTORAGE = 636
	MySqlParserSTORED = 637
	MySqlParserSTRING = 638
	MySqlParserSUBCLASS_ORIGIN = 639
	MySqlParserSUBJECT = 640
	MySqlParserSUBPARTITION = 641
	MySqlParserSUBPARTITIONS = 642
	MySqlParserSUSPEND = 643
	MySqlParserSWAPS = 644
	MySqlParserSWITCHES = 645
	MySqlParserTABLE_NAME = 646
	MySqlParserTABLESPACE = 647
	MySqlParserTABLE_TYPE = 648
	MySqlParserTEMPORARY = 649
	MySqlParserTEMPTABLE = 650
	MySqlParserTHAN = 651
	MySqlParserTRADITIONAL = 652
	MySqlParserTRANSACTION = 653
	MySqlParserTRANSACTIONAL = 654
	MySqlParserTRIGGERS = 655
	MySqlParserTRUNCATE = 656
	MySqlParserUNBOUNDED = 657
	MySqlParserUNDEFINED = 658
	MySqlParserUNDOFILE = 659
	MySqlParserUNDO_BUFFER_SIZE = 660
	MySqlParserUNINSTALL = 661
	MySqlParserUNKNOWN = 662
	MySqlParserUNTIL = 663
	MySqlParserUPGRADE = 664
	MySqlParserUSER = 665
	MySqlParserUSE_FRM = 666
	MySqlParserUSER_RESOURCES = 667
	MySqlParserVALIDATION = 668
	MySqlParserVALUE = 669
	MySqlParserVARIABLES = 670
	MySqlParserVIEW = 671
	MySqlParserVIRTUAL = 672
	MySqlParserVISIBLE = 673
	MySqlParserWAIT = 674
	MySqlParserWARNINGS = 675
	MySqlParserWINDOW = 676
	MySqlParserWITHOUT = 677
	MySqlParserWORK = 678
	MySqlParserWRAPPER = 679
	MySqlParserX509 = 680
	MySqlParserXA = 681
	MySqlParserXML = 682
	MySqlParserYES = 683
	MySqlParserEUR = 684
	MySqlParserUSA = 685
	MySqlParserJIS = 686
	MySqlParserISO = 687
	MySqlParserINTERNAL = 688
	MySqlParserQUARTER = 689
	MySqlParserMONTH = 690
	MySqlParserDAY = 691
	MySqlParserHOUR = 692
	MySqlParserMINUTE = 693
	MySqlParserWEEK = 694
	MySqlParserSECOND = 695
	MySqlParserMICROSECOND = 696
	MySqlParserADMIN = 697
	MySqlParserAPPLICATION_PASSWORD_ADMIN = 698
	MySqlParserAUDIT_ABORT_EXEMPT = 699
	MySqlParserAUDIT_ADMIN = 700
	MySqlParserAUTHENTICATION_POLICY_ADMIN = 701
	MySqlParserBACKUP_ADMIN = 702
	MySqlParserBINLOG_ADMIN = 703
	MySqlParserBINLOG_ENCRYPTION_ADMIN = 704
	MySqlParserCLONE_ADMIN = 705
	MySqlParserCONNECTION_ADMIN = 706
	MySqlParserENCRYPTION_KEY_ADMIN = 707
	MySqlParserEXECUTE = 708
	MySqlParserFILE = 709
	MySqlParserFIREWALL_ADMIN = 710
	MySqlParserFIREWALL_EXEMPT = 711
	MySqlParserFIREWALL_USER = 712
	MySqlParserFLUSH_OPTIMIZER_COSTS = 713
	MySqlParserFLUSH_STATUS = 714
	MySqlParserFLUSH_TABLES = 715
	MySqlParserFLUSH_USER_RESOURCES = 716
	MySqlParserGROUP_REPLICATION_ADMIN = 717
	MySqlParserINNODB_REDO_LOG_ARCHIVE = 718
	MySqlParserINNODB_REDO_LOG_ENABLE = 719
	MySqlParserINVOKE = 720
	MySqlParserLAMBDA = 721
	MySqlParserNDB_STORED_USER = 722
	MySqlParserPASSWORDLESS_USER_ADMIN = 723
	MySqlParserPERSIST_RO_VARIABLES_ADMIN = 724
	MySqlParserPRIVILEGES = 725
	MySqlParserPROCESS = 726
	MySqlParserRELOAD = 727
	MySqlParserREPLICATION_APPLIER = 728
	MySqlParserREPLICATION_SLAVE_ADMIN = 729
	MySqlParserRESOURCE_GROUP_ADMIN = 730
	MySqlParserRESOURCE_GROUP_USER = 731
	MySqlParserROLE_ADMIN = 732
	MySqlParserROUTINE = 733
	MySqlParserS3 = 734
	MySqlParserSERVICE_CONNECTION_ADMIN = 735
	MySqlParserSESSION_VARIABLES_ADMIN = 736
	MySqlParserSET_USER_ID = 737
	MySqlParserSHOW_ROUTINE = 738
	MySqlParserSHUTDOWN = 739
	MySqlParserSUPER = 740
	MySqlParserSYSTEM_VARIABLES_ADMIN = 741
	MySqlParserTABLES = 742
	MySqlParserTABLE_ENCRYPTION_ADMIN = 743
	MySqlParserVERSION_TOKEN_ADMIN = 744
	MySqlParserXA_RECOVER_ADMIN = 745
	MySqlParserARMSCII8 = 746
	MySqlParserASCII = 747
	MySqlParserBIG5 = 748
	MySqlParserCP1250 = 749
	MySqlParserCP1251 = 750
	MySqlParserCP1256 = 751
	MySqlParserCP1257 = 752
	MySqlParserCP850 = 753
	MySqlParserCP852 = 754
	MySqlParserCP866 = 755
	MySqlParserCP932 = 756
	MySqlParserDEC8 = 757
	MySqlParserEUCJPMS = 758
	MySqlParserEUCKR = 759
	MySqlParserGB18030 = 760
	MySqlParserGB2312 = 761
	MySqlParserGBK = 762
	MySqlParserGEOSTD8 = 763
	MySqlParserGREEK = 764
	MySqlParserHEBREW = 765
	MySqlParserHP8 = 766
	MySqlParserKEYBCS2 = 767
	MySqlParserKOI8R = 768
	MySqlParserKOI8U = 769
	MySqlParserLATIN1 = 770
	MySqlParserLATIN2 = 771
	MySqlParserLATIN5 = 772
	MySqlParserLATIN7 = 773
	MySqlParserMACCE = 774
	MySqlParserMACROMAN = 775
	MySqlParserSJIS = 776
	MySqlParserSWE7 = 777
	MySqlParserTIS620 = 778
	MySqlParserUCS2 = 779
	MySqlParserUJIS = 780
	MySqlParserUTF16 = 781
	MySqlParserUTF16LE = 782
	MySqlParserUTF32 = 783
	MySqlParserUTF8 = 784
	MySqlParserUTF8MB3 = 785
	MySqlParserUTF8MB4 = 786
	MySqlParserARCHIVE = 787
	MySqlParserBLACKHOLE = 788
	MySqlParserCSV = 789
	MySqlParserFEDERATED = 790
	MySqlParserINNODB = 791
	MySqlParserMEMORY = 792
	MySqlParserMRG_MYISAM = 793
	MySqlParserMYISAM = 794
	MySqlParserNDB = 795
	MySqlParserNDBCLUSTER = 796
	MySqlParserPERFORMANCE_SCHEMA = 797
	MySqlParserTOKUDB = 798
	MySqlParserREPEATABLE = 799
	MySqlParserCOMMITTED = 800
	MySqlParserUNCOMMITTED = 801
	MySqlParserSERIALIZABLE = 802
	MySqlParserGEOMETRYCOLLECTION = 803
	MySqlParserGEOMCOLLECTION = 804
	MySqlParserGEOMETRY = 805
	MySqlParserLINESTRING = 806
	MySqlParserMULTILINESTRING = 807
	MySqlParserMULTIPOINT = 808
	MySqlParserMULTIPOLYGON = 809
	MySqlParserPOINT = 810
	MySqlParserPOLYGON = 811
	MySqlParserABS = 812
	MySqlParserACOS = 813
	MySqlParserADDDATE = 814
	MySqlParserADDTIME = 815
	MySqlParserAES_DECRYPT = 816
	MySqlParserAES_ENCRYPT = 817
	MySqlParserAREA = 818
	MySqlParserASBINARY = 819
	MySqlParserASIN = 820
	MySqlParserASTEXT = 821
	MySqlParserASWKB = 822
	MySqlParserASWKT = 823
	MySqlParserASYMMETRIC_DECRYPT = 824
	MySqlParserASYMMETRIC_DERIVE = 825
	MySqlParserASYMMETRIC_ENCRYPT = 826
	MySqlParserASYMMETRIC_SIGN = 827
	MySqlParserASYMMETRIC_VERIFY = 828
	MySqlParserATAN = 829
	MySqlParserATAN2 = 830
	MySqlParserBENCHMARK = 831
	MySqlParserBIN = 832
	MySqlParserBIT_COUNT = 833
	MySqlParserBIT_LENGTH = 834
	MySqlParserBUFFER = 835
	MySqlParserCATALOG_NAME = 836
	MySqlParserCEIL = 837
	MySqlParserCEILING = 838
	MySqlParserCENTROID = 839
	MySqlParserCHARACTER_LENGTH = 840
	MySqlParserCHARSET = 841
	MySqlParserCHAR_LENGTH = 842
	MySqlParserCOERCIBILITY = 843
	MySqlParserCOLLATION = 844
	MySqlParserCOMPRESS = 845
	MySqlParserCONCAT = 846
	MySqlParserCONCAT_WS = 847
	MySqlParserCONNECTION_ID = 848
	MySqlParserCONV = 849
	MySqlParserCONVERT_TZ = 850
	MySqlParserCOS = 851
	MySqlParserCOT = 852
	MySqlParserCRC32 = 853
	MySqlParserCREATE_ASYMMETRIC_PRIV_KEY = 854
	MySqlParserCREATE_ASYMMETRIC_PUB_KEY = 855
	MySqlParserCREATE_DH_PARAMETERS = 856
	MySqlParserCREATE_DIGEST = 857
	MySqlParserCROSSES = 858
	MySqlParserDATEDIFF = 859
	MySqlParserDATE_FORMAT = 860
	MySqlParserDAYNAME = 861
	MySqlParserDAYOFMONTH = 862
	MySqlParserDAYOFWEEK = 863
	MySqlParserDAYOFYEAR = 864
	MySqlParserDECODE = 865
	MySqlParserDEGREES = 866
	MySqlParserDES_DECRYPT = 867
	MySqlParserDES_ENCRYPT = 868
	MySqlParserDIMENSION = 869
	MySqlParserDISJOINT = 870
	MySqlParserELT = 871
	MySqlParserENCODE = 872
	MySqlParserENCRYPT = 873
	MySqlParserENDPOINT = 874
	MySqlParserENGINE_ATTRIBUTE = 875
	MySqlParserENVELOPE = 876
	MySqlParserEQUALS = 877
	MySqlParserEXP = 878
	MySqlParserEXPORT_SET = 879
	MySqlParserEXTERIORRING = 880
	MySqlParserEXTRACTVALUE = 881
	MySqlParserFIELD = 882
	MySqlParserFIND_IN_SET = 883
	MySqlParserFLOOR = 884
	MySqlParserFORMAT = 885
	MySqlParserFOUND_ROWS = 886
	MySqlParserFROM_BASE64 = 887
	MySqlParserFROM_DAYS = 888
	MySqlParserFROM_UNIXTIME = 889
	MySqlParserGEOMCOLLFROMTEXT = 890
	MySqlParserGEOMCOLLFROMWKB = 891
	MySqlParserGEOMETRYCOLLECTIONFROMTEXT = 892
	MySqlParserGEOMETRYCOLLECTIONFROMWKB = 893
	MySqlParserGEOMETRYFROMTEXT = 894
	MySqlParserGEOMETRYFROMWKB = 895
	MySqlParserGEOMETRYN = 896
	MySqlParserGEOMETRYTYPE = 897
	MySqlParserGEOMFROMTEXT = 898
	MySqlParserGEOMFROMWKB = 899
	MySqlParserGET_FORMAT = 900
	MySqlParserGET_LOCK = 901
	MySqlParserGLENGTH = 902
	MySqlParserGREATEST = 903
	MySqlParserGTID_SUBSET = 904
	MySqlParserGTID_SUBTRACT = 905
	MySqlParserHEX = 906
	MySqlParserIFNULL = 907
	MySqlParserINET6_ATON = 908
	MySqlParserINET6_NTOA = 909
	MySqlParserINET_ATON = 910
	MySqlParserINET_NTOA = 911
	MySqlParserINSTR = 912
	MySqlParserINTERIORRINGN = 913
	MySqlParserINTERSECTS = 914
	MySqlParserISCLOSED = 915
	MySqlParserISEMPTY = 916
	MySqlParserISNULL = 917
	MySqlParserISSIMPLE = 918
	MySqlParserIS_FREE_LOCK = 919
	MySqlParserIS_IPV4 = 920
	MySqlParserIS_IPV4_COMPAT = 921
	MySqlParserIS_IPV4_MAPPED = 922
	MySqlParserIS_IPV6 = 923
	MySqlParserIS_USED_LOCK = 924
	MySqlParserLAST_INSERT_ID = 925
	MySqlParserLCASE = 926
	MySqlParserLEAST = 927
	MySqlParserLENGTH = 928
	MySqlParserLINEFROMTEXT = 929
	MySqlParserLINEFROMWKB = 930
	MySqlParserLINESTRINGFROMTEXT = 931
	MySqlParserLINESTRINGFROMWKB = 932
	MySqlParserLN = 933
	MySqlParserLOAD_FILE = 934
	MySqlParserLOCATE = 935
	MySqlParserLOG = 936
	MySqlParserLOG10 = 937
	MySqlParserLOG2 = 938
	MySqlParserLOWER = 939
	MySqlParserLPAD = 940
	MySqlParserLTRIM = 941
	MySqlParserMAKEDATE = 942
	MySqlParserMAKETIME = 943
	MySqlParserMAKE_SET = 944
	MySqlParserMASTER_POS_WAIT = 945
	MySqlParserMBRCONTAINS = 946
	MySqlParserMBRDISJOINT = 947
	MySqlParserMBREQUAL = 948
	MySqlParserMBRINTERSECTS = 949
	MySqlParserMBROVERLAPS = 950
	MySqlParserMBRTOUCHES = 951
	MySqlParserMBRWITHIN = 952
	MySqlParserMD5 = 953
	MySqlParserMLINEFROMTEXT = 954
	MySqlParserMLINEFROMWKB = 955
	MySqlParserMONTHNAME = 956
	MySqlParserMPOINTFROMTEXT = 957
	MySqlParserMPOINTFROMWKB = 958
	MySqlParserMPOLYFROMTEXT = 959
	MySqlParserMPOLYFROMWKB = 960
	MySqlParserMULTILINESTRINGFROMTEXT = 961
	MySqlParserMULTILINESTRINGFROMWKB = 962
	MySqlParserMULTIPOINTFROMTEXT = 963
	MySqlParserMULTIPOINTFROMWKB = 964
	MySqlParserMULTIPOLYGONFROMTEXT = 965
	MySqlParserMULTIPOLYGONFROMWKB = 966
	MySqlParserNAME_CONST = 967
	MySqlParserNULLIF = 968
	MySqlParserNUMGEOMETRIES = 969
	MySqlParserNUMINTERIORRINGS = 970
	MySqlParserNUMPOINTS = 971
	MySqlParserOCT = 972
	MySqlParserOCTET_LENGTH = 973
	MySqlParserORD = 974
	MySqlParserOVERLAPS = 975
	MySqlParserPERIOD_ADD = 976
	MySqlParserPERIOD_DIFF = 977
	MySqlParserPI = 978
	MySqlParserPOINTFROMTEXT = 979
	MySqlParserPOINTFROMWKB = 980
	MySqlParserPOINTN = 981
	MySqlParserPOLYFROMTEXT = 982
	MySqlParserPOLYFROMWKB = 983
	MySqlParserPOLYGONFROMTEXT = 984
	MySqlParserPOLYGONFROMWKB = 985
	MySqlParserPOW = 986
	MySqlParserPOWER = 987
	MySqlParserQUOTE = 988
	MySqlParserRADIANS = 989
	MySqlParserRAND = 990
	MySqlParserRANDOM = 991
	MySqlParserRANDOM_BYTES = 992
	MySqlParserRELEASE_LOCK = 993
	MySqlParserREVERSE = 994
	MySqlParserROUND = 995
	MySqlParserROW_COUNT = 996
	MySqlParserRPAD = 997
	MySqlParserRTRIM = 998
	MySqlParserSEC_TO_TIME = 999
	MySqlParserSECONDARY_ENGINE_ATTRIBUTE = 1000
	MySqlParserSESSION_USER = 1001
	MySqlParserSHA = 1002
	MySqlParserSHA1 = 1003
	MySqlParserSHA2 = 1004
	MySqlParserSCHEMA_NAME = 1005
	MySqlParserSIGN = 1006
	MySqlParserSIN = 1007
	MySqlParserSLEEP = 1008
	MySqlParserSOUNDEX = 1009
	MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS = 1010
	MySqlParserSQRT = 1011
	MySqlParserSRID = 1012
	MySqlParserSTARTPOINT = 1013
	MySqlParserSTRCMP = 1014
	MySqlParserSTR_TO_DATE = 1015
	MySqlParserST_AREA = 1016
	MySqlParserST_ASBINARY = 1017
	MySqlParserST_ASTEXT = 1018
	MySqlParserST_ASWKB = 1019
	MySqlParserST_ASWKT = 1020
	MySqlParserST_BUFFER = 1021
	MySqlParserST_CENTROID = 1022
	MySqlParserST_CONTAINS = 1023
	MySqlParserST_CROSSES = 1024
	MySqlParserST_DIFFERENCE = 1025
	MySqlParserST_DIMENSION = 1026
	MySqlParserST_DISJOINT = 1027
	MySqlParserST_DISTANCE = 1028
	MySqlParserST_ENDPOINT = 1029
	MySqlParserST_ENVELOPE = 1030
	MySqlParserST_EQUALS = 1031
	MySqlParserST_EXTERIORRING = 1032
	MySqlParserST_GEOMCOLLFROMTEXT = 1033
	MySqlParserST_GEOMCOLLFROMTXT = 1034
	MySqlParserST_GEOMCOLLFROMWKB = 1035
	MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT = 1036
	MySqlParserST_GEOMETRYCOLLECTIONFROMWKB = 1037
	MySqlParserST_GEOMETRYFROMTEXT = 1038
	MySqlParserST_GEOMETRYFROMWKB = 1039
	MySqlParserST_GEOMETRYN = 1040
	MySqlParserST_GEOMETRYTYPE = 1041
	MySqlParserST_GEOMFROMTEXT = 1042
	MySqlParserST_GEOMFROMWKB = 1043
	MySqlParserST_INTERIORRINGN = 1044
	MySqlParserST_INTERSECTION = 1045
	MySqlParserST_INTERSECTS = 1046
	MySqlParserST_ISCLOSED = 1047
	MySqlParserST_ISEMPTY = 1048
	MySqlParserST_ISSIMPLE = 1049
	MySqlParserST_LINEFROMTEXT = 1050
	MySqlParserST_LINEFROMWKB = 1051
	MySqlParserST_LINESTRINGFROMTEXT = 1052
	MySqlParserST_LINESTRINGFROMWKB = 1053
	MySqlParserST_NUMGEOMETRIES = 1054
	MySqlParserST_NUMINTERIORRING = 1055
	MySqlParserST_NUMINTERIORRINGS = 1056
	MySqlParserST_NUMPOINTS = 1057
	MySqlParserST_OVERLAPS = 1058
	MySqlParserST_POINTFROMTEXT = 1059
	MySqlParserST_POINTFROMWKB = 1060
	MySqlParserST_POINTN = 1061
	MySqlParserST_POLYFROMTEXT = 1062
	MySqlParserST_POLYFROMWKB = 1063
	MySqlParserST_POLYGONFROMTEXT = 1064
	MySqlParserST_POLYGONFROMWKB = 1065
	MySqlParserST_SRID = 1066
	MySqlParserST_STARTPOINT = 1067
	MySqlParserST_SYMDIFFERENCE = 1068
	MySqlParserST_TOUCHES = 1069
	MySqlParserST_UNION = 1070
	MySqlParserST_WITHIN = 1071
	MySqlParserST_X = 1072
	MySqlParserST_Y = 1073
	MySqlParserSUBDATE = 1074
	MySqlParserSUBSTRING_INDEX = 1075
	MySqlParserSUBTIME = 1076
	MySqlParserSYSTEM_USER = 1077
	MySqlParserTAN = 1078
	MySqlParserTIMEDIFF = 1079
	MySqlParserTIMESTAMPADD = 1080
	MySqlParserTIMESTAMPDIFF = 1081
	MySqlParserTIME_FORMAT = 1082
	MySqlParserTIME_TO_SEC = 1083
	MySqlParserTOUCHES = 1084
	MySqlParserTO_BASE64 = 1085
	MySqlParserTO_DAYS = 1086
	MySqlParserTO_SECONDS = 1087
	MySqlParserTP_CONNECTION_ADMIN = 1088
	MySqlParserUCASE = 1089
	MySqlParserUNCOMPRESS = 1090
	MySqlParserUNCOMPRESSED_LENGTH = 1091
	MySqlParserUNHEX = 1092
	MySqlParserUNIX_TIMESTAMP = 1093
	MySqlParserUPDATEXML = 1094
	MySqlParserUPPER = 1095
	MySqlParserUUID = 1096
	MySqlParserUUID_SHORT = 1097
	MySqlParserVALIDATE_PASSWORD_STRENGTH = 1098
	MySqlParserVERSION = 1099
	MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1100
	MySqlParserWEEKDAY = 1101
	MySqlParserWEEKOFYEAR = 1102
	MySqlParserWEIGHT_STRING = 1103
	MySqlParserWITHIN = 1104
	MySqlParserYEARWEEK = 1105
	MySqlParserY_FUNCTION = 1106
	MySqlParserX_FUNCTION = 1107
	MySqlParserVAR_ASSIGN = 1108
	MySqlParserPLUS_ASSIGN = 1109
	MySqlParserMINUS_ASSIGN = 1110
	MySqlParserMULT_ASSIGN = 1111
	MySqlParserDIV_ASSIGN = 1112
	MySqlParserMOD_ASSIGN = 1113
	MySqlParserAND_ASSIGN = 1114
	MySqlParserXOR_ASSIGN = 1115
	MySqlParserOR_ASSIGN = 1116
	MySqlParserSTAR = 1117
	MySqlParserDIVIDE = 1118
	MySqlParserMODULE = 1119
	MySqlParserPLUS = 1120
	MySqlParserMINUS = 1121
	MySqlParserDIV = 1122
	MySqlParserMOD = 1123
	MySqlParserEQUAL_SYMBOL = 1124
	MySqlParserGREATER_SYMBOL = 1125
	MySqlParserLESS_SYMBOL = 1126
	MySqlParserEXCLAMATION_SYMBOL = 1127
	MySqlParserBIT_NOT_OP = 1128
	MySqlParserBIT_OR_OP = 1129
	MySqlParserBIT_AND_OP = 1130
	MySqlParserBIT_XOR_OP = 1131
	MySqlParserDOT = 1132
	MySqlParserLR_BRACKET = 1133
	MySqlParserRR_BRACKET = 1134
	MySqlParserCOMMA = 1135
	MySqlParserSEMI = 1136
	MySqlParserAT_SIGN = 1137
	MySqlParserZERO_DECIMAL = 1138
	MySqlParserONE_DECIMAL = 1139
	MySqlParserTWO_DECIMAL = 1140
	MySqlParserSINGLE_QUOTE_SYMB = 1141
	MySqlParserDOUBLE_QUOTE_SYMB = 1142
	MySqlParserREVERSE_QUOTE_SYMB = 1143
	MySqlParserCOLON_SYMB = 1144
	MySqlParserCHARSET_REVERSE_QOUTE_STRING = 1145
	MySqlParserFILESIZE_LITERAL = 1146
	MySqlParserSTART_NATIONAL_STRING_LITERAL = 1147
	MySqlParserSTRING_LITERAL = 1148
	MySqlParserDECIMAL_LITERAL = 1149
	MySqlParserHEXADECIMAL_LITERAL = 1150
	MySqlParserREAL_LITERAL = 1151
	MySqlParserNULL_SPEC_LITERAL = 1152
	MySqlParserBIT_STRING = 1153
	MySqlParserSTRING_CHARSET_NAME = 1154
	MySqlParserDOT_ID = 1155
	MySqlParserID = 1156
	MySqlParserREVERSE_QUOTE_ID = 1157
	MySqlParserHOST_IP_ADDRESS = 1158
	MySqlParserLOCAL_ID = 1159
	MySqlParserGLOBAL_ID = 1160
	MySqlParserERROR_RECONGNIGION = 1161
)

// MySqlParser rules.
const (
	MySqlParserRULE_root = 0
	MySqlParserRULE_sqlStatements = 1
	MySqlParserRULE_sqlStatement = 2
	MySqlParserRULE_emptyStatement_ = 3
	MySqlParserRULE_ddlStatement = 4
	MySqlParserRULE_dmlStatement = 5
	MySqlParserRULE_transactionStatement = 6
	MySqlParserRULE_replicationStatement = 7
	MySqlParserRULE_preparedStatement = 8
	MySqlParserRULE_compoundStatement = 9
	MySqlParserRULE_administrationStatement = 10
	MySqlParserRULE_utilityStatement = 11
	MySqlParserRULE_createDatabase = 12
	MySqlParserRULE_createEvent = 13
	MySqlParserRULE_createIndex = 14
	MySqlParserRULE_createLogfileGroup = 15
	MySqlParserRULE_createProcedure = 16
	MySqlParserRULE_createFunction = 17
	MySqlParserRULE_createRole = 18
	MySqlParserRULE_createServer = 19
	MySqlParserRULE_createTable = 20
	MySqlParserRULE_createTablespaceInnodb = 21
	MySqlParserRULE_createTablespaceNdb = 22
	MySqlParserRULE_createTrigger = 23
	MySqlParserRULE_withClause = 24
	MySqlParserRULE_commonTableExpressions = 25
	MySqlParserRULE_cteName = 26
	MySqlParserRULE_cteColumnName = 27
	MySqlParserRULE_createView = 28
	MySqlParserRULE_createDatabaseOption = 29
	MySqlParserRULE_charSet = 30
	MySqlParserRULE_currentUserExpression = 31
	MySqlParserRULE_ownerStatement = 32
	MySqlParserRULE_scheduleExpression = 33
	MySqlParserRULE_timestampValue = 34
	MySqlParserRULE_intervalExpr = 35
	MySqlParserRULE_intervalType = 36
	MySqlParserRULE_enableType = 37
	MySqlParserRULE_indexType = 38
	MySqlParserRULE_indexOption = 39
	MySqlParserRULE_procedureParameter = 40
	MySqlParserRULE_functionParameter = 41
	MySqlParserRULE_routineOption = 42
	MySqlParserRULE_serverOption = 43
	MySqlParserRULE_createDefinitions = 44
	MySqlParserRULE_createDefinition = 45
	MySqlParserRULE_columnDefinition = 46
	MySqlParserRULE_columnConstraint = 47
	MySqlParserRULE_tableConstraint = 48
	MySqlParserRULE_referenceDefinition = 49
	MySqlParserRULE_referenceAction = 50
	MySqlParserRULE_referenceControlType = 51
	MySqlParserRULE_indexColumnDefinition = 52
	MySqlParserRULE_tableOption = 53
	MySqlParserRULE_tableType = 54
	MySqlParserRULE_tablespaceStorage = 55
	MySqlParserRULE_partitionDefinitions = 56
	MySqlParserRULE_partitionFunctionDefinition = 57
	MySqlParserRULE_subpartitionFunctionDefinition = 58
	MySqlParserRULE_partitionDefinition = 59
	MySqlParserRULE_partitionDefinerAtom = 60
	MySqlParserRULE_partitionDefinerVector = 61
	MySqlParserRULE_subpartitionDefinition = 62
	MySqlParserRULE_partitionOption = 63
	MySqlParserRULE_alterDatabase = 64
	MySqlParserRULE_alterEvent = 65
	MySqlParserRULE_alterFunction = 66
	MySqlParserRULE_alterInstance = 67
	MySqlParserRULE_alterLogfileGroup = 68
	MySqlParserRULE_alterProcedure = 69
	MySqlParserRULE_alterServer = 70
	MySqlParserRULE_alterTable = 71
	MySqlParserRULE_alterTablespace = 72
	MySqlParserRULE_alterView = 73
	MySqlParserRULE_alterSpecification = 74
	MySqlParserRULE_alterPartitionSpecification = 75
	MySqlParserRULE_dropDatabase = 76
	MySqlParserRULE_dropEvent = 77
	MySqlParserRULE_dropIndex = 78
	MySqlParserRULE_dropLogfileGroup = 79
	MySqlParserRULE_dropProcedure = 80
	MySqlParserRULE_dropFunction = 81
	MySqlParserRULE_dropServer = 82
	MySqlParserRULE_dropTable = 83
	MySqlParserRULE_dropTablespace = 84
	MySqlParserRULE_dropTrigger = 85
	MySqlParserRULE_dropView = 86
	MySqlParserRULE_dropRole = 87
	MySqlParserRULE_setRole = 88
	MySqlParserRULE_renameTable = 89
	MySqlParserRULE_renameTableClause = 90
	MySqlParserRULE_truncateTable = 91
	MySqlParserRULE_callStatement = 92
	MySqlParserRULE_deleteStatement = 93
	MySqlParserRULE_doStatement = 94
	MySqlParserRULE_handlerStatement = 95
	MySqlParserRULE_insertStatement = 96
	MySqlParserRULE_loadDataStatement = 97
	MySqlParserRULE_loadXmlStatement = 98
	MySqlParserRULE_replaceStatement = 99
	MySqlParserRULE_selectStatement = 100
	MySqlParserRULE_updateStatement = 101
	MySqlParserRULE_valuesStatement = 102
	MySqlParserRULE_insertStatementValue = 103
	MySqlParserRULE_updatedElement = 104
	MySqlParserRULE_assignmentField = 105
	MySqlParserRULE_lockClause = 106
	MySqlParserRULE_singleDeleteStatement = 107
	MySqlParserRULE_multipleDeleteStatement = 108
	MySqlParserRULE_handlerOpenStatement = 109
	MySqlParserRULE_handlerReadIndexStatement = 110
	MySqlParserRULE_handlerReadStatement = 111
	MySqlParserRULE_handlerCloseStatement = 112
	MySqlParserRULE_singleUpdateStatement = 113
	MySqlParserRULE_multipleUpdateStatement = 114
	MySqlParserRULE_orderByClause = 115
	MySqlParserRULE_orderByExpression = 116
	MySqlParserRULE_tableSources = 117
	MySqlParserRULE_tableSource = 118
	MySqlParserRULE_tableSourceItem = 119
	MySqlParserRULE_indexHint = 120
	MySqlParserRULE_indexHintType = 121
	MySqlParserRULE_joinPart = 122
	MySqlParserRULE_joinSpec = 123
	MySqlParserRULE_queryExpression = 124
	MySqlParserRULE_queryExpressionNointo = 125
	MySqlParserRULE_querySpecification = 126
	MySqlParserRULE_proxyHint = 127
	MySqlParserRULE_annotation = 128
	MySqlParserRULE_key = 129
	MySqlParserRULE_value = 130
	MySqlParserRULE_querySpecificationNointo = 131
	MySqlParserRULE_unionParenthesis = 132
	MySqlParserRULE_unionStatement = 133
	MySqlParserRULE_lateralStatement = 134
	MySqlParserRULE_jsonTable = 135
	MySqlParserRULE_jsonColumnList = 136
	MySqlParserRULE_jsonColumn = 137
	MySqlParserRULE_jsonOnEmpty = 138
	MySqlParserRULE_jsonOnError = 139
	MySqlParserRULE_selectSpec = 140
	MySqlParserRULE_selectElements = 141
	MySqlParserRULE_selectElement = 142
	MySqlParserRULE_selectIntoExpression = 143
	MySqlParserRULE_selectFieldsInto = 144
	MySqlParserRULE_selectLinesInto = 145
	MySqlParserRULE_fromClause = 146
	MySqlParserRULE_groupByClause = 147
	MySqlParserRULE_havingClause = 148
	MySqlParserRULE_windowClause = 149
	MySqlParserRULE_groupByItem = 150
	MySqlParserRULE_limitClause = 151
	MySqlParserRULE_limitClauseAtom = 152
	MySqlParserRULE_startTransaction = 153
	MySqlParserRULE_beginWork = 154
	MySqlParserRULE_commitWork = 155
	MySqlParserRULE_rollbackWork = 156
	MySqlParserRULE_savepointStatement = 157
	MySqlParserRULE_rollbackStatement = 158
	MySqlParserRULE_releaseStatement = 159
	MySqlParserRULE_lockTables = 160
	MySqlParserRULE_unlockTables = 161
	MySqlParserRULE_setAutocommitStatement = 162
	MySqlParserRULE_setTransactionStatement = 163
	MySqlParserRULE_transactionMode = 164
	MySqlParserRULE_lockTableElement = 165
	MySqlParserRULE_lockAction = 166
	MySqlParserRULE_transactionOption = 167
	MySqlParserRULE_transactionLevel = 168
	MySqlParserRULE_changeMaster = 169
	MySqlParserRULE_changeReplicationFilter = 170
	MySqlParserRULE_purgeBinaryLogs = 171
	MySqlParserRULE_resetMaster = 172
	MySqlParserRULE_resetSlave = 173
	MySqlParserRULE_startSlave = 174
	MySqlParserRULE_stopSlave = 175
	MySqlParserRULE_startGroupReplication = 176
	MySqlParserRULE_stopGroupReplication = 177
	MySqlParserRULE_masterOption = 178
	MySqlParserRULE_stringMasterOption = 179
	MySqlParserRULE_decimalMasterOption = 180
	MySqlParserRULE_boolMasterOption = 181
	MySqlParserRULE_channelOption = 182
	MySqlParserRULE_replicationFilter = 183
	MySqlParserRULE_tablePair = 184
	MySqlParserRULE_threadType = 185
	MySqlParserRULE_untilOption = 186
	MySqlParserRULE_connectionOption = 187
	MySqlParserRULE_gtuidSet = 188
	MySqlParserRULE_xaStartTransaction = 189
	MySqlParserRULE_xaEndTransaction = 190
	MySqlParserRULE_xaPrepareStatement = 191
	MySqlParserRULE_xaCommitWork = 192
	MySqlParserRULE_xaRollbackWork = 193
	MySqlParserRULE_xaRecoverWork = 194
	MySqlParserRULE_prepareStatement = 195
	MySqlParserRULE_executeStatement = 196
	MySqlParserRULE_deallocatePrepare = 197
	MySqlParserRULE_routineBody = 198
	MySqlParserRULE_blockStatement = 199
	MySqlParserRULE_caseStatement = 200
	MySqlParserRULE_ifStatement = 201
	MySqlParserRULE_iterateStatement = 202
	MySqlParserRULE_leaveStatement = 203
	MySqlParserRULE_loopStatement = 204
	MySqlParserRULE_repeatStatement = 205
	MySqlParserRULE_returnStatement = 206
	MySqlParserRULE_whileStatement = 207
	MySqlParserRULE_cursorStatement = 208
	MySqlParserRULE_declareVariable = 209
	MySqlParserRULE_declareCondition = 210
	MySqlParserRULE_declareCursor = 211
	MySqlParserRULE_declareHandler = 212
	MySqlParserRULE_handlerConditionValue = 213
	MySqlParserRULE_procedureSqlStatement = 214
	MySqlParserRULE_caseAlternative = 215
	MySqlParserRULE_elifAlternative = 216
	MySqlParserRULE_alterUser = 217
	MySqlParserRULE_createUser = 218
	MySqlParserRULE_dropUser = 219
	MySqlParserRULE_grantStatement = 220
	MySqlParserRULE_roleOption = 221
	MySqlParserRULE_grantProxy = 222
	MySqlParserRULE_renameUser = 223
	MySqlParserRULE_revokeStatement = 224
	MySqlParserRULE_revokeProxy = 225
	MySqlParserRULE_setPasswordStatement = 226
	MySqlParserRULE_userSpecification = 227
	MySqlParserRULE_userAuthOption = 228
	MySqlParserRULE_authOptionClause = 229
	MySqlParserRULE_authenticationRule = 230
	MySqlParserRULE_tlsOption = 231
	MySqlParserRULE_userResourceOption = 232
	MySqlParserRULE_userPasswordOption = 233
	MySqlParserRULE_userLockOption = 234
	MySqlParserRULE_privelegeClause = 235
	MySqlParserRULE_privilege = 236
	MySqlParserRULE_privilegeLevel = 237
	MySqlParserRULE_renameUserClause = 238
	MySqlParserRULE_analyzeTable = 239
	MySqlParserRULE_checkTable = 240
	MySqlParserRULE_checksumTable = 241
	MySqlParserRULE_optimizeTable = 242
	MySqlParserRULE_repairTable = 243
	MySqlParserRULE_checkTableOption = 244
	MySqlParserRULE_createUdfunction = 245
	MySqlParserRULE_installPlugin = 246
	MySqlParserRULE_uninstallPlugin = 247
	MySqlParserRULE_setStatement = 248
	MySqlParserRULE_showStatement = 249
	MySqlParserRULE_variableClause = 250
	MySqlParserRULE_showCommonEntity = 251
	MySqlParserRULE_showFilter = 252
	MySqlParserRULE_showGlobalInfoClause = 253
	MySqlParserRULE_showSchemaEntity = 254
	MySqlParserRULE_showProfileType = 255
	MySqlParserRULE_binlogStatement = 256
	MySqlParserRULE_cacheIndexStatement = 257
	MySqlParserRULE_flushStatement = 258
	MySqlParserRULE_killStatement = 259
	MySqlParserRULE_loadIndexIntoCache = 260
	MySqlParserRULE_resetStatement = 261
	MySqlParserRULE_shutdownStatement = 262
	MySqlParserRULE_tableIndexes = 263
	MySqlParserRULE_flushOption = 264
	MySqlParserRULE_flushTableOption = 265
	MySqlParserRULE_loadedTableIndexes = 266
	MySqlParserRULE_simpleDescribeStatement = 267
	MySqlParserRULE_fullDescribeStatement = 268
	MySqlParserRULE_helpStatement = 269
	MySqlParserRULE_useStatement = 270
	MySqlParserRULE_signalStatement = 271
	MySqlParserRULE_resignalStatement = 272
	MySqlParserRULE_signalConditionInformation = 273
	MySqlParserRULE_withStatement = 274
	MySqlParserRULE_tableStatement = 275
	MySqlParserRULE_diagnosticsStatement = 276
	MySqlParserRULE_diagnosticsConditionInformationName = 277
	MySqlParserRULE_describeObjectClause = 278
	MySqlParserRULE_fullId = 279
	MySqlParserRULE_tableName = 280
	MySqlParserRULE_roleName = 281
	MySqlParserRULE_fullColumnName = 282
	MySqlParserRULE_indexColumnName = 283
	MySqlParserRULE_simpleUserName = 284
	MySqlParserRULE_hostName = 285
	MySqlParserRULE_userName = 286
	MySqlParserRULE_mysqlVariable = 287
	MySqlParserRULE_charsetName = 288
	MySqlParserRULE_collationName = 289
	MySqlParserRULE_engineName = 290
	MySqlParserRULE_engineNameBase = 291
	MySqlParserRULE_uuidSet = 292
	MySqlParserRULE_xid = 293
	MySqlParserRULE_xuidStringId = 294
	MySqlParserRULE_authPlugin = 295
	MySqlParserRULE_uid = 296
	MySqlParserRULE_simpleId = 297
	MySqlParserRULE_dottedId = 298
	MySqlParserRULE_decimalLiteral = 299
	MySqlParserRULE_fileSizeLiteral = 300
	MySqlParserRULE_stringLiteral = 301
	MySqlParserRULE_booleanLiteral = 302
	MySqlParserRULE_hexadecimalLiteral = 303
	MySqlParserRULE_nullNotnull = 304
	MySqlParserRULE_constant = 305
	MySqlParserRULE_dataType = 306
	MySqlParserRULE_collectionOptions = 307
	MySqlParserRULE_convertedDataType = 308
	MySqlParserRULE_lengthOneDimension = 309
	MySqlParserRULE_lengthTwoDimension = 310
	MySqlParserRULE_lengthTwoOptionalDimension = 311
	MySqlParserRULE_uidList = 312
	MySqlParserRULE_fullColumnNameList = 313
	MySqlParserRULE_tables = 314
	MySqlParserRULE_indexColumnNames = 315
	MySqlParserRULE_expressions = 316
	MySqlParserRULE_expressionsWithDefaults = 317
	MySqlParserRULE_constants = 318
	MySqlParserRULE_simpleStrings = 319
	MySqlParserRULE_userVariables = 320
	MySqlParserRULE_defaultValue = 321
	MySqlParserRULE_currentTimestamp = 322
	MySqlParserRULE_expressionOrDefault = 323
	MySqlParserRULE_ifExists = 324
	MySqlParserRULE_ifNotExists = 325
	MySqlParserRULE_orReplace = 326
	MySqlParserRULE_waitNowaitClause = 327
	MySqlParserRULE_functionCall = 328
	MySqlParserRULE_specificFunction = 329
	MySqlParserRULE_caseFuncAlternative = 330
	MySqlParserRULE_levelsInWeightString = 331
	MySqlParserRULE_levelInWeightListElement = 332
	MySqlParserRULE_aggregateWindowedFunction = 333
	MySqlParserRULE_nonAggregateWindowedFunction = 334
	MySqlParserRULE_overClause = 335
	MySqlParserRULE_windowSpec = 336
	MySqlParserRULE_windowName = 337
	MySqlParserRULE_frameClause = 338
	MySqlParserRULE_frameUnits = 339
	MySqlParserRULE_frameExtent = 340
	MySqlParserRULE_frameBetween = 341
	MySqlParserRULE_frameRange = 342
	MySqlParserRULE_partitionClause = 343
	MySqlParserRULE_scalarFunctionName = 344
	MySqlParserRULE_passwordFunctionClause = 345
	MySqlParserRULE_functionArgs = 346
	MySqlParserRULE_functionArg = 347
	MySqlParserRULE_expression = 348
	MySqlParserRULE_predicate = 349
	MySqlParserRULE_expressionAtom = 350
	MySqlParserRULE_unaryOperator = 351
	MySqlParserRULE_comparisonOperator = 352
	MySqlParserRULE_logicalOperator = 353
	MySqlParserRULE_bitOperator = 354
	MySqlParserRULE_multOperator = 355
	MySqlParserRULE_addOperator = 356
	MySqlParserRULE_jsonOperator = 357
	MySqlParserRULE_charsetNameBase = 358
	MySqlParserRULE_transactionLevelBase = 359
	MySqlParserRULE_privilegesBase = 360
	MySqlParserRULE_intervalTypeBase = 361
	MySqlParserRULE_dataTypeBase = 362
	MySqlParserRULE_keywordsCanBeId = 363
	MySqlParserRULE_functionNameBase = 364
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	SqlStatements() ISqlStatementsContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySqlParserEOF, 0)
}

func (s *RootContext) SqlStatements() ISqlStatementsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementsContext)
}

func (s *RootContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *RootContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MySqlParserRULE_root)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 4614060972218253952) != 0) || ((int64((_la - 71)) & ^0x3f) == 0 && ((int64(1) << (_la - 71)) & 2306124490637066243) != 0) || ((int64((_la - 138)) & ^0x3f) == 0 && ((int64(1) << (_la - 138)) & 19509751503569451) != 0) || ((int64((_la - 344)) & ^0x3f) == 0 && ((int64(1) << (_la - 344)) & 36099165796700291) != 0) || ((int64((_la - 432)) & ^0x3f) == 0 && ((int64(1) << (_la - 432)) & 16782337) != 0) || ((int64((_la - 560)) & ^0x3f) == 0 && ((int64(1) << (_la - 560)) & 17730162917377) != 0) || ((int64((_la - 629)) & ^0x3f) == 0 && ((int64(1) << (_la - 629)) & 4503604056555585) != 0) || _la == MySqlParserEXECUTE || _la == MySqlParserSHUTDOWN || _la == MySqlParserLR_BRACKET || _la == MySqlParserSEMI {
		{
			p.SetState(730)
			p.SqlStatements()
		}

	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserMINUS {
		{
			p.SetState(733)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(734)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(737)
		p.Match(MySqlParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSqlStatement() []ISqlStatementContext
	SqlStatement(i int) ISqlStatementContext
	AllEmptyStatement_() []IEmptyStatement_Context
	EmptyStatement_(i int) IEmptyStatement_Context
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) AllSqlStatement() []ISqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ISqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlStatementContext); ok {
			tst[i] = t.(ISqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SqlStatement(i int) ISqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SqlStatementsContext) AllEmptyStatement_() []IEmptyStatement_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			len++
		}
	}

	tst := make([]IEmptyStatement_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmptyStatement_Context); ok {
			tst[i] = t.(IEmptyStatement_Context)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) EmptyStatement_(i int) IEmptyStatement_Context {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SqlStatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *SqlStatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *SqlStatementsContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *SqlStatementsContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MySqlParserRULE_sqlStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserLR_BRACKET:
				{
					p.SetState(739)
					p.SqlStatement()
				}
				p.SetState(742)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserMINUS {
					{
						p.SetState(740)
						p.Match(MySqlParserMINUS)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(741)
						p.Match(MySqlParserMINUS)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				p.SetState(745)
				p.GetErrorHandler().Sync(p)


				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(744)
						p.Match(MySqlParserSEMI)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

					} else if p.HasError() { // JIM
						goto errorExit
				}


			case MySqlParserSEMI:
				{
					p.SetState(747)
					p.EmptyStatement_()
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserLR_BRACKET:
		{
			p.SetState(753)
			p.SqlStatement()
		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			p.SetState(756)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserMINUS {
				{
					p.SetState(754)
					p.Match(MySqlParserMINUS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(755)
					p.Match(MySqlParserMINUS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(758)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserSEMI:
		{
			p.SetState(761)
			p.EmptyStatement_()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DdlStatement() IDdlStatementContext
	DmlStatement() IDmlStatementContext
	TransactionStatement() ITransactionStatementContext
	ReplicationStatement() IReplicationStatementContext
	PreparedStatement() IPreparedStatementContext
	AdministrationStatement() IAdministrationStatementContext
	UtilityStatement() IUtilityStatementContext

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatement
	return p
}

func InitEmptySqlStatementContext(p *SqlStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatement
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DdlStatement() IDdlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDdlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDdlStatementContext)
}

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) TransactionStatement() ITransactionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionStatementContext)
}

func (s *SqlStatementContext) ReplicationStatement() IReplicationStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationStatementContext)
}

func (s *SqlStatementContext) PreparedStatement() IPreparedStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreparedStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreparedStatementContext)
}

func (s *SqlStatementContext) AdministrationStatement() IAdministrationStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdministrationStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdministrationStatementContext)
}

func (s *SqlStatementContext) UtilityStatement() IUtilityStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUtilityStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUtilityStatementContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (s *SqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SqlStatement() (localctx ISqlStatementContext) {
	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MySqlParserRULE_sqlStatement)
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(764)
			p.DdlStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(765)
			p.DmlStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(766)
			p.TransactionStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(767)
			p.ReplicationStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(768)
			p.PreparedStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(769)
			p.AdministrationStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(770)
			p.UtilityStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MySqlParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Match(MySqlParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDdlStatementContext is an interface to support dynamic dispatch.
type IDdlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateDatabase() ICreateDatabaseContext
	CreateEvent() ICreateEventContext
	CreateIndex() ICreateIndexContext
	CreateLogfileGroup() ICreateLogfileGroupContext
	CreateProcedure() ICreateProcedureContext
	CreateFunction() ICreateFunctionContext
	CreateServer() ICreateServerContext
	CreateTable() ICreateTableContext
	CreateTablespaceInnodb() ICreateTablespaceInnodbContext
	CreateTablespaceNdb() ICreateTablespaceNdbContext
	CreateTrigger() ICreateTriggerContext
	CreateView() ICreateViewContext
	CreateRole() ICreateRoleContext
	AlterDatabase() IAlterDatabaseContext
	AlterEvent() IAlterEventContext
	AlterFunction() IAlterFunctionContext
	AlterInstance() IAlterInstanceContext
	AlterLogfileGroup() IAlterLogfileGroupContext
	AlterProcedure() IAlterProcedureContext
	AlterServer() IAlterServerContext
	AlterTable() IAlterTableContext
	AlterTablespace() IAlterTablespaceContext
	AlterView() IAlterViewContext
	DropDatabase() IDropDatabaseContext
	DropEvent() IDropEventContext
	DropIndex() IDropIndexContext
	DropLogfileGroup() IDropLogfileGroupContext
	DropProcedure() IDropProcedureContext
	DropFunction() IDropFunctionContext
	DropServer() IDropServerContext
	DropTable() IDropTableContext
	DropTablespace() IDropTablespaceContext
	DropTrigger() IDropTriggerContext
	DropView() IDropViewContext
	DropRole() IDropRoleContext
	SetRole() ISetRoleContext
	RenameTable() IRenameTableContext
	TruncateTable() ITruncateTableContext

	// IsDdlStatementContext differentiates from other interfaces.
	IsDdlStatementContext()
}

type DdlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDdlStatementContext() *DdlStatementContext {
	var p = new(DdlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ddlStatement
	return p
}

func InitEmptyDdlStatementContext(p *DdlStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ddlStatement
}

func (*DdlStatementContext) IsDdlStatementContext() {}

func NewDdlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DdlStatementContext {
	var p = new(DdlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ddlStatement

	return p
}

func (s *DdlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DdlStatementContext) CreateDatabase() ICreateDatabaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *DdlStatementContext) CreateEvent() ICreateEventContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateEventContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateEventContext)
}

func (s *DdlStatementContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *DdlStatementContext) CreateLogfileGroup() ICreateLogfileGroupContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateLogfileGroupContext)
}

func (s *DdlStatementContext) CreateProcedure() ICreateProcedureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateProcedureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateProcedureContext)
}

func (s *DdlStatementContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *DdlStatementContext) CreateServer() ICreateServerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateServerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateServerContext)
}

func (s *DdlStatementContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *DdlStatementContext) CreateTablespaceInnodb() ICreateTablespaceInnodbContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceInnodbContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceInnodbContext)
}

func (s *DdlStatementContext) CreateTablespaceNdb() ICreateTablespaceNdbContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceNdbContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceNdbContext)
}

func (s *DdlStatementContext) CreateTrigger() ICreateTriggerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *DdlStatementContext) CreateView() ICreateViewContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *DdlStatementContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *DdlStatementContext) AlterDatabase() IAlterDatabaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseContext)
}

func (s *DdlStatementContext) AlterEvent() IAlterEventContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterEventContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterEventContext)
}

func (s *DdlStatementContext) AlterFunction() IAlterFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterFunctionContext)
}

func (s *DdlStatementContext) AlterInstance() IAlterInstanceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterInstanceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterInstanceContext)
}

func (s *DdlStatementContext) AlterLogfileGroup() IAlterLogfileGroupContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLogfileGroupContext)
}

func (s *DdlStatementContext) AlterProcedure() IAlterProcedureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterProcedureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterProcedureContext)
}

func (s *DdlStatementContext) AlterServer() IAlterServerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterServerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterServerContext)
}

func (s *DdlStatementContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *DdlStatementContext) AlterTablespace() IAlterTablespaceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTablespaceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTablespaceContext)
}

func (s *DdlStatementContext) AlterView() IAlterViewContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewContext)
}

func (s *DdlStatementContext) DropDatabase() IDropDatabaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *DdlStatementContext) DropEvent() IDropEventContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropEventContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropEventContext)
}

func (s *DdlStatementContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *DdlStatementContext) DropLogfileGroup() IDropLogfileGroupContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropLogfileGroupContext)
}

func (s *DdlStatementContext) DropProcedure() IDropProcedureContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropProcedureContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropProcedureContext)
}

func (s *DdlStatementContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *DdlStatementContext) DropServer() IDropServerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropServerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropServerContext)
}

func (s *DdlStatementContext) DropTable() IDropTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *DdlStatementContext) DropTablespace() IDropTablespaceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTablespaceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTablespaceContext)
}

func (s *DdlStatementContext) DropTrigger() IDropTriggerContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *DdlStatementContext) DropView() IDropViewContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *DdlStatementContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *DdlStatementContext) SetRole() ISetRoleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleContext)
}

func (s *DdlStatementContext) RenameTable() IRenameTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableContext)
}

func (s *DdlStatementContext) TruncateTable() ITruncateTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableContext)
}

func (s *DdlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DdlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DdlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDdlStatement(s)
	}
}

func (s *DdlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDdlStatement(s)
	}
}

func (s *DdlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDdlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DdlStatement() (localctx IDdlStatementContext) {
	localctx = NewDdlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MySqlParserRULE_ddlStatement)
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(775)
			p.CreateDatabase()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(776)
			p.CreateEvent()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(777)
			p.CreateIndex()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(778)
			p.CreateLogfileGroup()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(779)
			p.CreateProcedure()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(780)
			p.CreateFunction()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(781)
			p.CreateServer()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(782)
			p.CreateTable()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(783)
			p.CreateTablespaceInnodb()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(784)
			p.CreateTablespaceNdb()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(785)
			p.CreateTrigger()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(786)
			p.CreateView()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(787)
			p.CreateRole()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(788)
			p.AlterDatabase()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(789)
			p.AlterEvent()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(790)
			p.AlterFunction()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(791)
			p.AlterInstance()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(792)
			p.AlterLogfileGroup()
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(793)
			p.AlterProcedure()
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(794)
			p.AlterServer()
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(795)
			p.AlterTable()
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(796)
			p.AlterTablespace()
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(797)
			p.AlterView()
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(798)
			p.DropDatabase()
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(799)
			p.DropEvent()
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(800)
			p.DropIndex()
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(801)
			p.DropLogfileGroup()
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(802)
			p.DropProcedure()
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(803)
			p.DropFunction()
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(804)
			p.DropServer()
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(805)
			p.DropTable()
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(806)
			p.DropTablespace()
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(807)
			p.DropTrigger()
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(808)
			p.DropView()
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(809)
			p.DropRole()
		}


	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(810)
			p.SetRole()
		}


	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(811)
			p.RenameTable()
		}


	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(812)
			p.TruncateTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStatement() ISelectStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	ReplaceStatement() IReplaceStatementContext
	CallStatement() ICallStatementContext
	LoadDataStatement() ILoadDataStatementContext
	LoadXmlStatement() ILoadXmlStatementContext
	DoStatement() IDoStatementContext
	HandlerStatement() IHandlerStatementContext
	ValuesStatement() IValuesStatementContext
	WithStatement() IWithStatementContext
	TableStatement() ITableStatementContext

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dmlStatement
	return p
}

func InitEmptyDmlStatementContext(p *DmlStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dmlStatement
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DmlStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DmlStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DmlStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DmlStatementContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DmlStatementContext) CallStatement() ICallStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *DmlStatementContext) LoadDataStatement() ILoadDataStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadDataStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadDataStatementContext)
}

func (s *DmlStatementContext) LoadXmlStatement() ILoadXmlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadXmlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadXmlStatementContext)
}

func (s *DmlStatementContext) DoStatement() IDoStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *DmlStatementContext) HandlerStatement() IHandlerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerStatementContext)
}

func (s *DmlStatementContext) ValuesStatement() IValuesStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesStatementContext)
}

func (s *DmlStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *DmlStatementContext) TableStatement() ITableStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDmlStatement(s)
	}
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDmlStatement(s)
	}
}

func (s *DmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DmlStatement() (localctx IDmlStatementContext) {
	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MySqlParserRULE_dmlStatement)
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(815)
			p.SelectStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(816)
			p.InsertStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(817)
			p.UpdateStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(818)
			p.DeleteStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(819)
			p.ReplaceStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(820)
			p.CallStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(821)
			p.LoadDataStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(822)
			p.LoadXmlStatement()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(823)
			p.DoStatement()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(824)
			p.HandlerStatement()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(825)
			p.ValuesStatement()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(826)
			p.WithStatement()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(827)
			p.TableStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITransactionStatementContext is an interface to support dynamic dispatch.
type ITransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StartTransaction() IStartTransactionContext
	BeginWork() IBeginWorkContext
	CommitWork() ICommitWorkContext
	RollbackWork() IRollbackWorkContext
	SavepointStatement() ISavepointStatementContext
	RollbackStatement() IRollbackStatementContext
	ReleaseStatement() IReleaseStatementContext
	LockTables() ILockTablesContext
	UnlockTables() IUnlockTablesContext

	// IsTransactionStatementContext differentiates from other interfaces.
	IsTransactionStatementContext()
}

type TransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionStatementContext() *TransactionStatementContext {
	var p = new(TransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionStatement
	return p
}

func InitEmptyTransactionStatementContext(p *TransactionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionStatement
}

func (*TransactionStatementContext) IsTransactionStatementContext() {}

func NewTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionStatementContext {
	var p = new(TransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionStatement

	return p
}

func (s *TransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionStatementContext) StartTransaction() IStartTransactionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartTransactionContext)
}

func (s *TransactionStatementContext) BeginWork() IBeginWorkContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginWorkContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginWorkContext)
}

func (s *TransactionStatementContext) CommitWork() ICommitWorkContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitWorkContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitWorkContext)
}

func (s *TransactionStatementContext) RollbackWork() IRollbackWorkContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackWorkContext)
}

func (s *TransactionStatementContext) SavepointStatement() ISavepointStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISavepointStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISavepointStatementContext)
}

func (s *TransactionStatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *TransactionStatementContext) ReleaseStatement() IReleaseStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReleaseStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReleaseStatementContext)
}

func (s *TransactionStatementContext) LockTables() ILockTablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTablesContext)
}

func (s *TransactionStatementContext) UnlockTables() IUnlockTablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlockTablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlockTablesContext)
}

func (s *TransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TransactionStatement() (localctx ITransactionStatementContext) {
	localctx = NewTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MySqlParserRULE_transactionStatement)
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(830)
			p.StartTransaction()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(831)
			p.BeginWork()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(832)
			p.CommitWork()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(833)
			p.RollbackWork()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(834)
			p.SavepointStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(835)
			p.RollbackStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(836)
			p.ReleaseStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(837)
			p.LockTables()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(838)
			p.UnlockTables()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplicationStatementContext is an interface to support dynamic dispatch.
type IReplicationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ChangeMaster() IChangeMasterContext
	ChangeReplicationFilter() IChangeReplicationFilterContext
	PurgeBinaryLogs() IPurgeBinaryLogsContext
	ResetMaster() IResetMasterContext
	ResetSlave() IResetSlaveContext
	StartSlave() IStartSlaveContext
	StopSlave() IStopSlaveContext
	StartGroupReplication() IStartGroupReplicationContext
	StopGroupReplication() IStopGroupReplicationContext
	XaStartTransaction() IXaStartTransactionContext
	XaEndTransaction() IXaEndTransactionContext
	XaPrepareStatement() IXaPrepareStatementContext
	XaCommitWork() IXaCommitWorkContext
	XaRollbackWork() IXaRollbackWorkContext
	XaRecoverWork() IXaRecoverWorkContext

	// IsReplicationStatementContext differentiates from other interfaces.
	IsReplicationStatementContext()
}

type ReplicationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationStatementContext() *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationStatement
	return p
}

func InitEmptyReplicationStatementContext(p *ReplicationStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationStatement
}

func (*ReplicationStatementContext) IsReplicationStatementContext() {}

func NewReplicationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replicationStatement

	return p
}

func (s *ReplicationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationStatementContext) ChangeMaster() IChangeMasterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterContext)
}

func (s *ReplicationStatementContext) ChangeReplicationFilter() IChangeReplicationFilterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeReplicationFilterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeReplicationFilterContext)
}

func (s *ReplicationStatementContext) PurgeBinaryLogs() IPurgeBinaryLogsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPurgeBinaryLogsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPurgeBinaryLogsContext)
}

func (s *ReplicationStatementContext) ResetMaster() IResetMasterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetMasterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetMasterContext)
}

func (s *ReplicationStatementContext) ResetSlave() IResetSlaveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetSlaveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetSlaveContext)
}

func (s *ReplicationStatementContext) StartSlave() IStartSlaveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartSlaveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartSlaveContext)
}

func (s *ReplicationStatementContext) StopSlave() IStopSlaveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopSlaveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopSlaveContext)
}

func (s *ReplicationStatementContext) StartGroupReplication() IStartGroupReplicationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartGroupReplicationContext)
}

func (s *ReplicationStatementContext) StopGroupReplication() IStopGroupReplicationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopGroupReplicationContext)
}

func (s *ReplicationStatementContext) XaStartTransaction() IXaStartTransactionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaStartTransactionContext)
}

func (s *ReplicationStatementContext) XaEndTransaction() IXaEndTransactionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaEndTransactionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaEndTransactionContext)
}

func (s *ReplicationStatementContext) XaPrepareStatement() IXaPrepareStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaPrepareStatementContext)
}

func (s *ReplicationStatementContext) XaCommitWork() IXaCommitWorkContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaCommitWorkContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaCommitWorkContext)
}

func (s *ReplicationStatementContext) XaRollbackWork() IXaRollbackWorkContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRollbackWorkContext)
}

func (s *ReplicationStatementContext) XaRecoverWork() IXaRecoverWorkContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRecoverWorkContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRecoverWorkContext)
}

func (s *ReplicationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplicationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReplicationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ReplicationStatement() (localctx IReplicationStatementContext) {
	localctx = NewReplicationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MySqlParserRULE_replicationStatement)
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.ChangeMaster()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(842)
			p.ChangeReplicationFilter()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(843)
			p.PurgeBinaryLogs()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(844)
			p.ResetMaster()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(845)
			p.ResetSlave()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(846)
			p.StartSlave()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(847)
			p.StopSlave()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(848)
			p.StartGroupReplication()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(849)
			p.StopGroupReplication()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(850)
			p.XaStartTransaction()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(851)
			p.XaEndTransaction()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(852)
			p.XaPrepareStatement()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(853)
			p.XaCommitWork()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(854)
			p.XaRollbackWork()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(855)
			p.XaRecoverWork()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPreparedStatementContext is an interface to support dynamic dispatch.
type IPreparedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocatePrepare() IDeallocatePrepareContext

	// IsPreparedStatementContext differentiates from other interfaces.
	IsPreparedStatementContext()
}

type PreparedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreparedStatementContext() *PreparedStatementContext {
	var p = new(PreparedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_preparedStatement
	return p
}

func InitEmptyPreparedStatementContext(p *PreparedStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_preparedStatement
}

func (*PreparedStatementContext) IsPreparedStatementContext() {}

func NewPreparedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreparedStatementContext {
	var p = new(PreparedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_preparedStatement

	return p
}

func (s *PreparedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PreparedStatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *PreparedStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *PreparedStatementContext) DeallocatePrepare() IDeallocatePrepareContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocatePrepareContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocatePrepareContext)
}

func (s *PreparedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreparedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PreparedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPreparedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PreparedStatement() (localctx IPreparedStatementContext) {
	localctx = NewPreparedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MySqlParserRULE_preparedStatement)
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserPREPARE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(858)
			p.PrepareStatement()
		}


	case MySqlParserEXECUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(859)
			p.ExecuteStatement()
		}


	case MySqlParserDROP, MySqlParserDEALLOCATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(860)
			p.DeallocatePrepare()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	CaseStatement() ICaseStatementContext
	IfStatement() IIfStatementContext
	LeaveStatement() ILeaveStatementContext
	LoopStatement() ILoopStatementContext
	RepeatStatement() IRepeatStatementContext
	WhileStatement() IWhileStatementContext
	IterateStatement() IIterateStatementContext
	ReturnStatement() IReturnStatementContext
	CursorStatement() ICursorStatementContext
	WithStatement() IWithStatementContext
	DmlStatement() IDmlStatementContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *CompoundStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *CompoundStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *CompoundStatementContext) LeaveStatement() ILeaveStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeaveStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeaveStatementContext)
}

func (s *CompoundStatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *CompoundStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *CompoundStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *CompoundStatementContext) IterateStatement() IIterateStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterateStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterateStatementContext)
}

func (s *CompoundStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CompoundStatementContext) CursorStatement() ICursorStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorStatementContext)
}

func (s *CompoundStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *CompoundStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MySqlParserRULE_compoundStatement)
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(863)
			p.BlockStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.CaseStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(865)
			p.IfStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(866)
			p.LeaveStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(867)
			p.LoopStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(868)
			p.RepeatStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(869)
			p.WhileStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(870)
			p.IterateStatement()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(871)
			p.ReturnStatement()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(872)
			p.CursorStatement()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(873)
			p.WithStatement()
		}
		{
			p.SetState(874)
			p.DmlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAdministrationStatementContext is an interface to support dynamic dispatch.
type IAdministrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterUser() IAlterUserContext
	CreateUser() ICreateUserContext
	DropUser() IDropUserContext
	GrantStatement() IGrantStatementContext
	GrantProxy() IGrantProxyContext
	RenameUser() IRenameUserContext
	RevokeStatement() IRevokeStatementContext
	RevokeProxy() IRevokeProxyContext
	AnalyzeTable() IAnalyzeTableContext
	CheckTable() ICheckTableContext
	ChecksumTable() IChecksumTableContext
	OptimizeTable() IOptimizeTableContext
	RepairTable() IRepairTableContext
	CreateUdfunction() ICreateUdfunctionContext
	InstallPlugin() IInstallPluginContext
	UninstallPlugin() IUninstallPluginContext
	SetStatement() ISetStatementContext
	ShowStatement() IShowStatementContext
	BinlogStatement() IBinlogStatementContext
	CacheIndexStatement() ICacheIndexStatementContext
	FlushStatement() IFlushStatementContext
	KillStatement() IKillStatementContext
	LoadIndexIntoCache() ILoadIndexIntoCacheContext
	ResetStatement() IResetStatementContext
	ShutdownStatement() IShutdownStatementContext

	// IsAdministrationStatementContext differentiates from other interfaces.
	IsAdministrationStatementContext()
}

type AdministrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdministrationStatementContext() *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_administrationStatement
	return p
}

func InitEmptyAdministrationStatementContext(p *AdministrationStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_administrationStatement
}

func (*AdministrationStatementContext) IsAdministrationStatementContext() {}

func NewAdministrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_administrationStatement

	return p
}

func (s *AdministrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdministrationStatementContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *AdministrationStatementContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *AdministrationStatementContext) DropUser() IDropUserContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *AdministrationStatementContext) GrantStatement() IGrantStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantStatementContext)
}

func (s *AdministrationStatementContext) GrantProxy() IGrantProxyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantProxyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantProxyContext)
}

func (s *AdministrationStatementContext) RenameUser() IRenameUserContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserContext)
}

func (s *AdministrationStatementContext) RevokeStatement() IRevokeStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeStatementContext)
}

func (s *AdministrationStatementContext) RevokeProxy() IRevokeProxyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeProxyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeProxyContext)
}

func (s *AdministrationStatementContext) AnalyzeTable() IAnalyzeTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeTableContext)
}

func (s *AdministrationStatementContext) CheckTable() ICheckTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableContext)
}

func (s *AdministrationStatementContext) ChecksumTable() IChecksumTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChecksumTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChecksumTableContext)
}

func (s *AdministrationStatementContext) OptimizeTable() IOptimizeTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeTableContext)
}

func (s *AdministrationStatementContext) RepairTable() IRepairTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepairTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepairTableContext)
}

func (s *AdministrationStatementContext) CreateUdfunction() ICreateUdfunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUdfunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUdfunctionContext)
}

func (s *AdministrationStatementContext) InstallPlugin() IInstallPluginContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginContext)
}

func (s *AdministrationStatementContext) UninstallPlugin() IUninstallPluginContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginContext)
}

func (s *AdministrationStatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *AdministrationStatementContext) ShowStatement() IShowStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatementContext)
}

func (s *AdministrationStatementContext) BinlogStatement() IBinlogStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinlogStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinlogStatementContext)
}

func (s *AdministrationStatementContext) CacheIndexStatement() ICacheIndexStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheIndexStatementContext)
}

func (s *AdministrationStatementContext) FlushStatement() IFlushStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushStatementContext)
}

func (s *AdministrationStatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *AdministrationStatementContext) LoadIndexIntoCache() ILoadIndexIntoCacheContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadIndexIntoCacheContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadIndexIntoCacheContext)
}

func (s *AdministrationStatementContext) ResetStatement() IResetStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetStatementContext)
}

func (s *AdministrationStatementContext) ShutdownStatement() IShutdownStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShutdownStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShutdownStatementContext)
}

func (s *AdministrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdministrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AdministrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAdministrationStatement(s)
	}
}

func (s *AdministrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAdministrationStatement(s)
	}
}

func (s *AdministrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAdministrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AdministrationStatement() (localctx IAdministrationStatementContext) {
	localctx = NewAdministrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MySqlParserRULE_administrationStatement)
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(878)
			p.AlterUser()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(879)
			p.CreateUser()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(880)
			p.DropUser()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(881)
			p.GrantStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(882)
			p.GrantProxy()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(883)
			p.RenameUser()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(884)
			p.RevokeStatement()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(885)
			p.RevokeProxy()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(886)
			p.AnalyzeTable()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(887)
			p.CheckTable()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(888)
			p.ChecksumTable()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(889)
			p.OptimizeTable()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(890)
			p.RepairTable()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(891)
			p.CreateUdfunction()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(892)
			p.InstallPlugin()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(893)
			p.UninstallPlugin()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(894)
			p.SetStatement()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(895)
			p.ShowStatement()
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(896)
			p.BinlogStatement()
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(897)
			p.CacheIndexStatement()
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(898)
			p.FlushStatement()
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(899)
			p.KillStatement()
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(900)
			p.LoadIndexIntoCache()
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(901)
			p.ResetStatement()
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(902)
			p.ShutdownStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUtilityStatementContext is an interface to support dynamic dispatch.
type IUtilityStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleDescribeStatement() ISimpleDescribeStatementContext
	FullDescribeStatement() IFullDescribeStatementContext
	HelpStatement() IHelpStatementContext
	UseStatement() IUseStatementContext
	SignalStatement() ISignalStatementContext
	ResignalStatement() IResignalStatementContext
	DiagnosticsStatement() IDiagnosticsStatementContext

	// IsUtilityStatementContext differentiates from other interfaces.
	IsUtilityStatementContext()
}

type UtilityStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtilityStatementContext() *UtilityStatementContext {
	var p = new(UtilityStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_utilityStatement
	return p
}

func InitEmptyUtilityStatementContext(p *UtilityStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_utilityStatement
}

func (*UtilityStatementContext) IsUtilityStatementContext() {}

func NewUtilityStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UtilityStatementContext {
	var p = new(UtilityStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_utilityStatement

	return p
}

func (s *UtilityStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UtilityStatementContext) SimpleDescribeStatement() ISimpleDescribeStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDescribeStatementContext)
}

func (s *UtilityStatementContext) FullDescribeStatement() IFullDescribeStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullDescribeStatementContext)
}

func (s *UtilityStatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *UtilityStatementContext) UseStatement() IUseStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *UtilityStatementContext) SignalStatement() ISignalStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalStatementContext)
}

func (s *UtilityStatementContext) ResignalStatement() IResignalStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignalStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignalStatementContext)
}

func (s *UtilityStatementContext) DiagnosticsStatement() IDiagnosticsStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsStatementContext)
}

func (s *UtilityStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UtilityStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UtilityStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUtilityStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UtilityStatement() (localctx IUtilityStatementContext) {
	localctx = NewUtilityStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MySqlParserRULE_utilityStatement)
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(905)
			p.SimpleDescribeStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(906)
			p.FullDescribeStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(907)
			p.HelpStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(908)
			p.UseStatement()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(909)
			p.SignalStatement()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(910)
			p.ResignalStatement()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(911)
			p.DiagnosticsStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token 


	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token) 


	// Getter signatures
	CREATE() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllCreateDatabaseOption() []ICreateDatabaseOptionContext
	CreateDatabaseOption(i int) ICreateDatabaseOptionContext

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabase
	return p
}

func InitEmptyCreateDatabaseContext(p *CreateDatabaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabase
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }


func (s *CreateDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }


func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MySqlParserRULE_createDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(915)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(916)
			p.IfNotExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(919)
		p.Uid()
	}
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 4398214283264) != 0) || _la == MySqlParserREAD || _la == MySqlParserCHAR || _la == MySqlParserENCRYPTION || _la == MySqlParserCHARSET {
		{
			p.SetState(920)
			p.CreateDatabaseOption()
		}


		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateEventContext is an interface to support dynamic dispatch.
type ICreateEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OwnerStatement() IOwnerStatementContext
	IfNotExists() IIfNotExistsContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsCreateEventContext differentiates from other interfaces.
	IsCreateEventContext()
}

type CreateEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateEventContext() *CreateEventContext {
	var p = new(CreateEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createEvent
	return p
}

func InitEmptyCreateEventContext(p *CreateEventContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createEvent
}

func (*CreateEventContext) IsCreateEventContext() {}

func NewCreateEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateEventContext {
	var p = new(CreateEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createEvent

	return p
}

func (s *CreateEventContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateEventContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *CreateEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *CreateEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *CreateEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *CreateEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *CreateEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *CreateEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateEventContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *CreateEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *CreateEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *CreateEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *CreateEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateEvent(s)
	}
}

func (s *CreateEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateEvent(s)
	}
}

func (s *CreateEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateEvent(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateEvent() (localctx ICreateEventContext) {
	localctx = NewCreateEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MySqlParserRULE_createEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFINER {
		{
			p.SetState(927)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(930)
		p.Match(MySqlParserEVENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(931)
			p.IfNotExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(934)
		p.FullId()
	}
	{
		p.SetState(935)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(936)
		p.Match(MySqlParserSCHEDULE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(937)
		p.ScheduleExpression()
	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserON {
		{
			p.SetState(938)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(939)
			p.Match(MySqlParserCOMPLETION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(940)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(943)
			p.Match(MySqlParserPRESERVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDISABLE || _la == MySqlParserENABLE {
		{
			p.SetState(946)
			p.EnableType()
		}

	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT {
		{
			p.SetState(949)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(950)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(953)
		p.Match(MySqlParserDO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(954)
		p.RoutineBody()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token 

	// GetIndexCategory returns the indexCategory token.
	GetIndexCategory() antlr.Token 

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token 

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token 


	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token) 

	// SetIndexCategory sets the indexCategory token.
	SetIndexCategory(antlr.Token) 

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token) 

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token) 


	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	IndexType() IIndexTypeContext
	AllIndexOption() []IIndexOptionContext
	IndexOption(i int) IIndexOptionContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	FULLTEXT() antlr.TerminalNode
	SPATIAL() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	intimeAction antlr.Token
	indexCategory antlr.Token
	algType antlr.Token
	lockType antlr.Token
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createIndex
	return p
}

func InitEmptyCreateIndexContext(p *CreateIndexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createIndex
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *CreateIndexContext) GetIndexCategory() antlr.Token { return s.indexCategory }

func (s *CreateIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateIndexContext) GetLockType() antlr.Token { return s.lockType }


func (s *CreateIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *CreateIndexContext) SetIndexCategory(v antlr.Token) { s.indexCategory = v }

func (s *CreateIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateIndexContext) SetLockType(v antlr.Token) { s.lockType = v }


func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *CreateIndexContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *CreateIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *CreateIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *CreateIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserALGORITHM)
}

func (s *CreateIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, i)
}

func (s *CreateIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCK)
}

func (s *CreateIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, i)
}

func (s *CreateIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *CreateIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *CreateIndexContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *CreateIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *CreateIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *CreateIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *CreateIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *CreateIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserINPLACE)
}

func (s *CreateIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, i)
}

func (s *CreateIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOPY)
}

func (s *CreateIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, i)
}

func (s *CreateIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNONE)
}

func (s *CreateIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, i)
}

func (s *CreateIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSHARED)
}

func (s *CreateIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, i)
}

func (s *CreateIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEXCLUSIVE)
}

func (s *CreateIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, i)
}

func (s *CreateIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (s *CreateIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateIndex(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateIndex() (localctx ICreateIndexContext) {
	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MySqlParserRULE_createIndex)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserOFFLINE || _la == MySqlParserONLINE {
		{
			p.SetState(957)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL || _la == MySqlParserUNIQUE {
		{
			p.SetState(960)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).indexCategory = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL || _la == MySqlParserUNIQUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).indexCategory = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(963)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(964)
		p.Uid()
	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserUSING {
		{
			p.SetState(965)
			p.IndexType()
		}

	}
	{
		p.SetState(968)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(969)
		p.TableName()
	}
	{
		p.SetState(970)
		p.IndexColumnNames()
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(971)
				p.IndexOption()
			}


		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(987)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALGORITHM:
				{
					p.SetState(977)
					p.Match(MySqlParserALGORITHM)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(979)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(978)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(981)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			case MySqlParserLOCK:
				{
					p.SetState(982)
					p.Match(MySqlParserLOCK)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(984)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(983)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(986)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateLogfileGroupContext is an interface to support dynamic dispatch.
type ICreateLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUndoFile returns the undoFile token.
	GetUndoFile() antlr.Token 

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetUndoFile sets the undoFile token.
	SetUndoFile(antlr.Token) 

	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetInitSize returns the initSize rule contexts.
	GetInitSize() IFileSizeLiteralContext

	// GetUndoSize returns the undoSize rule contexts.
	GetUndoSize() IFileSizeLiteralContext

	// GetRedoSize returns the redoSize rule contexts.
	GetRedoSize() IFileSizeLiteralContext


	// SetInitSize sets the initSize rule contexts.
	SetInitSize(IFileSizeLiteralContext)

	// SetUndoSize sets the undoSize rule contexts.
	SetUndoSize(IFileSizeLiteralContext)

	// SetRedoSize sets the redoSize rule contexts.
	SetRedoSize(IFileSizeLiteralContext)


	// Getter signatures
	CREATE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateLogfileGroupContext differentiates from other interfaces.
	IsCreateLogfileGroupContext()
}

type CreateLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	undoFile antlr.Token
	initSize IFileSizeLiteralContext 
	undoSize IFileSizeLiteralContext 
	redoSize IFileSizeLiteralContext 
	comment antlr.Token
}

func NewEmptyCreateLogfileGroupContext() *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createLogfileGroup
	return p
}

func InitEmptyCreateLogfileGroupContext(p *CreateLogfileGroupContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createLogfileGroup
}

func (*CreateLogfileGroupContext) IsCreateLogfileGroupContext() {}

func NewCreateLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createLogfileGroup

	return p
}

func (s *CreateLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateLogfileGroupContext) GetUndoFile() antlr.Token { return s.undoFile }

func (s *CreateLogfileGroupContext) GetComment() antlr.Token { return s.comment }


func (s *CreateLogfileGroupContext) SetUndoFile(v antlr.Token) { s.undoFile = v }

func (s *CreateLogfileGroupContext) SetComment(v antlr.Token) { s.comment = v }


func (s *CreateLogfileGroupContext) GetInitSize() IFileSizeLiteralContext { return s.initSize }

func (s *CreateLogfileGroupContext) GetUndoSize() IFileSizeLiteralContext { return s.undoSize }

func (s *CreateLogfileGroupContext) GetRedoSize() IFileSizeLiteralContext { return s.redoSize }


func (s *CreateLogfileGroupContext) SetInitSize(v IFileSizeLiteralContext) { s.initSize = v }

func (s *CreateLogfileGroupContext) SetUndoSize(v IFileSizeLiteralContext) { s.undoSize = v }

func (s *CreateLogfileGroupContext) SetRedoSize(v IFileSizeLiteralContext) { s.redoSize = v }


func (s *CreateLogfileGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *CreateLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *CreateLogfileGroupContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *CreateLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateLogfileGroupContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CreateLogfileGroupContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CreateLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *CreateLogfileGroupContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *CreateLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *CreateLogfileGroupContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateLogfileGroupContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateLogfileGroup() (localctx ICreateLogfileGroupContext) {
	localctx = NewCreateLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MySqlParserRULE_createLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(993)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(994)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(995)
		p.Uid()
	}
	{
		p.SetState(996)
		p.Match(MySqlParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(997)
		p.Match(MySqlParserUNDOFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(998)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateLogfileGroupContext).undoFile = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(999)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1000)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1003)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateLogfileGroupContext).initSize = _x
		}

	}
	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserUNDO_BUFFER_SIZE {
		{
			p.SetState(1006)
			p.Match(MySqlParserUNDO_BUFFER_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1007)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1010)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateLogfileGroupContext).undoSize = _x
		}

	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserREDO_BUFFER_SIZE {
		{
			p.SetState(1013)
			p.Match(MySqlParserREDO_BUFFER_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1014)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1017)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateLogfileGroupContext).redoSize = _x
		}

	}
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNODEGROUP {
		{
			p.SetState(1020)
			p.Match(MySqlParserNODEGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1021)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1024)
			p.Uid()
		}

	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWAIT {
		{
			p.SetState(1027)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT {
		{
			p.SetState(1030)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1031)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1034)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*CreateLogfileGroupContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1037)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(1038)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1041)
		p.EngineName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateProcedureContext is an interface to support dynamic dispatch.
type ICreateProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OwnerStatement() IOwnerStatementContext
	AllProcedureParameter() []IProcedureParameterContext
	ProcedureParameter(i int) IProcedureParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateProcedureContext differentiates from other interfaces.
	IsCreateProcedureContext()
}

type CreateProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateProcedureContext() *CreateProcedureContext {
	var p = new(CreateProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createProcedure
	return p
}

func InitEmptyCreateProcedureContext(p *CreateProcedureContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createProcedure
}

func (*CreateProcedureContext) IsCreateProcedureContext() {}

func NewCreateProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createProcedure

	return p
}

func (s *CreateProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateProcedureContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateProcedureContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateProcedureContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateProcedureContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateProcedureContext) AllProcedureParameter() []IProcedureParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			len++
		}
	}

	tst := make([]IProcedureParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureParameterContext); ok {
			tst[i] = t.(IProcedureParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) ProcedureParameter(i int) IProcedureParameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureParameterContext)
}

func (s *CreateProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateProcedure() (localctx ICreateProcedureContext) {
	localctx = NewCreateProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MySqlParserRULE_createProcedure)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1043)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFINER {
		{
			p.SetState(1044)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1047)
		p.Match(MySqlParserPROCEDURE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1048)
		p.FullId()
	}
	{
		p.SetState(1049)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 151169654698547409) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		{
			p.SetState(1050)
			p.ProcedureParameter()
		}

	}
	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(1053)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.ProcedureParameter()
		}


		p.SetState(1059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1060)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1061)
				p.RoutineOption()
			}


		}
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1067)
		p.RoutineBody()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	DataType() IDataTypeContext
	RoutineBody() IRoutineBodyContext
	ReturnStatement() IReturnStatementContext
	OwnerStatement() IOwnerStatementContext
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllFunctionParameter() []IFunctionParameterContext
	FunctionParameter(i int) IFunctionParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createFunction
	return p
}

func InitEmptyCreateFunctionContext(p *CreateFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createFunction
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *CreateFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *CreateFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateFunctionContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateFunctionContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CreateFunctionContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *CreateFunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionContext) AllFunctionParameter() []IFunctionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParameterContext); ok {
			tst[i] = t.(IFunctionParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) FunctionParameter(i int) IFunctionParameterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *CreateFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (s *CreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateFunction() (localctx ICreateFunctionContext) {
	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MySqlParserRULE_createFunction)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFINER {
		{
			p.SetState(1070)
			p.OwnerStatement()
		}

	}
	p.SetState(1074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserAGGREGATE {
		{
			p.SetState(1073)
			p.Match(MySqlParserAGGREGATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1076)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1077)
			p.IfNotExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1080)
		p.FullId()
	}
	{
		p.SetState(1081)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		{
			p.SetState(1082)
			p.FunctionParameter()
		}

	}
	p.SetState(1089)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(1085)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1086)
			p.FunctionParameter()
		}


		p.SetState(1091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1092)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1093)
		p.Match(MySqlParserRETURNS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1094)
		p.DataType()
	}
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1095)
				p.RoutineOption()
			}


		}
		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALTER, MySqlParserANALYZE, MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCONDITION, MySqlParserCREATE, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDIAGNOSTICS, MySqlParserDROP, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserKILL, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserLOAD, MySqlParserLOCK, MySqlParserNUMBER, MySqlParserOPTIMIZE, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserLR_BRACKET, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		{
			p.SetState(1101)
			p.RoutineBody()
		}


	case MySqlParserRETURN:
		{
			p.SetState(1102)
			p.ReturnStatement()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfNotExists() IIfNotExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createRole
	return p
}

func InitEmptyCreateRoleContext(p *CreateRoleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createRole
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *CreateRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *CreateRoleContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateRole() (localctx ICreateRoleContext) {
	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MySqlParserRULE_createRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1106)
		p.Match(MySqlParserROLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1107)
			p.IfNotExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1110)
		p.RoleName()
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(1111)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1112)
			p.RoleName()
		}


		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateServerContext is an interface to support dynamic dispatch.
type ICreateServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWrapperName returns the wrapperName token.
	GetWrapperName() antlr.Token 


	// SetWrapperName sets the wrapperName token.
	SetWrapperName(antlr.Token) 


	// Getter signatures
	CREATE() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	FOREIGN() antlr.TerminalNode
	DATA() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateServerContext differentiates from other interfaces.
	IsCreateServerContext()
}

type CreateServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	wrapperName antlr.Token
}

func NewEmptyCreateServerContext() *CreateServerContext {
	var p = new(CreateServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createServer
	return p
}

func InitEmptyCreateServerContext(p *CreateServerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createServer
}

func (*CreateServerContext) IsCreateServerContext() {}

func NewCreateServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServerContext {
	var p = new(CreateServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createServer

	return p
}

func (s *CreateServerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServerContext) GetWrapperName() antlr.Token { return s.wrapperName }


func (s *CreateServerContext) SetWrapperName(v antlr.Token) { s.wrapperName = v }


func (s *CreateServerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *CreateServerContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateServerContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *CreateServerContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *CreateServerContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRAPPER, 0)
}

func (s *CreateServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *CreateServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *CreateServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateServerContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *CreateServerContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateServer(s)
	}
}

func (s *CreateServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateServer(s)
	}
}

func (s *CreateServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateServer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateServer() (localctx ICreateServerContext) {
	localctx = NewCreateServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MySqlParserRULE_createServer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1119)
		p.Match(MySqlParserSERVER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1120)
		p.Uid()
	}
	{
		p.SetState(1121)
		p.Match(MySqlParserFOREIGN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1122)
		p.Match(MySqlParserDATA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1123)
		p.Match(MySqlParserWRAPPER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1124)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateServerContext).wrapperName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMYSQL || _la == MySqlParserSTRING_LITERAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateServerContext).wrapperName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1125)
		p.Match(MySqlParserOPTIONS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1126)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1127)
		p.ServerOption()
	}
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(1128)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1129)
			p.ServerOption()
		}


		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1135)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTable
	return p
}

func InitEmptyCreateTableContext(p *CreateTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTable
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) CopyAll(ctx *CreateTableContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type CopyCreateTableContext struct {
	CreateTableContext
	parenthesisTable ITableNameContext 
}

func NewCopyCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CopyCreateTableContext {
	var p = new(CopyCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}


func (s *CopyCreateTableContext) GetParenthesisTable() ITableNameContext { return s.parenthesisTable }


func (s *CopyCreateTableContext) SetParenthesisTable(v ITableNameContext) { s.parenthesisTable = v }

func (s *CopyCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CopyCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *CopyCreateTableContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *CopyCreateTableContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CopyCreateTableContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *CopyCreateTableContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CopyCreateTableContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CopyCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *CopyCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}


func (s *CopyCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCopyCreateTable(s)
	}
}

func (s *CopyCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCopyCreateTable(s)
	}
}

func (s *CopyCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCopyCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}


type ColumnCreateTableContext struct {
	CreateTableContext
}

func NewColumnCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnCreateTableContext {
	var p = new(ColumnCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}

func (s *ColumnCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ColumnCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ColumnCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ColumnCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *ColumnCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *ColumnCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ColumnCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *ColumnCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *ColumnCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ColumnCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *ColumnCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnCreateTable(s)
	}
}

func (s *ColumnCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnCreateTable(s)
	}
}

func (s *ColumnCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitColumnCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}


type QueryCreateTableContext struct {
	CreateTableContext
	keyViolate antlr.Token
}

func NewQueryCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryCreateTableContext {
	var p = new(QueryCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}


func (s *QueryCreateTableContext) GetKeyViolate() antlr.Token { return s.keyViolate }


func (s *QueryCreateTableContext) SetKeyViolate(v antlr.Token) { s.keyViolate = v }

func (s *QueryCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *QueryCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *QueryCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *QueryCreateTableContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *QueryCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *QueryCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *QueryCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *QueryCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *QueryCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *QueryCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *QueryCreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *QueryCreateTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *QueryCreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *QueryCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *QueryCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *QueryCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryCreateTable(s)
	}
}

func (s *QueryCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryCreateTable(s)
	}
}

func (s *QueryCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) CreateTable() (localctx ICreateTableContext) {
	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MySqlParserRULE_createTable)
	var _la int

	var _alt int

	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCopyCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1137)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1138)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1141)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1143)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1142)
				p.IfNotExists()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1145)
			p.TableName()
		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLIKE:
			{
				p.SetState(1146)
				p.Match(MySqlParserLIKE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1147)
				p.TableName()
			}


		case MySqlParserLR_BRACKET:
			{
				p.SetState(1148)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1149)
				p.Match(MySqlParserLIKE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1150)

				var _x = p.TableName()


				localctx.(*CopyCreateTableContext).parenthesisTable = _x
			}
			{
				p.SetState(1151)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 2:
		localctx = NewQueryCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1155)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1156)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1159)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1161)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1160)
				p.IfNotExists()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1163)
			p.TableName()
		}
		p.SetState(1165)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1164)
				p.CreateDefinitions()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 25)) & ^0x3f) == 0 && ((int64(1) << (_la - 25)) & 72057594038059013) != 0) || _la == MySqlParserUNION || _la == MySqlParserCHAR || ((int64((_la - 341)) & ^0x3f) == 0 && ((int64(1) << (_la - 341)) & 4644375904747527) != 0) || ((int64((_la - 405)) & ^0x3f) == 0 && ((int64(1) << (_la - 405)) & 4612811918334230547) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 2366149022974977) != 0) || ((int64((_la - 602)) & ^0x3f) == 0 && ((int64(1) << (_la - 602)) & 4609173815820289) != 0) || _la == MySqlParserCHARSET || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserSTRING_LITERAL {
			{
				p.SetState(1167)
				p.TableOption()
			}
			p.SetState(1174)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for ((int64((_la - 25)) & ^0x3f) == 0 && ((int64(1) << (_la - 25)) & 72057594038059013) != 0) || _la == MySqlParserUNION || _la == MySqlParserCHAR || ((int64((_la - 341)) & ^0x3f) == 0 && ((int64(1) << (_la - 341)) & 4644375904747527) != 0) || ((int64((_la - 405)) & ^0x3f) == 0 && ((int64(1) << (_la - 405)) & 4612811918334230547) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 2366149022974977) != 0) || ((int64((_la - 602)) & ^0x3f) == 0 && ((int64(1) << (_la - 602)) & 4609173815820289) != 0) || _la == MySqlParserCHARSET || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserCOMMA || _la == MySqlParserSTRING_LITERAL {
				p.SetState(1169)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserCOMMA {
					{
						p.SetState(1168)
						p.Match(MySqlParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(1171)
					p.TableOption()
				}


				p.SetState(1176)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPARTITION {
			{
				p.SetState(1179)
				p.PartitionDefinitions()
			}

		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
			{
				p.SetState(1182)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*QueryCreateTableContext).keyViolate = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*QueryCreateTableContext).keyViolate = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(1185)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1188)
			p.SelectStatement()
		}


	case 3:
		localctx = NewColumnCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1190)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1191)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1194)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1196)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1195)
				p.IfNotExists()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1198)
			p.TableName()
		}
		{
			p.SetState(1199)
			p.CreateDefinitions()
		}
		p.SetState(1210)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1200)
				p.TableOption()
			}
			p.SetState(1207)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(1202)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)


					if _la == MySqlParserCOMMA {
						{
							p.SetState(1201)
							p.Match(MySqlParserCOMMA)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}

					}
					{
						p.SetState(1204)
						p.TableOption()
					}


				}
				p.SetState(1209)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPARTITION {
			{
				p.SetState(1212)
				p.PartitionDefinitions()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTablespaceInnodbContext is an interface to support dynamic dispatch.
type ICreateTablespaceInnodbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token 


	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token) 


	// GetFileBlockSize returns the fileBlockSize rule contexts.
	GetFileBlockSize() IFileSizeLiteralContext


	// SetFileBlockSize sets the fileBlockSize rule contexts.
	SetFileBlockSize(IFileSizeLiteralContext)


	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	FileSizeLiteral() IFileSizeLiteralContext

	// IsCreateTablespaceInnodbContext differentiates from other interfaces.
	IsCreateTablespaceInnodbContext()
}

type CreateTablespaceInnodbContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	datafile antlr.Token
	fileBlockSize IFileSizeLiteralContext 
}

func NewEmptyCreateTablespaceInnodbContext() *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb
	return p
}

func InitEmptyCreateTablespaceInnodbContext(p *CreateTablespaceInnodbContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb
}

func (*CreateTablespaceInnodbContext) IsCreateTablespaceInnodbContext() {}

func NewCreateTablespaceInnodbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb

	return p
}

func (s *CreateTablespaceInnodbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceInnodbContext) GetDatafile() antlr.Token { return s.datafile }


func (s *CreateTablespaceInnodbContext) SetDatafile(v antlr.Token) { s.datafile = v }


func (s *CreateTablespaceInnodbContext) GetFileBlockSize() IFileSizeLiteralContext { return s.fileBlockSize }


func (s *CreateTablespaceInnodbContext) SetFileBlockSize(v IFileSizeLiteralContext) { s.fileBlockSize = v }


func (s *CreateTablespaceInnodbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTablespaceInnodbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *CreateTablespaceInnodbContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceInnodbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateTablespaceInnodbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *CreateTablespaceInnodbContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateTablespaceInnodbContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE_BLOCK_SIZE, 0)
}

func (s *CreateTablespaceInnodbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceInnodbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceInnodbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateTablespaceInnodbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceInnodbContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceInnodbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceInnodbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTablespaceInnodbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTablespaceInnodb(s)
	}
}

func (s *CreateTablespaceInnodbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTablespaceInnodb(s)
	}
}

func (s *CreateTablespaceInnodbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateTablespaceInnodb(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateTablespaceInnodb() (localctx ICreateTablespaceInnodbContext) {
	localctx = NewCreateTablespaceInnodbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MySqlParserRULE_createTablespaceInnodb)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1218)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1219)
		p.Uid()
	}
	{
		p.SetState(1220)
		p.Match(MySqlParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1221)
		p.Match(MySqlParserDATAFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1222)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateTablespaceInnodbContext).datafile = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFILE_BLOCK_SIZE {
		{
			p.SetState(1223)
			p.Match(MySqlParserFILE_BLOCK_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1224)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1225)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateTablespaceInnodbContext).fileBlockSize = _x
		}

	}
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserENGINE {
		{
			p.SetState(1228)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1229)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1232)
			p.EngineName()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTablespaceNdbContext is an interface to support dynamic dispatch.
type ICreateTablespaceNdbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token 

	// GetComment returns the comment token.
	GetComment() antlr.Token 


	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token) 

	// SetComment sets the comment token.
	SetComment(antlr.Token) 


	// GetExtentSize returns the extentSize rule contexts.
	GetExtentSize() IFileSizeLiteralContext

	// GetInitialSize returns the initialSize rule contexts.
	GetInitialSize() IFileSizeLiteralContext

	// GetAutoextendSize returns the autoextendSize rule contexts.
	GetAutoextendSize() IFileSizeLiteralContext

	// GetMaxSize returns the maxSize rule contexts.
	GetMaxSize() IFileSizeLiteralContext


	// SetExtentSize sets the extentSize rule contexts.
	SetExtentSize(IFileSizeLiteralContext)

	// SetInitialSize sets the initialSize rule contexts.
	SetInitialSize(IFileSizeLiteralContext)

	// SetAutoextendSize sets the autoextendSize rule contexts.
	SetAutoextendSize(IFileSizeLiteralContext)

	// SetMaxSize sets the maxSize rule contexts.
	SetMaxSize(IFileSizeLiteralContext)


	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	USE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateTablespaceNdbContext differentiates from other interfaces.
	IsCreateTablespaceNdbContext()
}

type CreateTablespaceNdbContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	datafile antlr.Token
	extentSize IFileSizeLiteralContext 
	initialSize IFileSizeLiteralContext 
	autoextendSize IFileSizeLiteralContext 
	maxSize IFileSizeLiteralContext 
	comment antlr.Token
}

func NewEmptyCreateTablespaceNdbContext() *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb
	return p
}

func InitEmptyCreateTablespaceNdbContext(p *CreateTablespaceNdbContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb
}

func (*CreateTablespaceNdbContext) IsCreateTablespaceNdbContext() {}

func NewCreateTablespaceNdbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb

	return p
}

func (s *CreateTablespaceNdbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceNdbContext) GetDatafile() antlr.Token { return s.datafile }

func (s *CreateTablespaceNdbContext) GetComment() antlr.Token { return s.comment }


func (s *CreateTablespaceNdbContext) SetDatafile(v antlr.Token) { s.datafile = v }

func (s *CreateTablespaceNdbContext) SetComment(v antlr.Token) { s.comment = v }


func (s *CreateTablespaceNdbContext) GetExtentSize() IFileSizeLiteralContext { return s.extentSize }

func (s *CreateTablespaceNdbContext) GetInitialSize() IFileSizeLiteralContext { return s.initialSize }

func (s *CreateTablespaceNdbContext) GetAutoextendSize() IFileSizeLiteralContext { return s.autoextendSize }

func (s *CreateTablespaceNdbContext) GetMaxSize() IFileSizeLiteralContext { return s.maxSize }


func (s *CreateTablespaceNdbContext) SetExtentSize(v IFileSizeLiteralContext) { s.extentSize = v }

func (s *CreateTablespaceNdbContext) SetInitialSize(v IFileSizeLiteralContext) { s.initialSize = v }

func (s *CreateTablespaceNdbContext) SetAutoextendSize(v IFileSizeLiteralContext) { s.autoextendSize = v }

func (s *CreateTablespaceNdbContext) SetMaxSize(v IFileSizeLiteralContext) { s.maxSize = v }


func (s *CreateTablespaceNdbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTablespaceNdbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *CreateTablespaceNdbContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceNdbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateTablespaceNdbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *CreateTablespaceNdbContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *CreateTablespaceNdbContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *CreateTablespaceNdbContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *CreateTablespaceNdbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateTablespaceNdbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceNdbContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CreateTablespaceNdbContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CreateTablespaceNdbContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENT_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *CreateTablespaceNdbContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *CreateTablespaceNdbContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateTablespaceNdbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceNdbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceNdbContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceNdbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceNdbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTablespaceNdbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTablespaceNdb(s)
	}
}

func (s *CreateTablespaceNdbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTablespaceNdb(s)
	}
}

func (s *CreateTablespaceNdbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateTablespaceNdb(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateTablespaceNdb() (localctx ICreateTablespaceNdbContext) {
	localctx = NewCreateTablespaceNdbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MySqlParserRULE_createTablespaceNdb)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1236)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1237)
		p.Uid()
	}
	{
		p.SetState(1238)
		p.Match(MySqlParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1239)
		p.Match(MySqlParserDATAFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1240)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateTablespaceNdbContext).datafile = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1241)
		p.Match(MySqlParserUSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1242)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1243)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1244)
		p.Uid()
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEXTENT_SIZE {
		{
			p.SetState(1245)
			p.Match(MySqlParserEXTENT_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1246)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1249)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateTablespaceNdbContext).extentSize = _x
		}

	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(1252)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1253)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1256)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateTablespaceNdbContext).initialSize = _x
		}

	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserAUTOEXTEND_SIZE {
		{
			p.SetState(1259)
			p.Match(MySqlParserAUTOEXTEND_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1260)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1263)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateTablespaceNdbContext).autoextendSize = _x
		}

	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserMAX_SIZE {
		{
			p.SetState(1266)
			p.Match(MySqlParserMAX_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1267)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1270)

			var _x = p.FileSizeLiteral()


			localctx.(*CreateTablespaceNdbContext).maxSize = _x
		}

	}
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNODEGROUP {
		{
			p.SetState(1273)
			p.Match(MySqlParserNODEGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1274)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1277)
			p.Uid()
		}

	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWAIT {
		{
			p.SetState(1280)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT {
		{
			p.SetState(1283)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1284)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1287)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*CreateTablespaceNdbContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1290)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(1291)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1294)
		p.EngineName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTriggerTime returns the triggerTime token.
	GetTriggerTime() antlr.Token 

	// GetTriggerEvent returns the triggerEvent token.
	GetTriggerEvent() antlr.Token 

	// GetTriggerPlace returns the triggerPlace token.
	GetTriggerPlace() antlr.Token 


	// SetTriggerTime sets the triggerTime token.
	SetTriggerTime(antlr.Token) 

	// SetTriggerEvent sets the triggerEvent token.
	SetTriggerEvent(antlr.Token) 

	// SetTriggerPlace sets the triggerPlace token.
	SetTriggerPlace(antlr.Token) 


	// GetThisTrigger returns the thisTrigger rule contexts.
	GetThisTrigger() IFullIdContext

	// GetOtherTrigger returns the otherTrigger rule contexts.
	GetOtherTrigger() IFullIdContext


	// SetThisTrigger sets the thisTrigger rule contexts.
	SetThisTrigger(IFullIdContext)

	// SetOtherTrigger sets the otherTrigger rule contexts.
	SetOtherTrigger(IFullIdContext)


	// Getter signatures
	CREATE() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	FOR() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	BEFORE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	FOLLOWS() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	thisTrigger IFullIdContext 
	triggerTime antlr.Token
	triggerEvent antlr.Token
	triggerPlace antlr.Token
	otherTrigger IFullIdContext 
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTrigger
	return p
}

func InitEmptyCreateTriggerContext(p *CreateTriggerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTrigger
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) GetTriggerTime() antlr.Token { return s.triggerTime }

func (s *CreateTriggerContext) GetTriggerEvent() antlr.Token { return s.triggerEvent }

func (s *CreateTriggerContext) GetTriggerPlace() antlr.Token { return s.triggerPlace }


func (s *CreateTriggerContext) SetTriggerTime(v antlr.Token) { s.triggerTime = v }

func (s *CreateTriggerContext) SetTriggerEvent(v antlr.Token) { s.triggerEvent = v }

func (s *CreateTriggerContext) SetTriggerPlace(v antlr.Token) { s.triggerPlace = v }


func (s *CreateTriggerContext) GetThisTrigger() IFullIdContext { return s.thisTrigger }

func (s *CreateTriggerContext) GetOtherTrigger() IFullIdContext { return s.otherTrigger }


func (s *CreateTriggerContext) SetThisTrigger(v IFullIdContext) { s.thisTrigger = v }

func (s *CreateTriggerContext) SetOtherTrigger(v IFullIdContext) { s.otherTrigger = v }


func (s *CreateTriggerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *CreateTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *CreateTriggerContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTriggerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *CreateTriggerContext) EACH() antlr.TerminalNode {
	return s.GetToken(MySqlParserEACH, 0)
}

func (s *CreateTriggerContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *CreateTriggerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *CreateTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateTriggerContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEFORE, 0)
}

func (s *CreateTriggerContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *CreateTriggerContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *CreateTriggerContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *CreateTriggerContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *CreateTriggerContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateTriggerContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWS, 0)
}

func (s *CreateTriggerContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDES, 0)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateTrigger() (localctx ICreateTriggerContext) {
	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MySqlParserRULE_createTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1296)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFINER {
		{
			p.SetState(1297)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1300)
		p.Match(MySqlParserTRIGGER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1301)

		var _x = p.FullId()


		localctx.(*CreateTriggerContext).thisTrigger = _x
	}
	{
		p.SetState(1302)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerTime = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBEFORE || _la == MySqlParserAFTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerTime = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1303)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerEvent = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDELETE || _la == MySqlParserINSERT || _la == MySqlParserUPDATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerEvent = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1304)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1305)
		p.TableName()
	}
	{
		p.SetState(1306)
		p.Match(MySqlParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1307)
		p.Match(MySqlParserEACH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1308)
		p.Match(MySqlParserROW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1309)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTriggerContext).triggerPlace = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWS || _la == MySqlParserPRECEDES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTriggerContext).triggerPlace = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1310)

			var _x = p.FullId()


			localctx.(*CreateTriggerContext).otherTrigger = _x
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1313)
		p.RoutineBody()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext
	RECURSIVE() antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *WithClauseContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *WithClauseContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MySqlParserRULE_withClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Match(MySqlParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1317)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1316)
			p.Match(MySqlParserRECURSIVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1319)
		p.CommonTableExpressions()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommonTableExpressionsContext is an interface to support dynamic dispatch.
type ICommonTableExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CteName() ICteNameContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	DmlStatement() IDmlStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCteColumnName() []ICteColumnNameContext
	CteColumnName(i int) ICteColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext

	// IsCommonTableExpressionsContext differentiates from other interfaces.
	IsCommonTableExpressionsContext()
}

type CommonTableExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonTableExpressionsContext() *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commonTableExpressions
	return p
}

func InitEmptyCommonTableExpressionsContext(p *CommonTableExpressionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commonTableExpressions
}

func (*CommonTableExpressionsContext) IsCommonTableExpressionsContext() {}

func NewCommonTableExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_commonTableExpressions

	return p
}

func (s *CommonTableExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionsContext) CteName() ICteNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteNameContext)
}

func (s *CommonTableExpressionsContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *CommonTableExpressionsContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *CommonTableExpressionsContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *CommonTableExpressionsContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *CommonTableExpressionsContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) AllCteColumnName() []ICteColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			len++
		}
	}

	tst := make([]ICteColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICteColumnNameContext); ok {
			tst[i] = t.(ICteColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *CommonTableExpressionsContext) CteColumnName(i int) ICteColumnNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteColumnNameContext)
}

func (s *CommonTableExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CommonTableExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CommonTableExpressionsContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *CommonTableExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CommonTableExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommonTableExpressions(s)
	}
}

func (s *CommonTableExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommonTableExpressions(s)
	}
}

func (s *CommonTableExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCommonTableExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CommonTableExpressions() (localctx ICommonTableExpressionsContext) {
	localctx = NewCommonTableExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MySqlParserRULE_commonTableExpressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1321)
		p.CteName()
	}
	p.SetState(1333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(1322)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1323)
			p.CteColumnName()
		}
		p.SetState(1328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(1324)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1325)
				p.CteColumnName()
			}


			p.SetState(1330)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1331)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1335)
		p.Match(MySqlParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1336)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1337)
		p.DmlStatement()
	}
	{
		p.SetState(1338)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1341)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1339)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1340)
			p.CommonTableExpressions()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICteNameContext is an interface to support dynamic dispatch.
type ICteNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteNameContext differentiates from other interfaces.
	IsCteNameContext()
}

type CteNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteNameContext() *CteNameContext {
	var p = new(CteNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteName
	return p
}

func InitEmptyCteNameContext(p *CteNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteName
}

func (*CteNameContext) IsCteNameContext() {}

func NewCteNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteNameContext {
	var p = new(CteNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cteName

	return p
}

func (s *CteNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CteNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCteName(s)
	}
}

func (s *CteNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCteName(s)
	}
}

func (s *CteNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCteName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CteName() (localctx ICteNameContext) {
	localctx = NewCteNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MySqlParserRULE_cteName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1343)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICteColumnNameContext is an interface to support dynamic dispatch.
type ICteColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteColumnNameContext differentiates from other interfaces.
	IsCteColumnNameContext()
}

type CteColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteColumnNameContext() *CteColumnNameContext {
	var p = new(CteColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteColumnName
	return p
}

func InitEmptyCteColumnNameContext(p *CteColumnNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteColumnName
}

func (*CteColumnNameContext) IsCteColumnNameContext() {}

func NewCteColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteColumnNameContext {
	var p = new(CteColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cteColumnName

	return p
}

func (s *CteColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CteColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCteColumnName(s)
	}
}

func (s *CteColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCteColumnName(s)
	}
}

func (s *CteColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCteColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CteColumnName() (localctx ICteColumnNameContext) {
	localctx = NewCteColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MySqlParserRULE_cteColumnName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1345)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token 

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token 

	// GetCheckOption returns the checkOption token.
	GetCheckOption() antlr.Token 


	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token) 

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token) 

	// SetCheckOption sets the checkOption token.
	SetCheckOption(antlr.Token) 


	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	OrReplace() IOrReplaceContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	UidList() IUidListContext
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	WithClause() IWithClauseContext
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	algType antlr.Token
	secContext antlr.Token
	checkOption antlr.Token
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createView
	return p
}

func InitEmptyCreateViewContext(p *CreateViewContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createView
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *CreateViewContext) GetCheckOption() antlr.Token { return s.checkOption }


func (s *CreateViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *CreateViewContext) SetCheckOption(v antlr.Token) { s.checkOption = v }


func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *CreateViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *CreateViewContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *CreateViewContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *CreateViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CreateViewContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *CreateViewContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *CreateViewContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *CreateViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *CreateViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *CreateViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *CreateViewContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CreateViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *CreateViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *CreateViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *CreateViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *CreateViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *CreateViewContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *CreateViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *CreateViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CreateViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *CreateViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *CreateViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateView() (localctx ICreateViewContext) {
	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MySqlParserRULE_createView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserOR {
		{
			p.SetState(1348)
			p.OrReplace()
		}

	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserALGORITHM {
		{
			p.SetState(1351)
			p.Match(MySqlParserALGORITHM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1353)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMERGE || _la == MySqlParserTEMPTABLE || _la == MySqlParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFINER {
		{
			p.SetState(1356)
			p.OwnerStatement()
		}

	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserSQL {
		{
			p.SetState(1359)
			p.Match(MySqlParserSQL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1360)
			p.Match(MySqlParserSECURITY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1361)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1364)
		p.Match(MySqlParserVIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1365)
		p.FullId()
	}
	p.SetState(1370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(1366)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1367)
			p.UidList()
		}
		{
			p.SetState(1368)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1372)
		p.Match(MySqlParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1373)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserWITH {
			{
				p.SetState(1374)
				p.WithClause()
			}

		}
		{
			p.SetState(1377)
			p.SelectStatement()
		}
		{
			p.SetState(1378)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.SetState(1381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserWITH {
			{
				p.SetState(1380)
				p.WithClause()
			}

		}
		{
			p.SetState(1383)
			p.SelectStatement()
		}
		p.SetState(1390)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1384)
				p.Match(MySqlParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1386)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserCASCADED || _la == MySqlParserLOCAL {
				{
					p.SetState(1385)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateViewContext).checkOption = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserCASCADED || _la == MySqlParserLOCAL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateViewContext).checkOption = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1388)
				p.Match(MySqlParserCHECK)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1389)
				p.Match(MySqlParserOPTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateDatabaseOptionContext is an interface to support dynamic dispatch.
type ICreateDatabaseOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext
	ENCRYPTION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsCreateDatabaseOptionContext differentiates from other interfaces.
	IsCreateDatabaseOptionContext()
}

type CreateDatabaseOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseOptionContext() *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabaseOption
	return p
}

func InitEmptyCreateDatabaseOptionContext(p *CreateDatabaseOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabaseOption
}

func (*CreateDatabaseOptionContext) IsCreateDatabaseOptionContext() {}

func NewCreateDatabaseOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDatabaseOption

	return p
}

func (s *CreateDatabaseOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseOptionContext) CharSet() ICharSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CreateDatabaseOptionContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CreateDatabaseOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *CreateDatabaseOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *CreateDatabaseOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *CreateDatabaseOptionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CreateDatabaseOptionContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CreateDatabaseOptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *CreateDatabaseOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateDatabaseOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *CreateDatabaseOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *CreateDatabaseOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateDatabaseOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateDatabaseOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateDatabaseOption() (localctx ICreateDatabaseOptionContext) {
	localctx = NewCreateDatabaseOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MySqlParserRULE_createDatabaseOption)
	var _la int

	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1394)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1397)
			p.CharSet()
		}
		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1398)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(1401)
				p.CharsetName()
			}


		case MySqlParserDEFAULT:
			{
				p.SetState(1402)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1405)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1408)
			p.Match(MySqlParserCOLLATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1409)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1412)
			p.CollationName()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1413)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1416)
			p.Match(MySqlParserENCRYPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1417)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1420)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1421)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1422)
			p.Match(MySqlParserONLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1423)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1426)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICharSetContext is an interface to support dynamic dispatch.
type ICharSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR() antlr.TerminalNode

	// IsCharSetContext differentiates from other interfaces.
	IsCharSetContext()
}

type CharSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharSetContext() *CharSetContext {
	var p = new(CharSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charSet
	return p
}

func InitEmptyCharSetContext(p *CharSetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charSet
}

func (*CharSetContext) IsCharSetContext() {}

func NewCharSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharSetContext {
	var p = new(CharSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charSet

	return p
}

func (s *CharSetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharSetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *CharSetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *CharSetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *CharSetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *CharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharSet(s)
	}
}

func (s *CharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharSet(s)
	}
}

func (s *CharSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharSet(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CharSet() (localctx ICharSetContext) {
	localctx = NewCharSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MySqlParserRULE_charSet)
	p.SetState(1434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1429)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1430)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1431)
			p.Match(MySqlParserCHARSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1432)
			p.Match(MySqlParserCHAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1433)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICurrentUserExpressionContext is an interface to support dynamic dispatch.
type ICurrentUserExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_USER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsCurrentUserExpressionContext differentiates from other interfaces.
	IsCurrentUserExpressionContext()
}

type CurrentUserExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentUserExpressionContext() *CurrentUserExpressionContext {
	var p = new(CurrentUserExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentUserExpression
	return p
}

func InitEmptyCurrentUserExpressionContext(p *CurrentUserExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentUserExpression
}

func (*CurrentUserExpressionContext) IsCurrentUserExpressionContext() {}

func NewCurrentUserExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentUserExpressionContext {
	var p = new(CurrentUserExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_currentUserExpression

	return p
}

func (s *CurrentUserExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentUserExpressionContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *CurrentUserExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CurrentUserExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CurrentUserExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CurrentUserExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentUserExpression(s)
	}
}

func (s *CurrentUserExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentUserExpression(s)
	}
}

func (s *CurrentUserExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentUserExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CurrentUserExpression() (localctx ICurrentUserExpressionContext) {
	localctx = NewCurrentUserExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MySqlParserRULE_currentUserExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1436)
		p.Match(MySqlParserCURRENT_USER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1437)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1438)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOwnerStatementContext is an interface to support dynamic dispatch.
type IOwnerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFINER() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	UserName() IUserNameContext
	CurrentUserExpression() ICurrentUserExpressionContext

	// IsOwnerStatementContext differentiates from other interfaces.
	IsOwnerStatementContext()
}

type OwnerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwnerStatementContext() *OwnerStatementContext {
	var p = new(OwnerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ownerStatement
	return p
}

func InitEmptyOwnerStatementContext(p *OwnerStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ownerStatement
}

func (*OwnerStatementContext) IsOwnerStatementContext() {}

func NewOwnerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OwnerStatementContext {
	var p = new(OwnerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ownerStatement

	return p
}

func (s *OwnerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OwnerStatementContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *OwnerStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *OwnerStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *OwnerStatementContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}

func (s *OwnerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OwnerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OwnerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOwnerStatement(s)
	}
}

func (s *OwnerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOwnerStatement(s)
	}
}

func (s *OwnerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOwnerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) OwnerStatement() (localctx IOwnerStatementContext) {
	localctx = NewOwnerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MySqlParserRULE_ownerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1441)
		p.Match(MySqlParserDEFINER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1442)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1443)
			p.UserName()
		}


	case 2:
		{
			p.SetState(1444)
			p.CurrentUserExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IScheduleExpressionContext is an interface to support dynamic dispatch.
type IScheduleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsScheduleExpressionContext differentiates from other interfaces.
	IsScheduleExpressionContext()
}

type ScheduleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScheduleExpressionContext() *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scheduleExpression
	return p
}

func InitEmptyScheduleExpressionContext(p *ScheduleExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scheduleExpression
}

func (*ScheduleExpressionContext) IsScheduleExpressionContext() {}

func NewScheduleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_scheduleExpression

	return p
}

func (s *ScheduleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScheduleExpressionContext) CopyAll(ctx *ScheduleExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ScheduleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScheduleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type PreciseScheduleContext struct {
	ScheduleExpressionContext
}

func NewPreciseScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreciseScheduleContext {
	var p = new(PreciseScheduleContext)

	InitEmptyScheduleExpressionContext(&p.ScheduleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ScheduleExpressionContext))

	return p
}

func (s *PreciseScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreciseScheduleContext) AT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT, 0)
}

func (s *PreciseScheduleContext) TimestampValue() ITimestampValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *PreciseScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *PreciseScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}


func (s *PreciseScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPreciseSchedule(s)
	}
}

func (s *PreciseScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPreciseSchedule(s)
	}
}

func (s *PreciseScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPreciseSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}


type IntervalScheduleContext struct {
	ScheduleExpressionContext
	startTimestamp ITimestampValueContext 
	_intervalExpr IIntervalExprContext 
	startIntervals []IIntervalExprContext
	endTimestamp ITimestampValueContext 
	endIntervals []IIntervalExprContext
}

func NewIntervalScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalScheduleContext {
	var p = new(IntervalScheduleContext)

	InitEmptyScheduleExpressionContext(&p.ScheduleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ScheduleExpressionContext))

	return p
}


func (s *IntervalScheduleContext) GetStartTimestamp() ITimestampValueContext { return s.startTimestamp }

func (s *IntervalScheduleContext) Get_intervalExpr() IIntervalExprContext { return s._intervalExpr }

func (s *IntervalScheduleContext) GetEndTimestamp() ITimestampValueContext { return s.endTimestamp }


func (s *IntervalScheduleContext) SetStartTimestamp(v ITimestampValueContext) { s.startTimestamp = v }

func (s *IntervalScheduleContext) Set_intervalExpr(v IIntervalExprContext) { s._intervalExpr = v }

func (s *IntervalScheduleContext) SetEndTimestamp(v ITimestampValueContext) { s.endTimestamp = v }


func (s *IntervalScheduleContext) GetStartIntervals() []IIntervalExprContext { return s.startIntervals }

func (s *IntervalScheduleContext) GetEndIntervals() []IIntervalExprContext { return s.endIntervals }


func (s *IntervalScheduleContext) SetStartIntervals(v []IIntervalExprContext) { s.startIntervals = v }

func (s *IntervalScheduleContext) SetEndIntervals(v []IIntervalExprContext) { s.endIntervals = v }

func (s *IntervalScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVERY, 0)
}

func (s *IntervalScheduleContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalScheduleContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalScheduleContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTS, 0)
}

func (s *IntervalScheduleContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDS, 0)
}

func (s *IntervalScheduleContext) AllTimestampValue() []ITimestampValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITimestampValueContext); ok {
			len++
		}
	}

	tst := make([]ITimestampValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITimestampValueContext); ok {
			tst[i] = t.(ITimestampValueContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) TimestampValue(i int) ITimestampValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *IntervalScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}


func (s *IntervalScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalSchedule(s)
	}
}

func (s *IntervalScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalSchedule(s)
	}
}

func (s *IntervalScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) ScheduleExpression() (localctx IScheduleExpressionContext) {
	localctx = NewScheduleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MySqlParserRULE_scheduleExpression)
	var _la int

	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAT:
		localctx = NewPreciseScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1447)
			p.Match(MySqlParserAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1448)
			p.TimestampValue()
		}
		p.SetState(1452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserPLUS {
			{
				p.SetState(1449)
				p.IntervalExpr()
			}


			p.SetState(1454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case MySqlParserEVERY:
		localctx = NewIntervalScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1455)
			p.Match(MySqlParserEVERY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1456)
				p.DecimalLiteral()
			}


		case 2:
			{
				p.SetState(1457)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1460)
			p.IntervalType()
		}
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserSTARTS {
			{
				p.SetState(1461)
				p.Match(MySqlParserSTARTS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1462)

				var _x = p.TimestampValue()


				localctx.(*IntervalScheduleContext).startTimestamp = _x
			}
			p.SetState(1466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserPLUS {
				{
					p.SetState(1463)

					var _x = p.IntervalExpr()


					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).startIntervals = append(localctx.(*IntervalScheduleContext).startIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)


				p.SetState(1468)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserENDS {
			{
				p.SetState(1471)
				p.Match(MySqlParserENDS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1472)

				var _x = p.TimestampValue()


				localctx.(*IntervalScheduleContext).endTimestamp = _x
			}
			p.SetState(1476)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserPLUS {
				{
					p.SetState(1473)

					var _x = p.IntervalExpr()


					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).endIntervals = append(localctx.(*IntervalScheduleContext).endIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)


				p.SetState(1478)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITimestampValueContext is an interface to support dynamic dispatch.
type ITimestampValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_TIMESTAMP() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsTimestampValueContext differentiates from other interfaces.
	IsTimestampValueContext()
}

type TimestampValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampValueContext() *TimestampValueContext {
	var p = new(TimestampValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_timestampValue
	return p
}

func InitEmptyTimestampValueContext(p *TimestampValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_timestampValue
}

func (*TimestampValueContext) IsTimestampValueContext() {}

func NewTimestampValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampValueContext {
	var p = new(TimestampValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_timestampValue

	return p
}

func (s *TimestampValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampValueContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *TimestampValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TimestampValueContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TimestampValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TimestampValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TimestampValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTimestampValue(s)
	}
}

func (s *TimestampValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTimestampValue(s)
	}
}

func (s *TimestampValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTimestampValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TimestampValue() (localctx ITimestampValueContext) {
	localctx = NewTimestampValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MySqlParserRULE_timestampValue)
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1483)
			p.Match(MySqlParserCURRENT_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1484)
			p.StringLiteral()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1485)
			p.DecimalLiteral()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1486)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalExprContext is an interface to support dynamic dispatch.
type IIntervalExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	IntervalType() IIntervalTypeContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsIntervalExprContext differentiates from other interfaces.
	IsIntervalExprContext()
}

type IntervalExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalExprContext() *IntervalExprContext {
	var p = new(IntervalExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalExpr
	return p
}

func InitEmptyIntervalExprContext(p *IntervalExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalExpr
}

func (*IntervalExprContext) IsIntervalExprContext() {}

func NewIntervalExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalExprContext {
	var p = new(IntervalExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalExpr

	return p
}

func (s *IntervalExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *IntervalExprContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *IntervalExprContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExprContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalExpr(s)
	}
}

func (s *IntervalExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalExpr(s)
	}
}

func (s *IntervalExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IntervalExpr() (localctx IIntervalExprContext) {
	localctx = NewIntervalExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MySqlParserRULE_intervalExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1489)
		p.Match(MySqlParserPLUS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1490)
		p.Match(MySqlParserINTERVAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1491)
			p.DecimalLiteral()
		}


	case 2:
		{
			p.SetState(1492)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1495)
		p.IntervalType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalTypeContext is an interface to support dynamic dispatch.
type IIntervalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalTypeBase() IIntervalTypeBaseContext
	YEAR() antlr.TerminalNode
	YEAR_MONTH() antlr.TerminalNode
	DAY_HOUR() antlr.TerminalNode
	DAY_MINUTE() antlr.TerminalNode
	DAY_SECOND() antlr.TerminalNode
	HOUR_MINUTE() antlr.TerminalNode
	HOUR_SECOND() antlr.TerminalNode
	MINUTE_SECOND() antlr.TerminalNode
	SECOND_MICROSECOND() antlr.TerminalNode
	MINUTE_MICROSECOND() antlr.TerminalNode
	HOUR_MICROSECOND() antlr.TerminalNode
	DAY_MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeContext differentiates from other interfaces.
	IsIntervalTypeContext()
}

type IntervalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeContext() *IntervalTypeContext {
	var p = new(IntervalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalType
	return p
}

func InitEmptyIntervalTypeContext(p *IntervalTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalType
}

func (*IntervalTypeContext) IsIntervalTypeContext() {}

func NewIntervalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalType

	return p
}

func (s *IntervalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *IntervalTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *IntervalTypeContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR_MONTH, 0)
}

func (s *IntervalTypeContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_HOUR, 0)
}

func (s *IntervalTypeContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MINUTE, 0)
}

func (s *IntervalTypeContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_SECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MINUTE, 0)
}

func (s *IntervalTypeContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_SECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_SECOND, 0)
}

func (s *IntervalTypeContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND_MICROSECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_MICROSECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MICROSECOND, 0)
}

func (s *IntervalTypeContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MICROSECOND, 0)
}

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (s *IntervalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IntervalType() (localctx IIntervalTypeContext) {
	localctx = NewIntervalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MySqlParserRULE_intervalType)
	p.SetState(1510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1497)
			p.IntervalTypeBase()
		}


	case MySqlParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1498)
			p.Match(MySqlParserYEAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserYEAR_MONTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1499)
			p.Match(MySqlParserYEAR_MONTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDAY_HOUR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1500)
			p.Match(MySqlParserDAY_HOUR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDAY_MINUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1501)
			p.Match(MySqlParserDAY_MINUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDAY_SECOND:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1502)
			p.Match(MySqlParserDAY_SECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserHOUR_MINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1503)
			p.Match(MySqlParserHOUR_MINUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserHOUR_SECOND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1504)
			p.Match(MySqlParserHOUR_SECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMINUTE_SECOND:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1505)
			p.Match(MySqlParserMINUTE_SECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSECOND_MICROSECOND:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1506)
			p.Match(MySqlParserSECOND_MICROSECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMINUTE_MICROSECOND:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1507)
			p.Match(MySqlParserMINUTE_MICROSECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserHOUR_MICROSECOND:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1508)
			p.Match(MySqlParserHOUR_MICROSECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDAY_MICROSECOND:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1509)
			p.Match(MySqlParserDAY_MICROSECOND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnableTypeContext is an interface to support dynamic dispatch.
type IEnableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENABLE() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SLAVE() antlr.TerminalNode

	// IsEnableTypeContext differentiates from other interfaces.
	IsEnableTypeContext()
}

type EnableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableTypeContext() *EnableTypeContext {
	var p = new(EnableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_enableType
	return p
}

func InitEmptyEnableTypeContext(p *EnableTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_enableType
}

func (*EnableTypeContext) IsEnableTypeContext() {}

func NewEnableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableTypeContext {
	var p = new(EnableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_enableType

	return p
}

func (s *EnableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableTypeContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *EnableTypeContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *EnableTypeContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *EnableTypeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *EnableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEnableType(s)
	}
}

func (s *EnableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEnableType(s)
	}
}

func (s *EnableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEnableType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) EnableType() (localctx IEnableTypeContext) {
	localctx = NewEnableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MySqlParserRULE_enableType)
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1512)
			p.Match(MySqlParserENABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1513)
			p.Match(MySqlParserDISABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1514)
			p.Match(MySqlParserDISABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1515)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1516)
			p.Match(MySqlParserSLAVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	HASH() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *IndexTypeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBTREE, 0)
}

func (s *IndexTypeContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MySqlParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Match(MySqlParserUSING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1520)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBTREE || _la == MySqlParserHASH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	EQUAL_SYMBOL() antlr.TerminalNode
	IndexType() IIndexTypeContext
	WITH() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	Uid() IUidContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexOption
	return p
}

func InitEmptyIndexOptionContext(p *IndexOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexOption
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *IndexOptionContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *IndexOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IndexOptionContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *IndexOptionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARSER, 0)
}

func (s *IndexOptionContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexOptionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *IndexOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *IndexOptionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *IndexOptionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *IndexOptionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (s *IndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IndexOption() (localctx IIndexOptionContext) {
	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MySqlParserRULE_indexOption)
	var _la int

	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserKEY_BLOCK_SIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1522)
			p.Match(MySqlParserKEY_BLOCK_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1523)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1526)
			p.FileSizeLiteral()
		}


	case MySqlParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1527)
			p.IndexType()
		}


	case MySqlParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1528)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1529)
			p.Match(MySqlParserPARSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1530)
			p.Uid()
		}


	case MySqlParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1531)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1532)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserINVISIBLE, MySqlParserVISIBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1533)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case MySqlParserENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1534)
			p.Match(MySqlParserENGINE_ATTRIBUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1535)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1538)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSECONDARY_ENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1539)
			p.Match(MySqlParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1540)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1543)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IProcedureParameterContext is an interface to support dynamic dispatch.
type IProcedureParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDirection returns the direction token.
	GetDirection() antlr.Token 


	// SetDirection sets the direction token.
	SetDirection(antlr.Token) 


	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode
	INOUT() antlr.TerminalNode

	// IsProcedureParameterContext differentiates from other interfaces.
	IsProcedureParameterContext()
}

type ProcedureParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	direction antlr.Token
}

func NewEmptyProcedureParameterContext() *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureParameter
	return p
}

func InitEmptyProcedureParameterContext(p *ProcedureParameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureParameter
}

func (*ProcedureParameterContext) IsProcedureParameterContext() {}

func NewProcedureParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_procedureParameter

	return p
}

func (s *ProcedureParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureParameterContext) GetDirection() antlr.Token { return s.direction }


func (s *ProcedureParameterContext) SetDirection(v antlr.Token) { s.direction = v }


func (s *ProcedureParameterContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ProcedureParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ProcedureParameterContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ProcedureParameterContext) OUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUT, 0)
}

func (s *ProcedureParameterContext) INOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINOUT, 0)
}

func (s *ProcedureParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ProcedureParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitProcedureParameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ProcedureParameter() (localctx IProcedureParameterContext) {
	localctx = NewProcedureParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MySqlParserRULE_procedureParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 80)) & ^0x3f) == 0 && ((int64(1) << (_la - 80)) & 35184372088849) != 0) {
		{
			p.SetState(1546)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ProcedureParameterContext).direction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 80)) & ^0x3f) == 0 && ((int64(1) << (_la - 80)) & 35184372088849) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ProcedureParameterContext).direction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1549)
		p.Uid()
	}
	{
		p.SetState(1550)
		p.DataType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionParameter
	return p
}

func InitEmptyFunctionParameterContext(p *FunctionParameterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionParameter
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FunctionParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FunctionParameter() (localctx IFunctionParameterContext) {
	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MySqlParserRULE_functionParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.Uid()
	}
	{
		p.SetState(1553)
		p.DataType()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRoutineOptionContext is an interface to support dynamic dispatch.
type IRoutineOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRoutineOptionContext differentiates from other interfaces.
	IsRoutineOptionContext()
}

type RoutineOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineOptionContext() *RoutineOptionContext {
	var p = new(RoutineOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineOption
	return p
}

func InitEmptyRoutineOptionContext(p *RoutineOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineOption
}

func (*RoutineOptionContext) IsRoutineOptionContext() {}

func NewRoutineOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineOptionContext {
	var p = new(RoutineOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_routineOption

	return p
}

func (s *RoutineOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineOptionContext) CopyAll(ctx *RoutineOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RoutineOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type RoutineBehaviorContext struct {
	RoutineOptionContext
}

func NewRoutineBehaviorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineBehaviorContext {
	var p = new(RoutineBehaviorContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBehaviorContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDETERMINISTIC, 0)
}

func (s *RoutineBehaviorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}


func (s *RoutineBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineBehavior(s)
	}
}

func (s *RoutineBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineBehavior(s)
	}
}

func (s *RoutineBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}


type RoutineLanguageContext struct {
	RoutineOptionContext
}

func NewRoutineLanguageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineLanguageContext {
	var p = new(RoutineLanguageContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineLanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineLanguageContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLANGUAGE, 0)
}

func (s *RoutineLanguageContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}


func (s *RoutineLanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineLanguage(s)

	default:
		return t.VisitChildren(s)
	}
}


type RoutineCommentContext struct {
	RoutineOptionContext
}

func NewRoutineCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineCommentContext {
	var p = new(RoutineCommentContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *RoutineCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *RoutineCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineComment(s)
	}
}

func (s *RoutineCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineComment(s)
	}
}

func (s *RoutineCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineComment(s)

	default:
		return t.VisitChildren(s)
	}
}


type RoutineSecurityContext struct {
	RoutineOptionContext
	context antlr.Token
}

func NewRoutineSecurityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineSecurityContext {
	var p = new(RoutineSecurityContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}


func (s *RoutineSecurityContext) GetContext() antlr.Token { return s.context }


func (s *RoutineSecurityContext) SetContext(v antlr.Token) { s.context = v }

func (s *RoutineSecurityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineSecurityContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineSecurityContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *RoutineSecurityContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *RoutineSecurityContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}


func (s *RoutineSecurityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineSecurity(s)
	}
}

func (s *RoutineSecurityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineSecurity(s)
	}
}

func (s *RoutineSecurityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineSecurity(s)

	default:
		return t.VisitChildren(s)
	}
}


type RoutineDataContext struct {
	RoutineOptionContext
}

func NewRoutineDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineDataContext {
	var p = new(RoutineDataContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineDataContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTAINS, 0)
}

func (s *RoutineDataContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineDataContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *RoutineDataContext) READS() antlr.TerminalNode {
	return s.GetToken(MySqlParserREADS, 0)
}

func (s *RoutineDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *RoutineDataContext) MODIFIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFIES, 0)
}


func (s *RoutineDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineData(s)
	}
}

func (s *RoutineDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineData(s)
	}
}

func (s *RoutineDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineData(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) RoutineOption() (localctx IRoutineOptionContext) {
	localctx = NewRoutineOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MySqlParserRULE_routineOption)
	var _la int

	p.SetState(1578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCOMMENT:
		localctx = NewRoutineCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1555)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1556)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserLANGUAGE:
		localctx = NewRoutineLanguageContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1557)
			p.Match(MySqlParserLANGUAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1558)
			p.Match(MySqlParserSQL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDETERMINISTIC, MySqlParserNOT:
		localctx = NewRoutineBehaviorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(1559)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1562)
			p.Match(MySqlParserDETERMINISTIC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMODIFIES, MySqlParserREADS, MySqlParserCONTAINS, MySqlParserNO:
		localctx = NewRoutineDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCONTAINS:
			{
				p.SetState(1563)
				p.Match(MySqlParserCONTAINS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1564)
				p.Match(MySqlParserSQL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserNO:
			{
				p.SetState(1565)
				p.Match(MySqlParserNO)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1566)
				p.Match(MySqlParserSQL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserREADS:
			{
				p.SetState(1567)
				p.Match(MySqlParserREADS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1568)
				p.Match(MySqlParserSQL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1569)
				p.Match(MySqlParserDATA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserMODIFIES:
			{
				p.SetState(1570)
				p.Match(MySqlParserMODIFIES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1571)
				p.Match(MySqlParserSQL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1572)
				p.Match(MySqlParserDATA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserSQL:
		localctx = NewRoutineSecurityContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1575)
			p.Match(MySqlParserSQL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1576)
			p.Match(MySqlParserSECURITY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1577)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RoutineSecurityContext).context = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RoutineSecurityContext).context = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IServerOptionContext is an interface to support dynamic dispatch.
type IServerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOST() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	USER() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PORT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsServerOptionContext differentiates from other interfaces.
	IsServerOptionContext()
}

type ServerOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerOptionContext() *ServerOptionContext {
	var p = new(ServerOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_serverOption
	return p
}

func InitEmptyServerOptionContext(p *ServerOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_serverOption
}

func (*ServerOptionContext) IsServerOptionContext() {}

func NewServerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerOptionContext {
	var p = new(ServerOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_serverOption

	return p
}

func (s *ServerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerOptionContext) HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST, 0)
}

func (s *ServerOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ServerOptionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *ServerOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *ServerOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *ServerOptionContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOCKET, 0)
}

func (s *ServerOptionContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOWNER, 0)
}

func (s *ServerOptionContext) PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPORT, 0)
}

func (s *ServerOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ServerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ServerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterServerOption(s)
	}
}

func (s *ServerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitServerOption(s)
	}
}

func (s *ServerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitServerOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ServerOption() (localctx IServerOptionContext) {
	localctx = NewServerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MySqlParserRULE_serverOption)
	p.SetState(1594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserHOST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1580)
			p.Match(MySqlParserHOST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1581)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1582)
			p.Match(MySqlParserDATABASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1583)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserUSER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1584)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPASSWORD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1586)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1587)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSOCKET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1588)
			p.Match(MySqlParserSOCKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1589)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserOWNER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1590)
			p.Match(MySqlParserOWNER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1591)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPORT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1592)
			p.Match(MySqlParserPORT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1593)
			p.DecimalLiteral()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateDefinitionsContext is an interface to support dynamic dispatch.
type ICreateDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllCreateDefinition() []ICreateDefinitionContext
	CreateDefinition(i int) ICreateDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateDefinitionsContext differentiates from other interfaces.
	IsCreateDefinitionsContext()
}

type CreateDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionsContext() *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinitions
	return p
}

func InitEmptyCreateDefinitionsContext(p *CreateDefinitionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinitions
}

func (*CreateDefinitionsContext) IsCreateDefinitionsContext() {}

func NewCreateDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDefinitions

	return p
}

func (s *CreateDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *CreateDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateDefinitions() (localctx ICreateDefinitionsContext) {
	localctx = NewCreateDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MySqlParserRULE_createDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1596)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1597)
		p.CreateDefinition()
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(1598)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1599)
			p.CreateDefinition()
		}


		p.SetState(1604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1605)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateDefinitionContext is an interface to support dynamic dispatch.
type ICreateDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateDefinitionContext differentiates from other interfaces.
	IsCreateDefinitionContext()
}

type CreateDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionContext() *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinition
	return p
}

func InitEmptyCreateDefinitionContext(p *CreateDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinition
}

func (*CreateDefinitionContext) IsCreateDefinitionContext() {}

func NewCreateDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDefinition

	return p
}

func (s *CreateDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionContext) CopyAll(ctx *CreateDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type ColumnDeclarationContext struct {
	CreateDefinitionContext
}

func NewColumnDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnDeclarationContext {
	var p = new(ColumnDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ColumnDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDeclarationContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ColumnDeclarationContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}


func (s *ColumnDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitColumnDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}


type ConstraintDeclarationContext struct {
	CreateDefinitionContext
}

func NewConstraintDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintDeclarationContext {
	var p = new(ConstraintDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ConstraintDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintDeclarationContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *ConstraintDeclarationContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ConstraintDeclarationContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}


func (s *ConstraintDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstraintDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}


type IndexDeclarationContext struct {
	CreateDefinitionContext
}

func NewIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexDeclarationContext {
	var p = new(IndexDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *IndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDeclarationContext) IndexColumnDefinition() IIndexColumnDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnDefinitionContext)
}


func (s *IndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) CreateDefinition() (localctx ICreateDefinitionContext) {
	localctx = NewCreateDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MySqlParserRULE_createDefinition)
	var _la int

	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1607)
			p.FullColumnName()
		}
		{
			p.SetState(1608)
			p.ColumnDefinition()
		}


	case 2:
		localctx = NewConstraintDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1610)
			p.TableConstraint()
		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(1611)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserENFORCED {
			{
				p.SetState(1614)
				p.Match(MySqlParserENFORCED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 3:
		localctx = NewIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1617)
			p.IndexColumnDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	AllColumnConstraint() []IColumnConstraintContext
	ColumnConstraint(i int) IColumnConstraintContext
	NOT() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllColumnConstraint() []IColumnConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnConstraintContext); ok {
			tst[i] = t.(IColumnConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ColumnDefinitionContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MySqlParserRULE_columnDefinition)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1620)
		p.DataType()
	}
	p.SetState(1624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1621)
				p.ColumnConstraint()
			}


		}
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNOT {
		{
			p.SetState(1627)
			p.Match(MySqlParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserENFORCED {
		{
			p.SetState(1630)
			p.Match(MySqlParserENFORCED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) CopyAll(ctx *ColumnConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type StorageColumnConstraintContext struct {
	ColumnConstraintContext
	storageval antlr.Token
}

func NewStorageColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StorageColumnConstraintContext {
	var p = new(StorageColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}


func (s *StorageColumnConstraintContext) GetStorageval() antlr.Token { return s.storageval }


func (s *StorageColumnConstraintContext) SetStorageval(v antlr.Token) { s.storageval = v }

func (s *StorageColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageColumnConstraintContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *StorageColumnConstraintContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *StorageColumnConstraintContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *StorageColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}


func (s *StorageColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStorageColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type VisibilityColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewVisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VisibilityColumnConstraintContext {
	var p = new(VisibilityColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *VisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityColumnConstraintContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}


func (s *VisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitVisibilityColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type AutoIncrementColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewAutoIncrementColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AutoIncrementColumnConstraintContext {
	var p = new(AutoIncrementColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *AutoIncrementColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoIncrementColumnConstraintContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *AutoIncrementColumnConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *AutoIncrementColumnConstraintContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *AutoIncrementColumnConstraintContext) CurrentTimestamp() ICurrentTimestampContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}


func (s *AutoIncrementColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAutoIncrementColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type CommentColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCommentColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentColumnConstraintContext {
	var p = new(CommentColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CommentColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentColumnConstraintContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CommentColumnConstraintContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *CommentColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCommentColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type UniqueKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewUniqueKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyColumnConstraintContext {
	var p = new(UniqueKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *UniqueKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *UniqueKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *UniqueKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUniqueKeyColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type SerialDefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewSerialDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerialDefaultColumnConstraintContext {
	var p = new(SerialDefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *SerialDefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerialDefaultColumnConstraintContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *SerialDefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SerialDefaultColumnConstraintContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}


func (s *SerialDefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSerialDefaultColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type GeneratedColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewGeneratedColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratedColumnConstraintContext {
	var p = new(GeneratedColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *GeneratedColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnConstraintContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *GeneratedColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERATED, 0)
}

func (s *GeneratedColumnConstraintContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserALWAYS, 0)
}

func (s *GeneratedColumnConstraintContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIRTUAL, 0)
}

func (s *GeneratedColumnConstraintContext) STORED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORED, 0)
}


func (s *GeneratedColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGeneratedColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type FormatColumnConstraintContext struct {
	ColumnConstraintContext
	colformat antlr.Token
}

func NewFormatColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FormatColumnConstraintContext {
	var p = new(FormatColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}


func (s *FormatColumnConstraintContext) GetColformat() antlr.Token { return s.colformat }


func (s *FormatColumnConstraintContext) SetColformat(v antlr.Token) { s.colformat = v }

func (s *FormatColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatColumnConstraintContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_FORMAT, 0)
}

func (s *FormatColumnConstraintContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *FormatColumnConstraintContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *FormatColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}


func (s *FormatColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFormatColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type CollateColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCollateColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateColumnConstraintContext {
	var p = new(CollateColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CollateColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateColumnConstraintContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CollateColumnConstraintContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}


func (s *CollateColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollateColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type PrimaryKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewPrimaryKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyColumnConstraintContext {
	var p = new(PrimaryKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *PrimaryKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}


func (s *PrimaryKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrimaryKeyColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type CheckColumnConstraintContext struct {
	ColumnConstraintContext
	name IUidContext 
}

func NewCheckColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckColumnConstraintContext {
	var p = new(CheckColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}


func (s *CheckColumnConstraintContext) GetName() IUidContext { return s.name }


func (s *CheckColumnConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *CheckColumnConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *CheckColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type NullColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewNullColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullColumnConstraintContext {
	var p = new(NullColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *NullColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullColumnConstraintContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}


func (s *NullColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNullColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type DefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultColumnConstraintContext {
	var p = new(DefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *DefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *DefaultColumnConstraintContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}


func (s *DefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefaultColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type ReferenceColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewReferenceColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferenceColumnConstraintContext {
	var p = new(ReferenceColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *ReferenceColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceColumnConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}


func (s *ReferenceColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type InvisibilityColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewInvisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvisibilityColumnConstraintContext {
	var p = new(InvisibilityColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *InvisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvisibilityColumnConstraintContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}


func (s *InvisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInvisibilityColumnConstraint(s)
	}
}

func (s *InvisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInvisibilityColumnConstraint(s)
	}
}

func (s *InvisibilityColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInvisibilityColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MySqlParserRULE_columnConstraint)
	var _la int

	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserNULL_SPEC_LITERAL:
		localctx = NewNullColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1633)
			p.NullNotnull()
		}


	case MySqlParserDEFAULT:
		localctx = NewDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1634)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.DefaultValue()
		}


	case MySqlParserVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1636)
			p.Match(MySqlParserVISIBLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserINVISIBLE:
		localctx = NewInvisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1637)
			p.Match(MySqlParserINVISIBLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserON, MySqlParserAUTO_INCREMENT:
		localctx = NewAutoIncrementColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserAUTO_INCREMENT:
			{
				p.SetState(1638)
				p.Match(MySqlParserAUTO_INCREMENT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserON:
			{
				p.SetState(1639)
				p.Match(MySqlParserON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1640)
				p.Match(MySqlParserUPDATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1641)
				p.CurrentTimestamp()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserKEY, MySqlParserPRIMARY:
		localctx = NewPrimaryKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPRIMARY {
			{
				p.SetState(1644)
				p.Match(MySqlParserPRIMARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1647)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserUNIQUE:
		localctx = NewUniqueKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1648)
			p.Match(MySqlParserUNIQUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1650)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1649)
				p.Match(MySqlParserKEY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserCOMMENT:
		localctx = NewCommentColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1652)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1653)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCOLUMN_FORMAT:
		localctx = NewFormatColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1654)
			p.Match(MySqlParserCOLUMN_FORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1655)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FormatColumnConstraintContext).colformat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserDYNAMIC || _la == MySqlParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FormatColumnConstraintContext).colformat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case MySqlParserSTORAGE:
		localctx = NewStorageColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1656)
			p.Match(MySqlParserSTORAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1657)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StorageColumnConstraintContext).storageval = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserDISK || _la == MySqlParserMEMORY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StorageColumnConstraintContext).storageval = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case MySqlParserREFERENCES:
		localctx = NewReferenceColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1658)
			p.ReferenceDefinition()
		}


	case MySqlParserCOLLATE:
		localctx = NewCollateColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1659)
			p.Match(MySqlParserCOLLATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1660)
			p.CollationName()
		}


	case MySqlParserAS, MySqlParserGENERATED:
		localctx = NewGeneratedColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(1663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserGENERATED {
			{
				p.SetState(1661)
				p.Match(MySqlParserGENERATED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1662)
				p.Match(MySqlParserALWAYS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1665)
			p.Match(MySqlParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1666)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1667)
			p.expression(0)
		}
		{
			p.SetState(1668)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserSTORED || _la == MySqlParserVIRTUAL {
			{
				p.SetState(1669)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserSTORED || _la == MySqlParserVIRTUAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}


	case MySqlParserSERIAL:
		localctx = NewSerialDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1672)
			p.Match(MySqlParserSERIAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1673)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1674)
			p.Match(MySqlParserVALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCHECK, MySqlParserCONSTRAINT:
		localctx = NewCheckColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1675)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1677)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(1676)

					var _x = p.Uid()


					localctx.(*CheckColumnConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1681)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1682)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1683)
			p.expression(0)
		}
		{
			p.SetState(1684)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CopyAll(ctx *TableConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type UniqueKeyTableConstraintContext struct {
	TableConstraintContext
	name IUidContext 
	indexFormat antlr.Token
	index IUidContext 
}

func NewUniqueKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyTableConstraintContext {
	var p = new(UniqueKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}


func (s *UniqueKeyTableConstraintContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *UniqueKeyTableConstraintContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }


func (s *UniqueKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *UniqueKeyTableConstraintContext) GetIndex() IUidContext { return s.index }


func (s *UniqueKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *UniqueKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *UniqueKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyTableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *UniqueKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *UniqueKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *UniqueKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UniqueKeyTableConstraintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *UniqueKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *UniqueKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUniqueKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type CheckTableConstraintContext struct {
	TableConstraintContext
	name IUidContext 
}

func NewCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckTableConstraintContext {
	var p = new(CheckTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}


func (s *CheckTableConstraintContext) GetName() IUidContext { return s.name }


func (s *CheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *CheckTableConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *CheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type PrimaryKeyTableConstraintContext struct {
	TableConstraintContext
	name IUidContext 
	index IUidContext 
}

func NewPrimaryKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyTableConstraintContext {
	var p = new(PrimaryKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}


func (s *PrimaryKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *PrimaryKeyTableConstraintContext) GetIndex() IUidContext { return s.index }


func (s *PrimaryKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *PrimaryKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *PrimaryKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyTableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *PrimaryKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *PrimaryKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PrimaryKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *PrimaryKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *PrimaryKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrimaryKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type ForeignKeyTableConstraintContext struct {
	TableConstraintContext
	name IUidContext 
	index IUidContext 
}

func NewForeignKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForeignKeyTableConstraintContext {
	var p = new(ForeignKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}


func (s *ForeignKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *ForeignKeyTableConstraintContext) GetIndex() IUidContext { return s.index }


func (s *ForeignKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *ForeignKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *ForeignKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyTableConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *ForeignKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *ForeignKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ForeignKeyTableConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ForeignKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *ForeignKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *ForeignKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *ForeignKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitForeignKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MySqlParserRULE_tableConstraint)
	var _la int

	p.SetState(1757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1688)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1690)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1689)

					var _x = p.Uid()


					localctx.(*PrimaryKeyTableConstraintContext).name = _x
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}

		}
		{
			p.SetState(1694)
			p.Match(MySqlParserPRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(1696)

				var _x = p.Uid()


				localctx.(*PrimaryKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUSING {
			{
				p.SetState(1699)
				p.IndexType()
			}

		}
		{
			p.SetState(1702)
			p.IndexColumnNames()
		}
		p.SetState(1706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1703)
				p.IndexOption()
			}


			p.SetState(1708)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewUniqueKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1709)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1711)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(1710)

					var _x = p.Uid()


					localctx.(*UniqueKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1715)
			p.Match(MySqlParserUNIQUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(1716)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UniqueKeyTableConstraintContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UniqueKeyTableConstraintContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(1719)

				var _x = p.Uid()


				localctx.(*UniqueKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUSING {
			{
				p.SetState(1722)
				p.IndexType()
			}

		}
		{
			p.SetState(1725)
			p.IndexColumnNames()
		}
		p.SetState(1729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1726)
				p.IndexOption()
			}


			p.SetState(1731)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 3:
		localctx = NewForeignKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1732)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1734)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(1733)

					var _x = p.Uid()


					localctx.(*ForeignKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1738)
			p.Match(MySqlParserFOREIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(1740)

				var _x = p.Uid()


				localctx.(*ForeignKeyTableConstraintContext).index = _x
			}

		}
		{
			p.SetState(1743)
			p.IndexColumnNames()
		}
		{
			p.SetState(1744)
			p.ReferenceDefinition()
		}


	case 4:
		localctx = NewCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1746)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(1748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(1747)

					var _x = p.Uid()


					localctx.(*CheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1752)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1753)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1754)
			p.expression(0)
		}
		{
			p.SetState(1755)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReferenceDefinitionContext is an interface to support dynamic dispatch.
type IReferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatchType returns the matchType token.
	GetMatchType() antlr.Token 


	// SetMatchType sets the matchType token.
	SetMatchType(antlr.Token) 


	// Getter signatures
	REFERENCES() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	MATCH() antlr.TerminalNode
	ReferenceAction() IReferenceActionContext
	FULL() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode

	// IsReferenceDefinitionContext differentiates from other interfaces.
	IsReferenceDefinitionContext()
}

type ReferenceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	matchType antlr.Token
}

func NewEmptyReferenceDefinitionContext() *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceDefinition
	return p
}

func InitEmptyReferenceDefinitionContext(p *ReferenceDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceDefinition
}

func (*ReferenceDefinitionContext) IsReferenceDefinitionContext() {}

func NewReferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceDefinition

	return p
}

func (s *ReferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceDefinitionContext) GetMatchType() antlr.Token { return s.matchType }


func (s *ReferenceDefinitionContext) SetMatchType(v antlr.Token) { s.matchType = v }


func (s *ReferenceDefinitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserREFERENCES, 0)
}

func (s *ReferenceDefinitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReferenceDefinitionContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ReferenceDefinitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMATCH, 0)
}

func (s *ReferenceDefinitionContext) ReferenceAction() IReferenceActionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceActionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceActionContext)
}

func (s *ReferenceDefinitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ReferenceDefinitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTIAL, 0)
}

func (s *ReferenceDefinitionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIMPLE, 0)
}

func (s *ReferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ReferenceDefinition() (localctx IReferenceDefinitionContext) {
	localctx = NewReferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MySqlParserRULE_referenceDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1759)
		p.Match(MySqlParserREFERENCES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1760)
		p.TableName()
	}
	p.SetState(1762)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1761)
			p.IndexColumnNames()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserMATCH {
		{
			p.SetState(1764)
			p.Match(MySqlParserMATCH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1765)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferenceDefinitionContext).matchType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULL || _la == MySqlParserPARTIAL || _la == MySqlParserSIMPLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferenceDefinitionContext).matchType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1769)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1768)
			p.ReferenceAction()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReferenceActionContext is an interface to support dynamic dispatch.
type IReferenceActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnDelete returns the onDelete rule contexts.
	GetOnDelete() IReferenceControlTypeContext

	// GetOnUpdate returns the onUpdate rule contexts.
	GetOnUpdate() IReferenceControlTypeContext


	// SetOnDelete sets the onDelete rule contexts.
	SetOnDelete(IReferenceControlTypeContext)

	// SetOnUpdate sets the onUpdate rule contexts.
	SetOnUpdate(IReferenceControlTypeContext)


	// Getter signatures
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	DELETE() antlr.TerminalNode
	AllReferenceControlType() []IReferenceControlTypeContext
	ReferenceControlType(i int) IReferenceControlTypeContext
	UPDATE() antlr.TerminalNode

	// IsReferenceActionContext differentiates from other interfaces.
	IsReferenceActionContext()
}

type ReferenceActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	onDelete IReferenceControlTypeContext 
	onUpdate IReferenceControlTypeContext 
}

func NewEmptyReferenceActionContext() *ReferenceActionContext {
	var p = new(ReferenceActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceAction
	return p
}

func InitEmptyReferenceActionContext(p *ReferenceActionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceAction
}

func (*ReferenceActionContext) IsReferenceActionContext() {}

func NewReferenceActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceActionContext {
	var p = new(ReferenceActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceAction

	return p
}

func (s *ReferenceActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceActionContext) GetOnDelete() IReferenceControlTypeContext { return s.onDelete }

func (s *ReferenceActionContext) GetOnUpdate() IReferenceControlTypeContext { return s.onUpdate }


func (s *ReferenceActionContext) SetOnDelete(v IReferenceControlTypeContext) { s.onDelete = v }

func (s *ReferenceActionContext) SetOnUpdate(v IReferenceControlTypeContext) { s.onUpdate = v }


func (s *ReferenceActionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *ReferenceActionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *ReferenceActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *ReferenceActionContext) AllReferenceControlType() []IReferenceControlTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			len++
		}
	}

	tst := make([]IReferenceControlTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReferenceControlTypeContext); ok {
			tst[i] = t.(IReferenceControlTypeContext)
			i++
		}
	}

	return tst
}

func (s *ReferenceActionContext) ReferenceControlType(i int) IReferenceControlTypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceControlTypeContext)
}

func (s *ReferenceActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *ReferenceActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceAction(s)
	}
}

func (s *ReferenceActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceAction(s)
	}
}

func (s *ReferenceActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceAction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ReferenceAction() (localctx IReferenceActionContext) {
	localctx = NewReferenceActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MySqlParserRULE_referenceAction)
	p.SetState(1787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1771)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1772)
			p.Match(MySqlParserDELETE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1773)

			var _x = p.ReferenceControlType()


			localctx.(*ReferenceActionContext).onDelete = _x
		}
		p.SetState(1777)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1774)
				p.Match(MySqlParserON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1775)
				p.Match(MySqlParserUPDATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1776)

				var _x = p.ReferenceControlType()


				localctx.(*ReferenceActionContext).onUpdate = _x
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1779)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1780)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1781)

			var _x = p.ReferenceControlType()


			localctx.(*ReferenceActionContext).onUpdate = _x
		}
		p.SetState(1785)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1782)
				p.Match(MySqlParserON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1783)
				p.Match(MySqlParserDELETE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1784)

				var _x = p.ReferenceControlType()


				localctx.(*ReferenceActionContext).onDelete = _x
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReferenceControlTypeContext is an interface to support dynamic dispatch.
type IReferenceControlTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsReferenceControlTypeContext differentiates from other interfaces.
	IsReferenceControlTypeContext()
}

type ReferenceControlTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceControlTypeContext() *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceControlType
	return p
}

func InitEmptyReferenceControlTypeContext(p *ReferenceControlTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceControlType
}

func (*ReferenceControlTypeContext) IsReferenceControlTypeContext() {}

func NewReferenceControlTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceControlType

	return p
}

func (s *ReferenceControlTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceControlTypeContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *ReferenceControlTypeContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *ReferenceControlTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ReferenceControlTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *ReferenceControlTypeContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *ReferenceControlTypeContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserACTION, 0)
}

func (s *ReferenceControlTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *ReferenceControlTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceControlTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferenceControlTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceControlType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ReferenceControlType() (localctx IReferenceControlTypeContext) {
	localctx = NewReferenceControlTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MySqlParserRULE_referenceControlType)
	p.SetState(1797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1789)
			p.Match(MySqlParserRESTRICT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1790)
			p.Match(MySqlParserCASCADE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1791)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1792)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1793)
			p.Match(MySqlParserNO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1794)
			p.Match(MySqlParserACTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1795)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1796)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexColumnDefinitionContext is an interface to support dynamic dispatch.
type IIndexColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIndexColumnDefinitionContext differentiates from other interfaces.
	IsIndexColumnDefinitionContext()
}

type IndexColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnDefinitionContext() *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition
	return p
}

func InitEmptyIndexColumnDefinitionContext(p *IndexColumnDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition
}

func (*IndexColumnDefinitionContext) IsIndexColumnDefinitionContext() {}

func NewIndexColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition

	return p
}

func (s *IndexColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnDefinitionContext) CopyAll(ctx *IndexColumnDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IndexColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SpecialIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSpecialIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialIndexDeclarationContext {
	var p = new(SpecialIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}


func (s *SpecialIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *SpecialIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SpecialIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SpecialIndexDeclarationContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *SpecialIndexDeclarationContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *SpecialIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SpecialIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SpecialIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *SpecialIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *SpecialIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpecialIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimpleIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSimpleIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleIndexDeclarationContext {
	var p = new(SimpleIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}


func (s *SimpleIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *SimpleIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SimpleIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SimpleIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *SimpleIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SimpleIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleIndexDeclarationContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *SimpleIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}


func (s *SimpleIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) IndexColumnDefinition() (localctx IIndexColumnDefinitionContext) {
	localctx = NewIndexColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MySqlParserRULE_indexColumnDefinition)
	var _la int

	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserINDEX, MySqlParserKEY:
		localctx = NewSimpleIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1799)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleIndexDeclarationContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleIndexDeclarationContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(1800)
				p.Uid()
			}

		}
		p.SetState(1804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUSING {
			{
				p.SetState(1803)
				p.IndexType()
			}

		}
		{
			p.SetState(1806)
			p.IndexColumnNames()
		}
		p.SetState(1810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1807)
				p.IndexOption()
			}


			p.SetState(1812)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case MySqlParserFULLTEXT, MySqlParserSPATIAL:
		localctx = NewSpecialIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1813)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(1814)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SpecialIndexDeclarationContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SpecialIndexDeclarationContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(1817)
				p.Uid()
			}

		}
		{
			p.SetState(1820)
			p.IndexColumnNames()
		}
		p.SetState(1824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1821)
				p.IndexOption()
			}


			p.SetState(1826)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableOptionContext is an interface to support dynamic dispatch.
type ITableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableOptionContext differentiates from other interfaces.
	IsTableOptionContext()
}

type TableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionContext() *TableOptionContext {
	var p = new(TableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableOption
	return p
}

func InitEmptyTableOptionContext(p *TableOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableOption
}

func (*TableOptionContext) IsTableOptionContext() {}

func NewTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionContext {
	var p = new(TableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableOption

	return p
}

func (s *TableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionContext) CopyAll(ctx *TableOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type TableOptionEngineContext struct {
	TableOptionContext
}

func NewTableOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineContext {
	var p = new(TableOptionEngineContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *TableOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}


func (s *TableOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEngine(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionMaxRowsContext struct {
	TableOptionContext
}

func NewTableOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMaxRowsContext {
	var p = new(TableOptionMaxRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *TableOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionMaxRows(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionCollateContext struct {
	TableOptionContext
}

func NewTableOptionCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCollateContext {
	var p = new(TableOptionCollateContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *TableOptionCollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *TableOptionCollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionCollateContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionCollate(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionPersistentContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPersistentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPersistentContext {
	var p = new(TableOptionPersistentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}


func (s *TableOptionPersistentContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }


func (s *TableOptionPersistentContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPersistentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPersistentContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_PERSISTENT, 0)
}

func (s *TableOptionPersistentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionPersistentContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionPersistentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPersistent(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionTablespaceContext struct {
	TableOptionContext
}

func NewTableOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTablespaceContext {
	var p = new(TableOptionTablespaceContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *TableOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *TableOptionTablespaceContext) TablespaceStorage() ITablespaceStorageContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceStorageContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceStorageContext)
}


func (s *TableOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionAutoextendSizeContext struct {
	TableOptionContext
}

func NewTableOptionAutoextendSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoextendSizeContext {
	var p = new(TableOptionAutoextendSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoextendSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoextendSizeContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *TableOptionAutoextendSizeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoextendSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionAutoextendSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionAutoextendSize(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionPageCompressedContext struct {
	TableOptionContext
}

func NewTableOptionPageCompressedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressedContext {
	var p = new(TableOptionPageCompressedContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressedContext) PAGE_COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_COMPRESSED, 0)
}

func (s *TableOptionPageCompressedContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressedContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionPageCompressedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPageCompressed(s)
	}
}

func (s *TableOptionPageCompressedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPageCompressed(s)
	}
}

func (s *TableOptionPageCompressedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPageCompressed(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionStartTransactionContext struct {
	TableOptionContext
}

func NewTableOptionStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionStartTransactionContext {
	var p = new(TableOptionStartTransactionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *TableOptionStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}


func (s *TableOptionStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionPackKeysContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPackKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPackKeysContext {
	var p = new(TableOptionPackKeysContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}


func (s *TableOptionPackKeysContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }


func (s *TableOptionPackKeysContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPackKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPackKeysContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPACK_KEYS, 0)
}

func (s *TableOptionPackKeysContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionPackKeysContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionPackKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPackKeys(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionPasswordContext struct {
	TableOptionContext
}

func NewTableOptionPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPasswordContext {
	var p = new(TableOptionPasswordContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *TableOptionPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPasswordContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPassword(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionUnionContext struct {
	TableOptionContext
}

func NewTableOptionUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionUnionContext {
	var p = new(TableOptionUnionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionUnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *TableOptionUnionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableOptionUnionContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableOptionUnionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableOptionUnionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionUnion(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionSamplePageContext struct {
	TableOptionContext
}

func NewTableOptionSamplePageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSamplePageContext {
	var p = new(TableOptionSamplePageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSamplePageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSamplePageContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_SAMPLE_PAGES, 0)
}

func (s *TableOptionSamplePageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionSamplePageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionSamplePageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionSamplePageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionSamplePage(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionCharsetContext struct {
	TableOptionContext
}

func NewTableOptionCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCharsetContext {
	var p = new(TableOptionCharsetContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *TableOptionCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *TableOptionCharsetContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *TableOptionCharsetContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *TableOptionCharsetContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionCharset(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionIndexDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionIndexDirectoryContext {
	var p = new(TableOptionIndexDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *TableOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionIndexDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionTableTypeContext struct {
	TableOptionContext
}

func NewTableOptionTableTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTableTypeContext {
	var p = new(TableOptionTableTypeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTableTypeContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_TYPE, 0)
}

func (s *TableOptionTableTypeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTableTypeContext) TableType() ITableTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}


func (s *TableOptionTableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionTableType(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionKeyBlockSizeContext struct {
	TableOptionContext
}

func NewTableOptionKeyBlockSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionKeyBlockSizeContext {
	var p = new(TableOptionKeyBlockSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionKeyBlockSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionKeyBlockSizeContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *TableOptionKeyBlockSizeContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *TableOptionKeyBlockSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionKeyBlockSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionKeyBlockSize(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionEncryptionContext struct {
	TableOptionContext
}

func NewTableOptionEncryptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionContext {
	var p = new(TableOptionEncryptionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *TableOptionEncryptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionEncryptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEncryption(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionDataDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDataDirectoryContext {
	var p = new(TableOptionDataDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *TableOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *TableOptionDataDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionDataDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionRecalculationContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionRecalculationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRecalculationContext {
	var p = new(TableOptionRecalculationContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}


func (s *TableOptionRecalculationContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }


func (s *TableOptionRecalculationContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionRecalculationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRecalculationContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_AUTO_RECALC, 0)
}

func (s *TableOptionRecalculationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionRecalculationContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionRecalculationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionRecalculation(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionAutoIncrementContext struct {
	TableOptionContext
}

func NewTableOptionAutoIncrementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoIncrementContext {
	var p = new(TableOptionAutoIncrementContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoIncrementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoIncrementContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *TableOptionAutoIncrementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoIncrementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionAutoIncrementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionAutoIncrement(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionEncryptionKeyIdContext struct {
	TableOptionContext
}

func NewTableOptionEncryptionKeyIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionKeyIdContext {
	var p = new(TableOptionEncryptionKeyIdContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionKeyIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionKeyIdContext) ENCRYPTION_KEY_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ID, 0)
}

func (s *TableOptionEncryptionKeyIdContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionEncryptionKeyIdContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionEncryptionKeyIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEncryptionKeyId(s)
	}
}

func (s *TableOptionEncryptionKeyIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEncryptionKeyId(s)
	}
}

func (s *TableOptionEncryptionKeyIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEncryptionKeyId(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionChecksumContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionChecksumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionChecksumContext {
	var p = new(TableOptionChecksumContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}


func (s *TableOptionChecksumContext) GetBoolValue() antlr.Token { return s.boolValue }


func (s *TableOptionChecksumContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionChecksumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionChecksumContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *TableOptionChecksumContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_CHECKSUM, 0)
}

func (s *TableOptionChecksumContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionChecksumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionChecksum(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionDelayContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionDelayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDelayContext {
	var p = new(TableOptionDelayContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}


func (s *TableOptionDelayContext) GetBoolValue() antlr.Token { return s.boolValue }


func (s *TableOptionDelayContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionDelayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDelayContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAY_KEY_WRITE, 0)
}

func (s *TableOptionDelayContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionDelayContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionDelayContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionDelayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionDelay(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionConnectionContext struct {
	TableOptionContext
}

func NewTableOptionConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionConnectionContext {
	var p = new(TableOptionConnectionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *TableOptionConnectionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionConnectionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionConnection(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionTransactionalContext struct {
	TableOptionContext
}

func NewTableOptionTransactionalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTransactionalContext {
	var p = new(TableOptionTransactionalContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTransactionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTransactionalContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTIONAL, 0)
}

func (s *TableOptionTransactionalContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionTransactionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTransactional(s)
	}
}

func (s *TableOptionTransactionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTransactional(s)
	}
}

func (s *TableOptionTransactionalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionTransactional(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionPageCompressionLevelContext struct {
	TableOptionContext
}

func NewTableOptionPageCompressionLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressionLevelContext {
	var p = new(TableOptionPageCompressionLevelContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressionLevelContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionPageCompressionLevelContext) PAGE_COMPRESSION_LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_COMPRESSION_LEVEL, 0)
}

func (s *TableOptionPageCompressionLevelContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressionLevelContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionPageCompressionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPageCompressionLevel(s)
	}
}

func (s *TableOptionPageCompressionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPageCompressionLevel(s)
	}
}

func (s *TableOptionPageCompressionLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPageCompressionLevel(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionSecondaryEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionSecondaryEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSecondaryEngineAttributeContext {
	var p = new(TableOptionSecondaryEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSecondaryEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSecondaryEngineAttributeContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionSecondaryEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionSecondaryEngineAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionCommentContext struct {
	TableOptionContext
}

func NewTableOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCommentContext {
	var p = new(TableOptionCommentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *TableOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionComment(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionAverageContext struct {
	TableOptionContext
}

func NewTableOptionAverageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAverageContext {
	var p = new(TableOptionAverageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAverageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAverageContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG_ROW_LENGTH, 0)
}

func (s *TableOptionAverageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAverageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionAverageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionAverage(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionRowFormatContext struct {
	TableOptionContext
	rowFormat antlr.Token
}

func NewTableOptionRowFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRowFormatContext {
	var p = new(TableOptionRowFormatContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}


func (s *TableOptionRowFormatContext) GetRowFormat() antlr.Token { return s.rowFormat }


func (s *TableOptionRowFormatContext) SetRowFormat(v antlr.Token) { s.rowFormat = v }

func (s *TableOptionRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRowFormatContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_FORMAT, 0)
}

func (s *TableOptionRowFormatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionRowFormatContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *TableOptionRowFormatContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *TableOptionRowFormatContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSED, 0)
}

func (s *TableOptionRowFormatContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDUNDANT, 0)
}

func (s *TableOptionRowFormatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPACT, 0)
}

func (s *TableOptionRowFormatContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *TableOptionRowFormatContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionRowFormat(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionCompressionContext struct {
	TableOptionContext
}

func NewTableOptionCompressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCompressionContext {
	var p = new(TableOptionCompressionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCompressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCompressionContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSION, 0)
}

func (s *TableOptionCompressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionCompressionContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *TableOptionCompressionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionCompressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionCompression(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionInsertMethodContext struct {
	TableOptionContext
	insertMethod antlr.Token
}

func NewTableOptionInsertMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionInsertMethodContext {
	var p = new(TableOptionInsertMethodContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}


func (s *TableOptionInsertMethodContext) GetInsertMethod() antlr.Token { return s.insertMethod }


func (s *TableOptionInsertMethodContext) SetInsertMethod(v antlr.Token) { s.insertMethod = v }

func (s *TableOptionInsertMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionInsertMethodContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT_METHOD, 0)
}

func (s *TableOptionInsertMethodContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *TableOptionInsertMethodContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *TableOptionInsertMethodContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *TableOptionInsertMethodContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionInsertMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionInsertMethod(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineAttributeContext {
	var p = new(TableOptionEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineAttributeContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEngineAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableOptionMinRowsContext struct {
	TableOptionContext
}

func NewTableOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMinRowsContext {
	var p = new(TableOptionMinRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *TableOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *TableOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionMinRows(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) TableOption() (localctx ITableOptionContext) {
	localctx = NewTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MySqlParserRULE_tableOption)
	var _la int

	p.SetState(2014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1829)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1830)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1834)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1833)
				p.EngineName()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		localctx = NewTableOptionEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1836)
			p.Match(MySqlParserENGINE_ATTRIBUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1837)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1840)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		localctx = NewTableOptionAutoextendSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1841)
			p.Match(MySqlParserAUTOEXTEND_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1842)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1845)
			p.DecimalLiteral()
		}


	case 4:
		localctx = NewTableOptionAutoIncrementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1846)
			p.Match(MySqlParserAUTO_INCREMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1847)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1850)
			p.DecimalLiteral()
		}


	case 5:
		localctx = NewTableOptionAverageContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1851)
			p.Match(MySqlParserAVG_ROW_LENGTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1852)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1855)
			p.DecimalLiteral()
		}


	case 6:
		localctx = NewTableOptionCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1856)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1859)
			p.CharSet()
		}
		p.SetState(1861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1860)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(1863)
				p.CharsetName()
			}


		case MySqlParserDEFAULT:
			{
				p.SetState(1864)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 7:
		localctx = NewTableOptionChecksumContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1867)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHECKSUM || _la == MySqlParserPAGE_CHECKSUM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1868)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1871)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionChecksumContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionChecksumContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 8:
		localctx = NewTableOptionCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1872)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1875)
			p.Match(MySqlParserCOLLATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1876)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1879)
			p.CollationName()
		}


	case 9:
		localctx = NewTableOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1880)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1881)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1884)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		localctx = NewTableOptionCompressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1885)
			p.Match(MySqlParserCOMPRESSION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1886)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1889)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSTRING_LITERAL || _la == MySqlParserID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 11:
		localctx = NewTableOptionConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1890)
			p.Match(MySqlParserCONNECTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1891)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1894)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		localctx = NewTableOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1895)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserDATA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1896)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1897)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1900)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 13:
		localctx = NewTableOptionDelayContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1901)
			p.Match(MySqlParserDELAY_KEY_WRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1902)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1905)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionDelayContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionDelayContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 14:
		localctx = NewTableOptionEncryptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1906)
			p.Match(MySqlParserENCRYPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1907)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1910)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		localctx = NewTableOptionPageCompressedContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1911)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPAGE_COMPRESSED || _la == MySqlParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1912)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1915)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 16:
		localctx = NewTableOptionPageCompressionLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1916)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPAGE_COMPRESSION_LEVEL || _la == MySqlParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1917)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1920)
			p.DecimalLiteral()
		}


	case 17:
		localctx = NewTableOptionEncryptionKeyIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1921)
			p.Match(MySqlParserENCRYPTION_KEY_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1922)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1925)
			p.DecimalLiteral()
		}


	case 18:
		localctx = NewTableOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1926)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1927)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1928)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1931)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 19:
		localctx = NewTableOptionInsertMethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1932)
			p.Match(MySqlParserINSERT_METHOD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1933)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1936)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionInsertMethodContext).insertMethod = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST || _la == MySqlParserLAST || _la == MySqlParserNO) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionInsertMethodContext).insertMethod = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 20:
		localctx = NewTableOptionKeyBlockSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1937)
			p.Match(MySqlParserKEY_BLOCK_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1938)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1941)
			p.FileSizeLiteral()
		}


	case 21:
		localctx = NewTableOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1942)
			p.Match(MySqlParserMAX_ROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1943)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1946)
			p.DecimalLiteral()
		}


	case 22:
		localctx = NewTableOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1947)
			p.Match(MySqlParserMIN_ROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1948)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1951)
			p.DecimalLiteral()
		}


	case 23:
		localctx = NewTableOptionPackKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1952)
			p.Match(MySqlParserPACK_KEYS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1953)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1956)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPackKeysContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPackKeysContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 24:
		localctx = NewTableOptionPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1957)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1958)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1961)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 25:
		localctx = NewTableOptionRowFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1962)
			p.Match(MySqlParserROW_FORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1963)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1966)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRowFormatContext).rowFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || ((int64((_la - 370)) & ^0x3f) == 0 && ((int64(1) << (_la - 370)) & 2305843013508661253) != 0) || _la == MySqlParserREDUNDANT || _la == MySqlParserID) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRowFormatContext).rowFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 26:
		localctx = NewTableOptionStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1967)
			p.Match(MySqlParserSTART)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1968)
			p.Match(MySqlParserTRANSACTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 27:
		localctx = NewTableOptionSecondaryEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1969)
			p.Match(MySqlParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1970)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1973)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 28:
		localctx = NewTableOptionRecalculationContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1974)
			p.Match(MySqlParserSTATS_AUTO_RECALC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1975)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1978)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRecalculationContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRecalculationContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 29:
		localctx = NewTableOptionPersistentContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1979)
			p.Match(MySqlParserSTATS_PERSISTENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1980)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1983)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPersistentContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPersistentContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 30:
		localctx = NewTableOptionSamplePageContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1984)
			p.Match(MySqlParserSTATS_SAMPLE_PAGES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1985)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(1988)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(1989)
				p.DecimalLiteral()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 31:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1992)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1993)
			p.Uid()
		}
		p.SetState(1995)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1994)
				p.TablespaceStorage()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 32:
		localctx = NewTableOptionTableTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1997)
			p.Match(MySqlParserTABLE_TYPE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1998)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1999)
			p.TableType()
		}


	case 33:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2000)
			p.TablespaceStorage()
		}


	case 34:
		localctx = NewTableOptionTransactionalContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2001)
			p.Match(MySqlParserTRANSACTIONAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2002)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2005)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 35:
		localctx = NewTableOptionUnionContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2006)
			p.Match(MySqlParserUNION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2007)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2010)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2011)
			p.Tables()
		}
		{
			p.SetState(2012)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableTypeContext is an interface to support dynamic dispatch.
type ITableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MYSQL() antlr.TerminalNode
	ODBC() antlr.TerminalNode

	// IsTableTypeContext differentiates from other interfaces.
	IsTableTypeContext()
}

type TableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeContext() *TableTypeContext {
	var p = new(TableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableType
	return p
}

func InitEmptyTableTypeContext(p *TableTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableType
}

func (*TableTypeContext) IsTableTypeContext() {}

func NewTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeContext {
	var p = new(TableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableType

	return p
}

func (s *TableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *TableTypeContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MySqlParserODBC, 0)
}

func (s *TableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableType(s)
	}
}

func (s *TableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableType(s)
	}
}

func (s *TableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TableType() (localctx ITableTypeContext) {
	localctx = NewTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MySqlParserRULE_tableType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2016)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMYSQL || _la == MySqlParserODBC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablespaceStorageContext is an interface to support dynamic dispatch.
type ITablespaceStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsTablespaceStorageContext differentiates from other interfaces.
	IsTablespaceStorageContext()
}

type TablespaceStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceStorageContext() *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablespaceStorage
	return p
}

func InitEmptyTablespaceStorageContext(p *TablespaceStorageContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablespaceStorage
}

func (*TablespaceStorageContext) IsTablespaceStorageContext() {}

func NewTablespaceStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tablespaceStorage

	return p
}

func (s *TablespaceStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceStorageContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *TablespaceStorageContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *TablespaceStorageContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *TablespaceStorageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TablespaceStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TablespaceStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTablespaceStorage(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TablespaceStorage() (localctx ITablespaceStorageContext) {
	localctx = NewTablespaceStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MySqlParserRULE_tablespaceStorage)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2018)
		p.Match(MySqlParserSTORAGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2019)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDEFAULT || _la == MySqlParserDISK || _la == MySqlParserMEMORY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCount returns the count rule contexts.
	GetCount() IDecimalLiteralContext

	// GetSubCount returns the subCount rule contexts.
	GetSubCount() IDecimalLiteralContext


	// SetCount sets the count rule contexts.
	SetCount(IDecimalLiteralContext)

	// SetSubCount sets the subCount rule contexts.
	SetSubCount(IDecimalLiteralContext)


	// Getter signatures
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	PartitionFunctionDefinition() IPartitionFunctionDefinitionContext
	PARTITIONS() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinition() []IPartitionDefinitionContext
	PartitionDefinition(i int) IPartitionDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	SUBPARTITIONS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	count IDecimalLiteralContext 
	subCount IDecimalLiteralContext 
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinitions
	return p
}

func InitEmptyPartitionDefinitionsContext(p *PartitionDefinitionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinitions
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) GetCount() IDecimalLiteralContext { return s.count }

func (s *PartitionDefinitionsContext) GetSubCount() IDecimalLiteralContext { return s.subCount }


func (s *PartitionDefinitionsContext) SetCount(v IDecimalLiteralContext) { s.count = v }

func (s *PartitionDefinitionsContext) SetSubCount(v IDecimalLiteralContext) { s.subCount = v }


func (s *PartitionDefinitionsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionDefinitionsContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBY)
}

func (s *PartitionDefinitionsContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, i)
}

func (s *PartitionDefinitionsContext) PartitionFunctionDefinition() IPartitionFunctionDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *PartitionDefinitionsContext) SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionDefinitionsContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MySqlParserRULE_partitionDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2021)
		p.Match(MySqlParserPARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2022)
		p.Match(MySqlParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2023)
		p.PartitionFunctionDefinition()
	}
	p.SetState(2026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITIONS {
		{
			p.SetState(2024)
			p.Match(MySqlParserPARTITIONS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2025)

			var _x = p.DecimalLiteral()


			localctx.(*PartitionDefinitionsContext).count = _x
		}

	}
	p.SetState(2035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserSUBPARTITION {
		{
			p.SetState(2028)
			p.Match(MySqlParserSUBPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2029)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2030)
			p.SubpartitionFunctionDefinition()
		}
		p.SetState(2033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserSUBPARTITIONS {
			{
				p.SetState(2031)
				p.Match(MySqlParserSUBPARTITIONS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2032)

				var _x = p.DecimalLiteral()


				localctx.(*PartitionDefinitionsContext).subCount = _x
			}

		}

	}
	p.SetState(2048)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2037)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2038)
			p.PartitionDefinition()
		}
		p.SetState(2043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2039)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2040)
				p.PartitionDefinition()
			}


			p.SetState(2045)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2046)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionFunctionDefinitionContext differentiates from other interfaces.
	IsPartitionFunctionDefinitionContext()
}

type PartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionFunctionDefinitionContext() *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition
	return p
}

func InitEmptyPartitionFunctionDefinitionContext(p *PartitionFunctionDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition
}

func (*PartitionFunctionDefinitionContext) IsPartitionFunctionDefinitionContext() {}

func NewPartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition

	return p
}

func (s *PartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFunctionDefinitionContext) CopyAll(ctx *PartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type PartitionFunctionKeyContext struct {
	PartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionKeyContext {
	var p = new(PartitionFunctionKeyContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}


func (s *PartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }


func (s *PartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *PartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *PartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *PartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}


func (s *PartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionKey(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionFunctionHashContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionHashContext {
	var p = new(PartitionFunctionHashContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *PartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}


func (s *PartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionHash(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionFunctionListContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionListContext {
	var p = new(PartitionFunctionListContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionListContext) LIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIST, 0)
}

func (s *PartitionFunctionListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *PartitionFunctionListContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}


func (s *PartitionFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionList(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionFunctionRangeContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionRangeContext {
	var p = new(PartitionFunctionRangeContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionRangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANGE, 0)
}

func (s *PartitionFunctionRangeContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionRangeContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *PartitionFunctionRangeContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}


func (s *PartitionFunctionRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionRange(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) PartitionFunctionDefinition() (localctx IPartitionFunctionDefinitionContext) {
	localctx = NewPartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MySqlParserRULE_partitionFunctionDefinition)
	var _la int

	p.SetState(2096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLINEAR {
			{
				p.SetState(2050)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2053)
			p.Match(MySqlParserHASH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2054)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2055)
			p.expression(0)
		}
		{
			p.SetState(2056)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		localctx = NewPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLINEAR {
			{
				p.SetState(2058)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2061)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserALGORITHM {
			{
				p.SetState(2062)
				p.Match(MySqlParserALGORITHM)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2063)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2064)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserONE_DECIMAL || _la == MySqlParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2067)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(2068)
				p.UidList()
			}

		}
		{
			p.SetState(2071)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		localctx = NewPartitionFunctionRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2072)
			p.Match(MySqlParserRANGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLR_BRACKET:
			{
				p.SetState(2073)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2074)
				p.expression(0)
			}
			{
				p.SetState(2075)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserCOLUMNS:
			{
				p.SetState(2077)
				p.Match(MySqlParserCOLUMNS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2078)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2079)
				p.UidList()
			}
			{
				p.SetState(2080)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 4:
		localctx = NewPartitionFunctionListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2084)
			p.Match(MySqlParserLIST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLR_BRACKET:
			{
				p.SetState(2085)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2086)
				p.expression(0)
			}
			{
				p.SetState(2087)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserCOLUMNS:
			{
				p.SetState(2089)
				p.Match(MySqlParserCOLUMNS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2090)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2091)
				p.UidList()
			}
			{
				p.SetState(2092)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubpartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSubpartitionFunctionDefinitionContext differentiates from other interfaces.
	IsSubpartitionFunctionDefinitionContext()
}

type SubpartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionFunctionDefinitionContext() *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition
	return p
}

func InitEmptySubpartitionFunctionDefinitionContext(p *SubpartitionFunctionDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition
}

func (*SubpartitionFunctionDefinitionContext) IsSubpartitionFunctionDefinitionContext() {}

func NewSubpartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition

	return p
}

func (s *SubpartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionFunctionDefinitionContext) CopyAll(ctx *SubpartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SubpartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SubPartitionFunctionHashContext struct {
	SubpartitionFunctionDefinitionContext
}

func NewSubPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionHashContext {
	var p = new(SubPartitionFunctionHashContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *SubPartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubPartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}


func (s *SubPartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubPartitionFunctionHash(s)

	default:
		return t.VisitChildren(s)
	}
}


type SubPartitionFunctionKeyContext struct {
	SubpartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewSubPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionKeyContext {
	var p = new(SubPartitionFunctionKeyContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}


func (s *SubPartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }


func (s *SubPartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *SubPartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SubPartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SubPartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *SubPartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *SubPartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SubPartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}


func (s *SubPartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubPartitionFunctionKey(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) SubpartitionFunctionDefinition() (localctx ISubpartitionFunctionDefinitionContext) {
	localctx = NewSubpartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MySqlParserRULE_subpartitionFunctionDefinition)
	var _la int

	p.SetState(2119)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSubPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLINEAR {
			{
				p.SetState(2098)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2101)
			p.Match(MySqlParserHASH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2102)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2103)
			p.expression(0)
		}
		{
			p.SetState(2104)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		localctx = NewSubPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLINEAR {
			{
				p.SetState(2106)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2109)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserALGORITHM {
			{
				p.SetState(2110)
				p.Match(MySqlParserALGORITHM)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2111)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2112)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SubPartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserONE_DECIMAL || _la == MySqlParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SubPartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2115)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.UidList()
		}
		{
			p.SetState(2117)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinition
	return p
}

func InitEmptyPartitionDefinitionContext(p *PartitionDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinition
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) CopyAll(ctx *PartitionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type PartitionComparisonContext struct {
	PartitionDefinitionContext
}

func NewPartitionComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionComparisonContext {
	var p = new(PartitionComparisonContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionComparisonContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionComparisonContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionComparisonContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS, 0)
}

func (s *PartitionComparisonContext) THAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHAN, 0)
}

func (s *PartitionComparisonContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionComparisonContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionComparisonContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionComparisonContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionComparisonContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionComparisonContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionComparisonContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}


func (s *PartitionComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionComparison(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionListAtomContext struct {
	PartitionDefinitionContext
}

func NewPartitionListAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListAtomContext {
	var p = new(PartitionListAtomContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListAtomContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionListAtomContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListAtomContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionListAtomContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PartitionListAtomContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionListAtomContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionListAtomContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionListAtomContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionListAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionListAtomContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListAtomContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}


func (s *PartitionListAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionListAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionListVectorContext struct {
	PartitionDefinitionContext
}

func NewPartitionListVectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListVectorContext {
	var p = new(PartitionListVectorContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListVectorContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionListVectorContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListVectorContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionListVectorContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PartitionListVectorContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionListVectorContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllPartitionDefinerVector() []IPartitionDefinerVectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerVectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerVectorContext); ok {
			tst[i] = t.(IPartitionDefinerVectorContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionDefinerVector(i int) IPartitionDefinerVectorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerVectorContext)
}

func (s *PartitionListVectorContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionListVectorContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionListVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionListVectorContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListVectorContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}


func (s *PartitionListVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionListVector(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionSimpleContext struct {
	PartitionDefinitionContext
}

func NewPartitionSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionSimpleContext {
	var p = new(PartitionSimpleContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSimpleContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionSimpleContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionSimpleContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionSimpleContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionSimpleContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionSimpleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *PartitionSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionSimple(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MySqlParserRULE_partitionDefinition)
	var _la int

	p.SetState(2267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2121)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2122)
			p.Uid()
		}
		{
			p.SetState(2123)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2124)
			p.Match(MySqlParserLESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2125)
			p.Match(MySqlParserTHAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2126)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2127)
			p.PartitionDefinerAtom()
		}
		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2128)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2129)
				p.PartitionDefinerAtom()
			}


			p.SetState(2134)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2135)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la - 368)) & ^0x3f) == 0 && ((int64(1) << (_la - 368)) & 2199024304129) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2136)
				p.PartitionOption()
			}


			p.SetState(2141)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2142)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2143)
				p.SubpartitionDefinition()
			}
			p.SetState(2148)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(2144)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2145)
					p.SubpartitionDefinition()
				}


				p.SetState(2150)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2151)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 2:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2155)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2156)
			p.Uid()
		}
		{
			p.SetState(2157)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2158)
			p.Match(MySqlParserLESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2159)
			p.Match(MySqlParserTHAN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2160)
			p.PartitionDefinerAtom()
		}
		p.SetState(2164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la - 368)) & ^0x3f) == 0 && ((int64(1) << (_la - 368)) & 2199024304129) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2161)
				p.PartitionOption()
			}


			p.SetState(2166)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2167)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2168)
				p.SubpartitionDefinition()
			}
			p.SetState(2173)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(2169)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2170)
					p.SubpartitionDefinition()
				}


				p.SetState(2175)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2176)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 3:
		localctx = NewPartitionListAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2180)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2181)
			p.Uid()
		}
		{
			p.SetState(2182)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2183)
			p.Match(MySqlParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2184)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2185)
			p.PartitionDefinerAtom()
		}
		p.SetState(2190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2186)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2187)
				p.PartitionDefinerAtom()
			}


			p.SetState(2192)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2193)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la - 368)) & ^0x3f) == 0 && ((int64(1) << (_la - 368)) & 2199024304129) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2194)
				p.PartitionOption()
			}


			p.SetState(2199)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2200)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2201)
				p.SubpartitionDefinition()
			}
			p.SetState(2206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(2202)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2203)
					p.SubpartitionDefinition()
				}


				p.SetState(2208)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2209)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 4:
		localctx = NewPartitionListVectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2213)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2214)
			p.Uid()
		}
		{
			p.SetState(2215)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2216)
			p.Match(MySqlParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2217)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2218)
			p.PartitionDefinerVector()
		}
		p.SetState(2223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2219)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2220)
				p.PartitionDefinerVector()
			}


			p.SetState(2225)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2226)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la - 368)) & ^0x3f) == 0 && ((int64(1) << (_la - 368)) & 2199024304129) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2227)
				p.PartitionOption()
			}


			p.SetState(2232)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2233)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2234)
				p.SubpartitionDefinition()
			}
			p.SetState(2239)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(2235)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2236)
					p.SubpartitionDefinition()
				}


				p.SetState(2241)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2242)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 5:
		localctx = NewPartitionSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2246)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2247)
			p.Uid()
		}
		p.SetState(2251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la - 368)) & ^0x3f) == 0 && ((int64(1) << (_la - 368)) & 2199024304129) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2248)
				p.PartitionOption()
			}


			p.SetState(2253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2254)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2255)
				p.SubpartitionDefinition()
			}
			p.SetState(2260)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(2256)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2257)
					p.SubpartitionDefinition()
				}


				p.SetState(2262)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2263)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionDefinerAtomContext is an interface to support dynamic dispatch.
type IPartitionDefinerAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	Expression() IExpressionContext
	MAXVALUE() antlr.TerminalNode

	// IsPartitionDefinerAtomContext differentiates from other interfaces.
	IsPartitionDefinerAtomContext()
}

type PartitionDefinerAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerAtomContext() *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom
	return p
}

func InitEmptyPartitionDefinerAtomContext(p *PartitionDefinerAtomContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom
}

func (*PartitionDefinerAtomContext) IsPartitionDefinerAtomContext() {}

func NewPartitionDefinerAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom

	return p
}

func (s *PartitionDefinerAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionDefinerAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionDefinerAtomContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAXVALUE, 0)
}

func (s *PartitionDefinerAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionDefinerAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionDefinerAtom(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PartitionDefinerAtom() (localctx IPartitionDefinerAtomContext) {
	localctx = NewPartitionDefinerAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MySqlParserRULE_partitionDefinerAtom)
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2269)
			p.Constant()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2270)
			p.expression(0)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2271)
			p.Match(MySqlParserMAXVALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionDefinerVectorContext is an interface to support dynamic dispatch.
type IPartitionDefinerVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinerAtom() []IPartitionDefinerAtomContext
	PartitionDefinerAtom(i int) IPartitionDefinerAtomContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinerVectorContext differentiates from other interfaces.
	IsPartitionDefinerVectorContext()
}

type PartitionDefinerVectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerVectorContext() *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector
	return p
}

func InitEmptyPartitionDefinerVectorContext(p *PartitionDefinerVectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector
}

func (*PartitionDefinerVectorContext) IsPartitionDefinerVectorContext() {}

func NewPartitionDefinerVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector

	return p
}

func (s *PartitionDefinerVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerVectorContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinerVectorContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionDefinerVectorContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionDefinerVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionDefinerVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionDefinerVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionDefinerVector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PartitionDefinerVector() (localctx IPartitionDefinerVectorContext) {
	localctx = NewPartitionDefinerVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MySqlParserRULE_partitionDefinerVector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2274)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2275)
		p.PartitionDefinerAtom()
	}
	p.SetState(2278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == MySqlParserCOMMA {
		{
			p.SetState(2276)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2277)
			p.PartitionDefinerAtom()
		}


		p.SetState(2280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2282)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Uid() IUidContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition
	return p
}

func InitEmptySubpartitionDefinitionContext(p *SubpartitionDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *SubpartitionDefinitionContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubpartitionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MySqlParserRULE_subpartitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2284)
		p.Match(MySqlParserSUBPARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2285)
		p.Uid()
	}
	p.SetState(2289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la - 368)) & ^0x3f) == 0 && ((int64(1) << (_la - 368)) & 2199024304129) != 0) || ((int64((_la - 500)) & ^0x3f) == 0 && ((int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
		{
			p.SetState(2286)
			p.PartitionOption()
		}


		p.SetState(2291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionOption
	return p
}

func InitEmptyPartitionOptionContext(p *PartitionOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionOption
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) CopyAll(ctx *PartitionOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type PartitionOptionCommentContext struct {
	PartitionOptionContext
	comment antlr.Token
}

func NewPartitionOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionCommentContext {
	var p = new(PartitionOptionCommentContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}


func (s *PartitionOptionCommentContext) GetComment() antlr.Token { return s.comment }


func (s *PartitionOptionCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *PartitionOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *PartitionOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionComment(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionOptionNodeGroupContext struct {
	PartitionOptionContext
	nodegroup IUidContext 
}

func NewPartitionOptionNodeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionNodeGroupContext {
	var p = new(PartitionOptionNodeGroupContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}


func (s *PartitionOptionNodeGroupContext) GetNodegroup() IUidContext { return s.nodegroup }


func (s *PartitionOptionNodeGroupContext) SetNodegroup(v IUidContext) { s.nodegroup = v }

func (s *PartitionOptionNodeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionNodeGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *PartitionOptionNodeGroupContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionNodeGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionNodeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionNodeGroup(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionOptionIndexDirectoryContext struct {
	PartitionOptionContext
	indexDirectory antlr.Token
}

func NewPartitionOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionIndexDirectoryContext {
	var p = new(PartitionOptionIndexDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}


func (s *PartitionOptionIndexDirectoryContext) GetIndexDirectory() antlr.Token { return s.indexDirectory }


func (s *PartitionOptionIndexDirectoryContext) SetIndexDirectory(v antlr.Token) { s.indexDirectory = v }

func (s *PartitionOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *PartitionOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *PartitionOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionIndexDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionOptionMaxRowsContext struct {
	PartitionOptionContext
	maxRows IDecimalLiteralContext 
}

func NewPartitionOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMaxRowsContext {
	var p = new(PartitionOptionMaxRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}


func (s *PartitionOptionMaxRowsContext) GetMaxRows() IDecimalLiteralContext { return s.maxRows }


func (s *PartitionOptionMaxRowsContext) SetMaxRows(v IDecimalLiteralContext) { s.maxRows = v }

func (s *PartitionOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *PartitionOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionMaxRows(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionOptionTablespaceContext struct {
	PartitionOptionContext
	tablespace IUidContext 
}

func NewPartitionOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionTablespaceContext {
	var p = new(PartitionOptionTablespaceContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}


func (s *PartitionOptionTablespaceContext) GetTablespace() IUidContext { return s.tablespace }


func (s *PartitionOptionTablespaceContext) SetTablespace(v IUidContext) { s.tablespace = v }

func (s *PartitionOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *PartitionOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionOptionEngineContext struct {
	PartitionOptionContext
}

func NewPartitionOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionEngineContext {
	var p = new(PartitionOptionEngineContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *PartitionOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *PartitionOptionEngineContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *PartitionOptionEngineContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *PartitionOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionEngine(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionOptionMinRowsContext struct {
	PartitionOptionContext
	minRows IDecimalLiteralContext 
}

func NewPartitionOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMinRowsContext {
	var p = new(PartitionOptionMinRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}


func (s *PartitionOptionMinRowsContext) GetMinRows() IDecimalLiteralContext { return s.minRows }


func (s *PartitionOptionMinRowsContext) SetMinRows(v IDecimalLiteralContext) { s.minRows = v }

func (s *PartitionOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *PartitionOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionMinRows(s)

	default:
		return t.VisitChildren(s)
	}
}


type PartitionOptionDataDirectoryContext struct {
	PartitionOptionContext
	dataDirectory antlr.Token
}

func NewPartitionOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionDataDirectoryContext {
	var p = new(PartitionOptionDataDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}


func (s *PartitionOptionDataDirectoryContext) GetDataDirectory() antlr.Token { return s.dataDirectory }


func (s *PartitionOptionDataDirectoryContext) SetDataDirectory(v antlr.Token) { s.dataDirectory = v }

func (s *PartitionOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *PartitionOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *PartitionOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *PartitionOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionDataDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) PartitionOption() (localctx IPartitionOptionContext) {
	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MySqlParserRULE_partitionOption)
	var _la int

	p.SetState(2340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDEFAULT, MySqlParserENGINE, MySqlParserSTORAGE:
		localctx = NewPartitionOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(2292)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(2296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserSTORAGE {
			{
				p.SetState(2295)
				p.Match(MySqlParserSTORAGE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2298)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2299)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2302)
			p.EngineName()
		}


	case MySqlParserCOMMENT:
		localctx = NewPartitionOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2303)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2304)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2307)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionCommentContext).comment = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDATA:
		localctx = NewPartitionOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2308)
			p.Match(MySqlParserDATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2309)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2310)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2313)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionDataDirectoryContext).dataDirectory = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserINDEX:
		localctx = NewPartitionOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2314)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2315)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2316)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2319)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionIndexDirectoryContext).indexDirectory = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMAX_ROWS:
		localctx = NewPartitionOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2320)
			p.Match(MySqlParserMAX_ROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2321)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2324)

			var _x = p.DecimalLiteral()


			localctx.(*PartitionOptionMaxRowsContext).maxRows = _x
		}


	case MySqlParserMIN_ROWS:
		localctx = NewPartitionOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2325)
			p.Match(MySqlParserMIN_ROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2326)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2329)

			var _x = p.DecimalLiteral()


			localctx.(*PartitionOptionMinRowsContext).minRows = _x
		}


	case MySqlParserTABLESPACE:
		localctx = NewPartitionOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2330)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2331)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2334)

			var _x = p.Uid()


			localctx.(*PartitionOptionTablespaceContext).tablespace = _x
		}


	case MySqlParserNODEGROUP:
		localctx = NewPartitionOptionNodeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2335)
			p.Match(MySqlParserNODEGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2336)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2339)

			var _x = p.Uid()


			localctx.(*PartitionOptionNodeGroupContext).nodegroup = _x
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterDatabaseContext is an interface to support dynamic dispatch.
type IAlterDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterDatabaseContext differentiates from other interfaces.
	IsAlterDatabaseContext()
}

type AlterDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseContext() *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterDatabase
	return p
}

func InitEmptyAlterDatabaseContext(p *AlterDatabaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterDatabase
}

func (*AlterDatabaseContext) IsAlterDatabaseContext() {}

func NewAlterDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterDatabase

	return p
}

func (s *AlterDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseContext) CopyAll(ctx *AlterDatabaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type AlterUpgradeNameContext struct {
	AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterUpgradeNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUpgradeNameContext {
	var p = new(AlterUpgradeNameContext)

	InitEmptyAlterDatabaseContext(&p.AlterDatabaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterDatabaseContext))

	return p
}


func (s *AlterUpgradeNameContext) GetDbFormat() antlr.Token { return s.dbFormat }


func (s *AlterUpgradeNameContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterUpgradeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUpgradeNameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUpgradeNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterUpgradeNameContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *AlterUpgradeNameContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *AlterUpgradeNameContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *AlterUpgradeNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME, 0)
}

func (s *AlterUpgradeNameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *AlterUpgradeNameContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}


func (s *AlterUpgradeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUpgradeName(s)
	}
}

func (s *AlterUpgradeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUpgradeName(s)
	}
}

func (s *AlterUpgradeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterUpgradeName(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterSimpleDatabaseContext struct {
	AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterSimpleDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSimpleDatabaseContext {
	var p = new(AlterSimpleDatabaseContext)

	InitEmptyAlterDatabaseContext(&p.AlterDatabaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterDatabaseContext))

	return p
}


func (s *AlterSimpleDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }


func (s *AlterSimpleDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterSimpleDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSimpleDatabaseContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterSimpleDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *AlterSimpleDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *AlterSimpleDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterSimpleDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterSimpleDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}


func (s *AlterSimpleDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterSimpleDatabase(s)
	}
}

func (s *AlterSimpleDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterSimpleDatabase(s)
	}
}

func (s *AlterSimpleDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterSimpleDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) AlterDatabase() (localctx IAlterDatabaseContext) {
	localctx = NewAlterDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MySqlParserRULE_alterDatabase)
	var _la int

	p.SetState(2360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterSimpleDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2342)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2343)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterSimpleDatabaseContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterSimpleDatabaseContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2345)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2344)
				p.Uid()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(2348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 4398214283264) != 0) || _la == MySqlParserREAD || _la == MySqlParserCHAR || _la == MySqlParserENCRYPTION || _la == MySqlParserCHARSET {
			{
				p.SetState(2347)
				p.CreateDatabaseOption()
			}


			p.SetState(2350)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewAlterUpgradeNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2352)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2353)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterUpgradeNameContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterUpgradeNameContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2354)
			p.Uid()
		}
		{
			p.SetState(2355)
			p.Match(MySqlParserUPGRADE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2356)
			p.Match(MySqlParserDATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2357)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2358)
			p.Match(MySqlParserNAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterEventContext is an interface to support dynamic dispatch.
type IAlterEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	OwnerStatement() IOwnerStatementContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	NOT() antlr.TerminalNode

	// IsAlterEventContext differentiates from other interfaces.
	IsAlterEventContext()
}

type AlterEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterEventContext() *AlterEventContext {
	var p = new(AlterEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterEvent
	return p
}

func InitEmptyAlterEventContext(p *AlterEventContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterEvent
}

func (*AlterEventContext) IsAlterEventContext() {}

func NewAlterEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterEventContext {
	var p = new(AlterEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterEvent

	return p
}

func (s *AlterEventContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterEventContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *AlterEventContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *AlterEventContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *AlterEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *AlterEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *AlterEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *AlterEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *AlterEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *AlterEventContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterEventContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *AlterEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *AlterEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *AlterEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *AlterEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterEvent(s)
	}
}

func (s *AlterEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterEvent(s)
	}
}

func (s *AlterEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterEvent(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterEvent() (localctx IAlterEventContext) {
	localctx = NewAlterEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MySqlParserRULE_alterEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2362)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFINER {
		{
			p.SetState(2363)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(2366)
		p.Match(MySqlParserEVENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2367)
		p.FullId()
	}
	p.SetState(2371)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2368)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2369)
			p.Match(MySqlParserSCHEDULE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2370)
			p.ScheduleExpression()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserON {
		{
			p.SetState(2373)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2374)
			p.Match(MySqlParserCOMPLETION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2376)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(2375)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2378)
			p.Match(MySqlParserPRESERVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(2384)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2381)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2382)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2383)
			p.FullId()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDISABLE || _la == MySqlParserENABLE {
		{
			p.SetState(2386)
			p.EnableType()
		}

	}
	p.SetState(2391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT {
		{
			p.SetState(2389)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2390)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(2395)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2393)
			p.Match(MySqlParserDO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2394)
			p.RoutineBody()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterFunctionContext is an interface to support dynamic dispatch.
type IAlterFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterFunctionContext differentiates from other interfaces.
	IsAlterFunctionContext()
}

type AlterFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterFunctionContext() *AlterFunctionContext {
	var p = new(AlterFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterFunction
	return p
}

func InitEmptyAlterFunctionContext(p *AlterFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterFunction
}

func (*AlterFunctionContext) IsAlterFunctionContext() {}

func NewAlterFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterFunction

	return p
}

func (s *AlterFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *AlterFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

func (s *AlterFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterFunction() (localctx IAlterFunctionContext) {
	localctx = NewAlterFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MySqlParserRULE_alterFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2397)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2398)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2399)
		p.FullId()
	}
	p.SetState(2403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserDETERMINISTIC || ((int64((_la - 112)) & ^0x3f) == 0 && ((int64(1) << (_la - 112)) & 281474985099269) != 0) || _la == MySqlParserCOMMENT || _la == MySqlParserCONTAINS || _la == MySqlParserLANGUAGE || _la == MySqlParserNO {
		{
			p.SetState(2400)
			p.RoutineOption()
		}


		p.SetState(2405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterInstanceContext is an interface to support dynamic dispatch.
type IAlterInstanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsAlterInstanceContext differentiates from other interfaces.
	IsAlterInstanceContext()
}

type AlterInstanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterInstanceContext() *AlterInstanceContext {
	var p = new(AlterInstanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterInstance
	return p
}

func InitEmptyAlterInstanceContext(p *AlterInstanceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterInstance
}

func (*AlterInstanceContext) IsAlterInstanceContext() {}

func NewAlterInstanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterInstanceContext {
	var p = new(AlterInstanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterInstance

	return p
}

func (s *AlterInstanceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterInstanceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterInstanceContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANCE, 0)
}

func (s *AlterInstanceContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROTATE, 0)
}

func (s *AlterInstanceContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB, 0)
}

func (s *AlterInstanceContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *AlterInstanceContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterInstanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterInstanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterInstanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterInstance(s)
	}
}

func (s *AlterInstanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterInstance(s)
	}
}

func (s *AlterInstanceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterInstance(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterInstance() (localctx IAlterInstanceContext) {
	localctx = NewAlterInstanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MySqlParserRULE_alterInstance)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2406)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2407)
		p.Match(MySqlParserINSTANCE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2408)
		p.Match(MySqlParserROTATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2409)
		p.Match(MySqlParserINNODB)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2410)
		p.Match(MySqlParserMASTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2411)
		p.Match(MySqlParserKEY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterLogfileGroupContext is an interface to support dynamic dispatch.
type IAlterLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	INITIAL_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsAlterLogfileGroupContext differentiates from other interfaces.
	IsAlterLogfileGroupContext()
}

type AlterLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLogfileGroupContext() *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup
	return p
}

func InitEmptyAlterLogfileGroupContext(p *AlterLogfileGroupContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup
}

func (*AlterLogfileGroupContext) IsAlterLogfileGroupContext() {}

func NewAlterLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup

	return p
}

func (s *AlterLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLogfileGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *AlterLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *AlterLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *AlterLogfileGroupContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *AlterLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *AlterLogfileGroupContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *AlterLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterLogfileGroup() (localctx IAlterLogfileGroupContext) {
	localctx = NewAlterLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MySqlParserRULE_alterLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2413)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2414)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2415)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2416)
		p.Uid()
	}
	{
		p.SetState(2417)
		p.Match(MySqlParserADD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2418)
		p.Match(MySqlParserUNDOFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2419)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(2420)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2421)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2424)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWAIT {
		{
			p.SetState(2427)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2430)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(2431)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2434)
		p.EngineName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterProcedureContext is an interface to support dynamic dispatch.
type IAlterProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterProcedureContext differentiates from other interfaces.
	IsAlterProcedureContext()
}

type AlterProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProcedureContext() *AlterProcedureContext {
	var p = new(AlterProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterProcedure
	return p
}

func InitEmptyAlterProcedureContext(p *AlterProcedureContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterProcedure
}

func (*AlterProcedureContext) IsAlterProcedureContext() {}

func NewAlterProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProcedureContext {
	var p = new(AlterProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterProcedure

	return p
}

func (s *AlterProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *AlterProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterProcedure() (localctx IAlterProcedureContext) {
	localctx = NewAlterProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MySqlParserRULE_alterProcedure)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2436)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2437)
		p.Match(MySqlParserPROCEDURE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2438)
		p.FullId()
	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserDETERMINISTIC || ((int64((_la - 112)) & ^0x3f) == 0 && ((int64(1) << (_la - 112)) & 281474985099269) != 0) || _la == MySqlParserCOMMENT || _la == MySqlParserCONTAINS || _la == MySqlParserLANGUAGE || _la == MySqlParserNO {
		{
			p.SetState(2439)
			p.RoutineOption()
		}


		p.SetState(2444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterServerContext is an interface to support dynamic dispatch.
type IAlterServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterServerContext differentiates from other interfaces.
	IsAlterServerContext()
}

type AlterServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServerContext() *AlterServerContext {
	var p = new(AlterServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterServer
	return p
}

func InitEmptyAlterServerContext(p *AlterServerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterServer
}

func (*AlterServerContext) IsAlterServerContext() {}

func NewAlterServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServerContext {
	var p = new(AlterServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterServer

	return p
}

func (s *AlterServerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *AlterServerContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *AlterServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *AlterServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterServer(s)
	}
}

func (s *AlterServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterServer(s)
	}
}

func (s *AlterServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterServer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterServer() (localctx IAlterServerContext) {
	localctx = NewAlterServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MySqlParserRULE_alterServer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2445)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2446)
		p.Match(MySqlParserSERVER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2447)
		p.Uid()
	}
	{
		p.SetState(2448)
		p.Match(MySqlParserOPTIONS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2449)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2450)
		p.ServerOption()
	}
	p.SetState(2455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(2451)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2452)
			p.ServerOption()
		}


		p.SetState(2457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2458)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token 


	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token) 


	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	IGNORE() antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext
	AllAlterSpecification() []IAlterSpecificationContext
	AlterSpecification(i int) IAlterSpecificationContext
	PartitionDefinitions() IPartitionDefinitionsContext
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	intimeAction antlr.Token
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTable
	return p
}

func InitEmptyAlterTableContext(p *AlterTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTable
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) GetIntimeAction() antlr.Token { return s.intimeAction }


func (s *AlterTableContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }


func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AlterTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *AlterTableContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *AlterTableContext) AllAlterSpecification() []IAlterSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IAlterSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterSpecificationContext); ok {
			tst[i] = t.(IAlterSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterSpecification(i int) IAlterSpecificationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSpecificationContext)
}

func (s *AlterTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *AlterTableContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *AlterTableContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (s *AlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterTable() (localctx IAlterTableContext) {
	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MySqlParserRULE_alterTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2460)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserOFFLINE || _la == MySqlParserONLINE {
		{
			p.SetState(2461)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterTableContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterTableContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(2464)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2467)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2468)
		p.TableName()
	}
	p.SetState(2470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNOWAIT || _la == MySqlParserWAIT {
		{
			p.SetState(2469)
			p.WaitNowaitClause()
		}

	}
	p.SetState(2480)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2472)
			p.AlterSpecification()
		}
		p.SetState(2477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2473)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2474)
				p.AlterSpecification()
			}


			p.SetState(2479)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(2482)
			p.PartitionDefinitions()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterTablespaceContext is an interface to support dynamic dispatch.
type IAlterTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetObjectAction returns the objectAction token.
	GetObjectAction() antlr.Token 


	// SetObjectAction sets the objectAction token.
	SetObjectAction(antlr.Token) 


	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode

	// IsAlterTablespaceContext differentiates from other interfaces.
	IsAlterTablespaceContext()
}

type AlterTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	objectAction antlr.Token
}

func NewEmptyAlterTablespaceContext() *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTablespace
	return p
}

func InitEmptyAlterTablespaceContext(p *AlterTablespaceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTablespace
}

func (*AlterTablespaceContext) IsAlterTablespaceContext() {}

func NewAlterTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterTablespace

	return p
}

func (s *AlterTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTablespaceContext) GetObjectAction() antlr.Token { return s.objectAction }


func (s *AlterTablespaceContext) SetObjectAction(v antlr.Token) { s.objectAction = v }


func (s *AlterTablespaceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterTablespaceContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *AlterTablespaceContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *AlterTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterTablespaceContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterTablespaceContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *AlterTablespaceContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterTablespaceContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterTablespaceContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterTablespaceContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *AlterTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterTablespace() (localctx IAlterTablespaceContext) {
	localctx = NewAlterTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MySqlParserRULE_alterTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2485)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2486)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2487)
		p.Uid()
	}
	{
		p.SetState(2488)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AlterTablespaceContext).objectAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserADD || _la == MySqlParserDROP) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AlterTablespaceContext).objectAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2489)
		p.Match(MySqlParserDATAFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2490)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(2491)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2492)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2493)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWAIT {
		{
			p.SetState(2496)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2499)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(2500)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2503)
		p.EngineName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterViewContext is an interface to support dynamic dispatch.
type IAlterViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token 

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token 

	// GetCheckOpt returns the checkOpt token.
	GetCheckOpt() antlr.Token 


	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token) 

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token) 

	// SetCheckOpt sets the checkOpt token.
	SetCheckOpt(antlr.Token) 


	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsAlterViewContext differentiates from other interfaces.
	IsAlterViewContext()
}

type AlterViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	algType antlr.Token
	secContext antlr.Token
	checkOpt antlr.Token
}

func NewEmptyAlterViewContext() *AlterViewContext {
	var p = new(AlterViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterView
	return p
}

func InitEmptyAlterViewContext(p *AlterViewContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterView
}

func (*AlterViewContext) IsAlterViewContext() {}

func NewAlterViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewContext {
	var p = new(AlterViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterView

	return p
}

func (s *AlterViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *AlterViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *AlterViewContext) GetCheckOpt() antlr.Token { return s.checkOpt }


func (s *AlterViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *AlterViewContext) SetCheckOpt(v antlr.Token) { s.checkOpt = v }


func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *AlterViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AlterViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *AlterViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *AlterViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AlterViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *AlterViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *AlterViewContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterViewContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterViewContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *AlterViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *AlterViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *AlterViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *AlterViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *AlterViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *AlterViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *AlterViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

func (s *AlterViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterView(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AlterView() (localctx IAlterViewContext) {
	localctx = NewAlterViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MySqlParserRULE_alterView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2505)
		p.Match(MySqlParserALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserALGORITHM {
		{
			p.SetState(2506)
			p.Match(MySqlParserALGORITHM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2507)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2508)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMERGE || _la == MySqlParserTEMPTABLE || _la == MySqlParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFINER {
		{
			p.SetState(2511)
			p.OwnerStatement()
		}

	}
	p.SetState(2517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserSQL {
		{
			p.SetState(2514)
			p.Match(MySqlParserSQL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2515)
			p.Match(MySqlParserSECURITY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2516)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2519)
		p.Match(MySqlParserVIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2520)
		p.FullId()
	}
	p.SetState(2525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(2521)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2522)
			p.UidList()
		}
		{
			p.SetState(2523)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2527)
		p.Match(MySqlParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2528)
		p.SelectStatement()
	}
	p.SetState(2535)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2529)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCASCADED || _la == MySqlParserLOCAL {
			{
				p.SetState(2530)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterViewContext).checkOpt = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCASCADED || _la == MySqlParserLOCAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterViewContext).checkOpt = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2533)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2534)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterSpecificationContext is an interface to support dynamic dispatch.
type IAlterSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSpecificationContext differentiates from other interfaces.
	IsAlterSpecificationContext()
}

type AlterSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSpecificationContext() *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterSpecification
	return p
}

func InitEmptyAlterSpecificationContext(p *AlterSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterSpecification
}

func (*AlterSpecificationContext) IsAlterSpecificationContext() {}

func NewAlterSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterSpecification

	return p
}

func (s *AlterSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSpecificationContext) CopyAll(ctx *AlterSpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type AlterByAlterColumnDefaultContext struct {
	AlterSpecificationContext
}

func NewAlterByAlterColumnDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterColumnDefaultContext {
	var p = new(AlterByAlterColumnDefaultContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterColumnDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterColumnDefaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterColumnDefaultContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterColumnDefaultContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByAlterColumnDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByAlterColumnDefaultContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByAlterColumnDefaultContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAlterColumnDefaultContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *AlterByAlterColumnDefaultContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *AlterByAlterColumnDefaultContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAlterColumnDefaultContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAlterColumnDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAlterColumnDefaultContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *AlterByAlterColumnDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterColumnDefault(s)
	}
}

func (s *AlterByAlterColumnDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterColumnDefault(s)
	}
}

func (s *AlterByAlterColumnDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAlterColumnDefault(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDisableKeysContext struct {
	AlterSpecificationContext
}

func NewAlterByDisableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDisableKeysContext {
	var p = new(AlterByDisableKeysContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDisableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDisableKeysContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *AlterByDisableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}


func (s *AlterByDisableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDisableKeys(s)
	}
}

func (s *AlterByDisableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDisableKeys(s)
	}
}

func (s *AlterByDisableKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDisableKeys(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDefaultCharsetContext struct {
	AlterSpecificationContext
}

func NewAlterByDefaultCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDefaultCharsetContext {
	var p = new(AlterByDefaultCharsetContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDefaultCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDefaultCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *AlterByDefaultCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByDefaultCharsetContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterByDefaultCharsetContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterByDefaultCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByDefaultCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByDefaultCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *AlterByDefaultCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}


func (s *AlterByDefaultCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDefaultCharset(s)
	}
}

func (s *AlterByDefaultCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDefaultCharset(s)
	}
}

func (s *AlterByDefaultCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDefaultCharset(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByRenameColumnContext struct {
	AlterSpecificationContext
	oldColumn IUidContext 
	newColumn IUidContext 
}

func NewAlterByRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameColumnContext {
	var p = new(AlterByRenameColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByRenameColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByRenameColumnContext) GetNewColumn() IUidContext { return s.newColumn }


func (s *AlterByRenameColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByRenameColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByRenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByRenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *AlterByRenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRenameColumn(s)
	}
}

func (s *AlterByRenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRenameColumn(s)
	}
}

func (s *AlterByRenameColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRenameColumn(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByConvertCharsetContext struct {
	AlterSpecificationContext
}

func NewAlterByConvertCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByConvertCharsetContext {
	var p = new(AlterByConvertCharsetContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByConvertCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByConvertCharsetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *AlterByConvertCharsetContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByConvertCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByConvertCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *AlterByConvertCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *AlterByConvertCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByConvertCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *AlterByConvertCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}


func (s *AlterByConvertCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByConvertCharset(s)
	}
}

func (s *AlterByConvertCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByConvertCharset(s)
	}
}

func (s *AlterByConvertCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByConvertCharset(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddForeignKeyContext struct {
	AlterSpecificationContext
	name IUidContext 
	indexName IUidContext 
}

func NewAlterByAddForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddForeignKeyContext {
	var p = new(AlterByAddForeignKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByAddForeignKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddForeignKeyContext) GetIndexName() IUidContext { return s.indexName }


func (s *AlterByAddForeignKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddForeignKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddForeignKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *AlterByAddForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddForeignKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddForeignKeyContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *AlterByAddForeignKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddForeignKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddForeignKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *AlterByAddForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddForeignKey(s)
	}
}

func (s *AlterByAddForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddForeignKey(s)
	}
}

func (s *AlterByAddForeignKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddForeignKey(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByRenameIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByRenameIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameIndexContext {
	var p = new(AlterByRenameIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByRenameIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *AlterByRenameIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByRenameIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameIndexContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameIndexContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameIndexContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameIndexContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByRenameIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *AlterByRenameIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRenameIndex(s)
	}
}

func (s *AlterByRenameIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRenameIndex(s)
	}
}

func (s *AlterByRenameIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRenameIndex(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByRenameContext struct {
	AlterSpecificationContext
	renameFormat antlr.Token
}

func NewAlterByRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameContext {
	var p = new(AlterByRenameContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByRenameContext) GetRenameFormat() antlr.Token { return s.renameFormat }


func (s *AlterByRenameContext) SetRenameFormat(v antlr.Token) { s.renameFormat = v }

func (s *AlterByRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterByRenameContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}


func (s *AlterByRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRename(s)
	}
}

func (s *AlterByRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRename(s)
	}
}

func (s *AlterByRenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRename(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByImportTablespaceContext struct {
	AlterSpecificationContext
}

func NewAlterByImportTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportTablespaceContext {
	var p = new(AlterByImportTablespaceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByImportTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportTablespaceContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *AlterByImportTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}


func (s *AlterByImportTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByImportTablespace(s)
	}
}

func (s *AlterByImportTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByImportTablespace(s)
	}
}

func (s *AlterByImportTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByImportTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddDefinitionsContext struct {
	AlterSpecificationContext
}

func NewAlterByAddDefinitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddDefinitionsContext {
	var p = new(AlterByAddDefinitionsContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddDefinitionsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *AlterByAddDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *AlterByAddDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddDefinitions(s)
	}
}

func (s *AlterByAddDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddDefinitions(s)
	}
}

func (s *AlterByAddDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAlterCheckTableConstraintContext struct {
	AlterSpecificationContext
	name IUidContext 
}

func NewAlterByAlterCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterCheckTableConstraintContext {
	var p = new(AlterByAlterCheckTableConstraintContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByAlterCheckTableConstraintContext) GetName() IUidContext { return s.name }


func (s *AlterByAlterCheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAlterCheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterCheckTableConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAlterCheckTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterCheckTableConstraintContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAlterCheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAlterCheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}


func (s *AlterByAlterCheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterCheckTableConstraint(s)
	}
}

func (s *AlterByAlterCheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterCheckTableConstraint(s)
	}
}

func (s *AlterByAlterCheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAlterCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDropConstraintCheckContext struct {
	AlterSpecificationContext
}

func NewAlterByDropConstraintCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropConstraintCheckContext {
	var p = new(AlterByDropConstraintCheckContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropConstraintCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropConstraintCheckContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropConstraintCheckContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropConstraintCheckContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByDropConstraintCheckContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}


func (s *AlterByDropConstraintCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropConstraintCheck(s)
	}
}

func (s *AlterByDropConstraintCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropConstraintCheck(s)
	}
}

func (s *AlterByDropConstraintCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropConstraintCheck(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddColumnsContext struct {
	AlterSpecificationContext
}

func NewAlterByAddColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnsContext {
	var p = new(AlterByAddColumnsContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddColumnsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnsContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddColumnsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddColumnsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *AlterByAddColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddColumns(s)
	}
}

func (s *AlterByAddColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddColumns(s)
	}
}

func (s *AlterByAddColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddColumns(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAlterIndexVisibilityContext struct {
	AlterSpecificationContext
}

func NewAlterByAlterIndexVisibilityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterIndexVisibilityContext {
	var p = new(AlterByAlterIndexVisibilityContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterIndexVisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterIndexVisibilityContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAlterIndexVisibilityContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterIndexVisibilityContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}


func (s *AlterByAlterIndexVisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterIndexVisibility(s)
	}
}

func (s *AlterByAlterIndexVisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterIndexVisibility(s)
	}
}

func (s *AlterByAlterIndexVisibilityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAlterIndexVisibility(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDropForeignKeyContext struct {
	AlterSpecificationContext
}

func NewAlterByDropForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropForeignKeyContext {
	var p = new(AlterByDropForeignKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropForeignKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *AlterByDropForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByDropForeignKeyContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *AlterByDropForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropForeignKey(s)
	}
}

func (s *AlterByDropForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropForeignKey(s)
	}
}

func (s *AlterByDropForeignKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropForeignKey(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddCheckTableConstraintContext struct {
	AlterSpecificationContext
	name IUidContext 
}

func NewAlterByAddCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddCheckTableConstraintContext {
	var p = new(AlterByAddCheckTableConstraintContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByAddCheckTableConstraintContext) GetName() IUidContext { return s.name }


func (s *AlterByAddCheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddCheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddCheckTableConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByAddCheckTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddCheckTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddCheckTableConstraintContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAddCheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAddCheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddCheckTableConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterByAddCheckTableConstraintContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}


func (s *AlterByAddCheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddCheckTableConstraint(s)
	}
}

func (s *AlterByAddCheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddCheckTableConstraint(s)
	}
}

func (s *AlterByAddCheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterPartitionContext {
	var p = new(AlterPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPartitionContext) AlterPartitionSpecification() IAlterPartitionSpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPartitionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPartitionSpecificationContext)
}


func (s *AlterPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterPartition(s)
	}
}

func (s *AlterPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterPartition(s)
	}
}

func (s *AlterPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByAddIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddIndexContext {
	var p = new(AlterByAddIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByAddIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *AlterByAddIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddIndexContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}


func (s *AlterByAddIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddIndex(s)
	}
}

func (s *AlterByAddIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddIndex(s)
	}
}

func (s *AlterByAddIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddIndex(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDropColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropColumnContext {
	var p = new(AlterByDropColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropColumnContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByDropColumnContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}


func (s *AlterByDropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropColumn(s)
	}
}

func (s *AlterByDropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropColumn(s)
	}
}

func (s *AlterByDropColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropColumn(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByChangeDefaultContext struct {
	AlterSpecificationContext
}

func NewAlterByChangeDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeDefaultContext {
	var p = new(AlterByChangeDefaultContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByChangeDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeDefaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByChangeDefaultContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeDefaultContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByChangeDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByChangeDefaultContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AlterByChangeDefaultContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByChangeDefaultContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}


func (s *AlterByChangeDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByChangeDefault(s)
	}
}

func (s *AlterByChangeDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByChangeDefault(s)
	}
}

func (s *AlterByChangeDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByChangeDefault(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByForceContext struct {
	AlterSpecificationContext
}

func NewAlterByForceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByForceContext {
	var p = new(AlterByForceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByForceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByForceContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORCE, 0)
}


func (s *AlterByForceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByForce(s)
	}
}

func (s *AlterByForceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByForce(s)
	}
}

func (s *AlterByForceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByForce(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddSpecialIndexContext struct {
	AlterSpecificationContext
	keyType antlr.Token
	indexFormat antlr.Token
}

func NewAlterByAddSpecialIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddSpecialIndexContext {
	var p = new(AlterByAddSpecialIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByAddSpecialIndexContext) GetKeyType() antlr.Token { return s.keyType }

func (s *AlterByAddSpecialIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *AlterByAddSpecialIndexContext) SetKeyType(v antlr.Token) { s.keyType = v }

func (s *AlterByAddSpecialIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddSpecialIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddSpecialIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddSpecialIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddSpecialIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *AlterByAddSpecialIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *AlterByAddSpecialIndexContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddSpecialIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddSpecialIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddSpecialIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddSpecialIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *AlterByAddSpecialIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddSpecialIndex(s)
	}
}

func (s *AlterByAddSpecialIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddSpecialIndex(s)
	}
}

func (s *AlterByAddSpecialIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddSpecialIndex(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByModifyColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByModifyColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByModifyColumnContext {
	var p = new(AlterByModifyColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByModifyColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByModifyColumnContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFY, 0)
}

func (s *AlterByModifyColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByModifyColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByModifyColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByModifyColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByModifyColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByModifyColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}


func (s *AlterByModifyColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByModifyColumn(s)
	}
}

func (s *AlterByModifyColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByModifyColumn(s)
	}
}

func (s *AlterByModifyColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByModifyColumn(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByTableOptionContext struct {
	AlterSpecificationContext
}

func NewAlterByTableOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTableOptionContext {
	var p = new(AlterByTableOptionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTableOptionContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByTableOptionContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *AlterByTableOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByTableOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *AlterByTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByTableOption(s)
	}
}

func (s *AlterByTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByTableOption(s)
	}
}

func (s *AlterByTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDropPrimaryKeyContext struct {
	AlterSpecificationContext
}

func NewAlterByDropPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPrimaryKeyContext {
	var p = new(AlterByDropPrimaryKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPrimaryKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *AlterByDropPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *AlterByDropPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropPrimaryKey(s)
	}
}

func (s *AlterByDropPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropPrimaryKey(s)
	}
}

func (s *AlterByDropPrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByLockContext struct {
	AlterSpecificationContext
	lockType antlr.Token
}

func NewAlterByLockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByLockContext {
	var p = new(AlterByLockContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByLockContext) GetLockType() antlr.Token { return s.lockType }


func (s *AlterByLockContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *AlterByLockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByLockContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *AlterByLockContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByLockContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *AlterByLockContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, 0)
}

func (s *AlterByLockContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, 0)
}

func (s *AlterByLockContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *AlterByLockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByLock(s)
	}
}

func (s *AlterByLockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByLock(s)
	}
}

func (s *AlterByLockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByLock(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDiscardTablespaceContext struct {
	AlterSpecificationContext
}

func NewAlterByDiscardTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardTablespaceContext {
	var p = new(AlterByDiscardTablespaceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDiscardTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardTablespaceContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *AlterByDiscardTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}


func (s *AlterByDiscardTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDiscardTablespace(s)
	}
}

func (s *AlterByDiscardTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDiscardTablespace(s)
	}
}

func (s *AlterByDiscardTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDiscardTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByValidateContext struct {
	AlterSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByValidateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByValidateContext {
	var p = new(AlterByValidateContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByValidateContext) GetValidationFormat() antlr.Token { return s.validationFormat }


func (s *AlterByValidateContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByValidateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByValidateContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *AlterByValidateContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *AlterByValidateContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}


func (s *AlterByValidateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByValidate(s)
	}
}

func (s *AlterByValidateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByValidate(s)
	}
}

func (s *AlterByValidateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByValidate(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddPrimaryKeyContext struct {
	AlterSpecificationContext
	name IUidContext 
	index IUidContext 
}

func NewAlterByAddPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPrimaryKeyContext {
	var p = new(AlterByAddPrimaryKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByAddPrimaryKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddPrimaryKeyContext) GetIndex() IUidContext { return s.index }


func (s *AlterByAddPrimaryKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddPrimaryKeyContext) SetIndex(v IUidContext) { s.index = v }

func (s *AlterByAddPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPrimaryKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *AlterByAddPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddPrimaryKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddPrimaryKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddPrimaryKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *AlterByAddPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddPrimaryKey(s)
	}
}

func (s *AlterByAddPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddPrimaryKey(s)
	}
}

func (s *AlterByAddPrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByEnableKeysContext struct {
	AlterSpecificationContext
}

func NewAlterByEnableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByEnableKeysContext {
	var p = new(AlterByEnableKeysContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByEnableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByEnableKeysContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *AlterByEnableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}


func (s *AlterByEnableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByEnableKeys(s)
	}
}

func (s *AlterByEnableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByEnableKeys(s)
	}
}

func (s *AlterByEnableKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByEnableKeys(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterBySetAlgorithmContext struct {
	AlterSpecificationContext
	algType antlr.Token
}

func NewAlterBySetAlgorithmContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterBySetAlgorithmContext {
	var p = new(AlterBySetAlgorithmContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterBySetAlgorithmContext) GetAlgType() antlr.Token { return s.algType }


func (s *AlterBySetAlgorithmContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterBySetAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterBySetAlgorithmContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *AlterBySetAlgorithmContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterBySetAlgorithmContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANT, 0)
}

func (s *AlterBySetAlgorithmContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, 0)
}

func (s *AlterBySetAlgorithmContext) COPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, 0)
}

func (s *AlterBySetAlgorithmContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}


func (s *AlterBySetAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterBySetAlgorithm(s)
	}
}

func (s *AlterBySetAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterBySetAlgorithm(s)
	}
}

func (s *AlterBySetAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterBySetAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByChangeColumnContext struct {
	AlterSpecificationContext
	oldColumn IUidContext 
	newColumn IUidContext 
	afterColumn IUidContext 
}

func NewAlterByChangeColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeColumnContext {
	var p = new(AlterByChangeColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByChangeColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByChangeColumnContext) GetNewColumn() IUidContext { return s.newColumn }

func (s *AlterByChangeColumnContext) GetAfterColumn() IUidContext { return s.afterColumn }


func (s *AlterByChangeColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByChangeColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByChangeColumnContext) SetAfterColumn(v IUidContext) { s.afterColumn = v }

func (s *AlterByChangeColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeColumnContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *AlterByChangeColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByChangeColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByChangeColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByChangeColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByChangeColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}


func (s *AlterByChangeColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByChangeColumn(s)
	}
}

func (s *AlterByChangeColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByChangeColumn(s)
	}
}

func (s *AlterByChangeColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByChangeColumn(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddUniqueKeyContext struct {
	AlterSpecificationContext
	name IUidContext 
	indexFormat antlr.Token
	indexName IUidContext 
}

func NewAlterByAddUniqueKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddUniqueKeyContext {
	var p = new(AlterByAddUniqueKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByAddUniqueKeyContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *AlterByAddUniqueKeyContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }


func (s *AlterByAddUniqueKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddUniqueKeyContext) GetIndexName() IUidContext { return s.indexName }


func (s *AlterByAddUniqueKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddUniqueKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddUniqueKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddUniqueKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddUniqueKeyContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *AlterByAddUniqueKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddUniqueKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddUniqueKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddUniqueKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddUniqueKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddUniqueKeyContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddUniqueKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *AlterByAddUniqueKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddUniqueKey(s)
	}
}

func (s *AlterByAddUniqueKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddUniqueKey(s)
	}
}

func (s *AlterByAddUniqueKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddUniqueKey(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDropIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropIndexContext {
	var p = new(AlterByDropIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}


func (s *AlterByDropIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *AlterByDropIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByDropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByDropIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}


func (s *AlterByDropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropIndex(s)
	}
}

func (s *AlterByDropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropIndex(s)
	}
}

func (s *AlterByDropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnContext {
	var p = new(AlterByAddColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByAddColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}


func (s *AlterByAddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddColumn(s)
	}
}

func (s *AlterByAddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddColumn(s)
	}
}

func (s *AlterByAddColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddColumn(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByOrderContext struct {
	AlterSpecificationContext
}

func NewAlterByOrderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOrderContext {
	var p = new(AlterByOrderContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *AlterByOrderContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AlterByOrderContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}


func (s *AlterByOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByOrder(s)
	}
}

func (s *AlterByOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByOrder(s)
	}
}

func (s *AlterByOrderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByOrder(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) AlterSpecification() (localctx IAlterSpecificationContext) {
	localctx = NewAlterSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MySqlParserRULE_alterSpecification)
	var _la int

	var _alt int

	p.SetState(2888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 369, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterByTableOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2537)
			p.TableOption()
		}
		p.SetState(2544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2539)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserCOMMA {
					{
						p.SetState(2538)
						p.Match(MySqlParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(2541)
					p.TableOption()
				}


			}
			p.SetState(2546)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 2:
		localctx = NewAlterByAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2547)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2549)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2548)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2551)
			p.Uid()
		}
		{
			p.SetState(2552)
			p.ColumnDefinition()
		}
		p.SetState(2556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2553)
				p.Match(MySqlParserFIRST)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserAFTER:
			{
				p.SetState(2554)
				p.Match(MySqlParserAFTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2555)
				p.Uid()
			}


		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:



		default:
		}


	case 3:
		localctx = NewAlterByAddColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2558)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2559)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2562)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2563)
			p.Uid()
		}
		{
			p.SetState(2564)
			p.ColumnDefinition()
		}
		p.SetState(2571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2565)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2566)
				p.Uid()
			}
			{
				p.SetState(2567)
				p.ColumnDefinition()
			}


			p.SetState(2573)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2574)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		localctx = NewAlterByAddIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2576)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2577)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(2578)
				p.Uid()
			}

		}
		p.SetState(2582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUSING {
			{
				p.SetState(2581)
				p.IndexType()
			}

		}
		{
			p.SetState(2584)
			p.IndexColumnNames()
		}
		p.SetState(2588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2585)
					p.IndexOption()
				}


			}
			p.SetState(2590)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 5:
		localctx = NewAlterByAddPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2591)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2592)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2594)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2593)

					var _x = p.Uid()


					localctx.(*AlterByAddPrimaryKeyContext).name = _x
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}

		}
		{
			p.SetState(2598)
			p.Match(MySqlParserPRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2599)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(2600)

				var _x = p.Uid()


				localctx.(*AlterByAddPrimaryKeyContext).index = _x
			}

		}
		p.SetState(2604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUSING {
			{
				p.SetState(2603)
				p.IndexType()
			}

		}
		{
			p.SetState(2606)
			p.IndexColumnNames()
		}
		p.SetState(2610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2607)
					p.IndexOption()
				}


			}
			p.SetState(2612)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 6:
		localctx = NewAlterByAddUniqueKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2613)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2614)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2616)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(2615)

					var _x = p.Uid()


					localctx.(*AlterByAddUniqueKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2620)
			p.Match(MySqlParserUNIQUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(2621)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddUniqueKeyContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddUniqueKeyContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2625)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(2624)

				var _x = p.Uid()


				localctx.(*AlterByAddUniqueKeyContext).indexName = _x
			}

		}
		p.SetState(2628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUSING {
			{
				p.SetState(2627)
				p.IndexType()
			}

		}
		{
			p.SetState(2630)
			p.IndexColumnNames()
		}
		p.SetState(2634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2631)
					p.IndexOption()
				}


			}
			p.SetState(2636)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 7:
		localctx = NewAlterByAddSpecialIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2637)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2638)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddSpecialIndexContext).keyType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddSpecialIndexContext).keyType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(2639)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddSpecialIndexContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddSpecialIndexContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(2642)
				p.Uid()
			}

		}
		{
			p.SetState(2645)
			p.IndexColumnNames()
		}
		p.SetState(2649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2646)
					p.IndexOption()
				}


			}
			p.SetState(2651)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 8:
		localctx = NewAlterByAddForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2652)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2653)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2655)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(2654)

					var _x = p.Uid()


					localctx.(*AlterByAddForeignKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2659)
			p.Match(MySqlParserFOREIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2660)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(2661)

				var _x = p.Uid()


				localctx.(*AlterByAddForeignKeyContext).indexName = _x
			}

		}
		{
			p.SetState(2664)
			p.IndexColumnNames()
		}
		{
			p.SetState(2665)
			p.ReferenceDefinition()
		}


	case 9:
		localctx = NewAlterByAddCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2667)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2668)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2670)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(2669)

					var _x = p.Uid()


					localctx.(*AlterByAddCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2674)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2675)
				p.Uid()
			}


		case 2:
			{
				p.SetState(2676)
				p.StringLiteral()
			}


		case 3:
			{
				p.SetState(2677)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2678)
				p.expression(0)
			}
			{
				p.SetState(2679)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(2684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(2683)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(2687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserENFORCED {
			{
				p.SetState(2686)
				p.Match(MySqlParserENFORCED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 10:
		localctx = NewAlterByAlterCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2689)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2690)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2692)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(2691)

					var _x = p.Uid()


					localctx.(*AlterByAlterCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2696)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2697)
				p.Uid()
			}


		case 2:
			{
				p.SetState(2698)
				p.StringLiteral()
			}


		case 3:
			{
				p.SetState(2699)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2700)
				p.expression(0)
			}
			{
				p.SetState(2701)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(2706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(2705)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(2709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserENFORCED {
			{
				p.SetState(2708)
				p.Match(MySqlParserENFORCED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 11:
		localctx = NewAlterByAddCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2711)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2712)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2714)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
				{
					p.SetState(2713)

					var _x = p.Uid()


					localctx.(*AlterByAddCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2718)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2719)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2720)
			p.expression(0)
		}
		{
			p.SetState(2721)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		localctx = NewAlterBySetAlgorithmContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2723)
			p.Match(MySqlParserALGORITHM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2724)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2727)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterBySetAlgorithmContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE || _la == MySqlParserINSTANT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterBySetAlgorithmContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 13:
		localctx = NewAlterByChangeDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2728)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2729)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2732)
			p.Uid()
		}
		p.SetState(2738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSET:
			{
				p.SetState(2733)
				p.Match(MySqlParserSET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2734)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2735)
				p.DefaultValue()
			}


		case MySqlParserDROP:
			{
				p.SetState(2736)
				p.Match(MySqlParserDROP)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2737)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 14:
		localctx = NewAlterByChangeColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2740)
			p.Match(MySqlParserCHANGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2741)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2744)

			var _x = p.Uid()


			localctx.(*AlterByChangeColumnContext).oldColumn = _x
		}
		{
			p.SetState(2745)

			var _x = p.Uid()


			localctx.(*AlterByChangeColumnContext).newColumn = _x
		}
		{
			p.SetState(2746)
			p.ColumnDefinition()
		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2747)
				p.Match(MySqlParserFIRST)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserAFTER:
			{
				p.SetState(2748)
				p.Match(MySqlParserAFTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2749)

				var _x = p.Uid()


				localctx.(*AlterByChangeColumnContext).afterColumn = _x
			}


		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:



		default:
		}


	case 15:
		localctx = NewAlterByRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2752)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.Match(MySqlParserCOLUMN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2754)

			var _x = p.Uid()


			localctx.(*AlterByRenameColumnContext).oldColumn = _x
		}
		{
			p.SetState(2755)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2756)

			var _x = p.Uid()


			localctx.(*AlterByRenameColumnContext).newColumn = _x
		}


	case 16:
		localctx = NewAlterByLockContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2758)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2759)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2762)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByLockContext).lockType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByLockContext).lockType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 17:
		localctx = NewAlterByModifyColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2763)
			p.Match(MySqlParserMODIFY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2764)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2767)
			p.Uid()
		}
		{
			p.SetState(2768)
			p.ColumnDefinition()
		}
		p.SetState(2772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2769)
				p.Match(MySqlParserFIRST)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserAFTER:
			{
				p.SetState(2770)
				p.Match(MySqlParserAFTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2771)
				p.Uid()
			}


		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:



		default:
		}


	case 18:
		localctx = NewAlterByDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2774)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2775)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2778)
			p.Uid()
		}
		p.SetState(2780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserRESTRICT {
			{
				p.SetState(2779)
				p.Match(MySqlParserRESTRICT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 19:
		localctx = NewAlterByDropConstraintCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2782)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2783)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHECK || _la == MySqlParserCONSTRAINT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2784)
			p.Uid()
		}


	case 20:
		localctx = NewAlterByDropPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2785)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2786)
			p.Match(MySqlParserPRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2787)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 21:
		localctx = NewAlterByDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2788)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2789)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByDropIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByDropIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2790)
			p.Uid()
		}


	case 22:
		localctx = NewAlterByRenameIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2791)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2792)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByRenameIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByRenameIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2793)
			p.Uid()
		}
		{
			p.SetState(2794)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2795)
			p.Uid()
		}


	case 23:
		localctx = NewAlterByAlterColumnDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2797)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2798)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2801)
			p.Uid()
		}
		p.SetState(2815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2802)
				p.Match(MySqlParserSET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2803)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2809)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSTART_NATIONAL_STRING_LITERAL, MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
				{
					p.SetState(2804)
					p.StringLiteral()
				}


			case MySqlParserLR_BRACKET:
				{
					p.SetState(2805)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2806)
					p.expression(0)
				}
				{
					p.SetState(2807)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}


		case 2:
			{
				p.SetState(2811)
				p.Match(MySqlParserSET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2812)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


		case 3:
			{
				p.SetState(2813)
				p.Match(MySqlParserDROP)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2814)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


	case 24:
		localctx = NewAlterByAlterIndexVisibilityContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2817)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2818)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2819)
			p.Uid()
		}
		{
			p.SetState(2820)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 25:
		localctx = NewAlterByDropForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2822)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2823)
			p.Match(MySqlParserFOREIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2824)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2825)
			p.Uid()
		}


	case 26:
		localctx = NewAlterByDisableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2826)
			p.Match(MySqlParserDISABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2827)
			p.Match(MySqlParserKEYS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 27:
		localctx = NewAlterByEnableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2828)
			p.Match(MySqlParserENABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2829)
			p.Match(MySqlParserKEYS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 28:
		localctx = NewAlterByRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2830)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS || _la == MySqlParserTO {
			{
				p.SetState(2831)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByRenameContext).renameFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserAS || _la == MySqlParserTO) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByRenameContext).renameFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2834)
				p.Uid()
			}


		case 2:
			{
				p.SetState(2835)
				p.FullId()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


	case 29:
		localctx = NewAlterByOrderContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2838)
			p.Match(MySqlParserORDER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2839)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2840)
			p.UidList()
		}


	case 30:
		localctx = NewAlterByConvertCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2841)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2842)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCHARSET:
			{
				p.SetState(2843)
				p.Match(MySqlParserCHARSET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserCHARACTER:
			{
				p.SetState(2844)
				p.Match(MySqlParserCHARACTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2845)
				p.Match(MySqlParserSET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2848)
			p.CharsetName()
		}
		p.SetState(2851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLLATE {
			{
				p.SetState(2849)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2850)
				p.CollationName()
			}

		}


	case 31:
		localctx = NewAlterByDefaultCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		p.SetState(2854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(2853)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2856)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2857)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2858)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2859)
			p.CharsetName()
		}
		p.SetState(2863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLLATE {
			{
				p.SetState(2860)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2861)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2862)
				p.CollationName()
			}

		}


	case 32:
		localctx = NewAlterByDiscardTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2865)
			p.Match(MySqlParserDISCARD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2866)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 33:
		localctx = NewAlterByImportTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2867)
			p.Match(MySqlParserIMPORT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2868)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 34:
		localctx = NewAlterByForceContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2869)
			p.Match(MySqlParserFORCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 35:
		localctx = NewAlterByValidateContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2870)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByValidateContext).validationFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserWITH || _la == MySqlParserWITHOUT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByValidateContext).validationFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2871)
			p.Match(MySqlParserVALIDATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 36:
		localctx = NewAlterByAddDefinitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2872)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2873)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2876)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2877)
			p.CreateDefinition()
		}
		p.SetState(2882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2878)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2879)
				p.CreateDefinition()
			}


			p.SetState(2884)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2885)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 37:
		localctx = NewAlterPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2887)
			p.AlterPartitionSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterPartitionSpecificationContext is an interface to support dynamic dispatch.
type IAlterPartitionSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterPartitionSpecificationContext differentiates from other interfaces.
	IsAlterPartitionSpecificationContext()
}

type AlterPartitionSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPartitionSpecificationContext() *AlterPartitionSpecificationContext {
	var p = new(AlterPartitionSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterPartitionSpecification
	return p
}

func InitEmptyAlterPartitionSpecificationContext(p *AlterPartitionSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterPartitionSpecification
}

func (*AlterPartitionSpecificationContext) IsAlterPartitionSpecificationContext() {}

func NewAlterPartitionSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPartitionSpecificationContext {
	var p = new(AlterPartitionSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterPartitionSpecification

	return p
}

func (s *AlterPartitionSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPartitionSpecificationContext) CopyAll(ctx *AlterPartitionSpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterPartitionSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPartitionSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type AlterByImportPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByImportPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportPartitionContext {
	var p = new(AlterByImportPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByImportPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportPartitionContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *AlterByImportPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByImportPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByImportPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByImportPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByImportPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByImportPartition(s)
	}
}

func (s *AlterByImportPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByImportPartition(s)
	}
}

func (s *AlterByImportPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByImportPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDropPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByDropPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPartitionContext {
	var p = new(AlterByDropPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByDropPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPartitionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByDropPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}


func (s *AlterByDropPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropPartition(s)
	}
}

func (s *AlterByDropPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropPartition(s)
	}
}

func (s *AlterByDropPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByDiscardPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByDiscardPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardPartitionContext {
	var p = new(AlterByDiscardPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByDiscardPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardPartitionContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *AlterByDiscardPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByDiscardPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByDiscardPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByDiscardPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByDiscardPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDiscardPartition(s)
	}
}

func (s *AlterByDiscardPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDiscardPartition(s)
	}
}

func (s *AlterByDiscardPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDiscardPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAddPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByAddPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPartitionContext {
	var p = new(AlterByAddPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByAddPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPartitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByAddPartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByAddPartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddPartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *AlterByAddPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddPartition(s)
	}
}

func (s *AlterByAddPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddPartition(s)
	}
}

func (s *AlterByAddPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByRemovePartitioningContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByRemovePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRemovePartitioningContext {
	var p = new(AlterByRemovePartitioningContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByRemovePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRemovePartitioningContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREMOVE, 0)
}

func (s *AlterByRemovePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}


func (s *AlterByRemovePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRemovePartitioning(s)
	}
}

func (s *AlterByRemovePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRemovePartitioning(s)
	}
}

func (s *AlterByRemovePartitioningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRemovePartitioning(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByOptimizePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByOptimizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOptimizePartitionContext {
	var p = new(AlterByOptimizePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByOptimizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOptimizePartitionContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZE, 0)
}

func (s *AlterByOptimizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByOptimizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByOptimizePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByOptimizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByOptimizePartition(s)
	}
}

func (s *AlterByOptimizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByOptimizePartition(s)
	}
}

func (s *AlterByOptimizePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByOptimizePartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByCheckPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByCheckPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCheckPartitionContext {
	var p = new(AlterByCheckPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByCheckPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCheckPartitionContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByCheckPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByCheckPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByCheckPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByCheckPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByCheckPartition(s)
	}
}

func (s *AlterByCheckPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByCheckPartition(s)
	}
}

func (s *AlterByCheckPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByCheckPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByCoalescePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByCoalescePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCoalescePartitionContext {
	var p = new(AlterByCoalescePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByCoalescePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCoalescePartitionContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOALESCE, 0)
}

func (s *AlterByCoalescePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByCoalescePartitionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *AlterByCoalescePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByCoalescePartition(s)
	}
}

func (s *AlterByCoalescePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByCoalescePartition(s)
	}
}

func (s *AlterByCoalescePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByCoalescePartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByReorganizePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByReorganizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByReorganizePartitionContext {
	var p = new(AlterByReorganizePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByReorganizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByReorganizePartitionContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREORGANIZE, 0)
}

func (s *AlterByReorganizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByReorganizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByReorganizePartitionContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *AlterByReorganizePartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByReorganizePartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByReorganizePartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByReorganizePartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *AlterByReorganizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByReorganizePartition(s)
	}
}

func (s *AlterByReorganizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByReorganizePartition(s)
	}
}

func (s *AlterByReorganizePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByReorganizePartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByAnalyzePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByAnalyzePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAnalyzePartitionContext {
	var p = new(AlterByAnalyzePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByAnalyzePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAnalyzePartitionContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserANALYZE, 0)
}

func (s *AlterByAnalyzePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByAnalyzePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByAnalyzePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByAnalyzePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAnalyzePartition(s)
	}
}

func (s *AlterByAnalyzePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAnalyzePartition(s)
	}
}

func (s *AlterByAnalyzePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAnalyzePartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByRebuildPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByRebuildPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRebuildPartitionContext {
	var p = new(AlterByRebuildPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByRebuildPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRebuildPartitionContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MySqlParserREBUILD, 0)
}

func (s *AlterByRebuildPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByRebuildPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRebuildPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByRebuildPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRebuildPartition(s)
	}
}

func (s *AlterByRebuildPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRebuildPartition(s)
	}
}

func (s *AlterByRebuildPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRebuildPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByUpgradePartitioningContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByUpgradePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByUpgradePartitioningContext {
	var p = new(AlterByUpgradePartitioningContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByUpgradePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByUpgradePartitioningContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *AlterByUpgradePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}


func (s *AlterByUpgradePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByUpgradePartitioning(s)
	}
}

func (s *AlterByUpgradePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByUpgradePartitioning(s)
	}
}

func (s *AlterByUpgradePartitioningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByUpgradePartitioning(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByTruncatePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByTruncatePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTruncatePartitionContext {
	var p = new(AlterByTruncatePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByTruncatePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTruncatePartitionContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *AlterByTruncatePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByTruncatePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByTruncatePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByTruncatePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByTruncatePartition(s)
	}
}

func (s *AlterByTruncatePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByTruncatePartition(s)
	}
}

func (s *AlterByTruncatePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByTruncatePartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByRepairPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByRepairPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRepairPartitionContext {
	var p = new(AlterByRepairPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByRepairPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRepairPartitionContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *AlterByRepairPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByRepairPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRepairPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}


func (s *AlterByRepairPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRepairPartition(s)
	}
}

func (s *AlterByRepairPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRepairPartition(s)
	}
}

func (s *AlterByRepairPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRepairPartition(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterByExchangePartitionContext struct {
	AlterPartitionSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByExchangePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByExchangePartitionContext {
	var p = new(AlterByExchangePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}


func (s *AlterByExchangePartitionContext) GetValidationFormat() antlr.Token { return s.validationFormat }


func (s *AlterByExchangePartitionContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByExchangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByExchangePartitionContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCHANGE, 0)
}

func (s *AlterByExchangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByExchangePartitionContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByExchangePartitionContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWITH)
}

func (s *AlterByExchangePartitionContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, i)
}

func (s *AlterByExchangePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AlterByExchangePartitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterByExchangePartitionContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *AlterByExchangePartitionContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}


func (s *AlterByExchangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByExchangePartition(s)
	}
}

func (s *AlterByExchangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByExchangePartition(s)
	}
}

func (s *AlterByExchangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByExchangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) AlterPartitionSpecification() (localctx IAlterPartitionSpecificationContext) {
	localctx = NewAlterPartitionSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MySqlParserRULE_alterPartitionSpecification)
	var _la int

	p.SetState(2988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserADD:
		localctx = NewAlterByAddPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2890)
			p.Match(MySqlParserADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2891)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2892)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2893)
			p.PartitionDefinition()
		}
		p.SetState(2898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2894)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2895)
				p.PartitionDefinition()
			}


			p.SetState(2900)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2901)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDROP:
		localctx = NewAlterByDropPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2903)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2904)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2905)
			p.UidList()
		}


	case MySqlParserDISCARD:
		localctx = NewAlterByDiscardPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2906)
			p.Match(MySqlParserDISCARD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2907)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2908)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2909)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2912)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserIMPORT:
		localctx = NewAlterByImportPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2913)
			p.Match(MySqlParserIMPORT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2914)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2915)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2916)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2919)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserTRUNCATE:
		localctx = NewAlterByTruncatePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2920)
			p.Match(MySqlParserTRUNCATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2921)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2922)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2923)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserCOALESCE:
		localctx = NewAlterByCoalescePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2926)
			p.Match(MySqlParserCOALESCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2927)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2928)
			p.DecimalLiteral()
		}


	case MySqlParserREORGANIZE:
		localctx = NewAlterByReorganizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2929)
			p.Match(MySqlParserREORGANIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2930)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2931)
			p.UidList()
		}
		{
			p.SetState(2932)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2933)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2934)
			p.PartitionDefinition()
		}
		p.SetState(2939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(2935)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2936)
				p.PartitionDefinition()
			}


			p.SetState(2941)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2942)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserEXCHANGE:
		localctx = NewAlterByExchangePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2944)
			p.Match(MySqlParserEXCHANGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2945)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2946)
			p.Uid()
		}
		{
			p.SetState(2947)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2948)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2949)
			p.TableName()
		}
		p.SetState(2952)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2950)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByExchangePartitionContext).validationFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserWITH || _la == MySqlParserWITHOUT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByExchangePartitionContext).validationFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2951)
				p.Match(MySqlParserVALIDATION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserANALYZE:
		localctx = NewAlterByAnalyzePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2954)
			p.Match(MySqlParserANALYZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2955)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2956)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2957)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserCHECK:
		localctx = NewAlterByCheckPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2960)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2961)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2962)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2963)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserOPTIMIZE:
		localctx = NewAlterByOptimizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2966)
			p.Match(MySqlParserOPTIMIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2967)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2968)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2969)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserREBUILD:
		localctx = NewAlterByRebuildPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2972)
			p.Match(MySqlParserREBUILD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2973)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2974)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2975)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserREPAIR:
		localctx = NewAlterByRepairPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2978)
			p.Match(MySqlParserREPAIR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2979)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2980)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(2981)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserREMOVE:
		localctx = NewAlterByRemovePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2984)
			p.Match(MySqlParserREMOVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2985)
			p.Match(MySqlParserPARTITIONING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserUPGRADE:
		localctx = NewAlterByUpgradePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2986)
			p.Match(MySqlParserUPGRADE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2987)
			p.Match(MySqlParserPARTITIONING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token 


	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token) 


	// Getter signatures
	DROP() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropDatabase
	return p
}

func InitEmptyDropDatabaseContext(p *DropDatabaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropDatabase
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }


func (s *DropDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }


func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *DropDatabaseContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (s *DropDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropDatabase() (localctx IDropDatabaseContext) {
	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MySqlParserRULE_dropDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2990)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2991)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DropDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DropDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2993)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2992)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2995)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropEventContext is an interface to support dynamic dispatch.
type IDropEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropEventContext differentiates from other interfaces.
	IsDropEventContext()
}

type DropEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropEventContext() *DropEventContext {
	var p = new(DropEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropEvent
	return p
}

func InitEmptyDropEventContext(p *DropEventContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropEvent
}

func (*DropEventContext) IsDropEventContext() {}

func NewDropEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropEventContext {
	var p = new(DropEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropEvent

	return p
}

func (s *DropEventContext) GetParser() antlr.Parser { return s.parser }

func (s *DropEventContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *DropEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropEventContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropEvent(s)
	}
}

func (s *DropEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropEvent(s)
	}
}

func (s *DropEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropEvent(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropEvent() (localctx IDropEventContext) {
	localctx = NewDropEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MySqlParserRULE_dropEvent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2997)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2998)
		p.Match(MySqlParserEVENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3000)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2999)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3002)
		p.FullId()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token 

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token 

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token 


	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token) 

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token) 

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token) 


	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	intimeAction antlr.Token
	algType antlr.Token
	lockType antlr.Token
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropIndex
	return p
}

func InitEmptyDropIndexContext(p *DropIndexContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropIndex
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *DropIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *DropIndexContext) GetLockType() antlr.Token { return s.lockType }


func (s *DropIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *DropIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *DropIndexContext) SetLockType(v antlr.Token) { s.lockType = v }


func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *DropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DropIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DropIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserALGORITHM)
}

func (s *DropIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, i)
}

func (s *DropIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCK)
}

func (s *DropIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, i)
}

func (s *DropIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *DropIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *DropIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *DropIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *DropIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserINPLACE)
}

func (s *DropIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, i)
}

func (s *DropIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOPY)
}

func (s *DropIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, i)
}

func (s *DropIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNONE)
}

func (s *DropIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, i)
}

func (s *DropIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSHARED)
}

func (s *DropIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, i)
}

func (s *DropIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEXCLUSIVE)
}

func (s *DropIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, i)
}

func (s *DropIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *DropIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (s *DropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropIndex() (localctx IDropIndexContext) {
	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MySqlParserRULE_dropIndex)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3004)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3005)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3007)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3006)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3009)
		p.Uid()
	}
	{
		p.SetState(3010)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3011)
		p.TableName()
	}
	p.SetState(3024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3022)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALGORITHM:
				{
					p.SetState(3012)
					p.Match(MySqlParserALGORITHM)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(3014)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(3013)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(3016)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			case MySqlParserLOCK:
				{
					p.SetState(3017)
					p.Match(MySqlParserLOCK)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(3019)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(3018)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(3021)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(3026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropLogfileGroupContext is an interface to support dynamic dispatch.
type IDropLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EngineName() IEngineNameContext

	// IsDropLogfileGroupContext differentiates from other interfaces.
	IsDropLogfileGroupContext()
}

type DropLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropLogfileGroupContext() *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup
	return p
}

func InitEmptyDropLogfileGroupContext(p *DropLogfileGroupContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup
}

func (*DropLogfileGroupContext) IsDropLogfileGroupContext() {}

func NewDropLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup

	return p
}

func (s *DropLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DropLogfileGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *DropLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *DropLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *DropLogfileGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DropLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropLogfileGroup() (localctx IDropLogfileGroupContext) {
	localctx = NewDropLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MySqlParserRULE_dropLogfileGroup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3028)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3029)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3030)
		p.Uid()
	}
	{
		p.SetState(3031)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3032)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3033)
		p.EngineName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropProcedureContext is an interface to support dynamic dispatch.
type IDropProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropProcedureContext differentiates from other interfaces.
	IsDropProcedureContext()
}

type DropProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropProcedureContext() *DropProcedureContext {
	var p = new(DropProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropProcedure
	return p
}

func InitEmptyDropProcedureContext(p *DropProcedureContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropProcedure
}

func (*DropProcedureContext) IsDropProcedureContext() {}

func NewDropProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropProcedureContext {
	var p = new(DropProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropProcedure

	return p
}

func (s *DropProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *DropProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropProcedureContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (s *DropProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropProcedure() (localctx IDropProcedureContext) {
	localctx = NewDropProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MySqlParserRULE_dropProcedure)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3035)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3036)
		p.Match(MySqlParserPROCEDURE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3038)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3037)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3040)
		p.FullId()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropFunction
	return p
}

func InitEmptyDropFunctionContext(p *DropFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropFunction
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *DropFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropFunctionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropFunction() (localctx IDropFunctionContext) {
	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MySqlParserRULE_dropFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3042)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3043)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3045)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3044)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3047)
		p.FullId()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropServerContext is an interface to support dynamic dispatch.
type IDropServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	IfExists() IIfExistsContext

	// IsDropServerContext differentiates from other interfaces.
	IsDropServerContext()
}

type DropServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropServerContext() *DropServerContext {
	var p = new(DropServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropServer
	return p
}

func InitEmptyDropServerContext(p *DropServerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropServer
}

func (*DropServerContext) IsDropServerContext() {}

func NewDropServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropServerContext {
	var p = new(DropServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropServer

	return p
}

func (s *DropServerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropServerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *DropServerContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropServerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropServer(s)
	}
}

func (s *DropServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropServer(s)
	}
}

func (s *DropServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropServer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropServer() (localctx IDropServerContext) {
	localctx = NewDropServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MySqlParserRULE_dropServer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3049)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3050)
		p.Match(MySqlParserSERVER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3052)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 391, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3051)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3054)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token 


	// SetDropType sets the dropType token.
	SetDropType(antlr.Token) 


	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	TEMPORARY() antlr.TerminalNode
	IfExists() IIfExistsContext
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTable
	return p
}

func InitEmptyDropTableContext(p *DropTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTable
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) GetDropType() antlr.Token { return s.dropType }


func (s *DropTableContext) SetDropType(v antlr.Token) { s.dropType = v }


func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *DropTableContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DropTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *DropTableContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *DropTableContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropTable() (localctx IDropTableContext) {
	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, MySqlParserRULE_dropTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3056)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserTEMPORARY {
		{
			p.SetState(3057)
			p.Match(MySqlParserTEMPORARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3060)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3062)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3061)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3064)
		p.Tables()
	}
	p.SetState(3066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCASCADE || _la == MySqlParserRESTRICT {
		{
			p.SetState(3065)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropTableContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCASCADE || _la == MySqlParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropTableContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropTablespaceContext is an interface to support dynamic dispatch.
type IDropTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	EQUAL_SYMBOL() antlr.TerminalNode

	// IsDropTablespaceContext differentiates from other interfaces.
	IsDropTablespaceContext()
}

type DropTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTablespaceContext() *DropTablespaceContext {
	var p = new(DropTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTablespace
	return p
}

func InitEmptyDropTablespaceContext(p *DropTablespaceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTablespace
}

func (*DropTablespaceContext) IsDropTablespaceContext() {}

func NewDropTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTablespaceContext {
	var p = new(DropTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTablespace

	return p
}

func (s *DropTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *DropTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *DropTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DropTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTablespace(s)
	}
}

func (s *DropTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTablespace(s)
	}
}

func (s *DropTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropTablespace() (localctx IDropTablespaceContext) {
	localctx = NewDropTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MySqlParserRULE_dropTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3068)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3069)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3070)
		p.Uid()
	}
	p.SetState(3076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserENGINE {
		{
			p.SetState(3071)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(3072)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3075)
			p.EngineName()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTrigger
	return p
}

func InitEmptyDropTriggerContext(p *DropTriggerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTrigger
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *DropTriggerContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropTriggerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (s *DropTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropTrigger() (localctx IDropTriggerContext) {
	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MySqlParserRULE_dropTrigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3078)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3079)
		p.Match(MySqlParserTRIGGER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3081)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 397, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3080)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3083)
		p.FullId()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token 


	// SetDropType sets the dropType token.
	SetDropType(antlr.Token) 


	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropView
	return p
}

func InitEmptyDropViewContext(p *DropViewContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropView
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) GetDropType() antlr.Token { return s.dropType }


func (s *DropViewContext) SetDropType(v antlr.Token) { s.dropType = v }


func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *DropViewContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *DropViewContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropViewContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropViewContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *DropViewContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropView() (localctx IDropViewContext) {
	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MySqlParserRULE_dropView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3085)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3086)
		p.Match(MySqlParserVIEW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3087)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3090)
		p.FullId()
	}
	p.SetState(3095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(3091)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3092)
			p.FullId()
		}


		p.SetState(3097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCASCADE || _la == MySqlParserRESTRICT {
		{
			p.SetState(3098)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropViewContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCASCADE || _la == MySqlParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropViewContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropRole
	return p
}

func InitEmptyDropRoleContext(p *DropRoleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropRole
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *DropRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *DropRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *DropRoleContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropRole() (localctx IDropRoleContext) {
	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, MySqlParserRULE_dropRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3101)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3102)
		p.Match(MySqlParserROLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3104)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3103)
			p.IfExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3106)
		p.RoleName()
	}
	p.SetState(3111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(3107)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3108)
			p.RoleName()
		}


		p.SetState(3113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetRoleContext is an interface to support dynamic dispatch.
type ISetRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RoleOption() IRoleOptionContext

	// IsSetRoleContext differentiates from other interfaces.
	IsSetRoleContext()
}

type SetRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleContext() *SetRoleContext {
	var p = new(SetRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setRole
	return p
}

func InitEmptySetRoleContext(p *SetRoleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setRole
}

func (*SetRoleContext) IsSetRoleContext() {}

func NewSetRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleContext {
	var p = new(SetRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setRole

	return p
}

func (s *SetRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetRoleContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *SetRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *SetRoleContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *SetRoleContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SetRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *SetRoleContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetRoleContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SetRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetRoleContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SetRole() (localctx ISetRoleContext) {
	localctx = NewSetRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MySqlParserRULE_setRole)
	var _la int

	p.SetState(3147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 408, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3114)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3115)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.Match(MySqlParserROLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 404, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3117)
				p.Match(MySqlParserNONE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			{
				p.SetState(3118)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 3:
			{
				p.SetState(3119)
				p.RoleName()
			}
			p.SetState(3124)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(3120)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3121)
					p.RoleName()
				}


				p.SetState(3126)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3129)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3130)
				p.UserName()
			}


		case 2:
			{
				p.SetState(3131)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3134)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3135)
					p.UserName()
				}


			case 2:
				{
					p.SetState(3136)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


			p.SetState(3143)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3144)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3145)
			p.Match(MySqlParserROLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3146)
			p.RoleOption()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRenameTableContext is an interface to support dynamic dispatch.
type IRenameTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllRenameTableClause() []IRenameTableClauseContext
	RenameTableClause(i int) IRenameTableClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameTableContext differentiates from other interfaces.
	IsRenameTableContext()
}

type RenameTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableContext() *RenameTableContext {
	var p = new(RenameTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTable
	return p
}

func InitEmptyRenameTableContext(p *RenameTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTable
}

func (*RenameTableContext) IsRenameTableContext() {}

func NewRenameTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableContext {
	var p = new(RenameTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameTable

	return p
}

func (s *RenameTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *RenameTableContext) AllRenameTableClause() []IRenameTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameTableClauseContext); ok {
			tst[i] = t.(IRenameTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableContext) RenameTableClause(i int) IRenameTableClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableClauseContext)
}

func (s *RenameTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RenameTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

func (s *RenameTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RenameTable() (localctx IRenameTableContext) {
	localctx = NewRenameTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MySqlParserRULE_renameTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3149)
		p.Match(MySqlParserRENAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3150)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3151)
		p.RenameTableClause()
	}
	p.SetState(3156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(3152)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3153)
			p.RenameTableClause()
		}


		p.SetState(3158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRenameTableClauseContext is an interface to support dynamic dispatch.
type IRenameTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	TO() antlr.TerminalNode

	// IsRenameTableClauseContext differentiates from other interfaces.
	IsRenameTableClauseContext()
}

type RenameTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableClauseContext() *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTableClause
	return p
}

func InitEmptyRenameTableClauseContext(p *RenameTableClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTableClause
}

func (*RenameTableClauseContext) IsRenameTableClauseContext() {}

func NewRenameTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameTableClause

	return p
}

func (s *RenameTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableClauseContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableClauseContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *RenameTableClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RenameTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RenameTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameTableClause(s)
	}
}

func (s *RenameTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameTableClause(s)
	}
}

func (s *RenameTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RenameTableClause() (localctx IRenameTableClauseContext) {
	localctx = NewRenameTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MySqlParserRULE_renameTableClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3159)
		p.TableName()
	}
	{
		p.SetState(3160)
		p.Match(MySqlParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3161)
		p.TableName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITruncateTableContext is an interface to support dynamic dispatch.
type ITruncateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TableName() ITableNameContext
	TABLE() antlr.TerminalNode

	// IsTruncateTableContext differentiates from other interfaces.
	IsTruncateTableContext()
}

type TruncateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableContext() *TruncateTableContext {
	var p = new(TruncateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_truncateTable
	return p
}

func InitEmptyTruncateTableContext(p *TruncateTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_truncateTable
}

func (*TruncateTableContext) IsTruncateTableContext() {}

func NewTruncateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableContext {
	var p = new(TruncateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_truncateTable

	return p
}

func (s *TruncateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (s *TruncateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTruncateTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TruncateTable() (localctx ITruncateTableContext) {
	localctx = NewTruncateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MySqlParserRULE_truncateTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3163)
		p.Match(MySqlParserTRUNCATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserTABLE {
		{
			p.SetState(3164)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3167)
		p.TableName()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	Expressions() IExpressionsContext

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_callStatement
	return p
}

func InitEmptyCallStatementContext(p *CallStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_callStatement
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCALL, 0)
}

func (s *CallStatementContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CallStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CallStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CallStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *CallStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (s *CallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CallStatement() (localctx ICallStatementContext) {
	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MySqlParserRULE_callStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3169)
		p.Match(MySqlParserCALL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3170)
		p.FullId()
	}
	p.SetState(3177)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 412, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3171)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3174)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3172)
				p.Constants()
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3173)
				p.Expressions()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3176)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleDeleteStatement() ISingleDeleteStatementContext
	MultipleDeleteStatement() IMultipleDeleteStatementContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) SingleDeleteStatement() ISingleDeleteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleDeleteStatementContext)
}

func (s *DeleteStatementContext) MultipleDeleteStatement() IMultipleDeleteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleDeleteStatementContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MySqlParserRULE_deleteStatement)
	p.SetState(3181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3179)
			p.SingleDeleteStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3180)
			p.MultipleDeleteStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Expressions() IExpressionsContext

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_doStatement
	return p
}

func InitEmptyDoStatementContext(p *DoStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_doStatement
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *DoStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DoStatement() (localctx IDoStatementContext) {
	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MySqlParserRULE_doStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3183)
		p.Match(MySqlParserDO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3184)
		p.Expressions()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHandlerStatementContext is an interface to support dynamic dispatch.
type IHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HandlerOpenStatement() IHandlerOpenStatementContext
	HandlerReadIndexStatement() IHandlerReadIndexStatementContext
	HandlerReadStatement() IHandlerReadStatementContext
	HandlerCloseStatement() IHandlerCloseStatementContext

	// IsHandlerStatementContext differentiates from other interfaces.
	IsHandlerStatementContext()
}

type HandlerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerStatementContext() *HandlerStatementContext {
	var p = new(HandlerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerStatement
	return p
}

func InitEmptyHandlerStatementContext(p *HandlerStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerStatement
}

func (*HandlerStatementContext) IsHandlerStatementContext() {}

func NewHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerStatementContext {
	var p = new(HandlerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerStatement

	return p
}

func (s *HandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerStatementContext) HandlerOpenStatement() IHandlerOpenStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerOpenStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerOpenStatementContext)
}

func (s *HandlerStatementContext) HandlerReadIndexStatement() IHandlerReadIndexStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadIndexStatementContext)
}

func (s *HandlerStatementContext) HandlerReadStatement() IHandlerReadStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadStatementContext)
}

func (s *HandlerStatementContext) HandlerCloseStatement() IHandlerCloseStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerCloseStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerCloseStatementContext)
}

func (s *HandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HandlerStatement() (localctx IHandlerStatementContext) {
	localctx = NewHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MySqlParserRULE_handlerStatement)
	p.SetState(3190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3186)
			p.HandlerOpenStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3187)
			p.HandlerReadIndexStatement()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3188)
			p.HandlerReadStatement()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3189)
			p.HandlerCloseStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 


	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IFullColumnNameListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext

	// GetDuplicatedFirst returns the duplicatedFirst rule contexts.
	GetDuplicatedFirst() IUpdatedElementContext


	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IFullColumnNameListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)

	// SetDuplicatedFirst sets the duplicatedFirst rule contexts.
	SetDuplicatedFirst(IUpdatedElementContext)


	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext

	// GetDuplicatedElements returns the duplicatedElements rule context list.
	GetDuplicatedElements() []IUpdatedElementContext


	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext) 

	// SetDuplicatedElements sets the duplicatedElements rule context list.
	SetDuplicatedElements([]IUpdatedElementContext) 


	// Getter signatures
	INSERT() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	IGNORE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	ON() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	UidList() IUidListContext
	AS() antlr.TerminalNode
	FullColumnNameList() IFullColumnNameListContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
	partitions IUidListContext 
	columns IFullColumnNameListContext 
	setFirst IUpdatedElementContext 
	_updatedElement IUpdatedElementContext 
	setElements []IUpdatedElementContext
	duplicatedFirst IUpdatedElementContext 
	duplicatedElements []IUpdatedElementContext
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) GetPriority() antlr.Token { return s.priority }


func (s *InsertStatementContext) SetPriority(v antlr.Token) { s.priority = v }


func (s *InsertStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *InsertStatementContext) GetColumns() IFullColumnNameListContext { return s.columns }

func (s *InsertStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *InsertStatementContext) Get_updatedElement() IUpdatedElementContext { return s._updatedElement }

func (s *InsertStatementContext) GetDuplicatedFirst() IUpdatedElementContext { return s.duplicatedFirst }


func (s *InsertStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *InsertStatementContext) SetColumns(v IFullColumnNameListContext) { s.columns = v }

func (s *InsertStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *InsertStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }

func (s *InsertStatementContext) SetDuplicatedFirst(v IUpdatedElementContext) { s.duplicatedFirst = v }


func (s *InsertStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }

func (s *InsertStatementContext) GetDuplicatedElements() []IUpdatedElementContext { return s.duplicatedElements }


func (s *InsertStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }

func (s *InsertStatementContext) SetDuplicatedElements(v []IUpdatedElementContext) { s.duplicatedElements = v }


func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *InsertStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *InsertStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *InsertStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *InsertStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *InsertStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *InsertStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *InsertStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *InsertStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *InsertStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *InsertStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *InsertStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *InsertStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *InsertStatementContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUPLICATE, 0)
}

func (s *InsertStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *InsertStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *InsertStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *InsertStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAYED, 0)
}

func (s *InsertStatementContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *InsertStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *InsertStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *InsertStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *InsertStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *InsertStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *InsertStatementContext) FullColumnNameList() IFullColumnNameListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameListContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MySqlParserRULE_insertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3192)
		p.Match(MySqlParserINSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(3193)
			p.ProxyHint()
		}

	}
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64((_la - 43)) & ^0x3f) == 0 && ((int64(1) << (_la - 43)) & -9223372032559808511) != 0) {
		{
			p.SetState(3196)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 43)) & ^0x3f) == 0 && ((int64(1) << (_la - 43)) & -9223372032559808511) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(3199)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserINTO {
		{
			p.SetState(3202)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3205)
		p.TableName()
	}
	p.SetState(3212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(3206)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3207)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(3208)

				var _x = p.UidList()


				localctx.(*InsertStatementContext).partitions = _x
			}

		}
		{
			p.SetState(3211)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserVALUES, MySqlParserVALUE, MySqlParserLR_BRACKET:
		p.SetState(3219)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3214)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3216)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3215)

					var _x = p.FullColumnNameList()


					localctx.(*InsertStatementContext).columns = _x
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			{
				p.SetState(3218)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3221)
			p.InsertStatementValue()
		}
		p.SetState(3226)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) == 1 {
			p.SetState(3223)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserAS {
				{
					p.SetState(3222)
					p.Match(MySqlParserAS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(3225)
				p.Uid()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserSET:
		{
			p.SetState(3228)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3229)

			var _x = p.UpdatedElement()


			localctx.(*InsertStatementContext).setFirst = _x
		}
		p.SetState(3234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3230)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3231)

				var _x = p.UpdatedElement()


				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).setElements = append(localctx.(*InsertStatementContext).setElements, localctx.(*InsertStatementContext)._updatedElement)


			p.SetState(3236)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserON {
		{
			p.SetState(3239)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3240)
			p.Match(MySqlParserDUPLICATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3241)
			p.Match(MySqlParserKEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3242)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3243)

			var _x = p.UpdatedElement()


			localctx.(*InsertStatementContext).duplicatedFirst = _x
		}
		p.SetState(3248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3244)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3245)

				var _x = p.UpdatedElement()


				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).duplicatedElements = append(localctx.(*InsertStatementContext).duplicatedElements, localctx.(*InsertStatementContext)._updatedElement)


			p.SetState(3250)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILoadDataStatementContext is an interface to support dynamic dispatch.
type ILoadDataStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 

	// GetFilename returns the filename token.
	GetFilename() antlr.Token 

	// GetViolation returns the violation token.
	GetViolation() antlr.Token 

	// GetFieldsFormat returns the fieldsFormat token.
	GetFieldsFormat() antlr.Token 

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 

	// SetFilename sets the filename token.
	SetFilename(antlr.Token) 

	// SetViolation sets the violation token.
	SetViolation(antlr.Token) 

	// SetFieldsFormat sets the fieldsFormat token.
	SetFieldsFormat(antlr.Token) 

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token) 


	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext


	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)


	// Getter signatures
	LOAD() antlr.TerminalNode
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	STRING_LITERAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	UidList() IUidListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllLINES() []antlr.TerminalNode
	LINES(i int) antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	AllSelectFieldsInto() []ISelectFieldsIntoContext
	SelectFieldsInto(i int) ISelectFieldsIntoContext
	AllSelectLinesInto() []ISelectLinesIntoContext
	SelectLinesInto(i int) ISelectLinesIntoContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadDataStatementContext differentiates from other interfaces.
	IsLoadDataStatementContext()
}

type LoadDataStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
	filename antlr.Token
	violation antlr.Token
	charset ICharsetNameContext 
	fieldsFormat antlr.Token
	linesFormat antlr.Token
}

func NewEmptyLoadDataStatementContext() *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadDataStatement
	return p
}

func InitEmptyLoadDataStatementContext(p *LoadDataStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadDataStatement
}

func (*LoadDataStatementContext) IsLoadDataStatementContext() {}

func NewLoadDataStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadDataStatement

	return p
}

func (s *LoadDataStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadDataStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadDataStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadDataStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadDataStatementContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *LoadDataStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }


func (s *LoadDataStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadDataStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadDataStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadDataStatementContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *LoadDataStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }


func (s *LoadDataStatementContext) GetCharset() ICharsetNameContext { return s.charset }


func (s *LoadDataStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }


func (s *LoadDataStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadDataStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *LoadDataStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINFILE, 0)
}

func (s *LoadDataStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadDataStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LoadDataStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadDataStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *LoadDataStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LoadDataStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *LoadDataStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *LoadDataStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *LoadDataStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadDataStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *LoadDataStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *LoadDataStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *LoadDataStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSET)
}

func (s *LoadDataStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, i)
}

func (s *LoadDataStatementContext) AllLINES() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLINES)
}

func (s *LoadDataStatementContext) LINES(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, i)
}

func (s *LoadDataStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIGNORE)
}

func (s *LoadDataStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, i)
}

func (s *LoadDataStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadDataStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadDataStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadDataStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadDataStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LoadDataStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *LoadDataStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *LoadDataStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *LoadDataStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *LoadDataStatementContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *LoadDataStatementContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *LoadDataStatementContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *LoadDataStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadDataStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadDataStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadDataStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LoadDataStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadDataStatement(s)
	}
}

func (s *LoadDataStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadDataStatement(s)
	}
}

func (s *LoadDataStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadDataStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LoadDataStatement() (localctx ILoadDataStatementContext) {
	localctx = NewLoadDataStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MySqlParserRULE_loadDataStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3253)
		p.Match(MySqlParserLOAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3254)
		p.Match(MySqlParserDATA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT {
		{
			p.SetState(3255)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOCAL {
		{
			p.SetState(3258)
			p.Match(MySqlParserLOCAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3261)
		p.Match(MySqlParserINFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3262)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*LoadDataStatementContext).filename = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
		{
			p.SetState(3263)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3266)
		p.Match(MySqlParserINTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3267)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3268)
		p.TableName()
	}
	p.SetState(3274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(3269)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3270)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3271)
			p.UidList()
		}
		{
			p.SetState(3272)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCHARACTER {
		{
			p.SetState(3276)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3277)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3278)

			var _x = p.CharsetName()


			localctx.(*LoadDataStatementContext).charset = _x
		}

	}
	p.SetState(3287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS {
		{
			p.SetState(3281)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).fieldsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).fieldsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MySqlParserENCLOSED || _la == MySqlParserESCAPED || _la == MySqlParserOPTIONALLY || _la == MySqlParserTERMINATED {
			{
				p.SetState(3282)
				p.SelectFieldsInto()
			}


			p.SetState(3285)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLINES {
		{
			p.SetState(3289)
			p.Match(MySqlParserLINES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MySqlParserSTARTING || _la == MySqlParserTERMINATED {
			{
				p.SetState(3290)
				p.SelectLinesInto()
			}


			p.SetState(3293)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(3297)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3298)
			p.DecimalLiteral()
		}
		{
			p.SetState(3299)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLINES || _la == MySqlParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3314)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3303)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3304)
			p.AssignmentField()
		}
		p.SetState(3309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3305)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3306)
				p.AssignmentField()
			}


			p.SetState(3311)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3312)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(3325)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 442, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3316)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3317)
			p.UpdatedElement()
		}
		p.SetState(3322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3318)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3319)
				p.UpdatedElement()
			}


			p.SetState(3324)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILoadXmlStatementContext is an interface to support dynamic dispatch.
type ILoadXmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 

	// GetFilename returns the filename token.
	GetFilename() antlr.Token 

	// GetViolation returns the violation token.
	GetViolation() antlr.Token 

	// GetTag returns the tag token.
	GetTag() antlr.Token 

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 

	// SetFilename sets the filename token.
	SetFilename(antlr.Token) 

	// SetViolation sets the violation token.
	SetViolation(antlr.Token) 

	// SetTag sets the tag token.
	SetTag(antlr.Token) 

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token) 


	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext


	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)


	// Getter signatures
	LOAD() antlr.TerminalNode
	XML() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllROWS() []antlr.TerminalNode
	ROWS(i int) antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	LR_BRACKET() antlr.TerminalNode
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	RR_BRACKET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadXmlStatementContext differentiates from other interfaces.
	IsLoadXmlStatementContext()
}

type LoadXmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
	filename antlr.Token
	violation antlr.Token
	charset ICharsetNameContext 
	tag antlr.Token
	linesFormat antlr.Token
}

func NewEmptyLoadXmlStatementContext() *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadXmlStatement
	return p
}

func InitEmptyLoadXmlStatementContext(p *LoadXmlStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadXmlStatement
}

func (*LoadXmlStatementContext) IsLoadXmlStatementContext() {}

func NewLoadXmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadXmlStatement

	return p
}

func (s *LoadXmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadXmlStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadXmlStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadXmlStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadXmlStatementContext) GetTag() antlr.Token { return s.tag }

func (s *LoadXmlStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }


func (s *LoadXmlStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadXmlStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadXmlStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadXmlStatementContext) SetTag(v antlr.Token) { s.tag = v }

func (s *LoadXmlStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }


func (s *LoadXmlStatementContext) GetCharset() ICharsetNameContext { return s.charset }


func (s *LoadXmlStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }


func (s *LoadXmlStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadXmlStatementContext) XML() antlr.TerminalNode {
	return s.GetToken(MySqlParserXML, 0)
}

func (s *LoadXmlStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINFILE, 0)
}

func (s *LoadXmlStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadXmlStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LoadXmlStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadXmlStatementContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *LoadXmlStatementContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *LoadXmlStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LoadXmlStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *LoadXmlStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSET)
}

func (s *LoadXmlStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, i)
}

func (s *LoadXmlStatementContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserROWS)
}

func (s *LoadXmlStatementContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, i)
}

func (s *LoadXmlStatementContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *LoadXmlStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *LoadXmlStatementContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIGNORE)
}

func (s *LoadXmlStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, i)
}

func (s *LoadXmlStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadXmlStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadXmlStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadXmlStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadXmlStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LoadXmlStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *LoadXmlStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *LoadXmlStatementContext) LINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, 0)
}

func (s *LoadXmlStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadXmlStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadXmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadXmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LoadXmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadXmlStatement(s)
	}
}

func (s *LoadXmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadXmlStatement(s)
	}
}

func (s *LoadXmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadXmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LoadXmlStatement() (localctx ILoadXmlStatementContext) {
	localctx = NewLoadXmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MySqlParserRULE_loadXmlStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3327)
		p.Match(MySqlParserLOAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3328)
		p.Match(MySqlParserXML)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT {
		{
			p.SetState(3329)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOCAL {
		{
			p.SetState(3332)
			p.Match(MySqlParserLOCAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3335)
		p.Match(MySqlParserINFILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3336)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*LoadXmlStatementContext).filename = _m
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
		{
			p.SetState(3337)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3340)
		p.Match(MySqlParserINTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3341)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3342)
		p.TableName()
	}
	p.SetState(3346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCHARACTER {
		{
			p.SetState(3343)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3344)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3345)

			var _x = p.CharsetName()


			localctx.(*LoadXmlStatementContext).charset = _x
		}

	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserROWS {
		{
			p.SetState(3348)
			p.Match(MySqlParserROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3349)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3350)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3351)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3352)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*LoadXmlStatementContext).tag = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3353)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(3356)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3357)
			p.DecimalLiteral()
		}
		{
			p.SetState(3358)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLINES || _la == MySqlParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3373)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 450, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3362)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3363)
			p.AssignmentField()
		}
		p.SetState(3368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3364)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3365)
				p.AssignmentField()
			}


			p.SetState(3370)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3371)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(3384)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3375)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3376)
			p.UpdatedElement()
		}
		p.SetState(3381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3377)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3378)
				p.UpdatedElement()
			}


			p.SetState(3383)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplaceStatementContext is an interface to support dynamic dispatch.
type IReplaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 


	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IUidListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext


	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IUidListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)


	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext


	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext) 


	// Getter signatures
	REPLACE() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReplaceStatementContext differentiates from other interfaces.
	IsReplaceStatementContext()
}

type ReplaceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
	partitions IUidListContext 
	columns IUidListContext 
	setFirst IUpdatedElementContext 
	_updatedElement IUpdatedElementContext 
	setElements []IUpdatedElementContext
}

func NewEmptyReplaceStatementContext() *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replaceStatement
	return p
}

func InitEmptyReplaceStatementContext(p *ReplaceStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replaceStatement
}

func (*ReplaceStatementContext) IsReplaceStatementContext() {}

func NewReplaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replaceStatement

	return p
}

func (s *ReplaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceStatementContext) GetPriority() antlr.Token { return s.priority }


func (s *ReplaceStatementContext) SetPriority(v antlr.Token) { s.priority = v }


func (s *ReplaceStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *ReplaceStatementContext) GetColumns() IUidListContext { return s.columns }

func (s *ReplaceStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *ReplaceStatementContext) Get_updatedElement() IUpdatedElementContext { return s._updatedElement }


func (s *ReplaceStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *ReplaceStatementContext) SetColumns(v IUidListContext) { s.columns = v }

func (s *ReplaceStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *ReplaceStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }


func (s *ReplaceStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }


func (s *ReplaceStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }


func (s *ReplaceStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *ReplaceStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReplaceStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *ReplaceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ReplaceStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *ReplaceStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *ReplaceStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *ReplaceStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *ReplaceStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *ReplaceStatementContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *ReplaceStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *ReplaceStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAYED, 0)
}

func (s *ReplaceStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ReplaceStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ReplaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReplaceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReplaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ReplaceStatement() (localctx IReplaceStatementContext) {
	localctx = NewReplaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MySqlParserRULE_replaceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3386)
		p.Match(MySqlParserREPLACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDELAYED || _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3387)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReplaceStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDELAYED || _la == MySqlParserLOW_PRIORITY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReplaceStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserINTO {
		{
			p.SetState(3390)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3393)
		p.TableName()
	}
	p.SetState(3399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(3394)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3395)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3396)

			var _x = p.UidList()


			localctx.(*ReplaceStatementContext).partitions = _x
		}
		{
			p.SetState(3397)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserVALUES, MySqlParserVALUE, MySqlParserLR_BRACKET:
		p.SetState(3405)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3401)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3402)

				var _x = p.UidList()


				localctx.(*ReplaceStatementContext).columns = _x
			}
			{
				p.SetState(3403)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3407)
			p.InsertStatementValue()
		}


	case MySqlParserSET:
		{
			p.SetState(3408)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3409)

			var _x = p.UpdatedElement()


			localctx.(*ReplaceStatementContext).setFirst = _x
		}
		p.SetState(3414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3410)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3411)

				var _x = p.UpdatedElement()


				localctx.(*ReplaceStatementContext)._updatedElement = _x
			}
			localctx.(*ReplaceStatementContext).setElements = append(localctx.(*ReplaceStatementContext).setElements, localctx.(*ReplaceStatementContext)._updatedElement)


			p.SetState(3416)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) CopyAll(ctx *SelectStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type UnionSelectContext struct {
	SelectStatementContext
	unionType antlr.Token
}

func NewUnionSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionSelectContext {
	var p = new(UnionSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}


func (s *UnionSelectContext) GetUnionType() antlr.Token { return s.unionType }


func (s *UnionSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionSelectContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionSelectContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionSelectContext) AllUnionStatement() []IUnionStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionStatementContext); ok {
			len++
		}
	}

	tst := make([]IUnionStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionStatementContext); ok {
			tst[i] = t.(IUnionStatementContext)
			i++
		}
	}

	return tst
}

func (s *UnionSelectContext) UnionStatement(i int) IUnionStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionStatementContext)
}

func (s *UnionSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *UnionSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}


func (s *UnionSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionSelect(s)
	}
}

func (s *UnionSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionSelect(s)
	}
}

func (s *UnionSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionSelect(s)

	default:
		return t.VisitChildren(s)
	}
}


type UnionParenthesisSelectContext struct {
	SelectStatementContext
	unionType antlr.Token
}

func NewUnionParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionParenthesisSelectContext {
	var p = new(UnionParenthesisSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}


func (s *UnionParenthesisSelectContext) GetUnionType() antlr.Token { return s.unionType }


func (s *UnionParenthesisSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisSelectContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisSelectContext) AllUnionParenthesis() []IUnionParenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			len++
		}
	}

	tst := make([]IUnionParenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionParenthesisContext); ok {
			tst[i] = t.(IUnionParenthesisContext)
			i++
		}
	}

	return tst
}

func (s *UnionParenthesisSelectContext) UnionParenthesis(i int) IUnionParenthesisContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionParenthesisContext)
}

func (s *UnionParenthesisSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionParenthesisSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionParenthesisSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionParenthesisSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionParenthesisSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}


func (s *UnionParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimpleSelectContext struct {
	SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext {
	var p = new(SimpleSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *SimpleSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}


func (s *SimpleSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleSelect(s)

	default:
		return t.VisitChildren(s)
	}
}


type ParenthesisSelectContext struct {
	SelectStatementContext
}

func NewParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisSelectContext {
	var p = new(ParenthesisSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *ParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *ParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}


func (s *ParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}


type WithLateralStatementContext struct {
	SelectStatementContext
}

func NewWithLateralStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithLateralStatementContext {
	var p = new(WithLateralStatementContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *WithLateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithLateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *WithLateralStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WithLateralStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WithLateralStatementContext) AllLateralStatement() []ILateralStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralStatementContext); ok {
			len++
		}
	}

	tst := make([]ILateralStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralStatementContext); ok {
			tst[i] = t.(ILateralStatementContext)
			i++
		}
	}

	return tst
}

func (s *WithLateralStatementContext) LateralStatement(i int) ILateralStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralStatementContext)
}


func (s *WithLateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithLateralStatement(s)
	}
}

func (s *WithLateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithLateralStatement(s)
	}
}

func (s *WithLateralStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWithLateralStatement(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MySqlParserRULE_selectStatement)
	var _la int

	var _alt int

	p.SetState(3484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 476, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3419)
			p.QuerySpecification()
		}
		p.SetState(3421)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3420)
				p.LockClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		localctx = NewParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3423)
			p.QueryExpression()
		}
		p.SetState(3425)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3424)
				p.LockClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		localctx = NewUnionSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT:
			{
				p.SetState(3427)
				p.QuerySpecificationNointo()
			}


		case MySqlParserLR_BRACKET:
			{
				p.SetState(3428)
				p.QueryExpressionNointo()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(3431)
						p.UnionStatement()
					}




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3434)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 462, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUNION {
			{
				p.SetState(3436)
				p.Match(MySqlParserUNION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3438)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
				{
					p.SetState(3437)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(3442)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSELECT:
				{
					p.SetState(3440)
					p.QuerySpecification()
				}


			case MySqlParserLR_BRACKET:
				{
					p.SetState(3441)
					p.QueryExpression()
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(3447)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3446)
				p.OrderByClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIMIT {
			{
				p.SetState(3449)
				p.LimitClause()
			}

		}
		p.SetState(3453)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3452)
				p.LockClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		localctx = NewUnionParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3455)
			p.QueryExpressionNointo()
		}
		p.SetState(3457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(3456)
						p.UnionParenthesis()
					}




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3459)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 469, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUNION {
			{
				p.SetState(3461)
				p.Match(MySqlParserUNION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3463)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
				{
					p.SetState(3462)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionParenthesisSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionParenthesisSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(3465)
				p.QueryExpression()
			}

		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3468)
				p.OrderByClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIMIT {
			{
				p.SetState(3471)
				p.LimitClause()
			}

		}
		p.SetState(3475)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 474, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3474)
				p.LockClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 5:
		localctx = NewWithLateralStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3477)
			p.QuerySpecificationNointo()
		}
		p.SetState(3480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MySqlParserCOMMA {
			{
				p.SetState(3478)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3479)
				p.LateralStatement()
			}


			p.SetState(3482)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleUpdateStatement() ISingleUpdateStatementContext
	MultipleUpdateStatement() IMultipleUpdateStatementContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) SingleUpdateStatement() ISingleUpdateStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleUpdateStatementContext)
}

func (s *UpdateStatementContext) MultipleUpdateStatement() IMultipleUpdateStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleUpdateStatementContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MySqlParserRULE_updateStatement)
	p.SetState(3488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 477, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3486)
			p.SingleUpdateStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3487)
			p.MultipleUpdateStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValuesStatementContext is an interface to support dynamic dispatch.
type IValuesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesStatementContext differentiates from other interfaces.
	IsValuesStatementContext()
}

type ValuesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesStatementContext() *ValuesStatementContext {
	var p = new(ValuesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_valuesStatement
	return p
}

func InitEmptyValuesStatementContext(p *ValuesStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_valuesStatement
}

func (*ValuesStatementContext) IsValuesStatementContext() {}

func NewValuesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesStatementContext {
	var p = new(ValuesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_valuesStatement

	return p
}

func (s *ValuesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *ValuesStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *ValuesStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *ValuesStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *ValuesStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *ValuesStatementContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *ValuesStatementContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *ValuesStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ValuesStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ValuesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValuesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValuesStatement(s)
	}
}

func (s *ValuesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValuesStatement(s)
	}
}

func (s *ValuesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitValuesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ValuesStatement() (localctx IValuesStatementContext) {
	localctx = NewValuesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MySqlParserRULE_valuesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3490)
		p.Match(MySqlParserVALUES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3491)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3493)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 478, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3492)
			p.ExpressionsWithDefaults()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3495)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(3496)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3497)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3499)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3498)
				p.ExpressionsWithDefaults()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3501)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(3506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsertStatementValueContext is an interface to support dynamic dispatch.
type IInsertStatementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInsertFormat returns the insertFormat token.
	GetInsertFormat() antlr.Token 


	// SetInsertFormat sets the insertFormat token.
	SetInsertFormat(antlr.Token) 


	// Getter signatures
	SelectStatement() ISelectStatementContext
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInsertStatementValueContext differentiates from other interfaces.
	IsInsertStatementValueContext()
}

type InsertStatementValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	insertFormat antlr.Token
}

func NewEmptyInsertStatementValueContext() *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatementValue
	return p
}

func InitEmptyInsertStatementValueContext(p *InsertStatementValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatementValue
}

func (*InsertStatementValueContext) IsInsertStatementValueContext() {}

func NewInsertStatementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_insertStatementValue

	return p
}

func (s *InsertStatementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementValueContext) GetInsertFormat() antlr.Token { return s.insertFormat }


func (s *InsertStatementValueContext) SetInsertFormat(v antlr.Token) { s.insertFormat = v }


func (s *InsertStatementValueContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InsertStatementValueContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *InsertStatementValueContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *InsertStatementValueContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *InsertStatementValueContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *InsertStatementValueContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *InsertStatementValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *InsertStatementValueContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementValueContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *InsertStatementValueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *InsertStatementValueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *InsertStatementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InsertStatementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInsertStatementValue(s)
	}
}

func (s *InsertStatementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInsertStatementValue(s)
	}
}

func (s *InsertStatementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInsertStatementValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) InsertStatementValue() (localctx IInsertStatementValueContext) {
	localctx = NewInsertStatementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MySqlParserRULE_insertStatementValue)
	var _la int

	p.SetState(3525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3507)
			p.SelectStatement()
		}


	case MySqlParserVALUES, MySqlParserVALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3508)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementValueContext).insertFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVALUES || _la == MySqlParserVALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementValueContext).insertFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3509)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3511)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3510)
				p.ExpressionsWithDefaults()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3513)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3514)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3515)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(3517)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 482, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3516)
					p.ExpressionsWithDefaults()
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			{
				p.SetState(3519)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(3524)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdatedElementContext is an interface to support dynamic dispatch.
type IUpdatedElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	EQUAL_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdatedElementContext differentiates from other interfaces.
	IsUpdatedElementContext()
}

type UpdatedElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatedElementContext() *UpdatedElementContext {
	var p = new(UpdatedElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updatedElement
	return p
}

func InitEmptyUpdatedElementContext(p *UpdatedElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updatedElement
}

func (*UpdatedElementContext) IsUpdatedElementContext() {}

func NewUpdatedElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatedElementContext {
	var p = new(UpdatedElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_updatedElement

	return p
}

func (s *UpdatedElementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatedElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *UpdatedElementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *UpdatedElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdatedElementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *UpdatedElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatedElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UpdatedElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUpdatedElement(s)
	}
}

func (s *UpdatedElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUpdatedElement(s)
	}
}

func (s *UpdatedElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUpdatedElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UpdatedElement() (localctx IUpdatedElementContext) {
	localctx = NewUpdatedElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MySqlParserRULE_updatedElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3527)
		p.FullColumnName()
	}
	{
		p.SetState(3528)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3529)
			p.expression(0)
		}


	case 2:
		{
			p.SetState(3530)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignmentFieldContext is an interface to support dynamic dispatch.
type IAssignmentFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	LOCAL_ID() antlr.TerminalNode

	// IsAssignmentFieldContext differentiates from other interfaces.
	IsAssignmentFieldContext()
}

type AssignmentFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentFieldContext() *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_assignmentField
	return p
}

func InitEmptyAssignmentFieldContext(p *AssignmentFieldContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_assignmentField
}

func (*AssignmentFieldContext) IsAssignmentFieldContext() {}

func NewAssignmentFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_assignmentField

	return p
}

func (s *AssignmentFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentFieldContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AssignmentFieldContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *AssignmentFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AssignmentFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAssignmentField(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AssignmentField() (localctx IAssignmentFieldContext) {
	localctx = NewAssignmentFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MySqlParserRULE_assignmentField)
	p.SetState(3535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3533)
			p.Uid()
		}


	case MySqlParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3534)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILockClauseContext is an interface to support dynamic dispatch.
type ILockClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	IN() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	MODE() antlr.TerminalNode

	// IsLockClauseContext differentiates from other interfaces.
	IsLockClauseContext()
}

type LockClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockClauseContext() *LockClauseContext {
	var p = new(LockClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
	return p
}

func InitEmptyLockClauseContext(p *LockClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
}

func (*LockClauseContext) IsLockClauseContext() {}

func NewLockClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockClauseContext {
	var p = new(LockClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockClause

	return p
}

func (s *LockClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *LockClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *LockClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *LockClauseContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *LockClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *LockClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LockClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockClause(s)
	}
}

func (s *LockClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockClause(s)
	}
}

func (s *LockClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LockClause() (localctx ILockClauseContext) {
	localctx = NewLockClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MySqlParserRULE_lockClause)
	p.SetState(3543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3537)
			p.Match(MySqlParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3538)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3539)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3540)
			p.Match(MySqlParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3541)
			p.Match(MySqlParserSHARE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3542)
			p.Match(MySqlParserMODE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISingleDeleteStatementContext is an interface to support dynamic dispatch.
type ISingleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 


	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TableName() ITableNameContext
	ProxyHint() IProxyHintContext
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	Uid() IUidContext
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	LOW_PRIORITY() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsSingleDeleteStatementContext differentiates from other interfaces.
	IsSingleDeleteStatementContext()
}

type SingleDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
}

func NewEmptySingleDeleteStatementContext() *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement
	return p
}

func InitEmptySingleDeleteStatementContext(p *SingleDeleteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement
}

func (*SingleDeleteStatementContext) IsSingleDeleteStatementContext() {}

func NewSingleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement

	return p
}

func (s *SingleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }


func (s *SingleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }


func (s *SingleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *SingleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *SingleDeleteStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleDeleteStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *SingleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *SingleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *SingleDeleteStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SingleDeleteStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *SingleDeleteStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SingleDeleteStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *SingleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleDeleteStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleDeleteStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *SingleDeleteStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *SingleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *SingleDeleteStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SingleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SingleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSingleDeleteStatement(s)
	}
}

func (s *SingleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSingleDeleteStatement(s)
	}
}

func (s *SingleDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSingleDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SingleDeleteStatement() (localctx ISingleDeleteStatementContext) {
	localctx = NewSingleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MySqlParserRULE_singleDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3545)
		p.Match(MySqlParserDELETE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(3546)
			p.ProxyHint()
		}

	}
	p.SetState(3550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3549)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*SingleDeleteStatementContext).priority = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserQUICK {
		{
			p.SetState(3552)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(3555)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3558)
		p.Match(MySqlParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3559)
		p.TableName()
	}
	p.SetState(3564)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) == 1 {
		p.SetState(3561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(3560)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3563)
			p.Uid()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(3571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(3566)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3567)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3568)
			p.UidList()
		}
		{
			p.SetState(3569)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWHERE {
		{
			p.SetState(3573)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3574)
			p.expression(0)
		}

	}
	p.SetState(3578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserORDER {
		{
			p.SetState(3577)
			p.OrderByClause()
		}

	}
	p.SetState(3582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLIMIT {
		{
			p.SetState(3580)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3581)
			p.LimitClauseAtom()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMultipleDeleteStatementContext is an interface to support dynamic dispatch.
type IMultipleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 


	// Getter signatures
	DELETE() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	USING() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultipleDeleteStatementContext differentiates from other interfaces.
	IsMultipleDeleteStatementContext()
}

type MultipleDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleDeleteStatementContext() *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement
	return p
}

func InitEmptyMultipleDeleteStatementContext(p *MultipleDeleteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement
}

func (*MultipleDeleteStatementContext) IsMultipleDeleteStatementContext() {}

func NewMultipleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement

	return p
}

func (s *MultipleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }


func (s *MultipleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }


func (s *MultipleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *MultipleDeleteStatementContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *MultipleDeleteStatementContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MultipleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *MultipleDeleteStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleDeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *MultipleDeleteStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *MultipleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *MultipleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *MultipleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *MultipleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *MultipleDeleteStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDOT)
}

func (s *MultipleDeleteStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, i)
}

func (s *MultipleDeleteStatementContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTAR)
}

func (s *MultipleDeleteStatementContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, i)
}

func (s *MultipleDeleteStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MultipleDeleteStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MultipleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MultipleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultipleDeleteStatement(s)
	}
}

func (s *MultipleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultipleDeleteStatement(s)
	}
}

func (s *MultipleDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMultipleDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) MultipleDeleteStatement() (localctx IMultipleDeleteStatementContext) {
	localctx = NewMultipleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MySqlParserRULE_multipleDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3584)
		p.Match(MySqlParserDELETE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(3585)
			p.ProxyHint()
		}

	}
	p.SetState(3589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3588)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*MultipleDeleteStatementContext).priority = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3592)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3591)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(3595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(3594)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		{
			p.SetState(3597)
			p.TableName()
		}
		p.SetState(3600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDOT {
			{
				p.SetState(3598)
				p.Match(MySqlParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3599)
				p.Match(MySqlParserSTAR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(3610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3602)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3603)
				p.TableName()
			}
			p.SetState(3606)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserDOT {
				{
					p.SetState(3604)
					p.Match(MySqlParserDOT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3605)
					p.Match(MySqlParserSTAR)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}


			p.SetState(3612)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3613)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3614)
			p.TableSources()
		}


	case MySqlParserFROM:
		{
			p.SetState(3616)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3617)
			p.TableName()
		}
		p.SetState(3620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDOT {
			{
				p.SetState(3618)
				p.Match(MySqlParserDOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3619)
				p.Match(MySqlParserSTAR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(3630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(3622)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3623)
				p.TableName()
			}
			p.SetState(3626)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserDOT {
				{
					p.SetState(3624)
					p.Match(MySqlParserDOT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3625)
					p.Match(MySqlParserSTAR)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}


			p.SetState(3632)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3633)
			p.Match(MySqlParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3634)
			p.TableSources()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWHERE {
		{
			p.SetState(3638)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3639)
			p.expression(0)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHandlerOpenStatementContext is an interface to support dynamic dispatch.
type IHandlerOpenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	OPEN() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsHandlerOpenStatementContext differentiates from other interfaces.
	IsHandlerOpenStatementContext()
}

type HandlerOpenStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerOpenStatementContext() *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement
	return p
}

func InitEmptyHandlerOpenStatementContext(p *HandlerOpenStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement
}

func (*HandlerOpenStatementContext) IsHandlerOpenStatementContext() {}

func NewHandlerOpenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement

	return p
}

func (s *HandlerOpenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerOpenStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerOpenStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerOpenStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *HandlerOpenStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerOpenStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *HandlerOpenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerOpenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HandlerOpenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerOpenStatement(s)
	}
}

func (s *HandlerOpenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerOpenStatement(s)
	}
}

func (s *HandlerOpenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerOpenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HandlerOpenStatement() (localctx IHandlerOpenStatementContext) {
	localctx = NewHandlerOpenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, MySqlParserRULE_handlerOpenStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3642)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3643)
		p.TableName()
	}
	{
		p.SetState(3644)
		p.Match(MySqlParserOPEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3649)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 511, p.GetParserRuleContext()) == 1 {
		p.SetState(3646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(3645)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3648)
			p.Uid()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHandlerReadIndexStatementContext is an interface to support dynamic dispatch.
type IHandlerReadIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token 


	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token) 


	// GetIndex returns the index rule contexts.
	GetIndex() IUidContext


	// SetIndex sets the index rule contexts.
	SetIndex(IUidContext)


	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	Uid() IUidContext
	ComparisonOperator() IComparisonOperatorContext
	LR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	PREV() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsHandlerReadIndexStatementContext differentiates from other interfaces.
	IsHandlerReadIndexStatementContext()
}

type HandlerReadIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	index IUidContext 
	moveOrder antlr.Token
}

func NewEmptyHandlerReadIndexStatementContext() *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement
	return p
}

func InitEmptyHandlerReadIndexStatementContext(p *HandlerReadIndexStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement
}

func (*HandlerReadIndexStatementContext) IsHandlerReadIndexStatementContext() {}

func NewHandlerReadIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement

	return p
}

func (s *HandlerReadIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadIndexStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }


func (s *HandlerReadIndexStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }


func (s *HandlerReadIndexStatementContext) GetIndex() IUidContext { return s.index }


func (s *HandlerReadIndexStatementContext) SetIndex(v IUidContext) { s.index = v }


func (s *HandlerReadIndexStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerReadIndexStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadIndexStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *HandlerReadIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerReadIndexStatementContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *HandlerReadIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *HandlerReadIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *HandlerReadIndexStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadIndexStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *HandlerReadIndexStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadIndexStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *HandlerReadIndexStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *HandlerReadIndexStatementContext) PREV() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREV, 0)
}

func (s *HandlerReadIndexStatementContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *HandlerReadIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HandlerReadIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerReadIndexStatement(s)
	}
}

func (s *HandlerReadIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerReadIndexStatement(s)
	}
}

func (s *HandlerReadIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerReadIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HandlerReadIndexStatement() (localctx IHandlerReadIndexStatementContext) {
	localctx = NewHandlerReadIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, MySqlParserRULE_handlerReadIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3651)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3652)
		p.TableName()
	}
	{
		p.SetState(3653)
		p.Match(MySqlParserREAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3654)

		var _x = p.Uid()


		localctx.(*HandlerReadIndexStatementContext).index = _x
	}
	p.SetState(3661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserEQUAL_SYMBOL, MySqlParserGREATER_SYMBOL, MySqlParserLESS_SYMBOL, MySqlParserEXCLAMATION_SYMBOL:
		{
			p.SetState(3655)
			p.ComparisonOperator()
		}
		{
			p.SetState(3656)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3657)
			p.Constants()
		}
		{
			p.SetState(3658)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserFIRST, MySqlParserLAST, MySqlParserNEXT, MySqlParserPREV:
		{
			p.SetState(3660)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*HandlerReadIndexStatementContext).moveOrder = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST || _la == MySqlParserLAST || _la == MySqlParserNEXT || _la == MySqlParserPREV) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*HandlerReadIndexStatementContext).moveOrder = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWHERE {
		{
			p.SetState(3663)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3664)
			p.expression(0)
		}

	}
	p.SetState(3669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLIMIT {
		{
			p.SetState(3667)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3668)
			p.LimitClauseAtom()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHandlerReadStatementContext is an interface to support dynamic dispatch.
type IHandlerReadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token 


	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token) 


	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext

	// IsHandlerReadStatementContext differentiates from other interfaces.
	IsHandlerReadStatementContext()
}

type HandlerReadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	moveOrder antlr.Token
}

func NewEmptyHandlerReadStatementContext() *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadStatement
	return p
}

func InitEmptyHandlerReadStatementContext(p *HandlerReadStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadStatement
}

func (*HandlerReadStatementContext) IsHandlerReadStatementContext() {}

func NewHandlerReadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerReadStatement

	return p
}

func (s *HandlerReadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }


func (s *HandlerReadStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }


func (s *HandlerReadStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerReadStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *HandlerReadStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *HandlerReadStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *HandlerReadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *HandlerReadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *HandlerReadStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HandlerReadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerReadStatement(s)
	}
}

func (s *HandlerReadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerReadStatement(s)
	}
}

func (s *HandlerReadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerReadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HandlerReadStatement() (localctx IHandlerReadStatementContext) {
	localctx = NewHandlerReadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, MySqlParserRULE_handlerReadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3671)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3672)
		p.TableName()
	}
	{
		p.SetState(3673)
		p.Match(MySqlParserREAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3674)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*HandlerReadStatementContext).moveOrder = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFIRST || _la == MySqlParserNEXT) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*HandlerReadStatementContext).moveOrder = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWHERE {
		{
			p.SetState(3675)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3676)
			p.expression(0)
		}

	}
	p.SetState(3681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLIMIT {
		{
			p.SetState(3679)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3680)
			p.LimitClauseAtom()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHandlerCloseStatementContext is an interface to support dynamic dispatch.
type IHandlerCloseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	CLOSE() antlr.TerminalNode

	// IsHandlerCloseStatementContext differentiates from other interfaces.
	IsHandlerCloseStatementContext()
}

type HandlerCloseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerCloseStatementContext() *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement
	return p
}

func InitEmptyHandlerCloseStatementContext(p *HandlerCloseStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement
}

func (*HandlerCloseStatementContext) IsHandlerCloseStatementContext() {}

func NewHandlerCloseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement

	return p
}

func (s *HandlerCloseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerCloseStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerCloseStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerCloseStatementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *HandlerCloseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerCloseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HandlerCloseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerCloseStatement(s)
	}
}

func (s *HandlerCloseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerCloseStatement(s)
	}
}

func (s *HandlerCloseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerCloseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HandlerCloseStatement() (localctx IHandlerCloseStatementContext) {
	localctx = NewHandlerCloseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, MySqlParserRULE_handlerCloseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3683)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3684)
		p.TableName()
	}
	{
		p.SetState(3685)
		p.Match(MySqlParserCLOSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISingleUpdateStatementContext is an interface to support dynamic dispatch.
type ISingleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 


	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableName() ITableNameContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	ProxyHint() IProxyHintContext
	IGNORE() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	LOW_PRIORITY() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsSingleUpdateStatementContext differentiates from other interfaces.
	IsSingleUpdateStatementContext()
}

type SingleUpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
}

func NewEmptySingleUpdateStatementContext() *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement
	return p
}

func InitEmptySingleUpdateStatementContext(p *SingleUpdateStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement
}

func (*SingleUpdateStatementContext) IsSingleUpdateStatementContext() {}

func NewSingleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement

	return p
}

func (s *SingleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }


func (s *SingleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }


func (s *SingleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *SingleUpdateStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SingleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *SingleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *SingleUpdateStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *SingleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *SingleUpdateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SingleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SingleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SingleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *SingleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleUpdateStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleUpdateStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SingleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *SingleUpdateStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SingleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SingleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSingleUpdateStatement(s)
	}
}

func (s *SingleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSingleUpdateStatement(s)
	}
}

func (s *SingleUpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSingleUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SingleUpdateStatement() (localctx ISingleUpdateStatementContext) {
	localctx = NewSingleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, MySqlParserRULE_singleUpdateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3687)
		p.Match(MySqlParserUPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(3688)
			p.ProxyHint()
		}

	}
	p.SetState(3692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3691)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*SingleUpdateStatementContext).priority = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(3694)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3697)
		p.TableName()
	}
	p.SetState(3702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513126400) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		p.SetState(3699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(3698)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3701)
			p.Uid()
		}

	}
	{
		p.SetState(3704)
		p.Match(MySqlParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3705)
		p.UpdatedElement()
	}
	p.SetState(3710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(3706)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3707)
			p.UpdatedElement()
		}


		p.SetState(3712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWHERE {
		{
			p.SetState(3713)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3714)
			p.expression(0)
		}

	}
	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserORDER {
		{
			p.SetState(3717)
			p.OrderByClause()
		}

	}
	p.SetState(3721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLIMIT {
		{
			p.SetState(3720)
			p.LimitClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMultipleUpdateStatementContext is an interface to support dynamic dispatch.
type IMultipleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token 


	// SetPriority sets the priority token.
	SetPriority(antlr.Token) 


	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableSources() ITableSourcesContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	ProxyHint() IProxyHintContext
	IGNORE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode

	// IsMultipleUpdateStatementContext differentiates from other interfaces.
	IsMultipleUpdateStatementContext()
}

type MultipleUpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleUpdateStatementContext() *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement
	return p
}

func InitEmptyMultipleUpdateStatementContext(p *MultipleUpdateStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement
}

func (*MultipleUpdateStatementContext) IsMultipleUpdateStatementContext() {}

func NewMultipleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement

	return p
}

func (s *MultipleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }


func (s *MultipleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }


func (s *MultipleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *MultipleUpdateStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *MultipleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *MultipleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *MultipleUpdateStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *MultipleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *MultipleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MultipleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MultipleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *MultipleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *MultipleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MultipleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultipleUpdateStatement(s)
	}
}

func (s *MultipleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultipleUpdateStatement(s)
	}
}

func (s *MultipleUpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMultipleUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) MultipleUpdateStatement() (localctx IMultipleUpdateStatementContext) {
	localctx = NewMultipleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, MySqlParserRULE_multipleUpdateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3723)
		p.Match(MySqlParserUPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(3724)
			p.ProxyHint()
		}

	}
	p.SetState(3728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3727)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*MultipleUpdateStatementContext).priority = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(3730)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(3733)
		p.TableSources()
	}
	{
		p.SetState(3734)
		p.Match(MySqlParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3735)
		p.UpdatedElement()
	}
	p.SetState(3740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(3736)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3737)
			p.UpdatedElement()
		}


		p.SetState(3742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWHERE {
		{
			p.SetState(3743)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3744)
			p.expression(0)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, MySqlParserRULE_orderByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3747)
		p.Match(MySqlParserORDER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3748)
		p.Match(MySqlParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3749)
		p.OrderByExpression()
	}
	p.SetState(3754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3750)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3751)
				p.OrderByExpression()
			}


		}
		p.SetState(3756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrderByExpressionContext is an interface to support dynamic dispatch.
type IOrderByExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token 


	// SetOrder sets the order token.
	SetOrder(antlr.Token) 


	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsOrderByExpressionContext differentiates from other interfaces.
	IsOrderByExpressionContext()
}

type OrderByExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	order antlr.Token
}

func NewEmptyOrderByExpressionContext() *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByExpression
	return p
}

func InitEmptyOrderByExpressionContext(p *OrderByExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByExpression
}

func (*OrderByExpressionContext) IsOrderByExpressionContext() {}

func NewOrderByExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByExpression

	return p
}

func (s *OrderByExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByExpressionContext) GetOrder() antlr.Token { return s.order }


func (s *OrderByExpressionContext) SetOrder(v antlr.Token) { s.order = v }


func (s *OrderByExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderByExpressionContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *OrderByExpressionContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *OrderByExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrderByExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrderByExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) OrderByExpression() (localctx IOrderByExpressionContext) {
	localctx = NewOrderByExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, MySqlParserRULE_orderByExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3757)
		p.expression(0)
	}
	p.SetState(3759)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3758)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderByExpressionContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderByExpressionContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableSource() []ITableSourceContext
	TableSource(i int) ITableSourceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableSourcesContext differentiates from other interfaces.
	IsTableSourcesContext()
}

type TableSourcesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext {
	var p = new(TableSourcesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
	return p
}

func InitEmptyTableSourcesContext(p *TableSourcesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
}

func (*TableSourcesContext) IsTableSourcesContext() {}

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext {
	var p = new(TableSourcesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSources

	return p
}

func (s *TableSourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableSourceContext); ok {
			len++
		}
	}

	tst := make([]ITableSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableSourceContext); ok {
			tst[i] = t.(ITableSourceContext)
			i++
		}
	}

	return tst
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableSourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSources(s)
	}
}

func (s *TableSourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSources(s)
	}
}

func (s *TableSourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSources(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TableSources() (localctx ITableSourcesContext) {
	localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, MySqlParserRULE_tableSources)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3761)
		p.TableSource()
	}
	p.SetState(3766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3762)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3763)
				p.TableSource()
			}


		}
		p.SetState(3768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
	return p
}

func InitEmptyTableSourceContext(p *TableSourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) CopyAll(ctx *TableSourceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type TableJsonContext struct {
	TableSourceContext
}

func NewTableJsonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableJsonContext {
	var p = new(TableJsonContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableJsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableJsonContext) JsonTable() IJsonTableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonTableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonTableContext)
}


func (s *TableJsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableJson(s)
	}
}

func (s *TableJsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableJson(s)
	}
}

func (s *TableJsonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableJson(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableSourceNestedContext struct {
	TableSourceContext
}

func NewTableSourceNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceNestedContext {
	var p = new(TableSourceNestedContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceNestedContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourceNestedContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceNestedContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableSourceNestedContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceNestedContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}


func (s *TableSourceNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceNested(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableSourceBaseContext struct {
	TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext {
	var p = new(TableSourceBaseContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceBaseContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceBaseContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceBaseContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}


func (s *TableSourceBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceBase(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) TableSource() (localctx ITableSourceContext) {
	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, MySqlParserRULE_tableSource)
	var _la int

	var _alt int

	p.SetState(3787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableSourceBaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3769)
			p.TableSourceItem()
		}
		p.SetState(3773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3770)
					p.JoinPart()
				}


			}
			p.SetState(3775)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 2:
		localctx = NewTableSourceNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3776)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3777)
			p.TableSourceItem()
		}
		p.SetState(3781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ((int64((_la - 34)) & ^0x3f) == 0 && ((int64(1) << (_la - 34)) & -9150751492863426559) != 0) || ((int64((_la - 113)) & ^0x3f) == 0 && ((int64(1) << (_la - 113)) & 288230410511450113) != 0) {
			{
				p.SetState(3778)
				p.JoinPart()
			}


			p.SetState(3783)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3784)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		localctx = NewTableJsonContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3786)
			p.JsonTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableSourceItemContext is an interface to support dynamic dispatch.
type ITableSourceItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceItemContext differentiates from other interfaces.
	IsTableSourceItemContext()
}

type TableSourceItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceItemContext() *TableSourceItemContext {
	var p = new(TableSourceItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSourceItem
	return p
}

func InitEmptyTableSourceItemContext(p *TableSourceItemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSourceItem
}

func (*TableSourceItemContext) IsTableSourceItemContext() {}

func NewTableSourceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceItemContext {
	var p = new(TableSourceItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSourceItem

	return p
}

func (s *TableSourceItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceItemContext) CopyAll(ctx *TableSourceItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableSourceItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SubqueryTableItemContext struct {
	TableSourceItemContext
	parenthesisSubquery ISelectStatementContext 
	alias IUidContext 
}

func NewSubqueryTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryTableItemContext {
	var p = new(SubqueryTableItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}


func (s *SubqueryTableItemContext) GetParenthesisSubquery() ISelectStatementContext { return s.parenthesisSubquery }

func (s *SubqueryTableItemContext) GetAlias() IUidContext { return s.alias }


func (s *SubqueryTableItemContext) SetParenthesisSubquery(v ISelectStatementContext) { s.parenthesisSubquery = v }

func (s *SubqueryTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *SubqueryTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubqueryTableItemContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}


func (s *SubqueryTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}


type AtomTableItemContext struct {
	TableSourceItemContext
	alias IUidContext 
}

func NewAtomTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtomTableItemContext {
	var p = new(AtomTableItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}


func (s *AtomTableItemContext) GetAlias() IUidContext { return s.alias }


func (s *AtomTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *AtomTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTableItemContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AtomTableItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AtomTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AtomTableItemContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AtomTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AtomTableItemContext) AllIndexHint() []IIndexHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexHintContext); ok {
			len++
		}
	}

	tst := make([]IIndexHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexHintContext); ok {
			tst[i] = t.(IIndexHintContext)
			i++
		}
	}

	return tst
}

func (s *AtomTableItemContext) IndexHint(i int) IIndexHintContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintContext)
}

func (s *AtomTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AtomTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AtomTableItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AtomTableItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *AtomTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAtomTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}


type TableSourcesItemContext struct {
	TableSourceItemContext
}

func NewTableSourcesItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourcesItemContext {
	var p = new(TableSourcesItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}

func (s *TableSourcesItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourcesItemContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *TableSourcesItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *TableSourcesItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourcesItem(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) TableSourceItem() (localctx ITableSourceItemContext) {
	localctx = NewTableSourceItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, MySqlParserRULE_tableSourceItem)
	var _la int

	var _alt int

	p.SetState(3829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 544, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAtomTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3789)
			p.TableName()
		}
		p.SetState(3795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPARTITION {
			{
				p.SetState(3790)
				p.Match(MySqlParserPARTITION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3791)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3792)
				p.UidList()
			}
			{
				p.SetState(3793)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(3801)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext()) == 1 {
			p.SetState(3798)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserAS {
				{
					p.SetState(3797)
					p.Match(MySqlParserAS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(3800)

				var _x = p.Uid()


				localctx.(*AtomTableItemContext).alias = _x
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3811)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3803)
				p.IndexHint()
			}
			p.SetState(3808)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 540, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3804)
						p.Match(MySqlParserCOMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(3805)
						p.IndexHint()
					}


				}
				p.SetState(3810)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 540, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		localctx = NewSubqueryTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3813)
				p.SelectStatement()
			}


		case 2:
			{
				p.SetState(3814)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3815)

				var _x = p.SelectStatement()


				localctx.(*SubqueryTableItemContext).parenthesisSubquery = _x
			}
			{
				p.SetState(3816)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(3820)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3823)

			var _x = p.Uid()


			localctx.(*SubqueryTableItemContext).alias = _x
		}


	case 3:
		localctx = NewTableSourcesItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3825)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3826)
			p.TableSources()
		}
		{
			p.SetState(3827)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexHintContext is an interface to support dynamic dispatch.
type IIndexHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexHintAction returns the indexHintAction token.
	GetIndexHintAction() antlr.Token 

	// GetKeyFormat returns the keyFormat token.
	GetKeyFormat() antlr.Token 


	// SetIndexHintAction sets the indexHintAction token.
	SetIndexHintAction(antlr.Token) 

	// SetKeyFormat sets the keyFormat token.
	SetKeyFormat(antlr.Token) 


	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	USE() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	IndexHintType() IIndexHintTypeContext

	// IsIndexHintContext differentiates from other interfaces.
	IsIndexHintContext()
}

type IndexHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	indexHintAction antlr.Token
	keyFormat antlr.Token
}

func NewEmptyIndexHintContext() *IndexHintContext {
	var p = new(IndexHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHint
	return p
}

func InitEmptyIndexHintContext(p *IndexHintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHint
}

func (*IndexHintContext) IsIndexHintContext() {}

func NewIndexHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintContext {
	var p = new(IndexHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHint

	return p
}

func (s *IndexHintContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintContext) GetIndexHintAction() antlr.Token { return s.indexHintAction }

func (s *IndexHintContext) GetKeyFormat() antlr.Token { return s.keyFormat }


func (s *IndexHintContext) SetIndexHintAction(v antlr.Token) { s.indexHintAction = v }

func (s *IndexHintContext) SetKeyFormat(v antlr.Token) { s.keyFormat = v }


func (s *IndexHintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexHintContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IndexHintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexHintContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *IndexHintContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *IndexHintContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORCE, 0)
}

func (s *IndexHintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *IndexHintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *IndexHintContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *IndexHintContext) IndexHintType() IIndexHintTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintTypeContext)
}

func (s *IndexHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IndexHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHint(s)
	}
}

func (s *IndexHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHint(s)
	}
}

func (s *IndexHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexHint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IndexHint() (localctx IIndexHintContext) {
	localctx = NewIndexHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, MySqlParserRULE_indexHint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3831)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).indexHintAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFORCE || _la == MySqlParserIGNORE || _la == MySqlParserUSE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).indexHintAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3832)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).keyFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).keyFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFOR {
		{
			p.SetState(3833)
			p.Match(MySqlParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3834)
			p.IndexHintType()
		}

	}
	{
		p.SetState(3837)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3838)
		p.UidList()
	}
	{
		p.SetState(3839)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexHintTypeContext is an interface to support dynamic dispatch.
type IIndexHintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	GROUP() antlr.TerminalNode

	// IsIndexHintTypeContext differentiates from other interfaces.
	IsIndexHintTypeContext()
}

type IndexHintTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintTypeContext() *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHintType
	return p
}

func InitEmptyIndexHintTypeContext(p *IndexHintTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHintType
}

func (*IndexHintTypeContext) IsIndexHintTypeContext() {}

func NewIndexHintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHintType

	return p
}

func (s *IndexHintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *IndexHintTypeContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *IndexHintTypeContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *IndexHintTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *IndexHintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IndexHintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexHintType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IndexHintType() (localctx IIndexHintTypeContext) {
	localctx = NewIndexHintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, MySqlParserRULE_indexHintType)
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3841)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserORDER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3842)
			p.Match(MySqlParserORDER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3843)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserGROUP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3844)
			p.Match(MySqlParserGROUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3845)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoinPartContext is an interface to support dynamic dispatch.
type IJoinPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinPartContext differentiates from other interfaces.
	IsJoinPartContext()
}

type JoinPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinPartContext() *JoinPartContext {
	var p = new(JoinPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinPart
	return p
}

func InitEmptyJoinPartContext(p *JoinPartContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinPart
}

func (*JoinPartContext) IsJoinPartContext() {}

func NewJoinPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinPartContext {
	var p = new(JoinPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_joinPart

	return p
}

func (s *JoinPartContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinPartContext) CopyAll(ctx *JoinPartContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type InnerJoinContext struct {
	JoinPartContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *InnerJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *InnerJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *InnerJoinContext) AllJoinSpec() []IJoinSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinSpecContext); ok {
			len++
		}
	}

	tst := make([]IJoinSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinSpecContext); ok {
			tst[i] = t.(IJoinSpecContext)
			i++
		}
	}

	return tst
}

func (s *InnerJoinContext) JoinSpec(i int) IJoinSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSpecContext)
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNER, 0)
}

func (s *InnerJoinContext) CROSS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSS, 0)
}


func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

func (s *InnerJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInnerJoin(s)

	default:
		return t.VisitChildren(s)
	}
}


type NaturalJoinContext struct {
	JoinPartContext
}

func NewNaturalJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NaturalJoinContext {
	var p = new(NaturalJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *NaturalJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalJoinContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATURAL, 0)
}

func (s *NaturalJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *NaturalJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *NaturalJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *NaturalJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *NaturalJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}


func (s *NaturalJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNaturalJoin(s)

	default:
		return t.VisitChildren(s)
	}
}


type OuterJoinContext struct {
	JoinPartContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *OuterJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *OuterJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *OuterJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}

func (s *OuterJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *OuterJoinContext) AllJoinSpec() []IJoinSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinSpecContext); ok {
			len++
		}
	}

	tst := make([]IJoinSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinSpecContext); ok {
			tst[i] = t.(IJoinSpecContext)
			i++
		}
	}

	return tst
}

func (s *OuterJoinContext) JoinSpec(i int) IJoinSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSpecContext)
}


func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (s *OuterJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOuterJoin(s)

	default:
		return t.VisitChildren(s)
	}
}


type StraightJoinContext struct {
	JoinPartContext
}

func NewStraightJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StraightJoinContext {
	var p = new(StraightJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *StraightJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StraightJoinContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *StraightJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *StraightJoinContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *StraightJoinContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *StraightJoinContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StraightJoinContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *StraightJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStraightJoin(s)
	}
}

func (s *StraightJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStraightJoin(s)
	}
}

func (s *StraightJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStraightJoin(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) JoinPart() (localctx IJoinPartContext) {
	localctx = NewJoinPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, MySqlParserRULE_joinPart)
	var _la int

	var _alt int

	p.SetState(3895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCROSS, MySqlParserINNER, MySqlParserJOIN:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3849)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCROSS || _la == MySqlParserINNER {
			{
				p.SetState(3848)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCROSS || _la == MySqlParserINNER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3851)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3853)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 548, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3852)
				p.Match(MySqlParserLATERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3855)
			p.TableSourceItem()
		}
		p.SetState(3859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3856)
					p.JoinSpec()
				}


			}
			p.SetState(3861)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case MySqlParserSTRAIGHT_JOIN:
		localctx = NewStraightJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3862)
			p.Match(MySqlParserSTRAIGHT_JOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3863)
			p.TableSourceItem()
		}
		p.SetState(3868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 550, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3864)
					p.Match(MySqlParserON)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3865)
					p.expression(0)
				}


			}
			p.SetState(3870)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 550, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case MySqlParserLEFT, MySqlParserRIGHT:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3871)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserOUTER {
			{
				p.SetState(3872)
				p.Match(MySqlParserOUTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(3875)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3877)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 552, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3876)
				p.Match(MySqlParserLATERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3879)
			p.TableSourceItem()
		}
		p.SetState(3883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3880)
					p.JoinSpec()
				}


			}
			p.SetState(3885)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case MySqlParserNATURAL:
		localctx = NewNaturalJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3886)
			p.Match(MySqlParserNATURAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLEFT || _la == MySqlParserRIGHT {
			{
				p.SetState(3887)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(3889)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserOUTER {
				{
					p.SetState(3888)
					p.Match(MySqlParserOUTER)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}

		}
		{
			p.SetState(3893)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3894)
			p.TableSourceItem()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJoinSpecContext is an interface to support dynamic dispatch.
type IJoinSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	USING() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode

	// IsJoinSpecContext differentiates from other interfaces.
	IsJoinSpecContext()
}

type JoinSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinSpecContext() *JoinSpecContext {
	var p = new(JoinSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinSpec
	return p
}

func InitEmptyJoinSpecContext(p *JoinSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinSpec
}

func (*JoinSpecContext) IsJoinSpecContext() {}

func NewJoinSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinSpecContext {
	var p = new(JoinSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_joinSpec

	return p
}

func (s *JoinSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinSpecContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JoinSpecContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinSpecContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *JoinSpecContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JoinSpecContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *JoinSpecContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JoinSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JoinSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJoinSpec(s)
	}
}

func (s *JoinSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJoinSpec(s)
	}
}

func (s *JoinSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJoinSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) JoinSpec() (localctx IJoinSpecContext) {
	localctx = NewJoinSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, MySqlParserRULE_joinSpec)
	p.SetState(3904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3897)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3898)
			p.expression(0)
		}



	case MySqlParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3899)
			p.Match(MySqlParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3900)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3901)
			p.UidList()
		}
		{
			p.SetState(3902)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecification() IQuerySpecificationContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpression() IQueryExpressionContext

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpression
	return p
}

func InitEmptyQueryExpressionContext(p *QueryExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpression
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) QueryExpression() (localctx IQueryExpressionContext) {
	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, MySqlParserRULE_queryExpression)
	p.SetState(3914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3906)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3907)
			p.QuerySpecification()
		}
		{
			p.SetState(3908)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3910)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3911)
			p.QueryExpression()
		}
		{
			p.SetState(3912)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryExpressionNointoContext is an interface to support dynamic dispatch.
type IQueryExpressionNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext

	// IsQueryExpressionNointoContext differentiates from other interfaces.
	IsQueryExpressionNointoContext()
}

type QueryExpressionNointoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionNointoContext() *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo
	return p
}

func InitEmptyQueryExpressionNointoContext(p *QueryExpressionNointoContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo
}

func (*QueryExpressionNointoContext) IsQueryExpressionNointoContext() {}

func NewQueryExpressionNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo

	return p
}

func (s *QueryExpressionNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionNointoContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *QueryExpressionNointoContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *QueryExpressionNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryExpressionNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryExpressionNointo(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) QueryExpressionNointo() (localctx IQueryExpressionNointoContext) {
	localctx = NewQueryExpressionNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, MySqlParserRULE_queryExpressionNointo)
	p.SetState(3924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 559, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3916)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3917)
			p.QuerySpecificationNointo()
		}
		{
			p.SetState(3918)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3920)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3921)
			p.QueryExpressionNointo()
		}
		{
			p.SetState(3922)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	FromClause() IFromClauseContext
	ProxyHint() IProxyHintContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	SelectIntoExpression() ISelectIntoExpressionContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *QuerySpecificationContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationContext) SelectIntoExpression() ISelectIntoExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectIntoExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectIntoExpressionContext)
}

func (s *QuerySpecificationContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, MySqlParserRULE_querySpecification)
	var _la int

	var _alt int

	p.SetState(3986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 576, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3926)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3928)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3927)
				p.ProxyHint()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3930)
					p.SelectSpec()
				}


			}
			p.SetState(3935)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3936)
			p.SelectElements()
		}
		p.SetState(3938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINTO {
			{
				p.SetState(3937)
				p.SelectIntoExpression()
			}

		}
		{
			p.SetState(3940)
			p.FromClause()
		}
		p.SetState(3942)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 563, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3941)
				p.GroupByClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserHAVING {
			{
				p.SetState(3944)
				p.HavingClause()
			}

		}
		p.SetState(3948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserWINDOW {
			{
				p.SetState(3947)
				p.WindowClause()
			}

		}
		p.SetState(3951)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 566, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3950)
				p.OrderByClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3954)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 567, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3953)
				p.LimitClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3956)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3958)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 568, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3957)
				p.ProxyHint()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 569, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3960)
					p.SelectSpec()
				}


			}
			p.SetState(3965)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 569, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3966)
			p.SelectElements()
		}
		{
			p.SetState(3967)
			p.FromClause()
		}
		p.SetState(3969)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 570, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3968)
				p.GroupByClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserHAVING {
			{
				p.SetState(3971)
				p.HavingClause()
			}

		}
		p.SetState(3975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserWINDOW {
			{
				p.SetState(3974)
				p.WindowClause()
			}

		}
		p.SetState(3978)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 573, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3977)
				p.OrderByClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3981)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 574, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3980)
				p.LimitClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(3984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINTO {
			{
				p.SetState(3983)
				p.SelectIntoExpression()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IProxyHintContext is an interface to support dynamic dispatch.
type IProxyHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT_START() antlr.TerminalNode
	COMMENT_END() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsProxyHintContext differentiates from other interfaces.
	IsProxyHintContext()
}

type ProxyHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProxyHintContext() *ProxyHintContext {
	var p = new(ProxyHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_proxyHint
	return p
}

func InitEmptyProxyHintContext(p *ProxyHintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_proxyHint
}

func (*ProxyHintContext) IsProxyHintContext() {}

func NewProxyHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProxyHintContext {
	var p = new(ProxyHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_proxyHint

	return p
}

func (s *ProxyHintContext) GetParser() antlr.Parser { return s.parser }

func (s *ProxyHintContext) COMMENT_START() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT_START, 0)
}

func (s *ProxyHintContext) COMMENT_END() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT_END, 0)
}

func (s *ProxyHintContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ProxyHintContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ProxyHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProxyHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ProxyHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProxyHint(s)
	}
}

func (s *ProxyHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProxyHint(s)
	}
}

func (s *ProxyHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitProxyHint(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ProxyHint() (localctx IProxyHintContext) {
	localctx = NewProxyHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, MySqlParserRULE_proxyHint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3988)
		p.Match(MySqlParserCOMMENT_START)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || _la == MySqlParserMOD || _la == MySqlParserID {
		{
			p.SetState(3989)
			p.Annotation()
		}


		p.SetState(3992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3994)
		p.Match(MySqlParserCOMMENT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Key() IKeyContext
	EQUAL_SYMBOL() antlr.TerminalNode
	Value() IValueContext
	SEMI() antlr.TerminalNode

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) Key() IKeyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyContext)
}

func (s *AnnotationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AnnotationContext) Value() IValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *AnnotationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, MySqlParserRULE_annotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3996)
		p.Key()
	}
	{
		p.SetState(3997)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3998)
		p.Value()
	}
	p.SetState(4000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserSEMI {
		{
			p.SetState(3999)
			p.Match(MySqlParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeyContext is an interface to support dynamic dispatch.
type IKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	TransactionLevelBase() ITransactionLevelBaseContext
	EngineNameBase() IEngineNameBaseContext
	PrivilegesBase() IPrivilegesBaseContext
	IntervalTypeBase() IIntervalTypeBaseContext
	DataTypeBase() IDataTypeBaseContext
	KeywordsCanBeId() IKeywordsCanBeIdContext
	ScalarFunctionName() IScalarFunctionNameContext

	// IsKeyContext differentiates from other interfaces.
	IsKeyContext()
}

type KeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyContext() *KeyContext {
	var p = new(KeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_key
	return p
}

func InitEmptyKeyContext(p *KeyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_key
}

func (*KeyContext) IsKeyContext() {}

func NewKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyContext {
	var p = new(KeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_key

	return p
}

func (s *KeyContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *KeyContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *KeyContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *KeyContext) EngineNameBase() IEngineNameBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameBaseContext)
}

func (s *KeyContext) PrivilegesBase() IPrivilegesBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegesBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *KeyContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *KeyContext) DataTypeBase() IDataTypeBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *KeyContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *KeyContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *KeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKey(s)
	}
}

func (s *KeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKey(s)
	}
}

func (s *KeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitKey(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Key() (localctx IKeyContext) {
	localctx = NewKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, MySqlParserRULE_key)
	p.SetState(4011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4002)
			p.Match(MySqlParserID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4003)
			p.CharsetNameBase()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4004)
			p.TransactionLevelBase()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4005)
			p.EngineNameBase()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4006)
			p.PrivilegesBase()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4007)
			p.IntervalTypeBase()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4008)
			p.DataTypeBase()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4009)
			p.KeywordsCanBeId()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4010)
			p.ScalarFunctionName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValue(s)
	}
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, MySqlParserRULE_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4013)
		p.Constant()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuerySpecificationNointoContext is an interface to support dynamic dispatch.
type IQuerySpecificationNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	FromClause() IFromClauseContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	UnionStatement() IUnionStatementContext

	// IsQuerySpecificationNointoContext differentiates from other interfaces.
	IsQuerySpecificationNointoContext()
}

type QuerySpecificationNointoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationNointoContext() *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo
	return p
}

func InitEmptyQuerySpecificationNointoContext(p *QuerySpecificationNointoContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo
}

func (*QuerySpecificationNointoContext) IsQuerySpecificationNointoContext() {}

func NewQuerySpecificationNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo

	return p
}

func (s *QuerySpecificationNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationNointoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationNointoContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationNointoContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationNointoContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationNointoContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationNointoContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationNointoContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationNointoContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationNointoContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationNointoContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationNointoContext) UnionStatement() IUnionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionStatementContext)
}

func (s *QuerySpecificationNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QuerySpecificationNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecificationNointo(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) QuerySpecificationNointo() (localctx IQuerySpecificationNointoContext) {
	localctx = NewQuerySpecificationNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, MySqlParserRULE_querySpecificationNointo)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4015)
		p.Match(MySqlParserSELECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4016)
				p.SelectSpec()
			}


		}
		p.SetState(4021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4022)
		p.SelectElements()
	}
	{
		p.SetState(4023)
		p.FromClause()
	}
	p.SetState(4025)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4024)
			p.GroupByClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserHAVING {
		{
			p.SetState(4027)
			p.HavingClause()
		}

	}
	p.SetState(4031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWINDOW {
		{
			p.SetState(4030)
			p.WindowClause()
		}

	}
	p.SetState(4034)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 584, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4033)
			p.OrderByClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4037)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4036)
			p.LimitClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4040)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 586, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4039)
			p.UnionStatement()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnionParenthesisContext is an interface to support dynamic dispatch.
type IUnionParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token 


	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token) 


	// Getter signatures
	UNION() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionParenthesisContext differentiates from other interfaces.
	IsUnionParenthesisContext()
}

type UnionParenthesisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionParenthesisContext() *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionParenthesis
	return p
}

func InitEmptyUnionParenthesisContext(p *UnionParenthesisContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionParenthesis
}

func (*UnionParenthesisContext) IsUnionParenthesisContext() {}

func NewUnionParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionParenthesis

	return p
}

func (s *UnionParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionParenthesisContext) GetUnionType() antlr.Token { return s.unionType }


func (s *UnionParenthesisContext) SetUnionType(v antlr.Token) { s.unionType = v }


func (s *UnionParenthesisContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionParenthesisContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionParenthesisContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnionParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UnionParenthesis() (localctx IUnionParenthesisContext) {
	localctx = NewUnionParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, MySqlParserRULE_unionParenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4042)
		p.Match(MySqlParserUNION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(4043)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionParenthesisContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionParenthesisContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4046)
		p.QueryExpressionNointo()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnionStatementContext is an interface to support dynamic dispatch.
type IUnionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token 


	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token) 


	// Getter signatures
	UNION() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionStatementContext differentiates from other interfaces.
	IsUnionStatementContext()
}

type UnionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionStatementContext() *UnionStatementContext {
	var p = new(UnionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionStatement
	return p
}

func InitEmptyUnionStatementContext(p *UnionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionStatement
}

func (*UnionStatementContext) IsUnionStatementContext() {}

func NewUnionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionStatementContext {
	var p = new(UnionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionStatement

	return p
}

func (s *UnionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionStatementContext) GetUnionType() antlr.Token { return s.unionType }


func (s *UnionStatementContext) SetUnionType(v antlr.Token) { s.unionType = v }


func (s *UnionStatementContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionStatementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionStatement(s)
	}
}

func (s *UnionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionStatement(s)
	}
}

func (s *UnionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UnionStatement() (localctx IUnionStatementContext) {
	localctx = NewUnionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, MySqlParserRULE_unionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4048)
		p.Match(MySqlParserUNION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(4049)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionStatementContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionStatementContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT:
		{
			p.SetState(4052)
			p.QuerySpecificationNointo()
		}


	case MySqlParserLR_BRACKET:
		{
			p.SetState(4053)
			p.QueryExpressionNointo()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILateralStatementContext is an interface to support dynamic dispatch.
type ILateralStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LATERAL() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLateralStatementContext differentiates from other interfaces.
	IsLateralStatementContext()
}

type LateralStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLateralStatementContext() *LateralStatementContext {
	var p = new(LateralStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lateralStatement
	return p
}

func InitEmptyLateralStatementContext(p *LateralStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lateralStatement
}

func (*LateralStatementContext) IsLateralStatementContext() {}

func NewLateralStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralStatementContext {
	var p = new(LateralStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lateralStatement

	return p
}

func (s *LateralStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralStatementContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *LateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *LateralStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *LateralStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LateralStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LateralStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LateralStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *LateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLateralStatement(s)
	}
}

func (s *LateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLateralStatement(s)
	}
}

func (s *LateralStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLateralStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LateralStatement() (localctx ILateralStatementContext) {
	localctx = NewLateralStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, MySqlParserRULE_lateralStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4056)
		p.Match(MySqlParserLATERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 593, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4057)
			p.QuerySpecificationNointo()
		}


	case 2:
		{
			p.SetState(4058)
			p.QueryExpressionNointo()
		}


	case 3:
		{
			p.SetState(4059)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT:
			{
				p.SetState(4060)
				p.QuerySpecificationNointo()
			}


		case MySqlParserLR_BRACKET:
			{
				p.SetState(4061)
				p.QueryExpressionNointo()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(4064)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4069)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 592, p.GetParserRuleContext()) == 1 {
			p.SetState(4066)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserAS {
				{
					p.SetState(4065)
					p.Match(MySqlParserAS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(4068)
				p.Uid()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJsonTableContext is an interface to support dynamic dispatch.
type IJsonTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_TABLE() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsJsonTableContext differentiates from other interfaces.
	IsJsonTableContext()
}

type JsonTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonTableContext() *JsonTableContext {
	var p = new(JsonTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonTable
	return p
}

func InitEmptyJsonTableContext(p *JsonTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonTable
}

func (*JsonTableContext) IsJsonTableContext() {}

func NewJsonTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonTableContext {
	var p = new(JsonTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonTable

	return p
}

func (s *JsonTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonTableContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TABLE, 0)
}

func (s *JsonTableContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *JsonTableContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *JsonTableContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *JsonTableContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *JsonTableContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *JsonTableContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *JsonTableContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonTableContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *JsonTableContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *JsonTableContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *JsonTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *JsonTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JsonTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonTable(s)
	}
}

func (s *JsonTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonTable(s)
	}
}

func (s *JsonTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) JsonTable() (localctx IJsonTableContext) {
	localctx = NewJsonTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, MySqlParserRULE_jsonTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4073)
		p.Match(MySqlParserJSON_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4074)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4075)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4076)
		p.Match(MySqlParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4077)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4078)
		p.Match(MySqlParserCOLUMNS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4079)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4080)
		p.JsonColumnList()
	}
	{
		p.SetState(4081)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4082)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4087)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) == 1 {
		p.SetState(4084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(4083)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4086)
			p.Uid()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJsonColumnListContext is an interface to support dynamic dispatch.
type IJsonColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJsonColumn() []IJsonColumnContext
	JsonColumn(i int) IJsonColumnContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsJsonColumnListContext differentiates from other interfaces.
	IsJsonColumnListContext()
}

type JsonColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnListContext() *JsonColumnListContext {
	var p = new(JsonColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumnList
	return p
}

func InitEmptyJsonColumnListContext(p *JsonColumnListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumnList
}

func (*JsonColumnListContext) IsJsonColumnListContext() {}

func NewJsonColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnListContext {
	var p = new(JsonColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonColumnList

	return p
}

func (s *JsonColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnListContext) AllJsonColumn() []IJsonColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonColumnContext); ok {
			len++
		}
	}

	tst := make([]IJsonColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonColumnContext); ok {
			tst[i] = t.(IJsonColumnContext)
			i++
		}
	}

	return tst
}

func (s *JsonColumnListContext) JsonColumn(i int) IJsonColumnContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnContext)
}

func (s *JsonColumnListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *JsonColumnListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *JsonColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JsonColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonColumnList(s)
	}
}

func (s *JsonColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonColumnList(s)
	}
}

func (s *JsonColumnListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonColumnList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) JsonColumnList() (localctx IJsonColumnListContext) {
	localctx = NewJsonColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, MySqlParserRULE_jsonColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4089)
		p.JsonColumn()
	}
	p.SetState(4094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(4090)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4091)
			p.JsonColumn()
		}


		p.SetState(4096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJsonColumnContext is an interface to support dynamic dispatch.
type IJsonColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	FOR() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	DataType() IDataTypeContext
	PATH() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	JsonOnEmpty() IJsonOnEmptyContext
	JsonOnError() IJsonOnErrorContext
	NESTED() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	RR_BRACKET() antlr.TerminalNode

	// IsJsonColumnContext differentiates from other interfaces.
	IsJsonColumnContext()
}

type JsonColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnContext() *JsonColumnContext {
	var p = new(JsonColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumn
	return p
}

func InitEmptyJsonColumnContext(p *JsonColumnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumn
}

func (*JsonColumnContext) IsJsonColumnContext() {}

func NewJsonColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnContext {
	var p = new(JsonColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonColumn

	return p
}

func (s *JsonColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *JsonColumnContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *JsonColumnContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDINALITY, 0)
}

func (s *JsonColumnContext) DataType() IDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *JsonColumnContext) PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserPATH, 0)
}

func (s *JsonColumnContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *JsonColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *JsonColumnContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonColumnContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}

func (s *JsonColumnContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserNESTED, 0)
}

func (s *JsonColumnContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *JsonColumnContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonColumnContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonColumnContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JsonColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonColumn(s)
	}
}

func (s *JsonColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonColumn(s)
	}
}

func (s *JsonColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonColumn(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) JsonColumn() (localctx IJsonColumnContext) {
	localctx = NewJsonColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, MySqlParserRULE_jsonColumn)
	var _la int

	p.SetState(4126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 602, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4097)
			p.FullColumnName()
		}
		p.SetState(4114)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserFOR:
			{
				p.SetState(4098)
				p.Match(MySqlParserFOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4099)
				p.Match(MySqlParserORDINALITY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserCHARACTER, MySqlParserSET, MySqlParserTINYINT, MySqlParserSMALLINT, MySqlParserMEDIUMINT, MySqlParserMIDDLEINT, MySqlParserINT, MySqlParserINT1, MySqlParserINT2, MySqlParserINT3, MySqlParserINT4, MySqlParserINT8, MySqlParserINTEGER, MySqlParserBIGINT, MySqlParserREAL, MySqlParserDOUBLE, MySqlParserFLOAT, MySqlParserFLOAT4, MySqlParserFLOAT8, MySqlParserDECIMAL, MySqlParserDEC, MySqlParserNUMERIC, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserCHAR, MySqlParserVARCHAR, MySqlParserNVARCHAR, MySqlParserNATIONAL, MySqlParserBINARY, MySqlParserVARBINARY, MySqlParserTINYBLOB, MySqlParserBLOB, MySqlParserMEDIUMBLOB, MySqlParserLONG, MySqlParserLONGBLOB, MySqlParserTINYTEXT, MySqlParserTEXT, MySqlParserMEDIUMTEXT, MySqlParserLONGTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserBIT, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserFIXED, MySqlParserJSON, MySqlParserNCHAR, MySqlParserGEOMETRYCOLLECTION, MySqlParserGEOMCOLLECTION, MySqlParserGEOMETRY, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON:
			{
				p.SetState(4100)
				p.DataType()
			}
			p.SetState(4112)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserPATH:
				{
					p.SetState(4101)
					p.Match(MySqlParserPATH)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(4102)
					p.Match(MySqlParserSTRING_LITERAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(4104)
				p.GetErrorHandler().Sync(p)


				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 597, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(4103)
						p.JsonOnEmpty()
					}

					} else if p.HasError() { // JIM
						goto errorExit
				}
				p.SetState(4107)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserDEFAULT || _la == MySqlParserNULL_LITERAL || _la == MySqlParserERROR {
					{
						p.SetState(4106)
						p.JsonOnError()
					}

				}


			case MySqlParserEXISTS:
				{
					p.SetState(4109)
					p.Match(MySqlParserEXISTS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(4110)
					p.Match(MySqlParserPATH)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(4111)
					p.Match(MySqlParserSTRING_LITERAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4116)
			p.Match(MySqlParserNESTED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPATH {
			{
				p.SetState(4117)
				p.Match(MySqlParserPATH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4120)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4121)
			p.Match(MySqlParserCOLUMNS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4122)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4123)
			p.JsonColumnList()
		}
		{
			p.SetState(4124)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJsonOnEmptyContext is an interface to support dynamic dispatch.
type IJsonOnEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnEmptyContext differentiates from other interfaces.
	IsJsonOnEmptyContext()
}

type JsonOnEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnEmptyContext() *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty
	return p
}

func InitEmptyJsonOnEmptyContext(p *JsonOnEmptyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty
}

func (*JsonOnEmptyContext) IsJsonOnEmptyContext() {}

func NewJsonOnEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty

	return p
}

func (s *JsonOnEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnEmptyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JsonOnEmptyContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEMPTY, 0)
}

func (s *JsonOnEmptyContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *JsonOnEmptyContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *JsonOnEmptyContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *JsonOnEmptyContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JsonOnEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOnEmpty(s)
	}
}

func (s *JsonOnEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOnEmpty(s)
	}
}

func (s *JsonOnEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonOnEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) JsonOnEmpty() (localctx IJsonOnEmptyContext) {
	localctx = NewJsonOnEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, MySqlParserRULE_jsonOnEmpty)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNULL_LITERAL:
		{
			p.SetState(4128)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserERROR:
		{
			p.SetState(4129)
			p.Match(MySqlParserERROR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDEFAULT:
		{
			p.SetState(4130)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4131)
			p.DefaultValue()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4134)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4135)
		p.Match(MySqlParserEMPTY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJsonOnErrorContext is an interface to support dynamic dispatch.
type IJsonOnErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnErrorContext differentiates from other interfaces.
	IsJsonOnErrorContext()
}

type JsonOnErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnErrorContext() *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnError
	return p
}

func InitEmptyJsonOnErrorContext(p *JsonOnErrorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnError
}

func (*JsonOnErrorContext) IsJsonOnErrorContext() {}

func NewJsonOnErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOnError

	return p
}

func (s *JsonOnErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnErrorContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JsonOnErrorContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserERROR)
}

func (s *JsonOnErrorContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, i)
}

func (s *JsonOnErrorContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *JsonOnErrorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *JsonOnErrorContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JsonOnErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOnError(s)
	}
}

func (s *JsonOnErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOnError(s)
	}
}

func (s *JsonOnErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonOnError(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) JsonOnError() (localctx IJsonOnErrorContext) {
	localctx = NewJsonOnErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, MySqlParserRULE_jsonOnError)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNULL_LITERAL:
		{
			p.SetState(4137)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserERROR:
		{
			p.SetState(4138)
			p.Match(MySqlParserERROR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDEFAULT:
		{
			p.SetState(4139)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4140)
			p.DefaultValue()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4143)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4144)
		p.Match(MySqlParserERROR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectSpecContext is an interface to support dynamic dispatch.
type ISelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	DISTINCTROW() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	STRAIGHT_JOIN() antlr.TerminalNode
	SQL_SMALL_RESULT() antlr.TerminalNode
	SQL_BIG_RESULT() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_CALC_FOUND_ROWS() antlr.TerminalNode

	// IsSelectSpecContext differentiates from other interfaces.
	IsSelectSpecContext()
}

type SelectSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecContext() *SelectSpecContext {
	var p = new(SelectSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
	return p
}

func InitEmptySelectSpecContext(p *SelectSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
}

func (*SelectSpecContext) IsSelectSpecContext() {}

func NewSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecContext {
	var p = new(SelectSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectSpec

	return p
}

func (s *SelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SelectSpecContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *SelectSpecContext) DISTINCTROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCTROW, 0)
}

func (s *SelectSpecContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *SelectSpecContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *SelectSpecContext) SQL_SMALL_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_SMALL_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BIG_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BIG_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *SelectSpecContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *SelectSpecContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *SelectSpecContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *SelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectSpec(s)
	}
}

func (s *SelectSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectSpec(s)
	}
}

func (s *SelectSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SelectSpec() (localctx ISelectSpecContext) {
	localctx = NewSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, MySqlParserRULE_selectSpec)
	var _la int

	p.SetState(4154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL, MySqlParserDISTINCT, MySqlParserDISTINCTROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4146)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 1688849860264000) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case MySqlParserHIGH_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4147)
			p.Match(MySqlParserHIGH_PRIORITY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSTRAIGHT_JOIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4148)
			p.Match(MySqlParserSTRAIGHT_JOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSQL_SMALL_RESULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4149)
			p.Match(MySqlParserSQL_SMALL_RESULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSQL_BIG_RESULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4150)
			p.Match(MySqlParserSQL_BIG_RESULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSQL_BUFFER_RESULT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4151)
			p.Match(MySqlParserSQL_BUFFER_RESULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4152)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_CACHE || _la == MySqlParserSQL_NO_CACHE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case MySqlParserSQL_CALC_FOUND_ROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4153)
			p.Match(MySqlParserSQL_CALC_FOUND_ROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token 


	// SetStar sets the star token.
	SetStar(antlr.Token) 


	// Getter signatures
	AllSelectElement() []ISelectElementContext
	SelectElement(i int) ISelectElementContext
	STAR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	star antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
	return p
}

func InitEmptySelectElementsContext(p *SelectElementsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }


func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }


func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectElements(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SelectElements() (localctx ISelectElementsContext) {
	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, MySqlParserRULE_selectElements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 606, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4156)

			var _m = p.Match(MySqlParserSTAR)

			localctx.(*SelectElementsContext).star = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(4157)
			p.SelectElement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(4164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 607, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4160)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4161)
				p.SelectElement()
			}


		}
		p.SetState(4166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 607, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
	return p
}

func InitEmptySelectElementContext(p *SelectElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyAll(ctx *SelectElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SelectExpressionElementContext struct {
	SelectElementContext
}

func NewSelectExpressionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectExpressionElementContext {
	var p = new(SelectExpressionElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectExpressionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExpressionElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectExpressionElementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *SelectExpressionElementContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *SelectExpressionElementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectExpressionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}


func (s *SelectExpressionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectExpressionElement(s)

	default:
		return t.VisitChildren(s)
	}
}


type SelectFunctionElementContext struct {
	SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext {
	var p = new(SelectFunctionElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectFunctionElementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}


func (s *SelectFunctionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFunctionElement(s)

	default:
		return t.VisitChildren(s)
	}
}


type SelectStarElementContext struct {
	SelectElementContext
}

func NewSelectStarElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectStarElementContext {
	var p = new(SelectStarElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectStarElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStarElementContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SelectStarElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *SelectStarElementContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}


func (s *SelectStarElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectStarElement(s)

	default:
		return t.VisitChildren(s)
	}
}


type SelectColumnElementContext struct {
	SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext {
	var p = new(SelectColumnElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *SelectColumnElementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectColumnElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}


func (s *SelectColumnElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectColumnElement(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) SelectElement() (localctx ISelectElementContext) {
	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, MySqlParserRULE_selectElement)
	var _la int

	p.SetState(4196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 615, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectStarElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4167)
			p.FullId()
		}
		{
			p.SetState(4168)
			p.Match(MySqlParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4169)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		localctx = NewSelectColumnElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4171)
			p.FullColumnName()
		}
		p.SetState(4176)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 609, p.GetParserRuleContext()) == 1 {
			p.SetState(4173)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserAS {
				{
					p.SetState(4172)
					p.Match(MySqlParserAS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(4175)
				p.Uid()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		localctx = NewSelectFunctionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4178)
			p.FunctionCall()
		}
		p.SetState(4183)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) == 1 {
			p.SetState(4180)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserAS {
				{
					p.SetState(4179)
					p.Match(MySqlParserAS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(4182)
				p.Uid()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		localctx = NewSelectExpressionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4187)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4185)
				p.Match(MySqlParserLOCAL_ID)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4186)
				p.Match(MySqlParserVAR_ASSIGN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(4189)
			p.expression(0)
		}
		p.SetState(4194)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) == 1 {
			p.SetState(4191)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserAS {
				{
					p.SetState(4190)
					p.Match(MySqlParserAS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(4193)
				p.Uid()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectIntoExpressionContext is an interface to support dynamic dispatch.
type ISelectIntoExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectIntoExpressionContext differentiates from other interfaces.
	IsSelectIntoExpressionContext()
}

type SelectIntoExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectIntoExpressionContext() *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectIntoExpression
	return p
}

func InitEmptySelectIntoExpressionContext(p *SelectIntoExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectIntoExpression
}

func (*SelectIntoExpressionContext) IsSelectIntoExpressionContext() {}

func NewSelectIntoExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectIntoExpression

	return p
}

func (s *SelectIntoExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectIntoExpressionContext) CopyAll(ctx *SelectIntoExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectIntoExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SelectIntoVariablesContext struct {
	SelectIntoExpressionContext
}

func NewSelectIntoVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoVariablesContext {
	var p = new(SelectIntoVariablesContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoVariablesContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoVariablesContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoVariablesContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *SelectIntoVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectIntoVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *SelectIntoVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoVariables(s)

	default:
		return t.VisitChildren(s)
	}
}


type SelectIntoTextFileContext struct {
	SelectIntoExpressionContext
	filename antlr.Token
	charset ICharsetNameContext 
	fieldsFormat antlr.Token
}

func NewSelectIntoTextFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoTextFileContext {
	var p = new(SelectIntoTextFileContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}


func (s *SelectIntoTextFileContext) GetFilename() antlr.Token { return s.filename }

func (s *SelectIntoTextFileContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }


func (s *SelectIntoTextFileContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *SelectIntoTextFileContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }


func (s *SelectIntoTextFileContext) GetCharset() ICharsetNameContext { return s.charset }


func (s *SelectIntoTextFileContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *SelectIntoTextFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoTextFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoTextFileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTFILE, 0)
}

func (s *SelectIntoTextFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectIntoTextFileContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *SelectIntoTextFileContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SelectIntoTextFileContext) LINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, 0)
}

func (s *SelectIntoTextFileContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SelectIntoTextFileContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *SelectIntoTextFileContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *SelectIntoTextFileContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *SelectIntoTextFileContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}


func (s *SelectIntoTextFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoTextFile(s)

	default:
		return t.VisitChildren(s)
	}
}


type SelectIntoDumpFileContext struct {
	SelectIntoExpressionContext
}

func NewSelectIntoDumpFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoDumpFileContext {
	var p = new(SelectIntoDumpFileContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoDumpFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoDumpFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoDumpFileContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *SelectIntoDumpFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *SelectIntoDumpFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoDumpFile(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) SelectIntoExpression() (localctx ISelectIntoExpressionContext) {
	localctx = NewSelectIntoExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, MySqlParserRULE_selectIntoExpression)
	var _la int

	p.SetState(4234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 622, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectIntoVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4198)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4199)
			p.AssignmentField()
		}
		p.SetState(4204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(4200)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4201)
				p.AssignmentField()
			}


			p.SetState(4206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewSelectIntoDumpFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4207)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4208)
			p.Match(MySqlParserDUMPFILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4209)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		localctx = NewSelectIntoTextFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4210)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4211)
			p.Match(MySqlParserOUTFILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4212)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectIntoTextFileContext).filename = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCHARACTER {
			{
				p.SetState(4213)
				p.Match(MySqlParserCHARACTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4214)
				p.Match(MySqlParserSET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4215)

				var _x = p.CharsetName()


				localctx.(*SelectIntoTextFileContext).charset = _x
			}

		}
		p.SetState(4224)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 619, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4218)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SelectIntoTextFileContext).fieldsFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SelectIntoTextFileContext).fieldsFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(4220)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == MySqlParserENCLOSED || _la == MySqlParserESCAPED || _la == MySqlParserOPTIONALLY || _la == MySqlParserTERMINATED {
				{
					p.SetState(4219)
					p.SelectFieldsInto()
				}


				p.SetState(4222)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(4232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLINES {
			{
				p.SetState(4226)
				p.Match(MySqlParserLINES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(4228)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = _la == MySqlParserSTARTING || _la == MySqlParserTERMINATED {
				{
					p.SetState(4227)
					p.SelectLinesInto()
				}


				p.SetState(4230)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}


	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectFieldsIntoContext is an interface to support dynamic dispatch.
type ISelectFieldsIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTerminationField returns the terminationField token.
	GetTerminationField() antlr.Token 

	// GetEnclosion returns the enclosion token.
	GetEnclosion() antlr.Token 

	// GetEscaping returns the escaping token.
	GetEscaping() antlr.Token 


	// SetTerminationField sets the terminationField token.
	SetTerminationField(antlr.Token) 

	// SetEnclosion sets the enclosion token.
	SetEnclosion(antlr.Token) 

	// SetEscaping sets the escaping token.
	SetEscaping(antlr.Token) 


	// Getter signatures
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENCLOSED() antlr.TerminalNode
	OPTIONALLY() antlr.TerminalNode
	ESCAPED() antlr.TerminalNode

	// IsSelectFieldsIntoContext differentiates from other interfaces.
	IsSelectFieldsIntoContext()
}

type SelectFieldsIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	terminationField antlr.Token
	enclosion antlr.Token
	escaping antlr.Token
}

func NewEmptySelectFieldsIntoContext() *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectFieldsInto
	return p
}

func InitEmptySelectFieldsIntoContext(p *SelectFieldsIntoContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectFieldsInto
}

func (*SelectFieldsIntoContext) IsSelectFieldsIntoContext() {}

func NewSelectFieldsIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectFieldsInto

	return p
}

func (s *SelectFieldsIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectFieldsIntoContext) GetTerminationField() antlr.Token { return s.terminationField }

func (s *SelectFieldsIntoContext) GetEnclosion() antlr.Token { return s.enclosion }

func (s *SelectFieldsIntoContext) GetEscaping() antlr.Token { return s.escaping }


func (s *SelectFieldsIntoContext) SetTerminationField(v antlr.Token) { s.terminationField = v }

func (s *SelectFieldsIntoContext) SetEnclosion(v antlr.Token) { s.enclosion = v }

func (s *SelectFieldsIntoContext) SetEscaping(v antlr.Token) { s.escaping = v }


func (s *SelectFieldsIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectFieldsIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectFieldsIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectFieldsIntoContext) ENCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCLOSED, 0)
}

func (s *SelectFieldsIntoContext) OPTIONALLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONALLY, 0)
}

func (s *SelectFieldsIntoContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPED, 0)
}

func (s *SelectFieldsIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFieldsIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectFieldsIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFieldsInto(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SelectFieldsInto() (localctx ISelectFieldsIntoContext) {
	localctx = NewSelectFieldsIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, MySqlParserRULE_selectFieldsInto)
	var _la int

	p.SetState(4248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4236)
			p.Match(MySqlParserTERMINATED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4237)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4238)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).terminationField = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserENCLOSED, MySqlParserOPTIONALLY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserOPTIONALLY {
			{
				p.SetState(4239)
				p.Match(MySqlParserOPTIONALLY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4242)
			p.Match(MySqlParserENCLOSED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4243)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4244)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).enclosion = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserESCAPED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4245)
			p.Match(MySqlParserESCAPED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4246)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4247)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).escaping = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelectLinesIntoContext is an interface to support dynamic dispatch.
type ISelectLinesIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStarting returns the starting token.
	GetStarting() antlr.Token 

	// GetTerminationLine returns the terminationLine token.
	GetTerminationLine() antlr.Token 


	// SetStarting sets the starting token.
	SetStarting(antlr.Token) 

	// SetTerminationLine sets the terminationLine token.
	SetTerminationLine(antlr.Token) 


	// Getter signatures
	STARTING() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode

	// IsSelectLinesIntoContext differentiates from other interfaces.
	IsSelectLinesIntoContext()
}

type SelectLinesIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	starting antlr.Token
	terminationLine antlr.Token
}

func NewEmptySelectLinesIntoContext() *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectLinesInto
	return p
}

func InitEmptySelectLinesIntoContext(p *SelectLinesIntoContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectLinesInto
}

func (*SelectLinesIntoContext) IsSelectLinesIntoContext() {}

func NewSelectLinesIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectLinesInto

	return p
}

func (s *SelectLinesIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectLinesIntoContext) GetStarting() antlr.Token { return s.starting }

func (s *SelectLinesIntoContext) GetTerminationLine() antlr.Token { return s.terminationLine }


func (s *SelectLinesIntoContext) SetStarting(v antlr.Token) { s.starting = v }

func (s *SelectLinesIntoContext) SetTerminationLine(v antlr.Token) { s.terminationLine = v }


func (s *SelectLinesIntoContext) STARTING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTING, 0)
}

func (s *SelectLinesIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectLinesIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectLinesIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectLinesIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectLinesIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SelectLinesIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectLinesInto(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SelectLinesInto() (localctx ISelectLinesIntoContext) {
	localctx = NewSelectLinesIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, MySqlParserRULE_selectLinesInto)
	p.SetState(4256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTARTING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4250)
			p.Match(MySqlParserSTARTING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4251)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4252)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).starting = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4253)
			p.Match(MySqlParserTERMINATED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4254)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4255)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).terminationLine = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhereExpr returns the whereExpr rule contexts.
	GetWhereExpr() IExpressionContext


	// SetWhereExpr sets the whereExpr rule contexts.
	SetWhereExpr(IExpressionContext)


	// Getter signatures
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	whereExpr IExpressionContext 
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) GetWhereExpr() IExpressionContext { return s.whereExpr }


func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) { s.whereExpr = v }


func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FromClauseContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *FromClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, MySqlParserRULE_fromClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4260)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFROM {
		{
			p.SetState(4258)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4259)
			p.TableSources()
		}

	}
	p.SetState(4264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWHERE {
		{
			p.SetState(4262)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4263)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).whereExpr = _x
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllGroupByItem() []IGroupByItemContext
	GroupByItem(i int) IGroupByItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *GroupByClauseContext) AllGroupByItem() []IGroupByItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByItemContext); ok {
			len++
		}
	}

	tst := make([]IGroupByItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByItemContext); ok {
			tst[i] = t.(IGroupByItemContext)
			i++
		}
	}

	return tst
}

func (s *GroupByClauseContext) GroupByItem(i int) IGroupByItemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByItemContext)
}

func (s *GroupByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GroupByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GroupByClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, MySqlParserRULE_groupByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4266)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4267)
		p.Match(MySqlParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4268)
		p.GroupByItem()
	}
	p.SetState(4273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4269)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4270)
				p.GroupByItem()
			}


		}
		p.SetState(4275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4278)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 629, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4276)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4277)
			p.Match(MySqlParserROLLUP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHavingExpr returns the havingExpr rule contexts.
	GetHavingExpr() IExpressionContext


	// SetHavingExpr sets the havingExpr rule contexts.
	SetHavingExpr(IExpressionContext)


	// Getter signatures
	HAVING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	havingExpr IExpressionContext 
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) GetHavingExpr() IExpressionContext { return s.havingExpr }


func (s *HavingClauseContext) SetHavingExpr(v IExpressionContext) { s.havingExpr = v }


func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(MySqlParserHAVING, 0)
}

func (s *HavingClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, MySqlParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4280)
		p.Match(MySqlParserHAVING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4281)

		var _x = p.expression(0)

		localctx.(*HavingClauseContext).havingExpr = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	AllWindowName() []IWindowNameContext
	WindowName(i int) IWindowNameContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllWindowSpec() []IWindowSpecContext
	WindowSpec(i int) IWindowSpecContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserWINDOW, 0)
}

func (s *WindowClauseContext) AllWindowName() []IWindowNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowNameContext); ok {
			len++
		}
	}

	tst := make([]IWindowNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowNameContext); ok {
			tst[i] = t.(IWindowNameContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowName(i int) IWindowNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowClauseContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAS)
}

func (s *WindowClauseContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, i)
}

func (s *WindowClauseContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *WindowClauseContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *WindowClauseContext) AllWindowSpec() []IWindowSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowSpecContext); ok {
			len++
		}
	}

	tst := make([]IWindowSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowSpecContext); ok {
			tst[i] = t.(IWindowSpecContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowSpec(i int) IWindowSpecContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowClauseContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *WindowClauseContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *WindowClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WindowClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (s *WindowClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWindowClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, MySqlParserRULE_windowClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4283)
		p.Match(MySqlParserWINDOW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4284)
		p.WindowName()
	}
	{
		p.SetState(4285)
		p.Match(MySqlParserAS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4286)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4287)
		p.WindowSpec()
	}
	{
		p.SetState(4288)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4289)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4290)
				p.WindowName()
			}
			{
				p.SetState(4291)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4292)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4293)
				p.WindowSpec()
			}
			{
				p.SetState(4294)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(4300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroupByItemContext is an interface to support dynamic dispatch.
type IGroupByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token 


	// SetOrder sets the order token.
	SetOrder(antlr.Token) 


	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsGroupByItemContext differentiates from other interfaces.
	IsGroupByItemContext()
}

type GroupByItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	order antlr.Token
}

func NewEmptyGroupByItemContext() *GroupByItemContext {
	var p = new(GroupByItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByItem
	return p
}

func InitEmptyGroupByItemContext(p *GroupByItemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByItem
}

func (*GroupByItemContext) IsGroupByItemContext() {}

func NewGroupByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByItemContext {
	var p = new(GroupByItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_groupByItem

	return p
}

func (s *GroupByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByItemContext) GetOrder() antlr.Token { return s.order }


func (s *GroupByItemContext) SetOrder(v antlr.Token) { s.order = v }


func (s *GroupByItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *GroupByItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *GroupByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GroupByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGroupByItem(s)
	}
}

func (s *GroupByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGroupByItem(s)
	}
}

func (s *GroupByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGroupByItem(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) GroupByItem() (localctx IGroupByItemContext) {
	localctx = NewGroupByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, MySqlParserRULE_groupByItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4301)
		p.expression(0)
	}
	p.SetState(4303)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 631, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4302)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GroupByItemContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GroupByItemContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitClauseAtomContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitClauseAtomContext


	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitClauseAtomContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitClauseAtomContext)


	// Getter signatures
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	AllLimitClauseAtom() []ILimitClauseAtomContext
	LimitClauseAtom(i int) ILimitClauseAtomContext
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	offset ILimitClauseAtomContext 
	limit ILimitClauseAtomContext 
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() ILimitClauseAtomContext { return s.offset }

func (s *LimitClauseContext) GetLimit() ILimitClauseAtomContext { return s.limit }


func (s *LimitClauseContext) SetOffset(v ILimitClauseAtomContext) { s.offset = v }

func (s *LimitClauseContext) SetLimit(v ILimitClauseAtomContext) { s.limit = v }


func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *LimitClauseContext) AllLimitClauseAtom() []ILimitClauseAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			len++
		}
	}

	tst := make([]ILimitClauseAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitClauseAtomContext); ok {
			tst[i] = t.(ILimitClauseAtomContext)
			i++
		}
	}

	return tst
}

func (s *LimitClauseContext) LimitClauseAtom(i int) ILimitClauseAtomContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, MySqlParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4305)
		p.Match(MySqlParserLIMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 633, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4309)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 632, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4306)

				var _x = p.LimitClauseAtom()


				localctx.(*LimitClauseContext).offset = _x
			}
			{
				p.SetState(4307)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(4311)

			var _x = p.LimitClauseAtom()


			localctx.(*LimitClauseContext).limit = _x
		}


	case 2:
		{
			p.SetState(4312)

			var _x = p.LimitClauseAtom()


			localctx.(*LimitClauseContext).limit = _x
		}
		{
			p.SetState(4313)
			p.Match(MySqlParserOFFSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4314)

			var _x = p.LimitClauseAtom()


			localctx.(*LimitClauseContext).offset = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILimitClauseAtomContext is an interface to support dynamic dispatch.
type ILimitClauseAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsLimitClauseAtomContext differentiates from other interfaces.
	IsLimitClauseAtomContext()
}

type LimitClauseAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseAtomContext() *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
	return p
}

func InitEmptyLimitClauseAtomContext(p *LimitClauseAtomContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
}

func (*LimitClauseAtomContext) IsLimitClauseAtomContext() {}

func NewLimitClauseAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClauseAtom

	return p
}

func (s *LimitClauseAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseAtomContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitClauseAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *LimitClauseAtomContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *LimitClauseAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LimitClauseAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClauseAtom(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LimitClauseAtom() (localctx ILimitClauseAtomContext) {
	localctx = NewLimitClauseAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, MySqlParserRULE_limitClauseAtom)
	p.SetState(4321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4318)
			p.DecimalLiteral()
		}


	case MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4319)
			p.MysqlVariable()
		}


	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4320)
			p.SimpleId()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStartTransactionContext is an interface to support dynamic dispatch.
type IStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionMode() []ITransactionModeContext
	TransactionMode(i int) ITransactionModeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartTransactionContext differentiates from other interfaces.
	IsStartTransactionContext()
}

type StartTransactionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartTransactionContext() *StartTransactionContext {
	var p = new(StartTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startTransaction
	return p
}

func InitEmptyStartTransactionContext(p *StartTransactionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startTransaction
}

func (*StartTransactionContext) IsStartTransactionContext() {}

func NewStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartTransactionContext {
	var p = new(StartTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startTransaction

	return p
}

func (s *StartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StartTransactionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

func (s *StartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) StartTransaction() (localctx IStartTransactionContext) {
	localctx = NewStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, MySqlParserRULE_startTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4323)
		p.Match(MySqlParserSTART)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4324)
		p.Match(MySqlParserTRANSACTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4333)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 636, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4325)
			p.TransactionMode()
		}
		p.SetState(4330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(4326)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4327)
				p.TransactionMode()
			}


			p.SetState(4332)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBeginWorkContext is an interface to support dynamic dispatch.
type IBeginWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode
	ProxyHint() IProxyHintContext

	// IsBeginWorkContext differentiates from other interfaces.
	IsBeginWorkContext()
}

type BeginWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginWorkContext() *BeginWorkContext {
	var p = new(BeginWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_beginWork
	return p
}

func InitEmptyBeginWorkContext(p *BeginWorkContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_beginWork
}

func (*BeginWorkContext) IsBeginWorkContext() {}

func NewBeginWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginWorkContext {
	var p = new(BeginWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_beginWork

	return p
}

func (s *BeginWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginWorkContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *BeginWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *BeginWorkContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *BeginWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BeginWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBeginWork(s)
	}
}

func (s *BeginWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBeginWork(s)
	}
}

func (s *BeginWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBeginWork(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) BeginWork() (localctx IBeginWorkContext) {
	localctx = NewBeginWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, MySqlParserRULE_beginWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4335)
		p.Match(MySqlParserBEGIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWORK {
		{
			p.SetState(4336)
			p.Match(MySqlParserWORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(4339)
			p.ProxyHint()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommitWorkContext is an interface to support dynamic dispatch.
type ICommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token 

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token 


	// SetNochain sets the nochain token.
	SetNochain(antlr.Token) 

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token) 


	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitWorkContext differentiates from other interfaces.
	IsCommitWorkContext()
}

type CommitWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	nochain antlr.Token
	norelease antlr.Token
}

func NewEmptyCommitWorkContext() *CommitWorkContext {
	var p = new(CommitWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commitWork
	return p
}

func InitEmptyCommitWorkContext(p *CommitWorkContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commitWork
}

func (*CommitWorkContext) IsCommitWorkContext() {}

func NewCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitWorkContext {
	var p = new(CommitWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_commitWork

	return p
}

func (s *CommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *CommitWorkContext) GetNorelease() antlr.Token { return s.norelease }


func (s *CommitWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *CommitWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }


func (s *CommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *CommitWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *CommitWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *CommitWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *CommitWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *CommitWorkContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *CommitWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNO)
}

func (s *CommitWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, i)
}

func (s *CommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommitWork(s)
	}
}

func (s *CommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommitWork(s)
	}
}

func (s *CommitWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCommitWork(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CommitWork() (localctx ICommitWorkContext) {
	localctx = NewCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, MySqlParserRULE_commitWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4342)
		p.Match(MySqlParserCOMMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWORK {
		{
			p.SetState(4343)
			p.Match(MySqlParserWORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserAND {
		{
			p.SetState(4346)
			p.Match(MySqlParserAND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNO {
			{
				p.SetState(4347)

				var _m = p.Match(MySqlParserNO)

				localctx.(*CommitWorkContext).nochain = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4350)
			p.Match(MySqlParserCHAIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4357)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 643, p.GetParserRuleContext()) == 1 {
		p.SetState(4354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNO {
			{
				p.SetState(4353)

				var _m = p.Match(MySqlParserNO)

				localctx.(*CommitWorkContext).norelease = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4356)
			p.Match(MySqlParserRELEASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(4359)
			p.ProxyHint()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollbackWorkContext is an interface to support dynamic dispatch.
type IRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token 

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token 


	// SetNochain sets the nochain token.
	SetNochain(antlr.Token) 

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token) 


	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackWorkContext differentiates from other interfaces.
	IsRollbackWorkContext()
}

type RollbackWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	nochain antlr.Token
	norelease antlr.Token
}

func NewEmptyRollbackWorkContext() *RollbackWorkContext {
	var p = new(RollbackWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackWork
	return p
}

func InitEmptyRollbackWorkContext(p *RollbackWorkContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackWork
}

func (*RollbackWorkContext) IsRollbackWorkContext() {}

func NewRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackWorkContext {
	var p = new(RollbackWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_rollbackWork

	return p
}

func (s *RollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *RollbackWorkContext) GetNorelease() antlr.Token { return s.norelease }


func (s *RollbackWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *RollbackWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }


func (s *RollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *RollbackWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *RollbackWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *RollbackWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *RollbackWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *RollbackWorkContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *RollbackWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNO)
}

func (s *RollbackWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, i)
}

func (s *RollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRollbackWork(s)
	}
}

func (s *RollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRollbackWork(s)
	}
}

func (s *RollbackWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRollbackWork(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RollbackWork() (localctx IRollbackWorkContext) {
	localctx = NewRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, MySqlParserRULE_rollbackWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4362)
		p.Match(MySqlParserROLLBACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWORK {
		{
			p.SetState(4363)
			p.Match(MySqlParserWORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserAND {
		{
			p.SetState(4366)
			p.Match(MySqlParserAND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNO {
			{
				p.SetState(4367)

				var _m = p.Match(MySqlParserNO)

				localctx.(*RollbackWorkContext).nochain = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4370)
			p.Match(MySqlParserCHAIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4377)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 649, p.GetParserRuleContext()) == 1 {
		p.SetState(4374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNO {
			{
				p.SetState(4373)

				var _m = p.Match(MySqlParserNO)

				localctx.(*RollbackWorkContext).norelease = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4376)
			p.Match(MySqlParserRELEASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMENT_START {
		{
			p.SetState(4379)
			p.ProxyHint()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISavepointStatementContext is an interface to support dynamic dispatch.
type ISavepointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsSavepointStatementContext differentiates from other interfaces.
	IsSavepointStatementContext()
}

type SavepointStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointStatementContext() *SavepointStatementContext {
	var p = new(SavepointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_savepointStatement
	return p
}

func InitEmptySavepointStatementContext(p *SavepointStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_savepointStatement
}

func (*SavepointStatementContext) IsSavepointStatementContext() {}

func NewSavepointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointStatementContext {
	var p = new(SavepointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_savepointStatement

	return p
}

func (s *SavepointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *SavepointStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SavepointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SavepointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSavepointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SavepointStatement() (localctx ISavepointStatementContext) {
	localctx = NewSavepointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, MySqlParserRULE_savepointStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4382)
		p.Match(MySqlParserSAVEPOINT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4383)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	TO() antlr.TerminalNode
	Uid() IUidContext
	WORK() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *RollbackStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RollbackStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *RollbackStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRollbackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, MySqlParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4385)
		p.Match(MySqlParserROLLBACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserWORK {
		{
			p.SetState(4386)
			p.Match(MySqlParserWORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4389)
		p.Match(MySqlParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4391)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 652, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4390)
			p.Match(MySqlParserSAVEPOINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4393)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReleaseStatementContext is an interface to support dynamic dispatch.
type IReleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELEASE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsReleaseStatementContext differentiates from other interfaces.
	IsReleaseStatementContext()
}

type ReleaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReleaseStatementContext() *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_releaseStatement
	return p
}

func InitEmptyReleaseStatementContext(p *ReleaseStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_releaseStatement
}

func (*ReleaseStatementContext) IsReleaseStatementContext() {}

func NewReleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_releaseStatement

	return p
}

func (s *ReleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReleaseStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *ReleaseStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *ReleaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ReleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReleaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ReleaseStatement() (localctx IReleaseStatementContext) {
	localctx = NewReleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, MySqlParserRULE_releaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4395)
		p.Match(MySqlParserRELEASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4396)
		p.Match(MySqlParserSAVEPOINT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4397)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILockTablesContext is an interface to support dynamic dispatch.
type ILockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	AllLockTableElement() []ILockTableElementContext
	LockTableElement(i int) ILockTableElementContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext

	// IsLockTablesContext differentiates from other interfaces.
	IsLockTablesContext()
}

type LockTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTablesContext() *LockTablesContext {
	var p = new(LockTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTables
	return p
}

func InitEmptyLockTablesContext(p *LockTablesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTables
}

func (*LockTablesContext) IsLockTablesContext() {}

func NewLockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTablesContext {
	var p = new(LockTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockTables

	return p
}

func (s *LockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTablesContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockTablesContext) AllLockTableElement() []ILockTableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockTableElementContext); ok {
			len++
		}
	}

	tst := make([]ILockTableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockTableElementContext); ok {
			tst[i] = t.(ILockTableElementContext)
			i++
		}
	}

	return tst
}

func (s *LockTablesContext) LockTableElement(i int) ILockTableElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTableElementContext)
}

func (s *LockTablesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *LockTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LockTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LockTablesContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *LockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockTables(s)
	}
}

func (s *LockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockTables(s)
	}
}

func (s *LockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockTables(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LockTables() (localctx ILockTablesContext) {
	localctx = NewLockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, MySqlParserRULE_lockTables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4399)
		p.Match(MySqlParserLOCK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4400)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4401)
		p.LockTableElement()
	}
	p.SetState(4406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(4402)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4403)
			p.LockTableElement()
		}


		p.SetState(4408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNOWAIT || _la == MySqlParserWAIT {
		{
			p.SetState(4409)
			p.WaitNowaitClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnlockTablesContext is an interface to support dynamic dispatch.
type IUnlockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNLOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsUnlockTablesContext differentiates from other interfaces.
	IsUnlockTablesContext()
}

type UnlockTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlockTablesContext() *UnlockTablesContext {
	var p = new(UnlockTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unlockTables
	return p
}

func InitEmptyUnlockTablesContext(p *UnlockTablesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unlockTables
}

func (*UnlockTablesContext) IsUnlockTablesContext() {}

func NewUnlockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlockTablesContext {
	var p = new(UnlockTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unlockTables

	return p
}

func (s *UnlockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlockTablesContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNLOCK, 0)
}

func (s *UnlockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *UnlockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnlockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnlockTables(s)
	}
}

func (s *UnlockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnlockTables(s)
	}
}

func (s *UnlockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnlockTables(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UnlockTables() (localctx IUnlockTablesContext) {
	localctx = NewUnlockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, MySqlParserRULE_unlockTables)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4412)
		p.Match(MySqlParserUNLOCK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4413)
		p.Match(MySqlParserTABLES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetAutocommitStatementContext is an interface to support dynamic dispatch.
type ISetAutocommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutocommitValue returns the autocommitValue token.
	GetAutocommitValue() antlr.Token 


	// SetAutocommitValue sets the autocommitValue token.
	SetAutocommitValue(antlr.Token) 


	// Getter signatures
	SET() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsSetAutocommitStatementContext differentiates from other interfaces.
	IsSetAutocommitStatementContext()
}

type SetAutocommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	autocommitValue antlr.Token
}

func NewEmptySetAutocommitStatementContext() *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement
	return p
}

func InitEmptySetAutocommitStatementContext(p *SetAutocommitStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement
}

func (*SetAutocommitStatementContext) IsSetAutocommitStatementContext() {}

func NewSetAutocommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement

	return p
}

func (s *SetAutocommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAutocommitStatementContext) GetAutocommitValue() antlr.Token { return s.autocommitValue }


func (s *SetAutocommitStatementContext) SetAutocommitValue(v antlr.Token) { s.autocommitValue = v }


func (s *SetAutocommitStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetAutocommitStatementContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOCOMMIT, 0)
}

func (s *SetAutocommitStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SetAutocommitStatementContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetAutocommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetAutocommitStatement(s)
	}
}

func (s *SetAutocommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetAutocommitStatement(s)
	}
}

func (s *SetAutocommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetAutocommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SetAutocommitStatement() (localctx ISetAutocommitStatementContext) {
	localctx = NewSetAutocommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, MySqlParserRULE_setAutocommitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4415)
		p.Match(MySqlParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4416)
		p.Match(MySqlParserAUTOCOMMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4417)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4418)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SetAutocommitStatementContext).autocommitValue = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SetAutocommitStatementContext).autocommitValue = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetTransactionStatementContext is an interface to support dynamic dispatch.
type ISetTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTransactionContext returns the transactionContext token.
	GetTransactionContext() antlr.Token 


	// SetTransactionContext sets the transactionContext token.
	SetTransactionContext(antlr.Token) 


	// Getter signatures
	SET() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionOption() []ITransactionOptionContext
	TransactionOption(i int) ITransactionOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsSetTransactionStatementContext differentiates from other interfaces.
	IsSetTransactionStatementContext()
}

type SetTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	transactionContext antlr.Token
}

func NewEmptySetTransactionStatementContext() *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setTransactionStatement
	return p
}

func InitEmptySetTransactionStatementContext(p *SetTransactionStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setTransactionStatement
}

func (*SetTransactionStatementContext) IsSetTransactionStatementContext() {}

func NewSetTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setTransactionStatement

	return p
}

func (s *SetTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTransactionStatementContext) GetTransactionContext() antlr.Token { return s.transactionContext }


func (s *SetTransactionStatementContext) SetTransactionContext(v antlr.Token) { s.transactionContext = v }


func (s *SetTransactionStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *SetTransactionStatementContext) AllTransactionOption() []ITransactionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			len++
		}
	}

	tst := make([]ITransactionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionOptionContext); ok {
			tst[i] = t.(ITransactionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SetTransactionStatementContext) TransactionOption(i int) ITransactionOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionOptionContext)
}

func (s *SetTransactionStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetTransactionStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetTransactionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *SetTransactionStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *SetTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetTransactionStatement(s)
	}
}

func (s *SetTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetTransactionStatement(s)
	}
}

func (s *SetTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SetTransactionStatement() (localctx ISetTransactionStatementContext) {
	localctx = NewSetTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, MySqlParserRULE_setTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4420)
		p.Match(MySqlParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserGLOBAL || _la == MySqlParserSESSION {
		{
			p.SetState(4421)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SetTransactionStatementContext).transactionContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserGLOBAL || _la == MySqlParserSESSION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SetTransactionStatementContext).transactionContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4424)
		p.Match(MySqlParserTRANSACTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4425)
		p.TransactionOption()
	}
	p.SetState(4430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(4426)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4427)
			p.TransactionOption()
		}


		p.SetState(4432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionMode
	return p
}

func InitEmptyTransactionModeContext(p *TransactionModeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionMode
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *TransactionModeContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSISTENT, 0)
}

func (s *TransactionModeContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSNAPSHOT, 0)
}

func (s *TransactionModeContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *TransactionModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TransactionModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionMode(s)
	}
}

func (s *TransactionModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionMode(s)
	}
}

func (s *TransactionModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionMode(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, MySqlParserRULE_transactionMode)
	p.SetState(4440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 657, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4433)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4434)
			p.Match(MySqlParserCONSISTENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4435)
			p.Match(MySqlParserSNAPSHOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4436)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4437)
			p.Match(MySqlParserWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4438)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4439)
			p.Match(MySqlParserONLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILockTableElementContext is an interface to support dynamic dispatch.
type ILockTableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	LockAction() ILockActionContext
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLockTableElementContext differentiates from other interfaces.
	IsLockTableElementContext()
}

type LockTableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTableElementContext() *LockTableElementContext {
	var p = new(LockTableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTableElement
	return p
}

func InitEmptyLockTableElementContext(p *LockTableElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTableElement
}

func (*LockTableElementContext) IsLockTableElementContext() {}

func NewLockTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTableElementContext {
	var p = new(LockTableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockTableElement

	return p
}

func (s *LockTableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTableElementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LockTableElementContext) LockAction() ILockActionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockActionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockActionContext)
}

func (s *LockTableElementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LockTableElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *LockTableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LockTableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockTableElement(s)
	}
}

func (s *LockTableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockTableElement(s)
	}
}

func (s *LockTableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LockTableElement() (localctx ILockTableElementContext) {
	localctx = NewLockTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, MySqlParserRULE_lockTableElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4442)
		p.TableName()
	}
	p.SetState(4447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513126400) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		p.SetState(4444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(4443)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4446)
			p.Uid()
		}

	}
	{
		p.SetState(4449)
		p.LockAction()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILockActionContext is an interface to support dynamic dispatch.
type ILockActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLockActionContext differentiates from other interfaces.
	IsLockActionContext()
}

type LockActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockActionContext() *LockActionContext {
	var p = new(LockActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockAction
	return p
}

func InitEmptyLockActionContext(p *LockActionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockAction
}

func (*LockActionContext) IsLockActionContext() {}

func NewLockActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockActionContext {
	var p = new(LockActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockAction

	return p
}

func (s *LockActionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockActionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *LockActionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LockActionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *LockActionContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LockActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LockActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockAction(s)
	}
}

func (s *LockActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockAction(s)
	}
}

func (s *LockActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockAction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LockAction() (localctx ILockActionContext) {
	localctx = NewLockActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, MySqlParserRULE_lockAction)
	var _la int

	p.SetState(4459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4451)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLOCAL {
			{
				p.SetState(4452)
				p.Match(MySqlParserLOCAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case MySqlParserLOW_PRIORITY, MySqlParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLOW_PRIORITY {
			{
				p.SetState(4455)
				p.Match(MySqlParserLOW_PRIORITY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4458)
			p.Match(MySqlParserWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITransactionOptionContext is an interface to support dynamic dispatch.
type ITransactionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	TransactionLevel() ITransactionLevelContext
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionOptionContext differentiates from other interfaces.
	IsTransactionOptionContext()
}

type TransactionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionOptionContext() *TransactionOptionContext {
	var p = new(TransactionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionOption
	return p
}

func InitEmptyTransactionOptionContext(p *TransactionOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionOption
}

func (*TransactionOptionContext) IsTransactionOptionContext() {}

func NewTransactionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionOptionContext {
	var p = new(TransactionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionOption

	return p
}

func (s *TransactionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionOptionContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserISOLATION, 0)
}

func (s *TransactionOptionContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *TransactionOptionContext) TransactionLevel() ITransactionLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelContext)
}

func (s *TransactionOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionOptionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *TransactionOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *TransactionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TransactionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionOption(s)
	}
}

func (s *TransactionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionOption(s)
	}
}

func (s *TransactionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TransactionOption() (localctx ITransactionOptionContext) {
	localctx = NewTransactionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, MySqlParserRULE_transactionOption)
	p.SetState(4468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 663, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4461)
			p.Match(MySqlParserISOLATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4462)
			p.Match(MySqlParserLEVEL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4463)
			p.TransactionLevel()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4464)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4465)
			p.Match(MySqlParserWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4466)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4467)
			p.Match(MySqlParserONLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITransactionLevelContext is an interface to support dynamic dispatch.
type ITransactionLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	READ() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelContext differentiates from other interfaces.
	IsTransactionLevelContext()
}

type TransactionLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelContext() *TransactionLevelContext {
	var p = new(TransactionLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevel
	return p
}

func InitEmptyTransactionLevelContext(p *TransactionLevelContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevel
}

func (*TransactionLevelContext) IsTransactionLevelContext() {}

func NewTransactionLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelContext {
	var p = new(TransactionLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionLevel

	return p
}

func (s *TransactionLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEATABLE, 0)
}

func (s *TransactionLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMITTED, 0)
}

func (s *TransactionLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMMITTED, 0)
}

func (s *TransactionLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIALIZABLE, 0)
}

func (s *TransactionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TransactionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionLevel(s)
	}
}

func (s *TransactionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionLevel(s)
	}
}

func (s *TransactionLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionLevel(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TransactionLevel() (localctx ITransactionLevelContext) {
	localctx = NewTransactionLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, MySqlParserRULE_transactionLevel)
	p.SetState(4477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 664, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4470)
			p.Match(MySqlParserREPEATABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4471)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4472)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4473)
			p.Match(MySqlParserCOMMITTED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4474)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4475)
			p.Match(MySqlParserUNCOMMITTED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4476)
			p.Match(MySqlParserSERIALIZABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChangeMasterContext is an interface to support dynamic dispatch.
type IChangeMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllMasterOption() []IMasterOptionContext
	MasterOption(i int) IMasterOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsChangeMasterContext differentiates from other interfaces.
	IsChangeMasterContext()
}

type ChangeMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterContext() *ChangeMasterContext {
	var p = new(ChangeMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeMaster
	return p
}

func InitEmptyChangeMasterContext(p *ChangeMasterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeMaster
}

func (*ChangeMasterContext) IsChangeMasterContext() {}

func NewChangeMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterContext {
	var p = new(ChangeMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_changeMaster

	return p
}

func (s *ChangeMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *ChangeMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ChangeMasterContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *ChangeMasterContext) AllMasterOption() []IMasterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterOptionContext); ok {
			len++
		}
	}

	tst := make([]IMasterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterOptionContext); ok {
			tst[i] = t.(IMasterOptionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeMasterContext) MasterOption(i int) IMasterOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterOptionContext)
}

func (s *ChangeMasterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ChangeMasterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ChangeMasterContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ChangeMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ChangeMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChangeMaster(s)
	}
}

func (s *ChangeMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChangeMaster(s)
	}
}

func (s *ChangeMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChangeMaster(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ChangeMaster() (localctx IChangeMasterContext) {
	localctx = NewChangeMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, MySqlParserRULE_changeMaster)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4479)
		p.Match(MySqlParserCHANGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4480)
		p.Match(MySqlParserMASTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4481)
		p.Match(MySqlParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4482)
		p.MasterOption()
	}
	p.SetState(4487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(4483)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4484)
			p.MasterOption()
		}


		p.SetState(4489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFOR {
		{
			p.SetState(4490)
			p.ChannelOption()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChangeReplicationFilterContext is an interface to support dynamic dispatch.
type IChangeReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	AllReplicationFilter() []IReplicationFilterContext
	ReplicationFilter(i int) IReplicationFilterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChangeReplicationFilterContext differentiates from other interfaces.
	IsChangeReplicationFilterContext()
}

type ChangeReplicationFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeReplicationFilterContext() *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter
	return p
}

func InitEmptyChangeReplicationFilterContext(p *ChangeReplicationFilterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter
}

func (*ChangeReplicationFilterContext) IsChangeReplicationFilterContext() {}

func NewChangeReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter

	return p
}

func (s *ChangeReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeReplicationFilterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *ChangeReplicationFilterContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *ChangeReplicationFilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILTER, 0)
}

func (s *ChangeReplicationFilterContext) AllReplicationFilter() []IReplicationFilterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			len++
		}
	}

	tst := make([]IReplicationFilterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplicationFilterContext); ok {
			tst[i] = t.(IReplicationFilterContext)
			i++
		}
	}

	return tst
}

func (s *ChangeReplicationFilterContext) ReplicationFilter(i int) IReplicationFilterContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationFilterContext)
}

func (s *ChangeReplicationFilterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ChangeReplicationFilterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ChangeReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ChangeReplicationFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChangeReplicationFilter(s)
	}
}

func (s *ChangeReplicationFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChangeReplicationFilter(s)
	}
}

func (s *ChangeReplicationFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChangeReplicationFilter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ChangeReplicationFilter() (localctx IChangeReplicationFilterContext) {
	localctx = NewChangeReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, MySqlParserRULE_changeReplicationFilter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4493)
		p.Match(MySqlParserCHANGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4494)
		p.Match(MySqlParserREPLICATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4495)
		p.Match(MySqlParserFILTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4496)
		p.ReplicationFilter()
	}
	p.SetState(4501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(4497)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4498)
			p.ReplicationFilter()
		}


		p.SetState(4503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPurgeBinaryLogsContext is an interface to support dynamic dispatch.
type IPurgeBinaryLogsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPurgeFormat returns the purgeFormat token.
	GetPurgeFormat() antlr.Token 

	// GetFileName returns the fileName token.
	GetFileName() antlr.Token 

	// GetTimeValue returns the timeValue token.
	GetTimeValue() antlr.Token 


	// SetPurgeFormat sets the purgeFormat token.
	SetPurgeFormat(antlr.Token) 

	// SetFileName sets the fileName token.
	SetFileName(antlr.Token) 

	// SetTimeValue sets the timeValue token.
	SetTimeValue(antlr.Token) 


	// Getter signatures
	PURGE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsPurgeBinaryLogsContext differentiates from other interfaces.
	IsPurgeBinaryLogsContext()
}

type PurgeBinaryLogsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	purgeFormat antlr.Token
	fileName antlr.Token
	timeValue antlr.Token
}

func NewEmptyPurgeBinaryLogsContext() *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs
	return p
}

func InitEmptyPurgeBinaryLogsContext(p *PurgeBinaryLogsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs
}

func (*PurgeBinaryLogsContext) IsPurgeBinaryLogsContext() {}

func NewPurgeBinaryLogsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs

	return p
}

func (s *PurgeBinaryLogsContext) GetParser() antlr.Parser { return s.parser }

func (s *PurgeBinaryLogsContext) GetPurgeFormat() antlr.Token { return s.purgeFormat }

func (s *PurgeBinaryLogsContext) GetFileName() antlr.Token { return s.fileName }

func (s *PurgeBinaryLogsContext) GetTimeValue() antlr.Token { return s.timeValue }


func (s *PurgeBinaryLogsContext) SetPurgeFormat(v antlr.Token) { s.purgeFormat = v }

func (s *PurgeBinaryLogsContext) SetFileName(v antlr.Token) { s.fileName = v }

func (s *PurgeBinaryLogsContext) SetTimeValue(v antlr.Token) { s.timeValue = v }


func (s *PurgeBinaryLogsContext) PURGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPURGE, 0)
}

func (s *PurgeBinaryLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *PurgeBinaryLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *PurgeBinaryLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *PurgeBinaryLogsContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *PurgeBinaryLogsContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEFORE, 0)
}

func (s *PurgeBinaryLogsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PurgeBinaryLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PurgeBinaryLogsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PurgeBinaryLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPurgeBinaryLogs(s)
	}
}

func (s *PurgeBinaryLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPurgeBinaryLogs(s)
	}
}

func (s *PurgeBinaryLogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPurgeBinaryLogs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PurgeBinaryLogs() (localctx IPurgeBinaryLogsContext) {
	localctx = NewPurgeBinaryLogsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, MySqlParserRULE_purgeBinaryLogs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4504)
		p.Match(MySqlParserPURGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4505)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PurgeBinaryLogsContext).purgeFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBINARY || _la == MySqlParserMASTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PurgeBinaryLogsContext).purgeFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4506)
		p.Match(MySqlParserLOGS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserTO:
		{
			p.SetState(4507)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4508)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).fileName = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBEFORE:
		{
			p.SetState(4509)
			p.Match(MySqlParserBEFORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4510)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).timeValue = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResetMasterContext is an interface to support dynamic dispatch.
type IResetMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	MASTER() antlr.TerminalNode

	// IsResetMasterContext differentiates from other interfaces.
	IsResetMasterContext()
}

type ResetMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetMasterContext() *ResetMasterContext {
	var p = new(ResetMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetMaster
	return p
}

func InitEmptyResetMasterContext(p *ResetMasterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetMaster
}

func (*ResetMasterContext) IsResetMasterContext() {}

func NewResetMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetMasterContext {
	var p = new(ResetMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetMaster

	return p
}

func (s *ResetMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetMasterContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ResetMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResetMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetMaster(s)
	}
}

func (s *ResetMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetMaster(s)
	}
}

func (s *ResetMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResetMaster(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ResetMaster() (localctx IResetMasterContext) {
	localctx = NewResetMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, MySqlParserRULE_resetMaster)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4513)
		p.Match(MySqlParserRESET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4514)
		p.Match(MySqlParserMASTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResetSlaveContext is an interface to support dynamic dispatch.
type IResetSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsResetSlaveContext differentiates from other interfaces.
	IsResetSlaveContext()
}

type ResetSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetSlaveContext() *ResetSlaveContext {
	var p = new(ResetSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetSlave
	return p
}

func InitEmptyResetSlaveContext(p *ResetSlaveContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetSlave
}

func (*ResetSlaveContext) IsResetSlaveContext() {}

func NewResetSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetSlaveContext {
	var p = new(ResetSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetSlave

	return p
}

func (s *ResetSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetSlaveContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ResetSlaveContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ResetSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ResetSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResetSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetSlave(s)
	}
}

func (s *ResetSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetSlave(s)
	}
}

func (s *ResetSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResetSlave(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ResetSlave() (localctx IResetSlaveContext) {
	localctx = NewResetSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, MySqlParserRULE_resetSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4516)
		p.Match(MySqlParserRESET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4517)
		p.Match(MySqlParserSLAVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserALL {
		{
			p.SetState(4518)
			p.Match(MySqlParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(4522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFOR {
		{
			p.SetState(4521)
			p.ChannelOption()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStartSlaveContext is an interface to support dynamic dispatch.
type IStartSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	UNTIL() antlr.TerminalNode
	UntilOption() IUntilOptionContext
	AllConnectionOption() []IConnectionOptionContext
	ConnectionOption(i int) IConnectionOptionContext
	ChannelOption() IChannelOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartSlaveContext differentiates from other interfaces.
	IsStartSlaveContext()
}

type StartSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartSlaveContext() *StartSlaveContext {
	var p = new(StartSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startSlave
	return p
}

func InitEmptyStartSlaveContext(p *StartSlaveContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startSlave
}

func (*StartSlaveContext) IsStartSlaveContext() {}

func NewStartSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartSlaveContext {
	var p = new(StartSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startSlave

	return p
}

func (s *StartSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StartSlaveContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *StartSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StartSlaveContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *StartSlaveContext) UntilOption() IUntilOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUntilOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUntilOptionContext)
}

func (s *StartSlaveContext) AllConnectionOption() []IConnectionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			len++
		}
	}

	tst := make([]IConnectionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConnectionOptionContext); ok {
			tst[i] = t.(IConnectionOptionContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ConnectionOption(i int) IConnectionOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectionOptionContext)
}

func (s *StartSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *StartSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StartSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StartSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StartSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartSlave(s)
	}
}

func (s *StartSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartSlave(s)
	}
}

func (s *StartSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStartSlave(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) StartSlave() (localctx IStartSlaveContext) {
	localctx = NewStartSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, MySqlParserRULE_startSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4524)
		p.Match(MySqlParserSTART)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4525)
		p.Match(MySqlParserSLAVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD {
		{
			p.SetState(4526)
			p.ThreadType()
		}
		p.SetState(4531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(4527)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4528)
				p.ThreadType()
			}


			p.SetState(4533)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserUNTIL {
		{
			p.SetState(4536)
			p.Match(MySqlParserUNTIL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4537)
			p.UntilOption()
		}

	}
	p.SetState(4543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserDEFAULT_AUTH || _la == MySqlParserPASSWORD || _la == MySqlParserPLUGIN_DIR || _la == MySqlParserUSER {
		{
			p.SetState(4540)
			p.ConnectionOption()
		}


		p.SetState(4545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFOR {
		{
			p.SetState(4546)
			p.ChannelOption()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStopSlaveContext is an interface to support dynamic dispatch.
type IStopSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStopSlaveContext differentiates from other interfaces.
	IsStopSlaveContext()
}

type StopSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopSlaveContext() *StopSlaveContext {
	var p = new(StopSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopSlave
	return p
}

func InitEmptyStopSlaveContext(p *StopSlaveContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopSlave
}

func (*StopSlaveContext) IsStopSlaveContext() {}

func NewStopSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopSlaveContext {
	var p = new(StopSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stopSlave

	return p
}

func (s *StopSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StopSlaveContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *StopSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *StopSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StopSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StopSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StopSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StopSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StopSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStopSlave(s)
	}
}

func (s *StopSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStopSlave(s)
	}
}

func (s *StopSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStopSlave(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) StopSlave() (localctx IStopSlaveContext) {
	localctx = NewStopSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, MySqlParserRULE_stopSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4549)
		p.Match(MySqlParserSTOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4550)
		p.Match(MySqlParserSLAVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD {
		{
			p.SetState(4551)
			p.ThreadType()
		}
		p.SetState(4556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(4552)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4553)
				p.ThreadType()
			}


			p.SetState(4558)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStartGroupReplicationContext is an interface to support dynamic dispatch.
type IStartGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStartGroupReplicationContext differentiates from other interfaces.
	IsStartGroupReplicationContext()
}

type StartGroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartGroupReplicationContext() *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startGroupReplication
	return p
}

func InitEmptyStartGroupReplicationContext(p *StartGroupReplicationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startGroupReplication
}

func (*StartGroupReplicationContext) IsStartGroupReplicationContext() {}

func NewStartGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startGroupReplication

	return p
}

func (s *StartGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StartGroupReplicationContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *StartGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StartGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartGroupReplication(s)
	}
}

func (s *StartGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartGroupReplication(s)
	}
}

func (s *StartGroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStartGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) StartGroupReplication() (localctx IStartGroupReplicationContext) {
	localctx = NewStartGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, MySqlParserRULE_startGroupReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4561)
		p.Match(MySqlParserSTART)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4562)
		p.Match(MySqlParserGROUP_REPLICATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStopGroupReplicationContext is an interface to support dynamic dispatch.
type IStopGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStopGroupReplicationContext differentiates from other interfaces.
	IsStopGroupReplicationContext()
}

type StopGroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopGroupReplicationContext() *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopGroupReplication
	return p
}

func InitEmptyStopGroupReplicationContext(p *StopGroupReplicationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopGroupReplication
}

func (*StopGroupReplicationContext) IsStopGroupReplicationContext() {}

func NewStopGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stopGroupReplication

	return p
}

func (s *StopGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StopGroupReplicationContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *StopGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *StopGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StopGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStopGroupReplication(s)
	}
}

func (s *StopGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStopGroupReplication(s)
	}
}

func (s *StopGroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStopGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) StopGroupReplication() (localctx IStopGroupReplicationContext) {
	localctx = NewStopGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, MySqlParserRULE_stopGroupReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4564)
		p.Match(MySqlParserSTOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4565)
		p.Match(MySqlParserGROUP_REPLICATION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMasterOptionContext is an interface to support dynamic dispatch.
type IMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMasterOptionContext differentiates from other interfaces.
	IsMasterOptionContext()
}

type MasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterOptionContext() *MasterOptionContext {
	var p = new(MasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_masterOption
	return p
}

func InitEmptyMasterOptionContext(p *MasterOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_masterOption
}

func (*MasterOptionContext) IsMasterOptionContext() {}

func NewMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterOptionContext {
	var p = new(MasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_masterOption

	return p
}

func (s *MasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterOptionContext) CopyAll(ctx *MasterOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type MasterStringOptionContext struct {
	MasterOptionContext
}

func NewMasterStringOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterStringOptionContext {
	var p = new(MasterStringOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterStringOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterStringOptionContext) StringMasterOption() IStringMasterOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringMasterOptionContext)
}

func (s *MasterStringOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterStringOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *MasterStringOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterStringOption(s)
	}
}

func (s *MasterStringOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterStringOption(s)
	}
}

func (s *MasterStringOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterStringOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type MasterRealOptionContext struct {
	MasterOptionContext
}

func NewMasterRealOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterRealOptionContext {
	var p = new(MasterRealOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterRealOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterRealOptionContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *MasterRealOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterRealOptionContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}


func (s *MasterRealOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterRealOption(s)
	}
}

func (s *MasterRealOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterRealOption(s)
	}
}

func (s *MasterRealOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterRealOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type MasterBoolOptionContext struct {
	MasterOptionContext
	boolVal antlr.Token
}

func NewMasterBoolOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterBoolOptionContext {
	var p = new(MasterBoolOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}


func (s *MasterBoolOptionContext) GetBoolVal() antlr.Token { return s.boolVal }


func (s *MasterBoolOptionContext) SetBoolVal(v antlr.Token) { s.boolVal = v }

func (s *MasterBoolOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterBoolOptionContext) BoolMasterOption() IBoolMasterOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolMasterOptionContext)
}

func (s *MasterBoolOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterBoolOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *MasterBoolOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}


func (s *MasterBoolOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterBoolOption(s)
	}
}

func (s *MasterBoolOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterBoolOption(s)
	}
}

func (s *MasterBoolOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterBoolOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type MasterUidListOptionContext struct {
	MasterOptionContext
}

func NewMasterUidListOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterUidListOptionContext {
	var p = new(MasterUidListOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterUidListOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterUidListOptionContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE_SERVER_IDS, 0)
}

func (s *MasterUidListOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterUidListOptionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *MasterUidListOptionContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *MasterUidListOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MasterUidListOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *MasterUidListOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterUidListOption(s)
	}
}

func (s *MasterUidListOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterUidListOption(s)
	}
}

func (s *MasterUidListOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterUidListOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type MasterDecimalOptionContext struct {
	MasterOptionContext
}

func NewMasterDecimalOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterDecimalOptionContext {
	var p = new(MasterDecimalOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterDecimalOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterDecimalOptionContext) DecimalMasterOption() IDecimalMasterOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalMasterOptionContext)
}

func (s *MasterDecimalOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterDecimalOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *MasterDecimalOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterDecimalOption(s)
	}
}

func (s *MasterDecimalOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterDecimalOption(s)
	}
}

func (s *MasterDecimalOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterDecimalOption(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) MasterOption() (localctx IMasterOptionContext) {
	localctx = NewMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, MySqlParserRULE_masterOption)
	var _la int

	p.SetState(4596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserMASTER_BIND, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserRELAY_LOG_FILE:
		localctx = NewMasterStringOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4567)
			p.StringMasterOption()
		}
		{
			p.SetState(4568)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4569)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserRELAY_LOG_POS:
		localctx = NewMasterDecimalOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4571)
			p.DecimalMasterOption()
		}
		{
			p.SetState(4572)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4573)
			p.DecimalLiteral()
		}


	case MySqlParserMASTER_SSL_VERIFY_SERVER_CERT, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_SSL:
		localctx = NewMasterBoolOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4575)
			p.BoolMasterOption()
		}
		{
			p.SetState(4576)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4577)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*MasterBoolOptionContext).boolVal = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*MasterBoolOptionContext).boolVal = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case MySqlParserMASTER_HEARTBEAT_PERIOD:
		localctx = NewMasterRealOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4579)
			p.Match(MySqlParserMASTER_HEARTBEAT_PERIOD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4580)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4581)
			p.Match(MySqlParserREAL_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserIGNORE_SERVER_IDS:
		localctx = NewMasterUidListOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4582)
			p.Match(MySqlParserIGNORE_SERVER_IDS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4583)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4584)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
			{
				p.SetState(4585)
				p.Uid()
			}
			p.SetState(4590)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(4586)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(4587)
					p.Uid()
				}


				p.SetState(4592)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4595)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStringMasterOptionContext is an interface to support dynamic dispatch.
type IStringMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_BIND() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode

	// IsStringMasterOptionContext differentiates from other interfaces.
	IsStringMasterOptionContext()
}

type StringMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringMasterOptionContext() *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringMasterOption
	return p
}

func InitEmptyStringMasterOptionContext(p *StringMasterOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringMasterOption
}

func (*StringMasterOptionContext) IsStringMasterOptionContext() {}

func NewStringMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringMasterOption

	return p
}

func (s *StringMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringMasterOptionContext) MASTER_BIND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_BIND, 0)
}

func (s *StringMasterOptionContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HOST, 0)
}

func (s *StringMasterOptionContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_USER, 0)
}

func (s *StringMasterOptionContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PASSWORD, 0)
}

func (s *StringMasterOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CA, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CAPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CERT, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRL, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRLPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_KEY, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CIPHER, 0)
}

func (s *StringMasterOptionContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_TLS_VERSION, 0)
}

func (s *StringMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StringMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringMasterOption(s)
	}
}

func (s *StringMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringMasterOption(s)
	}
}

func (s *StringMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) StringMasterOption() (localctx IStringMasterOptionContext) {
	localctx = NewStringMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, MySqlParserRULE_stringMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4598)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMASTER_BIND || ((int64((_la - 482)) & ^0x3f) == 0 && ((int64(1) << (_la - 482)) & 65419) != 0) || _la == MySqlParserRELAY_LOG_FILE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDecimalMasterOptionContext is an interface to support dynamic dispatch.
type IDecimalMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_PORT() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode

	// IsDecimalMasterOptionContext differentiates from other interfaces.
	IsDecimalMasterOptionContext()
}

type DecimalMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalMasterOptionContext() *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalMasterOption
	return p
}

func InitEmptyDecimalMasterOptionContext(p *DecimalMasterOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalMasterOption
}

func (*DecimalMasterOptionContext) IsDecimalMasterOptionContext() {}

func NewDecimalMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalMasterOption

	return p
}

func (s *DecimalMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalMasterOptionContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PORT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_CONNECT_RETRY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_RETRY_COUNT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_DELAY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecimalMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDecimalMasterOption(s)
	}
}

func (s *DecimalMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDecimalMasterOption(s)
	}
}

func (s *DecimalMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDecimalMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DecimalMasterOption() (localctx IDecimalMasterOptionContext) {
	localctx = NewDecimalMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, MySqlParserRULE_decimalMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4600)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 479)) & ^0x3f) == 0 && ((int64(1) << (_la - 479)) & 419) != 0) || _la == MySqlParserRELAY_LOG_POS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBoolMasterOptionContext is an interface to support dynamic dispatch.
type IBoolMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode

	// IsBoolMasterOptionContext differentiates from other interfaces.
	IsBoolMasterOptionContext()
}

type BoolMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolMasterOptionContext() *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_boolMasterOption
	return p
}

func InitEmptyBoolMasterOptionContext(p *BoolMasterOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_boolMasterOption
}

func (*BoolMasterOptionContext) IsBoolMasterOptionContext() {}

func NewBoolMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_boolMasterOption

	return p
}

func (s *BoolMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolMasterOptionContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_AUTO_POSITION, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_VERIFY_SERVER_CERT, 0)
}

func (s *BoolMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BoolMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBoolMasterOption(s)
	}
}

func (s *BoolMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBoolMasterOption(s)
	}
}

func (s *BoolMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBoolMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) BoolMasterOption() (localctx IBoolMasterOptionContext) {
	localctx = NewBoolMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, MySqlParserRULE_boolMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4602)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMASTER_SSL_VERIFY_SERVER_CERT || _la == MySqlParserMASTER_AUTO_POSITION || _la == MySqlParserMASTER_SSL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChannelOptionContext is an interface to support dynamic dispatch.
type IChannelOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsChannelOptionContext differentiates from other interfaces.
	IsChannelOptionContext()
}

type ChannelOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelOptionContext() *ChannelOptionContext {
	var p = new(ChannelOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_channelOption
	return p
}

func InitEmptyChannelOptionContext(p *ChannelOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_channelOption
}

func (*ChannelOptionContext) IsChannelOptionContext() {}

func NewChannelOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelOptionContext {
	var p = new(ChannelOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_channelOption

	return p
}

func (s *ChannelOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ChannelOptionContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *ChannelOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ChannelOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ChannelOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChannelOption(s)
	}
}

func (s *ChannelOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChannelOption(s)
	}
}

func (s *ChannelOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChannelOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ChannelOption() (localctx IChannelOptionContext) {
	localctx = NewChannelOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, MySqlParserRULE_channelOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4604)
		p.Match(MySqlParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4605)
		p.Match(MySqlParserCHANNEL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4606)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReplicationFilterContext is an interface to support dynamic dispatch.
type IReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReplicationFilterContext differentiates from other interfaces.
	IsReplicationFilterContext()
}

type ReplicationFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationFilterContext() *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationFilter
	return p
}

func InitEmptyReplicationFilterContext(p *ReplicationFilterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationFilter
}

func (*ReplicationFilterContext) IsReplicationFilterContext() {}

func NewReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replicationFilter

	return p
}

func (s *ReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationFilterContext) CopyAll(ctx *ReplicationFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type WildIgnoreTableReplicationContext struct {
	ReplicationFilterContext
}

func NewWildIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildIgnoreTableReplicationContext {
	var p = new(WildIgnoreTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildIgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildIgnoreTableReplicationContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *WildIgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *WildIgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *WildIgnoreTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildIgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *WildIgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWildIgnoreTableReplication(s)
	}
}

func (s *WildIgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWildIgnoreTableReplication(s)
	}
}

func (s *WildIgnoreTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWildIgnoreTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}


type DoTableReplicationContext struct {
	ReplicationFilterContext
}

func NewDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoTableReplicationContext {
	var p = new(DoTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoTableReplicationContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_TABLE, 0)
}

func (s *DoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DoTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *DoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoTableReplication(s)
	}
}

func (s *DoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoTableReplication(s)
	}
}

func (s *DoTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDoTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}


type IgnoreTableReplicationContext struct {
	ReplicationFilterContext
}

func NewIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreTableReplicationContext {
	var p = new(IgnoreTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreTableReplicationContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *IgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IgnoreTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *IgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *IgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIgnoreTableReplication(s)
	}
}

func (s *IgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIgnoreTableReplication(s)
	}
}

func (s *IgnoreTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIgnoreTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}


type RewriteDbReplicationContext struct {
	ReplicationFilterContext
}

func NewRewriteDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RewriteDbReplicationContext {
	var p = new(RewriteDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *RewriteDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteDbReplicationContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_REWRITE_DB, 0)
}

func (s *RewriteDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *RewriteDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllTablePair() []ITablePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePairContext); ok {
			len++
		}
	}

	tst := make([]ITablePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePairContext); ok {
			tst[i] = t.(ITablePairContext)
			i++
		}
	}

	return tst
}

func (s *RewriteDbReplicationContext) TablePair(i int) ITablePairContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePairContext)
}

func (s *RewriteDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RewriteDbReplicationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *RewriteDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRewriteDbReplication(s)
	}
}

func (s *RewriteDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRewriteDbReplication(s)
	}
}

func (s *RewriteDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRewriteDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}


type DoDbReplicationContext struct {
	ReplicationFilterContext
}

func NewDoDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoDbReplicationContext {
	var p = new(DoDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoDbReplicationContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_DB, 0)
}

func (s *DoDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DoDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DoDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DoDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *DoDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoDbReplication(s)
	}
}

func (s *DoDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoDbReplication(s)
	}
}

func (s *DoDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDoDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}


type IgnoreDbReplicationContext struct {
	ReplicationFilterContext
}

func NewIgnoreDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreDbReplicationContext {
	var p = new(IgnoreDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreDbReplicationContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_DB, 0)
}

func (s *IgnoreDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IgnoreDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IgnoreDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *IgnoreDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIgnoreDbReplication(s)
	}
}

func (s *IgnoreDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIgnoreDbReplication(s)
	}
}

func (s *IgnoreDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIgnoreDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}


type WildDoTableReplicationContext struct {
	ReplicationFilterContext
}

func NewWildDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildDoTableReplicationContext {
	var p = new(WildDoTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildDoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildDoTableReplicationContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *WildDoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *WildDoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *WildDoTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildDoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *WildDoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWildDoTableReplication(s)
	}
}

func (s *WildDoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWildDoTableReplication(s)
	}
}

func (s *WildDoTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWildDoTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) ReplicationFilter() (localctx IReplicationFilterContext) {
	localctx = NewReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, MySqlParserRULE_replicationFilter)
	var _la int

	p.SetState(4657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserREPLICATE_DO_DB:
		localctx = NewDoDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4608)
			p.Match(MySqlParserREPLICATE_DO_DB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4609)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4610)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4611)
			p.UidList()
		}
		{
			p.SetState(4612)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPLICATE_IGNORE_DB:
		localctx = NewIgnoreDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4614)
			p.Match(MySqlParserREPLICATE_IGNORE_DB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4615)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4616)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4617)
			p.UidList()
		}
		{
			p.SetState(4618)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPLICATE_DO_TABLE:
		localctx = NewDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4620)
			p.Match(MySqlParserREPLICATE_DO_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4621)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4622)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4623)
			p.Tables()
		}
		{
			p.SetState(4624)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPLICATE_IGNORE_TABLE:
		localctx = NewIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4626)
			p.Match(MySqlParserREPLICATE_IGNORE_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4627)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4628)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4629)
			p.Tables()
		}
		{
			p.SetState(4630)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPLICATE_WILD_DO_TABLE:
		localctx = NewWildDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4632)
			p.Match(MySqlParserREPLICATE_WILD_DO_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4633)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4634)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4635)
			p.SimpleStrings()
		}
		{
			p.SetState(4636)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPLICATE_WILD_IGNORE_TABLE:
		localctx = NewWildIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4638)
			p.Match(MySqlParserREPLICATE_WILD_IGNORE_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4639)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4640)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4641)
			p.SimpleStrings()
		}
		{
			p.SetState(4642)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPLICATE_REWRITE_DB:
		localctx = NewRewriteDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4644)
			p.Match(MySqlParserREPLICATE_REWRITE_DB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4645)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4646)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4647)
			p.TablePair()
		}
		p.SetState(4652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(4648)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4649)
				p.TablePair()
			}


			p.SetState(4654)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4655)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablePairContext is an interface to support dynamic dispatch.
type ITablePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirstTable returns the firstTable rule contexts.
	GetFirstTable() ITableNameContext

	// GetSecondTable returns the secondTable rule contexts.
	GetSecondTable() ITableNameContext


	// SetFirstTable sets the firstTable rule contexts.
	SetFirstTable(ITableNameContext)

	// SetSecondTable sets the secondTable rule contexts.
	SetSecondTable(ITableNameContext)


	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext

	// IsTablePairContext differentiates from other interfaces.
	IsTablePairContext()
}

type TablePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	firstTable ITableNameContext 
	secondTable ITableNameContext 
}

func NewEmptyTablePairContext() *TablePairContext {
	var p = new(TablePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablePair
	return p
}

func InitEmptyTablePairContext(p *TablePairContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablePair
}

func (*TablePairContext) IsTablePairContext() {}

func NewTablePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePairContext {
	var p = new(TablePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tablePair

	return p
}

func (s *TablePairContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePairContext) GetFirstTable() ITableNameContext { return s.firstTable }

func (s *TablePairContext) GetSecondTable() ITableNameContext { return s.secondTable }


func (s *TablePairContext) SetFirstTable(v ITableNameContext) { s.firstTable = v }

func (s *TablePairContext) SetSecondTable(v ITableNameContext) { s.secondTable = v }


func (s *TablePairContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TablePairContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *TablePairContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TablePairContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablePairContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TablePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTablePair(s)
	}
}

func (s *TablePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTablePair(s)
	}
}

func (s *TablePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTablePair(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TablePair() (localctx ITablePairContext) {
	localctx = NewTablePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, MySqlParserRULE_tablePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4659)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4660)

		var _x = p.TableName()


		localctx.(*TablePairContext).firstTable = _x
	}
	{
		p.SetState(4661)
		p.Match(MySqlParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4662)

		var _x = p.TableName()


		localctx.(*TablePairContext).secondTable = _x
	}
	{
		p.SetState(4663)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IThreadTypeContext is an interface to support dynamic dispatch.
type IThreadTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IO_THREAD() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode

	// IsThreadTypeContext differentiates from other interfaces.
	IsThreadTypeContext()
}

type ThreadTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThreadTypeContext() *ThreadTypeContext {
	var p = new(ThreadTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_threadType
	return p
}

func InitEmptyThreadTypeContext(p *ThreadTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_threadType
}

func (*ThreadTypeContext) IsThreadTypeContext() {}

func NewThreadTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThreadTypeContext {
	var p = new(ThreadTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_threadType

	return p
}

func (s *ThreadTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ThreadTypeContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO_THREAD, 0)
}

func (s *ThreadTypeContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD, 0)
}

func (s *ThreadTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThreadTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ThreadTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterThreadType(s)
	}
}

func (s *ThreadTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitThreadType(s)
	}
}

func (s *ThreadTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitThreadType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ThreadType() (localctx IThreadTypeContext) {
	localctx = NewThreadTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, MySqlParserRULE_threadType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4665)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUntilOptionContext is an interface to support dynamic dispatch.
type IUntilOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUntilOptionContext differentiates from other interfaces.
	IsUntilOptionContext()
}

type UntilOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntilOptionContext() *UntilOptionContext {
	var p = new(UntilOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_untilOption
	return p
}

func InitEmptyUntilOptionContext(p *UntilOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_untilOption
}

func (*UntilOptionContext) IsUntilOptionContext() {}

func NewUntilOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UntilOptionContext {
	var p = new(UntilOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_untilOption

	return p
}

func (s *UntilOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UntilOptionContext) CopyAll(ctx *UntilOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UntilOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type GtidsUntilOptionContext struct {
	UntilOptionContext
	gtids antlr.Token
}

func NewGtidsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GtidsUntilOptionContext {
	var p = new(GtidsUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}


func (s *GtidsUntilOptionContext) GetGtids() antlr.Token { return s.gtids }


func (s *GtidsUntilOptionContext) SetGtids(v antlr.Token) { s.gtids = v }

func (s *GtidsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtidsUntilOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *GtidsUntilOptionContext) GtuidSet() IGtuidSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGtuidSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGtuidSetContext)
}

func (s *GtidsUntilOptionContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BEFORE_GTIDS, 0)
}

func (s *GtidsUntilOptionContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_GTIDS, 0)
}


func (s *GtidsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGtidsUntilOption(s)
	}
}

func (s *GtidsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGtidsUntilOption(s)
	}
}

func (s *GtidsUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGtidsUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type SqlGapsUntilOptionContext struct {
	UntilOptionContext
}

func NewSqlGapsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SqlGapsUntilOptionContext {
	var p = new(SqlGapsUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *SqlGapsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlGapsUntilOptionContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_MTS_GAPS, 0)
}


func (s *SqlGapsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlGapsUntilOption(s)
	}
}

func (s *SqlGapsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlGapsUntilOption(s)
	}
}

func (s *SqlGapsUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlGapsUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type MasterLogUntilOptionContext struct {
	UntilOptionContext
}

func NewMasterLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterLogUntilOptionContext {
	var p = new(MasterLogUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *MasterLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *MasterLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *MasterLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *MasterLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *MasterLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *MasterLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *MasterLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterLogUntilOption(s)
	}
}

func (s *MasterLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterLogUntilOption(s)
	}
}

func (s *MasterLogUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterLogUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type RelayLogUntilOptionContext struct {
	UntilOptionContext
}

func NewRelayLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelayLogUntilOptionContext {
	var p = new(RelayLogUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *RelayLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *RelayLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *RelayLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *RelayLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *RelayLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *RelayLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *RelayLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRelayLogUntilOption(s)
	}
}

func (s *RelayLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRelayLogUntilOption(s)
	}
}

func (s *RelayLogUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRelayLogUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) UntilOption() (localctx IUntilOptionContext) {
	localctx = NewUntilOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, MySqlParserRULE_untilOption)
	var _la int

	p.SetState(4685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_BEFORE_GTIDS:
		localctx = NewGtidsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4667)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GtidsUntilOptionContext).gtids = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_AFTER_GTIDS || _la == MySqlParserSQL_BEFORE_GTIDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GtidsUntilOptionContext).gtids = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4668)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4669)
			p.GtuidSet()
		}


	case MySqlParserMASTER_LOG_FILE:
		localctx = NewMasterLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4670)
			p.Match(MySqlParserMASTER_LOG_FILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4671)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4672)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4673)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4674)
			p.Match(MySqlParserMASTER_LOG_POS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4675)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4676)
			p.DecimalLiteral()
		}


	case MySqlParserRELAY_LOG_FILE:
		localctx = NewRelayLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4677)
			p.Match(MySqlParserRELAY_LOG_FILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4678)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4679)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4680)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4681)
			p.Match(MySqlParserRELAY_LOG_POS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4682)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4683)
			p.DecimalLiteral()
		}


	case MySqlParserSQL_AFTER_MTS_GAPS:
		localctx = NewSqlGapsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4684)
			p.Match(MySqlParserSQL_AFTER_MTS_GAPS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConnectionOptionContext is an interface to support dynamic dispatch.
type IConnectionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConnectionOptionContext differentiates from other interfaces.
	IsConnectionOptionContext()
}

type ConnectionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectionOptionContext() *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_connectionOption
	return p
}

func InitEmptyConnectionOptionContext(p *ConnectionOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_connectionOption
}

func (*ConnectionOptionContext) IsConnectionOptionContext() {}

func NewConnectionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_connectionOption

	return p
}

func (s *ConnectionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectionOptionContext) CopyAll(ctx *ConnectionOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type PluginDirConnectionOptionContext struct {
	ConnectionOptionContext
	conOptPluginDir antlr.Token
}

func NewPluginDirConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PluginDirConnectionOptionContext {
	var p = new(PluginDirConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}


func (s *PluginDirConnectionOptionContext) GetConOptPluginDir() antlr.Token { return s.conOptPluginDir }


func (s *PluginDirConnectionOptionContext) SetConOptPluginDir(v antlr.Token) { s.conOptPluginDir = v }

func (s *PluginDirConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluginDirConnectionOptionContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN_DIR, 0)
}

func (s *PluginDirConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PluginDirConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *PluginDirConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPluginDirConnectionOption(s)
	}
}

func (s *PluginDirConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPluginDirConnectionOption(s)
	}
}

func (s *PluginDirConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPluginDirConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type UserConnectionOptionContext struct {
	ConnectionOptionContext
	conOptUser antlr.Token
}

func NewUserConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserConnectionOptionContext {
	var p = new(UserConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}


func (s *UserConnectionOptionContext) GetConOptUser() antlr.Token { return s.conOptUser }


func (s *UserConnectionOptionContext) SetConOptUser(v antlr.Token) { s.conOptUser = v }

func (s *UserConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserConnectionOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *UserConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *UserConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *UserConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserConnectionOption(s)
	}
}

func (s *UserConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserConnectionOption(s)
	}
}

func (s *UserConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type DefaultAuthConnectionOptionContext struct {
	ConnectionOptionContext
	conOptDefAuth antlr.Token
}

func NewDefaultAuthConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultAuthConnectionOptionContext {
	var p = new(DefaultAuthConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}


func (s *DefaultAuthConnectionOptionContext) GetConOptDefAuth() antlr.Token { return s.conOptDefAuth }


func (s *DefaultAuthConnectionOptionContext) SetConOptDefAuth(v antlr.Token) { s.conOptDefAuth = v }

func (s *DefaultAuthConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultAuthConnectionOptionContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT_AUTH, 0)
}

func (s *DefaultAuthConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DefaultAuthConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *DefaultAuthConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultAuthConnectionOption(s)
	}
}

func (s *DefaultAuthConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultAuthConnectionOption(s)
	}
}

func (s *DefaultAuthConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefaultAuthConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type PasswordConnectionOptionContext struct {
	ConnectionOptionContext
	conOptPassword antlr.Token
}

func NewPasswordConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordConnectionOptionContext {
	var p = new(PasswordConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}


func (s *PasswordConnectionOptionContext) GetConOptPassword() antlr.Token { return s.conOptPassword }


func (s *PasswordConnectionOptionContext) SetConOptPassword(v antlr.Token) { s.conOptPassword = v }

func (s *PasswordConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordConnectionOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *PasswordConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PasswordConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *PasswordConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordConnectionOption(s)
	}
}

func (s *PasswordConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordConnectionOption(s)
	}
}

func (s *PasswordConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) ConnectionOption() (localctx IConnectionOptionContext) {
	localctx = NewConnectionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, MySqlParserRULE_connectionOption)
	p.SetState(4699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserUSER:
		localctx = NewUserConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4687)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4688)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4689)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*UserConnectionOptionContext).conOptUser = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPASSWORD:
		localctx = NewPasswordConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4690)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4691)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4692)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PasswordConnectionOptionContext).conOptPassword = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDEFAULT_AUTH:
		localctx = NewDefaultAuthConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4693)
			p.Match(MySqlParserDEFAULT_AUTH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4694)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4695)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*DefaultAuthConnectionOptionContext).conOptDefAuth = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPLUGIN_DIR:
		localctx = NewPluginDirConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4696)
			p.Match(MySqlParserPLUGIN_DIR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4697)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4698)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PluginDirConnectionOptionContext).conOptPluginDir = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGtuidSetContext is an interface to support dynamic dispatch.
type IGtuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUuidSet() []IUuidSetContext
	UuidSet(i int) IUuidSetContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsGtuidSetContext differentiates from other interfaces.
	IsGtuidSetContext()
}

type GtuidSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGtuidSetContext() *GtuidSetContext {
	var p = new(GtuidSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_gtuidSet
	return p
}

func InitEmptyGtuidSetContext(p *GtuidSetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_gtuidSet
}

func (*GtuidSetContext) IsGtuidSetContext() {}

func NewGtuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GtuidSetContext {
	var p = new(GtuidSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_gtuidSet

	return p
}

func (s *GtuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GtuidSetContext) AllUuidSet() []IUuidSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUuidSetContext); ok {
			len++
		}
	}

	tst := make([]IUuidSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUuidSetContext); ok {
			tst[i] = t.(IUuidSetContext)
			i++
		}
	}

	return tst
}

func (s *GtuidSetContext) UuidSet(i int) IUuidSetContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidSetContext)
}

func (s *GtuidSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GtuidSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GtuidSetContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *GtuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GtuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGtuidSet(s)
	}
}

func (s *GtuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGtuidSet(s)
	}
}

func (s *GtuidSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGtuidSet(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) GtuidSet() (localctx IGtuidSetContext) {
	localctx = NewGtuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, MySqlParserRULE_gtuidSet)
	var _la int

	p.SetState(4710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4701)
			p.UuidSet()
		}
		p.SetState(4706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(4702)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4703)
				p.UuidSet()
			}


			p.SetState(4708)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4709)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXaStartTransactionContext is an interface to support dynamic dispatch.
type IXaStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetXaStart returns the xaStart token.
	GetXaStart() antlr.Token 

	// GetXaAction returns the xaAction token.
	GetXaAction() antlr.Token 


	// SetXaStart sets the xaStart token.
	SetXaStart(antlr.Token) 

	// SetXaAction sets the xaAction token.
	SetXaAction(antlr.Token) 


	// Getter signatures
	XA() antlr.TerminalNode
	Xid() IXidContext
	START() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RESUME() antlr.TerminalNode

	// IsXaStartTransactionContext differentiates from other interfaces.
	IsXaStartTransactionContext()
}

type XaStartTransactionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	xaStart antlr.Token
	xaAction antlr.Token
}

func NewEmptyXaStartTransactionContext() *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaStartTransaction
	return p
}

func InitEmptyXaStartTransactionContext(p *XaStartTransactionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaStartTransaction
}

func (*XaStartTransactionContext) IsXaStartTransactionContext() {}

func NewXaStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaStartTransaction

	return p
}

func (s *XaStartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaStartTransactionContext) GetXaStart() antlr.Token { return s.xaStart }

func (s *XaStartTransactionContext) GetXaAction() antlr.Token { return s.xaAction }


func (s *XaStartTransactionContext) SetXaStart(v antlr.Token) { s.xaStart = v }

func (s *XaStartTransactionContext) SetXaAction(v antlr.Token) { s.xaAction = v }


func (s *XaStartTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaStartTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *XaStartTransactionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *XaStartTransactionContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *XaStartTransactionContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESUME, 0)
}

func (s *XaStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaStartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XaStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaStartTransaction(s)
	}
}

func (s *XaStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaStartTransaction(s)
	}
}

func (s *XaStartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) XaStartTransaction() (localctx IXaStartTransactionContext) {
	localctx = NewXaStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, MySqlParserRULE_xaStartTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4712)
		p.Match(MySqlParserXA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4713)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*XaStartTransactionContext).xaStart = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBEGIN || _la == MySqlParserSTART) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*XaStartTransactionContext).xaStart = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4714)
		p.Xid()
	}
	p.SetState(4716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserJOIN || _la == MySqlParserRESUME {
		{
			p.SetState(4715)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*XaStartTransactionContext).xaAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJOIN || _la == MySqlParserRESUME) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*XaStartTransactionContext).xaAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXaEndTransactionContext is an interface to support dynamic dispatch.
type IXaEndTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	END() antlr.TerminalNode
	Xid() IXidContext
	SUSPEND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode

	// IsXaEndTransactionContext differentiates from other interfaces.
	IsXaEndTransactionContext()
}

type XaEndTransactionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaEndTransactionContext() *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaEndTransaction
	return p
}

func InitEmptyXaEndTransactionContext(p *XaEndTransactionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaEndTransaction
}

func (*XaEndTransactionContext) IsXaEndTransactionContext() {}

func NewXaEndTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaEndTransaction

	return p
}

func (s *XaEndTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaEndTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaEndTransactionContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *XaEndTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaEndTransactionContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUSPEND, 0)
}

func (s *XaEndTransactionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *XaEndTransactionContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIGRATE, 0)
}

func (s *XaEndTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaEndTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XaEndTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaEndTransaction(s)
	}
}

func (s *XaEndTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaEndTransaction(s)
	}
}

func (s *XaEndTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaEndTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) XaEndTransaction() (localctx IXaEndTransactionContext) {
	localctx = NewXaEndTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, MySqlParserRULE_xaEndTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4718)
		p.Match(MySqlParserXA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4719)
		p.Match(MySqlParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4720)
		p.Xid()
	}
	p.SetState(4726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserSUSPEND {
		{
			p.SetState(4721)
			p.Match(MySqlParserSUSPEND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFOR {
			{
				p.SetState(4722)
				p.Match(MySqlParserFOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(4723)
				p.Match(MySqlParserMIGRATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXaPrepareStatementContext is an interface to support dynamic dispatch.
type IXaPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	Xid() IXidContext

	// IsXaPrepareStatementContext differentiates from other interfaces.
	IsXaPrepareStatementContext()
}

type XaPrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaPrepareStatementContext() *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement
	return p
}

func InitEmptyXaPrepareStatementContext(p *XaPrepareStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement
}

func (*XaPrepareStatementContext) IsXaPrepareStatementContext() {}

func NewXaPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement

	return p
}

func (s *XaPrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *XaPrepareStatementContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaPrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *XaPrepareStatementContext) Xid() IXidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaPrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaPrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XaPrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaPrepareStatement(s)
	}
}

func (s *XaPrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaPrepareStatement(s)
	}
}

func (s *XaPrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) XaPrepareStatement() (localctx IXaPrepareStatementContext) {
	localctx = NewXaPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, MySqlParserRULE_xaPrepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4728)
		p.Match(MySqlParserXA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4729)
		p.Match(MySqlParserPREPARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4730)
		p.Xid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXaCommitWorkContext is an interface to support dynamic dispatch.
type IXaCommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	Xid() IXidContext
	ONE() antlr.TerminalNode
	PHASE() antlr.TerminalNode

	// IsXaCommitWorkContext differentiates from other interfaces.
	IsXaCommitWorkContext()
}

type XaCommitWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaCommitWorkContext() *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaCommitWork
	return p
}

func InitEmptyXaCommitWorkContext(p *XaCommitWorkContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaCommitWork
}

func (*XaCommitWorkContext) IsXaCommitWorkContext() {}

func NewXaCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaCommitWork

	return p
}

func (s *XaCommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaCommitWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaCommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *XaCommitWorkContext) Xid() IXidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaCommitWorkContext) ONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE, 0)
}

func (s *XaCommitWorkContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPHASE, 0)
}

func (s *XaCommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaCommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XaCommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaCommitWork(s)
	}
}

func (s *XaCommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaCommitWork(s)
	}
}

func (s *XaCommitWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaCommitWork(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) XaCommitWork() (localctx IXaCommitWorkContext) {
	localctx = NewXaCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, MySqlParserRULE_xaCommitWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4732)
		p.Match(MySqlParserXA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4733)
		p.Match(MySqlParserCOMMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4734)
		p.Xid()
	}
	p.SetState(4737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserONE {
		{
			p.SetState(4735)
			p.Match(MySqlParserONE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4736)
			p.Match(MySqlParserPHASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXaRollbackWorkContext is an interface to support dynamic dispatch.
type IXaRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRollbackWorkContext differentiates from other interfaces.
	IsXaRollbackWorkContext()
}

type XaRollbackWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRollbackWorkContext() *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRollbackWork
	return p
}

func InitEmptyXaRollbackWorkContext(p *XaRollbackWorkContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRollbackWork
}

func (*XaRollbackWorkContext) IsXaRollbackWorkContext() {}

func NewXaRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaRollbackWork

	return p
}

func (s *XaRollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRollbackWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaRollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *XaRollbackWorkContext) Xid() IXidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XaRollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaRollbackWork(s)
	}
}

func (s *XaRollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaRollbackWork(s)
	}
}

func (s *XaRollbackWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaRollbackWork(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) XaRollbackWork() (localctx IXaRollbackWorkContext) {
	localctx = NewXaRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, MySqlParserRULE_xaRollbackWork)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4739)
		p.Match(MySqlParserXA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4740)
		p.Match(MySqlParserROLLBACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4741)
		p.Xid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXaRecoverWorkContext is an interface to support dynamic dispatch.
type IXaRecoverWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRecoverWorkContext differentiates from other interfaces.
	IsXaRecoverWorkContext()
}

type XaRecoverWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRecoverWorkContext() *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRecoverWork
	return p
}

func InitEmptyXaRecoverWorkContext(p *XaRecoverWorkContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRecoverWork
}

func (*XaRecoverWorkContext) IsXaRecoverWorkContext() {}

func NewXaRecoverWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaRecoverWork

	return p
}

func (s *XaRecoverWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRecoverWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaRecoverWorkContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECOVER, 0)
}

func (s *XaRecoverWorkContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *XaRecoverWorkContext) Xid() IXidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRecoverWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRecoverWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XaRecoverWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaRecoverWork(s)
	}
}

func (s *XaRecoverWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaRecoverWork(s)
	}
}

func (s *XaRecoverWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaRecoverWork(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) XaRecoverWork() (localctx IXaRecoverWorkContext) {
	localctx = NewXaRecoverWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, MySqlParserRULE_xaRecoverWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4743)
		p.Match(MySqlParserXA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4744)
		p.Match(MySqlParserRECOVER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCONVERT {
		{
			p.SetState(4745)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4746)
			p.Xid()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetQuery returns the query token.
	GetQuery() antlr.Token 

	// GetVariable returns the variable token.
	GetVariable() antlr.Token 


	// SetQuery sets the query token.
	SetQuery(antlr.Token) 

	// SetVariable sets the variable token.
	SetVariable(antlr.Token) 


	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	FROM() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	LOCAL_ID() antlr.TerminalNode

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	query antlr.Token
	variable antlr.Token
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) GetQuery() antlr.Token { return s.query }

func (s *PrepareStatementContext) GetVariable() antlr.Token { return s.variable }


func (s *PrepareStatementContext) SetQuery(v antlr.Token) { s.query = v }

func (s *PrepareStatementContext) SetVariable(v antlr.Token) { s.variable = v }


func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *PrepareStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *PrepareStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PrepareStatementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, MySqlParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4749)
		p.Match(MySqlParserPREPARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4750)
		p.Uid()
	}
	{
		p.SetState(4751)
		p.Match(MySqlParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTRING_LITERAL:
		{
			p.SetState(4752)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PrepareStatementContext).query = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserLOCAL_ID:
		{
			p.SetState(4753)

			var _m = p.Match(MySqlParserLOCAL_ID)

			localctx.(*PrepareStatementContext).variable = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Uid() IUidContext
	USING() antlr.TerminalNode
	UserVariables() IUserVariablesContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *ExecuteStatementContext) UserVariables() IUserVariablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariablesContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, MySqlParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4756)
		p.Match(MySqlParserEXECUTE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4757)
		p.Uid()
	}
	p.SetState(4760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserUSING {
		{
			p.SetState(4758)
			p.Match(MySqlParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4759)
			p.UserVariables()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeallocatePrepareContext is an interface to support dynamic dispatch.
type IDeallocatePrepareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropFormat returns the dropFormat token.
	GetDropFormat() antlr.Token 


	// SetDropFormat sets the dropFormat token.
	SetDropFormat(antlr.Token) 


	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocatePrepareContext differentiates from other interfaces.
	IsDeallocatePrepareContext()
}

type DeallocatePrepareContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dropFormat antlr.Token
}

func NewEmptyDeallocatePrepareContext() *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deallocatePrepare
	return p
}

func InitEmptyDeallocatePrepareContext(p *DeallocatePrepareContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deallocatePrepare
}

func (*DeallocatePrepareContext) IsDeallocatePrepareContext() {}

func NewDeallocatePrepareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_deallocatePrepare

	return p
}

func (s *DeallocatePrepareContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocatePrepareContext) GetDropFormat() antlr.Token { return s.dropFormat }


func (s *DeallocatePrepareContext) SetDropFormat(v antlr.Token) { s.dropFormat = v }


func (s *DeallocatePrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *DeallocatePrepareContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeallocatePrepareContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEALLOCATE, 0)
}

func (s *DeallocatePrepareContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DeallocatePrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocatePrepareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeallocatePrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeallocatePrepare(s)
	}
}

func (s *DeallocatePrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeallocatePrepare(s)
	}
}

func (s *DeallocatePrepareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeallocatePrepare(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DeallocatePrepare() (localctx IDeallocatePrepareContext) {
	localctx = NewDeallocatePrepareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, MySqlParserRULE_deallocatePrepare)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4762)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeallocatePrepareContext).dropFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDROP || _la == MySqlParserDEALLOCATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeallocatePrepareContext).dropFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4763)
		p.Match(MySqlParserPREPARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4764)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	SqlStatement() ISqlStatementContext

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineBody
	return p
}

func InitEmptyRoutineBodyContext(p *RoutineBodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineBody
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *RoutineBodyContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (s *RoutineBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineBody(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RoutineBody() (localctx IRoutineBodyContext) {
	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, MySqlParserRULE_routineBody)
	p.SetState(4768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4766)
			p.BlockStatement()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4767)
			p.SqlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllDeclareVariable() []IDeclareVariableContext
	DeclareVariable(i int) IDeclareVariableContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllDeclareCondition() []IDeclareConditionContext
	DeclareCondition(i int) IDeclareConditionContext
	AllDeclareCursor() []IDeclareCursorContext
	DeclareCursor(i int) IDeclareCursorContext
	AllDeclareHandler() []IDeclareHandlerContext
	DeclareHandler(i int) IDeclareHandlerContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_blockStatement
	return p
}

func InitEmptyBlockStatementContext(p *BlockStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_blockStatement
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *BlockStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *BlockStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *BlockStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *BlockStatementContext) AllDeclareVariable() []IDeclareVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			len++
		}
	}

	tst := make([]IDeclareVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareVariableContext); ok {
			tst[i] = t.(IDeclareVariableContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareVariable(i int) IDeclareVariableContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareVariableContext)
}

func (s *BlockStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *BlockStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *BlockStatementContext) AllDeclareCondition() []IDeclareConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			len++
		}
	}

	tst := make([]IDeclareConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareConditionContext); ok {
			tst[i] = t.(IDeclareConditionContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCondition(i int) IDeclareConditionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareConditionContext)
}

func (s *BlockStatementContext) AllDeclareCursor() []IDeclareCursorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			len++
		}
	}

	tst := make([]IDeclareCursorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareCursorContext); ok {
			tst[i] = t.(IDeclareCursorContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCursor(i int) IDeclareCursorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareCursorContext)
}

func (s *BlockStatementContext) AllDeclareHandler() []IDeclareHandlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			len++
		}
	}

	tst := make([]IDeclareHandlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareHandlerContext); ok {
			tst[i] = t.(IDeclareHandlerContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareHandler(i int) IDeclareHandlerContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareHandlerContext)
}

func (s *BlockStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, MySqlParserRULE_blockStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4773)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4770)
			p.Uid()
		}
		{
			p.SetState(4771)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4775)
		p.Match(MySqlParserBEGIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4776)
				p.DeclareVariable()
			}
			{
				p.SetState(4777)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(4783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4784)
				p.DeclareCondition()
			}
			{
				p.SetState(4785)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(4791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4792)
				p.DeclareCursor()
			}
			{
				p.SetState(4793)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(4799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserDECLARE {
		{
			p.SetState(4800)
			p.DeclareHandler()
		}
		{
			p.SetState(4801)
			p.Match(MySqlParserSEMI)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(4807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 700, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4808)
				p.ProcedureSqlStatement()
			}


		}
		p.SetState(4813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 700, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4814)
		p.Match(MySqlParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4816)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4815)
			p.Uid()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCASE() []antlr.TerminalNode
	CASE(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	Uid() IUidContext
	Expression() IExpressionContext
	AllCaseAlternative() []ICaseAlternativeContext
	CaseAlternative(i int) ICaseAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCASE)
}

func (s *CaseStatementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, i)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) AllCaseAlternative() []ICaseAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseAlternativeContext); ok {
			tst[i] = t.(ICaseAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseAlternative(i int) ICaseAlternativeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseAlternativeContext)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, MySqlParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4818)
		p.Match(MySqlParserCASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4821)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4819)
			p.Uid()
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4820)
			p.expression(0)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(4824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == MySqlParserWHEN {
		{
			p.SetState(4823)
			p.CaseAlternative()
		}


		p.SetState(4826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserELSE {
		{
			p.SetState(4828)
			p.Match(MySqlParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(4829)
						p.ProcedureSqlStatement()
					}




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4832)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	{
		p.SetState(4836)
		p.Match(MySqlParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4837)
		p.Match(MySqlParserCASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_procedureSqlStatement returns the _procedureSqlStatement rule contexts.
	Get_procedureSqlStatement() IProcedureSqlStatementContext


	// Set_procedureSqlStatement sets the _procedureSqlStatement rule contexts.
	Set_procedureSqlStatement(IProcedureSqlStatementContext)


	// GetThenStatements returns the thenStatements rule context list.
	GetThenStatements() []IProcedureSqlStatementContext

	// GetElseStatements returns the elseStatements rule context list.
	GetElseStatements() []IProcedureSqlStatementContext


	// SetThenStatements sets the thenStatements rule context list.
	SetThenStatements([]IProcedureSqlStatementContext) 

	// SetElseStatements sets the elseStatements rule context list.
	SetElseStatements([]IProcedureSqlStatementContext) 


	// Getter signatures
	AllIF() []antlr.TerminalNode
	IF(i int) antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllElifAlternative() []IElifAlternativeContext
	ElifAlternative(i int) IElifAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_procedureSqlStatement IProcedureSqlStatementContext 
	thenStatements []IProcedureSqlStatementContext
	elseStatements []IProcedureSqlStatementContext
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Get_procedureSqlStatement() IProcedureSqlStatementContext { return s._procedureSqlStatement }


func (s *IfStatementContext) Set_procedureSqlStatement(v IProcedureSqlStatementContext) { s._procedureSqlStatement = v }


func (s *IfStatementContext) GetThenStatements() []IProcedureSqlStatementContext { return s.thenStatements }

func (s *IfStatementContext) GetElseStatements() []IProcedureSqlStatementContext { return s.elseStatements }


func (s *IfStatementContext) SetThenStatements(v []IProcedureSqlStatementContext) { s.thenStatements = v }

func (s *IfStatementContext) SetElseStatements(v []IProcedureSqlStatementContext) { s.elseStatements = v }


func (s *IfStatementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIF)
}

func (s *IfStatementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, i)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *IfStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *IfStatementContext) AllElifAlternative() []IElifAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			len++
		}
	}

	tst := make([]IElifAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElifAlternativeContext); ok {
			tst[i] = t.(IElifAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElifAlternative(i int) IElifAlternativeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElifAlternativeContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *IfStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, MySqlParserRULE_ifStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4839)
		p.Match(MySqlParserIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4840)
		p.expression(0)
	}
	{
		p.SetState(4841)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(4842)

					var _x = p.ProcedureSqlStatement()


					localctx.(*IfStatementContext)._procedureSqlStatement = _x
				}
				localctx.(*IfStatementContext).thenStatements = append(localctx.(*IfStatementContext).thenStatements, localctx.(*IfStatementContext)._procedureSqlStatement)




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4845)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 706, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserELSEIF {
		{
			p.SetState(4847)
			p.ElifAlternative()
		}


		p.SetState(4852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserELSE {
		{
			p.SetState(4853)
			p.Match(MySqlParserELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(4854)

						var _x = p.ProcedureSqlStatement()


						localctx.(*IfStatementContext)._procedureSqlStatement = _x
					}
					localctx.(*IfStatementContext).elseStatements = append(localctx.(*IfStatementContext).elseStatements, localctx.(*IfStatementContext)._procedureSqlStatement)




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4857)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	{
		p.SetState(4861)
		p.Match(MySqlParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4862)
		p.Match(MySqlParserIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIterateStatementContext is an interface to support dynamic dispatch.
type IIterateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ITERATE() antlr.TerminalNode
	Uid() IUidContext

	// IsIterateStatementContext differentiates from other interfaces.
	IsIterateStatementContext()
}

type IterateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterateStatementContext() *IterateStatementContext {
	var p = new(IterateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_iterateStatement
	return p
}

func InitEmptyIterateStatementContext(p *IterateStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_iterateStatement
}

func (*IterateStatementContext) IsIterateStatementContext() {}

func NewIterateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterateStatementContext {
	var p = new(IterateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_iterateStatement

	return p
}

func (s *IterateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterateStatementContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserITERATE, 0)
}

func (s *IterateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IterateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IterateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIterateStatement(s)
	}
}

func (s *IterateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIterateStatement(s)
	}
}

func (s *IterateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIterateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IterateStatement() (localctx IIterateStatementContext) {
	localctx = NewIterateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, MySqlParserRULE_iterateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4864)
		p.Match(MySqlParserITERATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4865)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILeaveStatementContext is an interface to support dynamic dispatch.
type ILeaveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEAVE() antlr.TerminalNode
	Uid() IUidContext

	// IsLeaveStatementContext differentiates from other interfaces.
	IsLeaveStatementContext()
}

type LeaveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeaveStatementContext() *LeaveStatementContext {
	var p = new(LeaveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_leaveStatement
	return p
}

func InitEmptyLeaveStatementContext(p *LeaveStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_leaveStatement
}

func (*LeaveStatementContext) IsLeaveStatementContext() {}

func NewLeaveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeaveStatementContext {
	var p = new(LeaveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_leaveStatement

	return p
}

func (s *LeaveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LeaveStatementContext) LEAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVE, 0)
}

func (s *LeaveStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LeaveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeaveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LeaveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLeaveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LeaveStatement() (localctx ILeaveStatementContext) {
	localctx = NewLeaveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, MySqlParserRULE_leaveStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4867)
		p.Match(MySqlParserLEAVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4868)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOOP() []antlr.TerminalNode
	LOOP(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOOP)
}

func (s *LoopStatementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOOP, i)
}

func (s *LoopStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *LoopStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LoopStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *LoopStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, MySqlParserRULE_loopStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		{
			p.SetState(4870)
			p.Uid()
		}
		{
			p.SetState(4871)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4875)
		p.Match(MySqlParserLOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(4876)
					p.ProcedureSqlStatement()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4879)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4881)
		p.Match(MySqlParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4882)
		p.Match(MySqlParserLOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		{
			p.SetState(4883)
			p.Uid()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllREPEAT() []antlr.TerminalNode
	REPEAT(i int) antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) AllREPEAT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserREPEAT)
}

func (s *RepeatStatementContext) REPEAT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEAT, i)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *RepeatStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RepeatStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *RepeatStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, MySqlParserRULE_repeatStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4889)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 713, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4886)
			p.Uid()
		}
		{
			p.SetState(4887)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(4891)
		p.Match(MySqlParserREPEAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(4892)
					p.ProcedureSqlStatement()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4895)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 714, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4897)
		p.Match(MySqlParserUNTIL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4898)
		p.expression(0)
	}
	{
		p.SetState(4899)
		p.Match(MySqlParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4900)
		p.Match(MySqlParserREPEAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		{
			p.SetState(4901)
			p.Uid()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, MySqlParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4904)
		p.Match(MySqlParserRETURN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4905)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWHILE() []antlr.TerminalNode
	WHILE(i int) antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) AllWHILE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWHILE)
}

func (s *WhileStatementContext) WHILE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWHILE, i)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *WhileStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *WhileStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WhileStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *WhileStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, MySqlParserRULE_whileStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		{
			p.SetState(4907)
			p.Uid()
		}
		{
			p.SetState(4908)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(4912)
		p.Match(MySqlParserWHILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4913)
		p.expression(0)
	}
	{
		p.SetState(4914)
		p.Match(MySqlParserDO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(4915)
					p.ProcedureSqlStatement()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4918)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 717, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4920)
		p.Match(MySqlParserEND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4921)
		p.Match(MySqlParserWHILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756891332513122304) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((int64((_la - 140)) & ^0x3f) == 0 && ((int64(1) << (_la - 140)) & 268698883) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17174494689) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & -1099511627777) != 0) || ((int64((_la - 345)) & ^0x3f) == 0 && ((int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & -4398063288321) != 0) || ((int64((_la - 473)) & ^0x3f) == 0 && ((int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((int64((_la - 537)) & ^0x3f) == 0 && ((int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((int64((_la - 601)) & ^0x3f) == 0 && ((int64(1) << (_la - 601)) & -68719476801) != 0) || ((int64((_la - 665)) & ^0x3f) == 0 && ((int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((int64((_la - 729)) & ^0x3f) == 0 && ((int64(1) << (_la - 729)) & -65) != 0) || ((int64((_la - 793)) & ^0x3f) == 0 && ((int64(1) << (_la - 793)) & -6145) != 0) || ((int64((_la - 857)) & ^0x3f) == 0 && ((int64(1) << (_la - 857)) & -1) != 0) || ((int64((_la - 921)) & ^0x3f) == 0 && ((int64(1) << (_la - 921)) & -1) != 0) || ((int64((_la - 985)) & ^0x3f) == 0 && ((int64(1) << (_la - 985)) & -1) != 0) || ((int64((_la - 1049)) & ^0x3f) == 0 && ((int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((int64((_la - 1123)) & ^0x3f) == 0 && ((int64(1) << (_la - 1123)) & 8627683329) != 0) {
		{
			p.SetState(4922)
			p.Uid()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICursorStatementContext is an interface to support dynamic dispatch.
type ICursorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCursorStatementContext differentiates from other interfaces.
	IsCursorStatementContext()
}

type CursorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorStatementContext() *CursorStatementContext {
	var p = new(CursorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cursorStatement
	return p
}

func InitEmptyCursorStatementContext(p *CursorStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cursorStatement
}

func (*CursorStatementContext) IsCursorStatementContext() {}

func NewCursorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorStatementContext {
	var p = new(CursorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cursorStatement

	return p
}

func (s *CursorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorStatementContext) CopyAll(ctx *CursorStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CursorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type CloseCursorContext struct {
	CursorStatementContext
}

func NewCloseCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CloseCursorContext {
	var p = new(CloseCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *CloseCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseCursorContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *CloseCursorContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *CloseCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCloseCursor(s)
	}
}

func (s *CloseCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCloseCursor(s)
	}
}

func (s *CloseCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCloseCursor(s)

	default:
		return t.VisitChildren(s)
	}
}


type OpenCursorContext struct {
	CursorStatementContext
}

func NewOpenCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OpenCursorContext {
	var p = new(OpenCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *OpenCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenCursorContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *OpenCursorContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *OpenCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOpenCursor(s)
	}
}

func (s *OpenCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOpenCursor(s)
	}
}

func (s *OpenCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOpenCursor(s)

	default:
		return t.VisitChildren(s)
	}
}


type FetchCursorContext struct {
	CursorStatementContext
}

func NewFetchCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FetchCursorContext {
	var p = new(FetchCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *FetchCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FetchCursorContext) FETCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFETCH, 0)
}

func (s *FetchCursorContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FetchCursorContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *FetchCursorContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *FetchCursorContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FetchCursorContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}


func (s *FetchCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFetchCursor(s)
	}
}

func (s *FetchCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFetchCursor(s)
	}
}

func (s *FetchCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFetchCursor(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) CursorStatement() (localctx ICursorStatementContext) {
	localctx = NewCursorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, MySqlParserRULE_cursorStatement)
	var _la int

	p.SetState(4940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCLOSE:
		localctx = NewCloseCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4925)
			p.Match(MySqlParserCLOSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4926)
			p.Uid()
		}


	case MySqlParserFETCH:
		localctx = NewFetchCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4927)
			p.Match(MySqlParserFETCH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4932)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 720, p.GetParserRuleContext()) == 1 {
			p.SetState(4929)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserNEXT {
				{
					p.SetState(4928)
					p.Match(MySqlParserNEXT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(4931)
				p.Match(MySqlParserFROM)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(4934)
			p.Uid()
		}
		{
			p.SetState(4935)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4936)
			p.UidList()
		}


	case MySqlParserOPEN:
		localctx = NewOpenCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4938)
			p.Match(MySqlParserOPEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4939)
			p.Uid()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclareVariableContext is an interface to support dynamic dispatch.
type IDeclareVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	UidList() IUidListContext
	DataType() IDataTypeContext
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeclareVariableContext differentiates from other interfaces.
	IsDeclareVariableContext()
}

type DeclareVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareVariableContext() *DeclareVariableContext {
	var p = new(DeclareVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareVariable
	return p
}

func InitEmptyDeclareVariableContext(p *DeclareVariableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareVariable
}

func (*DeclareVariableContext) IsDeclareVariableContext() {}

func NewDeclareVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareVariableContext {
	var p = new(DeclareVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareVariable

	return p
}

func (s *DeclareVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareVariableContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareVariableContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DeclareVariableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DeclareVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *DeclareVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeclareVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclareVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareVariable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DeclareVariable() (localctx IDeclareVariableContext) {
	localctx = NewDeclareVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, MySqlParserRULE_declareVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4942)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4943)
		p.UidList()
	}
	{
		p.SetState(4944)
		p.DataType()
	}
	p.SetState(4947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserDEFAULT {
		{
			p.SetState(4945)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4946)
			p.expression(0)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclareConditionContext is an interface to support dynamic dispatch.
type IDeclareConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CONDITION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	SQLSTATE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDeclareConditionContext differentiates from other interfaces.
	IsDeclareConditionContext()
}

type DeclareConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareConditionContext() *DeclareConditionContext {
	var p = new(DeclareConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCondition
	return p
}

func InitEmptyDeclareConditionContext(p *DeclareConditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCondition
}

func (*DeclareConditionContext) IsDeclareConditionContext() {}

func NewDeclareConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareConditionContext {
	var p = new(DeclareConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareCondition

	return p
}

func (s *DeclareConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareConditionContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareConditionContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareConditionContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *DeclareConditionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareConditionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DeclareConditionContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *DeclareConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *DeclareConditionContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *DeclareConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclareConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareCondition(s)
	}
}

func (s *DeclareConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareCondition(s)
	}
}

func (s *DeclareConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareCondition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DeclareCondition() (localctx IDeclareConditionContext) {
	localctx = NewDeclareConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, MySqlParserRULE_declareCondition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4949)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4950)
		p.Uid()
	}
	{
		p.SetState(4951)
		p.Match(MySqlParserCONDITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4952)
		p.Match(MySqlParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(4959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		{
			p.SetState(4953)
			p.DecimalLiteral()
		}


	case MySqlParserSQLSTATE:
		{
			p.SetState(4954)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserVALUE {
			{
				p.SetState(4955)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4958)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclareCursorContext is an interface to support dynamic dispatch.
type IDeclareCursorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CURSOR() antlr.TerminalNode
	FOR() antlr.TerminalNode
	SelectStatement() ISelectStatementContext

	// IsDeclareCursorContext differentiates from other interfaces.
	IsDeclareCursorContext()
}

type DeclareCursorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareCursorContext() *DeclareCursorContext {
	var p = new(DeclareCursorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCursor
	return p
}

func InitEmptyDeclareCursorContext(p *DeclareCursorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCursor
}

func (*DeclareCursorContext) IsDeclareCursorContext() {}

func NewDeclareCursorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareCursorContext {
	var p = new(DeclareCursorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareCursor

	return p
}

func (s *DeclareCursorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareCursorContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareCursorContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareCursorContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR, 0)
}

func (s *DeclareCursorContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareCursorContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DeclareCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareCursorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclareCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareCursor(s)
	}
}

func (s *DeclareCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareCursor(s)
	}
}

func (s *DeclareCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareCursor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DeclareCursor() (localctx IDeclareCursorContext) {
	localctx = NewDeclareCursorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, MySqlParserRULE_declareCursor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4961)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4962)
		p.Uid()
	}
	{
		p.SetState(4963)
		p.Match(MySqlParserCURSOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4964)
		p.Match(MySqlParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4965)
		p.SelectStatement()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclareHandlerContext is an interface to support dynamic dispatch.
type IDeclareHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHandlerAction returns the handlerAction token.
	GetHandlerAction() antlr.Token 


	// SetHandlerAction sets the handlerAction token.
	SetHandlerAction(antlr.Token) 


	// Getter signatures
	DECLARE() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllHandlerConditionValue() []IHandlerConditionValueContext
	HandlerConditionValue(i int) IHandlerConditionValueContext
	RoutineBody() IRoutineBodyContext
	CONTINUE() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	UNDO() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDeclareHandlerContext differentiates from other interfaces.
	IsDeclareHandlerContext()
}

type DeclareHandlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	handlerAction antlr.Token
}

func NewEmptyDeclareHandlerContext() *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareHandler
	return p
}

func InitEmptyDeclareHandlerContext(p *DeclareHandlerContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareHandler
}

func (*DeclareHandlerContext) IsDeclareHandlerContext() {}

func NewDeclareHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareHandler

	return p
}

func (s *DeclareHandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareHandlerContext) GetHandlerAction() antlr.Token { return s.handlerAction }


func (s *DeclareHandlerContext) SetHandlerAction(v antlr.Token) { s.handlerAction = v }


func (s *DeclareHandlerContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareHandlerContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *DeclareHandlerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareHandlerContext) AllHandlerConditionValue() []IHandlerConditionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			len++
		}
	}

	tst := make([]IHandlerConditionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHandlerConditionValueContext); ok {
			tst[i] = t.(IHandlerConditionValueContext)
			i++
		}
	}

	return tst
}

func (s *DeclareHandlerContext) HandlerConditionValue(i int) IHandlerConditionValueContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerConditionValueContext)
}

func (s *DeclareHandlerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *DeclareHandlerContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTINUE, 0)
}

func (s *DeclareHandlerContext) EXIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXIT, 0)
}

func (s *DeclareHandlerContext) UNDO() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO, 0)
}

func (s *DeclareHandlerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DeclareHandlerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DeclareHandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareHandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DeclareHandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareHandler(s)
	}
}

func (s *DeclareHandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareHandler(s)
	}
}

func (s *DeclareHandlerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareHandler(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DeclareHandler() (localctx IDeclareHandlerContext) {
	localctx = NewDeclareHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, MySqlParserRULE_declareHandler)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4967)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4968)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeclareHandlerContext).handlerAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserCONTINUE || _la == MySqlParserEXIT || _la == MySqlParserUNDO) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeclareHandlerContext).handlerAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4969)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4970)
		p.Match(MySqlParserFOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(4971)
		p.HandlerConditionValue()
	}
	p.SetState(4976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(4972)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4973)
			p.HandlerConditionValue()
		}


		p.SetState(4978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4979)
		p.RoutineBody()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHandlerConditionValueContext is an interface to support dynamic dispatch.
type IHandlerConditionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsHandlerConditionValueContext differentiates from other interfaces.
	IsHandlerConditionValueContext()
}

type HandlerConditionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerConditionValueContext() *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerConditionValue
	return p
}

func InitEmptyHandlerConditionValueContext(p *HandlerConditionValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerConditionValue
}

func (*HandlerConditionValueContext) IsHandlerConditionValueContext() {}

func NewHandlerConditionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerConditionValue

	return p
}

func (s *HandlerConditionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerConditionValueContext) CopyAll(ctx *HandlerConditionValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *HandlerConditionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type HandlerConditionWarningContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionWarningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionWarningContext {
	var p = new(HandlerConditionWarningContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionWarningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionWarningContext) SQLWARNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLWARNING, 0)
}


func (s *HandlerConditionWarningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionWarning(s)
	}
}

func (s *HandlerConditionWarningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionWarning(s)
	}
}

func (s *HandlerConditionWarningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionWarning(s)

	default:
		return t.VisitChildren(s)
	}
}


type HandlerConditionCodeContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionCodeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionCodeContext {
	var p = new(HandlerConditionCodeContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionCodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionCodeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *HandlerConditionCodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionCode(s)
	}
}

func (s *HandlerConditionCodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionCode(s)
	}
}

func (s *HandlerConditionCodeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionCode(s)

	default:
		return t.VisitChildren(s)
	}
}


type HandlerConditionNotfoundContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionNotfoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNotfoundContext {
	var p = new(HandlerConditionNotfoundContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNotfoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNotfoundContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *HandlerConditionNotfoundContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND, 0)
}


func (s *HandlerConditionNotfoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionNotfound(s)
	}
}

func (s *HandlerConditionNotfoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionNotfound(s)
	}
}

func (s *HandlerConditionNotfoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionNotfound(s)

	default:
		return t.VisitChildren(s)
	}
}


type HandlerConditionStateContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionStateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionStateContext {
	var p = new(HandlerConditionStateContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionStateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionStateContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *HandlerConditionStateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HandlerConditionStateContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}


func (s *HandlerConditionStateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionState(s)
	}
}

func (s *HandlerConditionStateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionState(s)
	}
}

func (s *HandlerConditionStateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionState(s)

	default:
		return t.VisitChildren(s)
	}
}


type HandlerConditionExceptionContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionExceptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionExceptionContext {
	var p = new(HandlerConditionExceptionContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionExceptionContext) SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLEXCEPTION, 0)
}


func (s *HandlerConditionExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionException(s)
	}
}

func (s *HandlerConditionExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionException(s)
	}
}

func (s *HandlerConditionExceptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionException(s)

	default:
		return t.VisitChildren(s)
	}
}


type HandlerConditionNameContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNameContext {
	var p = new(HandlerConditionNameContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *HandlerConditionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionName(s)
	}
}

func (s *HandlerConditionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionName(s)
	}
}

func (s *HandlerConditionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionName(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) HandlerConditionValue() (localctx IHandlerConditionValueContext) {
	localctx = NewHandlerConditionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, MySqlParserRULE_handlerConditionValue)
	var _la int

	p.SetState(4992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		localctx = NewHandlerConditionCodeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4981)
			p.DecimalLiteral()
		}


	case MySqlParserSQLSTATE:
		localctx = NewHandlerConditionStateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4982)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(4984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserVALUE {
			{
				p.SetState(4983)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(4986)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		localctx = NewHandlerConditionNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4987)
			p.Uid()
		}


	case MySqlParserSQLWARNING:
		localctx = NewHandlerConditionWarningContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4988)
			p.Match(MySqlParserSQLWARNING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserNOT:
		localctx = NewHandlerConditionNotfoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4989)
			p.Match(MySqlParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(4990)
			p.Match(MySqlParserFOUND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSQLEXCEPTION:
		localctx = NewHandlerConditionExceptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4991)
			p.Match(MySqlParserSQLEXCEPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IProcedureSqlStatementContext is an interface to support dynamic dispatch.
type IProcedureSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	SqlStatement() ISqlStatementContext

	// IsProcedureSqlStatementContext differentiates from other interfaces.
	IsProcedureSqlStatementContext()
}

type ProcedureSqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSqlStatementContext() *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement
	return p
}

func InitEmptyProcedureSqlStatementContext(p *ProcedureSqlStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement
}

func (*ProcedureSqlStatementContext) IsProcedureSqlStatementContext() {}

func NewProcedureSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement

	return p
}

func (s *ProcedureSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSqlStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *ProcedureSqlStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureSqlStatementContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *ProcedureSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ProcedureSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProcedureSqlStatement(s)
	}
}

func (s *ProcedureSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProcedureSqlStatement(s)
	}
}

func (s *ProcedureSqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitProcedureSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ProcedureSqlStatement() (localctx IProcedureSqlStatementContext) {
	localctx = NewProcedureSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, MySqlParserRULE_procedureSqlStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4994)
			p.CompoundStatement()
		}


	case 2:
		{
			p.SetState(4995)
			p.SqlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4998)
		p.Match(MySqlParserSEMI)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICaseAlternativeContext is an interface to support dynamic dispatch.
type ICaseAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	Constant() IConstantContext
	Expression() IExpressionContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseAlternativeContext differentiates from other interfaces.
	IsCaseAlternativeContext()
}

type CaseAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAlternativeContext() *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseAlternative
	return p
}

func InitEmptyCaseAlternativeContext(p *CaseAlternativeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseAlternative
}

func (*CaseAlternativeContext) IsCaseAlternativeContext() {}

func NewCaseAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseAlternative

	return p
}

func (s *CaseAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHEN, 0)
}

func (s *CaseAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *CaseAlternativeContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *CaseAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CaseAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseAlternative(s)
	}
}

func (s *CaseAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseAlternative(s)
	}
}

func (s *CaseAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CaseAlternative() (localctx ICaseAlternativeContext) {
	localctx = NewCaseAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, MySqlParserRULE_caseAlternative)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5000)
		p.Match(MySqlParserWHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5001)
			p.Constant()
		}


	case 2:
		{
			p.SetState(5002)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(5005)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(5006)
					p.ProcedureSqlStatement()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5009)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElifAlternativeContext is an interface to support dynamic dispatch.
type IElifAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSEIF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsElifAlternativeContext differentiates from other interfaces.
	IsElifAlternativeContext()
}

type ElifAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElifAlternativeContext() *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_elifAlternative
	return p
}

func InitEmptyElifAlternativeContext(p *ElifAlternativeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_elifAlternative
}

func (*ElifAlternativeContext) IsElifAlternativeContext() {}

func NewElifAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_elifAlternative

	return p
}

func (s *ElifAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ElifAlternativeContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSEIF, 0)
}

func (s *ElifAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElifAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *ElifAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *ElifAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *ElifAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElifAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElifAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterElifAlternative(s)
	}
}

func (s *ElifAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitElifAlternative(s)
	}
}

func (s *ElifAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitElifAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ElifAlternative() (localctx IElifAlternativeContext) {
	localctx = NewElifAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, MySqlParserRULE_elifAlternative)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5011)
		p.Match(MySqlParserELSEIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5012)
		p.expression(0)
	}
	{
		p.SetState(5013)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(5014)
					p.ProcedureSqlStatement()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5017)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterUser
	return p
}

func InitEmptyAlterUserContext(p *AlterUserContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterUser
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) CopyAll(ctx *AlterUserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type AlterUserMysqlV80Context struct {
	AlterUserContext
	tlsNone antlr.Token
}

func NewAlterUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV80Context {
	var p = new(AlterUserMysqlV80Context)

	InitEmptyAlterUserContext(&p.AlterUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterUserContext))

	return p
}


func (s *AlterUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }


func (s *AlterUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *AlterUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV80Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *AlterUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *AlterUserMysqlV80Context) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *AlterUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *AlterUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *AlterUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *AlterUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *AlterUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *AlterUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *AlterUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *AlterUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *AlterUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *AlterUserMysqlV80Context) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterUserMysqlV80Context) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *AlterUserMysqlV80Context) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *AlterUserMysqlV80Context) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *AlterUserMysqlV80Context) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *AlterUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUserMysqlV80(s)
	}
}

func (s *AlterUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUserMysqlV80(s)
	}
}

func (s *AlterUserMysqlV80Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterUserMysqlV80(s)

	default:
		return t.VisitChildren(s)
	}
}


type AlterUserMysqlV56Context struct {
	AlterUserContext
}

func NewAlterUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV56Context {
	var p = new(AlterUserMysqlV56Context)

	InitEmptyAlterUserContext(&p.AlterUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterUserContext))

	return p
}

func (s *AlterUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV56Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *AlterUserMysqlV56Context) AllUserSpecification() []IUserSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IUserSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserSpecificationContext); ok {
			tst[i] = t.(IUserSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV56Context) UserSpecification(i int) IUserSpecificationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserSpecificationContext)
}

func (s *AlterUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *AlterUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUserMysqlV56(s)
	}
}

func (s *AlterUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUserMysqlV56(s)
	}
}

func (s *AlterUserMysqlV56Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterUserMysqlV56(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) AlterUser() (localctx IAlterUserContext) {
	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, MySqlParserRULE_alterUser)
	var _la int

	p.SetState(5092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 746, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5019)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5020)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5021)
			p.UserSpecification()
		}
		p.SetState(5026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5022)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5023)
				p.UserSpecification()
			}


			p.SetState(5028)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewAlterUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5029)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5030)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserIF {
			{
				p.SetState(5031)
				p.IfExists()
			}

		}
		{
			p.SetState(5034)
			p.UserAuthOption()
		}
		p.SetState(5039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5035)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5036)
				p.UserAuthOption()
			}


			p.SetState(5041)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5042)
				p.Match(MySqlParserREQUIRE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5054)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5043)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*AlterUserMysqlV80Context).tlsNone = _m
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5044)
					p.TlsOption()
				}
				p.SetState(5051)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5046)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)


					if _la == MySqlParserAND {
						{
							p.SetState(5045)
							p.Match(MySqlParserAND)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}

					}
					{
						p.SetState(5048)
						p.TlsOption()
					}


					p.SetState(5053)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_la = p.GetTokenStream().LA(1)
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5064)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 740, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5058)
				p.Match(MySqlParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5060)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = ((int64((_la - 498)) & ^0x3f) == 0 && ((int64(1) << (_la - 498)) & 51) != 0) {
				{
					p.SetState(5059)
					p.UserResourceOption()
				}


				p.SetState(5062)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(5070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserACCOUNT || _la == MySqlParserFAILED_LOGIN_ATTEMPTS || _la == MySqlParserPASSWORD || _la == MySqlParserPASSWORD_LOCK_TIME {
			p.SetState(5068)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME:
				{
					p.SetState(5066)
					p.UserPasswordOption()
				}


			case MySqlParserACCOUNT:
				{
					p.SetState(5067)
					p.UserLockOption()
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(5072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserCOMMENT:
			{
				p.SetState(5073)
				p.Match(MySqlParserCOMMENT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5074)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserATTRIBUTE:
			{
				p.SetState(5075)
				p.Match(MySqlParserATTRIBUTE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5076)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:



		default:
		}


	case 3:
		localctx = NewAlterUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5079)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5080)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5082)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 744, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5081)
				p.IfExists()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(5086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5084)
				p.UserName()
			}


		case 2:
			{
				p.SetState(5085)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(5088)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5089)
			p.Match(MySqlParserROLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5090)
			p.RoleOption()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUser
	return p
}

func InitEmptyCreateUserContext(p *CreateUserContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUser
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CopyAll(ctx *CreateUserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type CreateUserMysqlV56Context struct {
	CreateUserContext
}

func NewCreateUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV56Context {
	var p = new(CreateUserMysqlV56Context)

	InitEmptyCreateUserContext(&p.CreateUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateUserContext))

	return p
}

func (s *CreateUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV56Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *CreateUserMysqlV56Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV56Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *CreateUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUserMysqlV56(s)
	}
}

func (s *CreateUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUserMysqlV56(s)
	}
}

func (s *CreateUserMysqlV56Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateUserMysqlV56(s)

	default:
		return t.VisitChildren(s)
	}
}


type CreateUserMysqlV80Context struct {
	CreateUserContext
	tlsNone antlr.Token
}

func NewCreateUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV80Context {
	var p = new(CreateUserMysqlV80Context)

	InitEmptyCreateUserContext(&p.CreateUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateUserContext))

	return p
}


func (s *CreateUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }


func (s *CreateUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *CreateUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV80Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *CreateUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV80Context) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateUserMysqlV80Context) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *CreateUserMysqlV80Context) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *CreateUserMysqlV80Context) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *CreateUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *CreateUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *CreateUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *CreateUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *CreateUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *CreateUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *CreateUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *CreateUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *CreateUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *CreateUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}


func (s *CreateUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUserMysqlV80(s)
	}
}

func (s *CreateUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUserMysqlV80(s)
	}
}

func (s *CreateUserMysqlV80Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateUserMysqlV80(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) CreateUser() (localctx ICreateUserContext) {
	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, MySqlParserRULE_createUser)
	var _la int

	p.SetState(5159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 760, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5094)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5095)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5096)
			p.UserAuthOption()
		}
		p.SetState(5101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5097)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5098)
				p.UserAuthOption()
			}


			p.SetState(5103)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewCreateUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5104)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5105)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserIF {
			{
				p.SetState(5106)
				p.IfNotExists()
			}

		}
		{
			p.SetState(5109)
			p.UserAuthOption()
		}
		p.SetState(5114)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5110)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5111)
				p.UserAuthOption()
			}


			p.SetState(5116)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT {
			{
				p.SetState(5117)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5118)
				p.Match(MySqlParserROLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5119)
				p.RoleOption()
			}

		}
		p.SetState(5136)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5122)
				p.Match(MySqlParserREQUIRE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5134)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5123)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*CreateUserMysqlV80Context).tlsNone = _m
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5124)
					p.TlsOption()
				}
				p.SetState(5131)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5126)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)


					if _la == MySqlParserAND {
						{
							p.SetState(5125)
							p.Match(MySqlParserAND)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}

					}
					{
						p.SetState(5128)
						p.TlsOption()
					}


					p.SetState(5133)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_la = p.GetTokenStream().LA(1)
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5144)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 756, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5138)
				p.Match(MySqlParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5140)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for ok := true; ok; ok = ((int64((_la - 498)) & ^0x3f) == 0 && ((int64(1) << (_la - 498)) & 51) != 0) {
				{
					p.SetState(5139)
					p.UserResourceOption()
				}


				p.SetState(5142)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(5150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserACCOUNT || _la == MySqlParserFAILED_LOGIN_ATTEMPTS || _la == MySqlParserPASSWORD || _la == MySqlParserPASSWORD_LOCK_TIME {
			p.SetState(5148)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME:
				{
					p.SetState(5146)
					p.UserPasswordOption()
				}


			case MySqlParserACCOUNT:
				{
					p.SetState(5147)
					p.UserLockOption()
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(5152)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserCOMMENT:
			{
				p.SetState(5153)
				p.Match(MySqlParserCOMMENT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5154)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserATTRIBUTE:
			{
				p.SetState(5155)
				p.Match(MySqlParserATTRIBUTE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5156)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:



		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropUser
	return p
}

func InitEmptyDropUserContext(p *DropUserContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropUser
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *DropUserContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DropUserContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DropUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (s *DropUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropUser(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DropUser() (localctx IDropUserContext) {
	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, MySqlParserRULE_dropUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5161)
		p.Match(MySqlParserDROP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5162)
		p.Match(MySqlParserUSER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIF {
		{
			p.SetState(5163)
			p.IfExists()
		}

	}
	{
		p.SetState(5166)
		p.UserName()
	}
	p.SetState(5171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(5167)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5168)
			p.UserName()
		}


		p.SetState(5173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrantStatementContext is an interface to support dynamic dispatch.
type IGrantStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrivilegeObject returns the privilegeObject token.
	GetPrivilegeObject() antlr.Token 

	// GetTlsNone returns the tlsNone token.
	GetTlsNone() antlr.Token 


	// SetPrivilegeObject sets the privilegeObject token.
	SetPrivilegeObject(antlr.Token) 

	// SetTlsNone sets the tlsNone token.
	SetTlsNone(antlr.Token) 


	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	AllPrivelegeClause() []IPrivelegeClauseContext
	PrivelegeClause(i int) IPrivelegeClauseContext
	ON() antlr.TerminalNode
	PrivilegeLevel() IPrivilegeLevelContext
	TO() antlr.TerminalNode
	AllUserAuthOption() []IUserAuthOptionContext
	UserAuthOption(i int) IUserAuthOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	ROLE() antlr.TerminalNode
	RoleOption() IRoleOptionContext
	TABLE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	AllTlsOption() []ITlsOptionContext
	TlsOption(i int) ITlsOptionContext
	NONE() antlr.TerminalNode
	AllOPTION() []antlr.TerminalNode
	OPTION(i int) antlr.TerminalNode
	AllUserResourceOption() []IUserResourceOptionContext
	UserResourceOption(i int) IUserResourceOptionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADMIN() antlr.TerminalNode

	// IsGrantStatementContext differentiates from other interfaces.
	IsGrantStatementContext()
}

type GrantStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	privilegeObject antlr.Token
	tlsNone antlr.Token
}

func NewEmptyGrantStatementContext() *GrantStatementContext {
	var p = new(GrantStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantStatement
	return p
}

func InitEmptyGrantStatementContext(p *GrantStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantStatement
}

func (*GrantStatementContext) IsGrantStatementContext() {}

func NewGrantStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantStatementContext {
	var p = new(GrantStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_grantStatement

	return p
}

func (s *GrantStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantStatementContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }

func (s *GrantStatementContext) GetTlsNone() antlr.Token { return s.tlsNone }


func (s *GrantStatementContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *GrantStatementContext) SetTlsNone(v antlr.Token) { s.tlsNone = v }


func (s *GrantStatementContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGRANT)
}

func (s *GrantStatementContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, i)
}

func (s *GrantStatementContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *GrantStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *GrantStatementContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *GrantStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *GrantStatementContext) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *GrantStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GrantStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GrantStatementContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *GrantStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWITH)
}

func (s *GrantStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, i)
}

func (s *GrantStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *GrantStatementContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *GrantStatementContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *GrantStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *GrantStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *GrantStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *GrantStatementContext) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *GrantStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *GrantStatementContext) AllOPTION() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserOPTION)
}

func (s *GrantStatementContext) OPTION(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, i)
}

func (s *GrantStatementContext) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *GrantStatementContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *GrantStatementContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *GrantStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *GrantStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *GrantStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GrantStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGrantStatement(s)
	}
}

func (s *GrantStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGrantStatement(s)
	}
}

func (s *GrantStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGrantStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) GrantStatement() (localctx IGrantStatementContext) {
	localctx = NewGrantStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, MySqlParserRULE_grantStatement)
	var _la int

	var _alt int

	p.SetState(5267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 781, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5174)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5175)
			p.PrivelegeClause()
		}
		p.SetState(5180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5176)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5177)
				p.PrivelegeClause()
			}


			p.SetState(5182)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5183)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5185)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 764, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5184)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*GrantStatementContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserPROCEDURE || _la == MySqlParserTABLE || _la == MySqlParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*GrantStatementContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(5187)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5188)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5189)
			p.UserAuthOption()
		}
		p.SetState(5194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5190)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5191)
				p.UserAuthOption()
			}


			p.SetState(5196)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5197)
				p.Match(MySqlParserREQUIRE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5198)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*GrantStatementContext).tlsNone = _m
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5199)
					p.TlsOption()
				}
				p.SetState(5206)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5201)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)


					if _la == MySqlParserAND {
						{
							p.SetState(5200)
							p.Match(MySqlParserAND)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}

					}
					{
						p.SetState(5203)
						p.TlsOption()
					}


					p.SetState(5208)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
				    	goto errorExit
				    }
					_la = p.GetTokenStream().LA(1)
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5222)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5213)
				p.Match(MySqlParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5219)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 771, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(5217)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case MySqlParserGRANT:
						{
							p.SetState(5214)
							p.Match(MySqlParserGRANT)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}
						{
							p.SetState(5215)
							p.Match(MySqlParserOPTION)
							if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
							}
						}


					case MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS:
						{
							p.SetState(5216)
							p.UserResourceOption()
						}



					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

				}
				p.SetState(5221)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 771, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(5230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(5224)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5225)
				p.UserName()
			}
			{
				p.SetState(5226)
				p.Match(MySqlParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5227)
				p.Match(MySqlParserROLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5228)
				p.RoleOption()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5232)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5233)
				p.UserName()
			}


		case 2:
			{
				p.SetState(5234)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5237)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5240)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 775, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5238)
					p.UserName()
				}


			case 2:
				{
					p.SetState(5239)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


			p.SetState(5246)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5247)
			p.Match(MySqlParserTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5248)
				p.UserName()
			}


		case 2:
			{
				p.SetState(5249)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5252)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5255)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 778, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5253)
					p.UserName()
				}


			case 2:
				{
					p.SetState(5254)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


			p.SetState(5261)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5265)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 780, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5262)
				p.Match(MySqlParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5263)
				p.Match(MySqlParserADMIN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5264)
				p.Match(MySqlParserOPTION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRoleOptionContext is an interface to support dynamic dispatch.
type IRoleOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRoleOptionContext differentiates from other interfaces.
	IsRoleOptionContext()
}

type RoleOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOptionContext() *RoleOptionContext {
	var p = new(RoleOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleOption
	return p
}

func InitEmptyRoleOptionContext(p *RoleOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleOption
}

func (*RoleOptionContext) IsRoleOptionContext() {}

func NewRoleOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOptionContext {
	var p = new(RoleOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_roleOption

	return p
}

func (s *RoleOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *RoleOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *RoleOptionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *RoleOptionContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCEPT, 0)
}

func (s *RoleOptionContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleOptionContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RoleOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RoleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RoleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleOption(s)
	}
}

func (s *RoleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleOption(s)
	}
}

func (s *RoleOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoleOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RoleOption() (localctx IRoleOptionContext) {
	localctx = NewRoleOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, MySqlParserRULE_roleOption)
	var _la int

	p.SetState(5291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 785, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5269)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5270)
			p.Match(MySqlParserNONE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5271)
			p.Match(MySqlParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserEXCEPT {
			{
				p.SetState(5272)
				p.Match(MySqlParserEXCEPT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5273)
				p.UserName()
			}
			p.SetState(5278)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(5274)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(5275)
					p.UserName()
				}


				p.SetState(5280)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5283)
			p.UserName()
		}
		p.SetState(5288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5284)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5285)
				p.UserName()
			}


			p.SetState(5290)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrantProxyContext is an interface to support dynamic dispatch.
type IGrantProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext


	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)


	// GetToOther returns the toOther rule context list.
	GetToOther() []IUserNameContext


	// SetToOther sets the toOther rule context list.
	SetToOther([]IUserNameContext) 


	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	OPTION() antlr.TerminalNode

	// IsGrantProxyContext differentiates from other interfaces.
	IsGrantProxyContext()
}

type GrantProxyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	fromFirst IUserNameContext 
	toFirst IUserNameContext 
	_userName IUserNameContext 
	toOther []IUserNameContext
}

func NewEmptyGrantProxyContext() *GrantProxyContext {
	var p = new(GrantProxyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantProxy
	return p
}

func InitEmptyGrantProxyContext(p *GrantProxyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantProxy
}

func (*GrantProxyContext) IsGrantProxyContext() {}

func NewGrantProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantProxyContext {
	var p = new(GrantProxyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_grantProxy

	return p
}

func (s *GrantProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *GrantProxyContext) GetToFirst() IUserNameContext { return s.toFirst }

func (s *GrantProxyContext) Get_userName() IUserNameContext { return s._userName }


func (s *GrantProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *GrantProxyContext) SetToFirst(v IUserNameContext) { s.toFirst = v }

func (s *GrantProxyContext) Set_userName(v IUserNameContext) { s._userName = v }


func (s *GrantProxyContext) GetToOther() []IUserNameContext { return s.toOther }


func (s *GrantProxyContext) SetToOther(v []IUserNameContext) { s.toOther = v }


func (s *GrantProxyContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGRANT)
}

func (s *GrantProxyContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, i)
}

func (s *GrantProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *GrantProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *GrantProxyContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *GrantProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GrantProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GrantProxyContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *GrantProxyContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *GrantProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GrantProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGrantProxy(s)
	}
}

func (s *GrantProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGrantProxy(s)
	}
}

func (s *GrantProxyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGrantProxy(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) GrantProxy() (localctx IGrantProxyContext) {
	localctx = NewGrantProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, MySqlParserRULE_grantProxy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5293)
		p.Match(MySqlParserGRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5294)
		p.Match(MySqlParserPROXY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5295)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5296)

		var _x = p.UserName()


		localctx.(*GrantProxyContext).fromFirst = _x
	}
	{
		p.SetState(5297)
		p.Match(MySqlParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5298)

		var _x = p.UserName()


		localctx.(*GrantProxyContext).toFirst = _x
	}
	p.SetState(5303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(5299)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5300)

			var _x = p.UserName()


			localctx.(*GrantProxyContext)._userName = _x
		}
		localctx.(*GrantProxyContext).toOther = append(localctx.(*GrantProxyContext).toOther, localctx.(*GrantProxyContext)._userName)


		p.SetState(5305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5309)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 787, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5306)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5307)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5308)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRenameUserContext is an interface to support dynamic dispatch.
type IRenameUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllRenameUserClause() []IRenameUserClauseContext
	RenameUserClause(i int) IRenameUserClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameUserContext differentiates from other interfaces.
	IsRenameUserContext()
}

type RenameUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameUserContext() *RenameUserContext {
	var p = new(RenameUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUser
	return p
}

func InitEmptyRenameUserContext(p *RenameUserContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUser
}

func (*RenameUserContext) IsRenameUserContext() {}

func NewRenameUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserContext {
	var p = new(RenameUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameUser

	return p
}

func (s *RenameUserContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *RenameUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *RenameUserContext) AllRenameUserClause() []IRenameUserClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameUserClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameUserClauseContext); ok {
			tst[i] = t.(IRenameUserClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserContext) RenameUserClause(i int) IRenameUserClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserClauseContext)
}

func (s *RenameUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RenameUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RenameUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RenameUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameUser(s)
	}
}

func (s *RenameUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameUser(s)
	}
}

func (s *RenameUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameUser(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RenameUser() (localctx IRenameUserContext) {
	localctx = NewRenameUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, MySqlParserRULE_renameUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5311)
		p.Match(MySqlParserRENAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5312)
		p.Match(MySqlParserUSER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5313)
		p.RenameUserClause()
	}
	p.SetState(5318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(5314)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5315)
			p.RenameUserClause()
		}


		p.SetState(5320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRevokeStatementContext is an interface to support dynamic dispatch.
type IRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeStatementContext differentiates from other interfaces.
	IsRevokeStatementContext()
}

type RevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeStatementContext() *RevokeStatementContext {
	var p = new(RevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeStatement
	return p
}

func InitEmptyRevokeStatementContext(p *RevokeStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeStatement
}

func (*RevokeStatementContext) IsRevokeStatementContext() {}

func NewRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeStatementContext {
	var p = new(RevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_revokeStatement

	return p
}

func (s *RevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeStatementContext) CopyAll(ctx *RevokeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type DetailRevokeContext struct {
	RevokeStatementContext
	privilegeObject antlr.Token
}

func NewDetailRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DetailRevokeContext {
	var p = new(DetailRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}


func (s *DetailRevokeContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }


func (s *DetailRevokeContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *DetailRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DetailRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *DetailRevokeContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *DetailRevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DetailRevokeContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *DetailRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *DetailRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DetailRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DetailRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DetailRevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *DetailRevokeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *DetailRevokeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}


func (s *DetailRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDetailRevoke(s)
	}
}

func (s *DetailRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDetailRevoke(s)
	}
}

func (s *DetailRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDetailRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}


type RoleRevokeContext struct {
	RevokeStatementContext
}

func NewRoleRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoleRevokeContext {
	var p = new(RoleRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *RoleRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *RoleRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *RoleRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleRevokeContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RoleRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *RoleRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleRevoke(s)
	}
}

func (s *RoleRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleRevoke(s)
	}
}

func (s *RoleRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoleRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShortRevokeContext struct {
	RevokeStatementContext
}

func NewShortRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShortRevokeContext {
	var p = new(ShortRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *ShortRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *ShortRevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ShortRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ShortRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ShortRevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, 0)
}

func (s *ShortRevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *ShortRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShortRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *ShortRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShortRevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}


func (s *ShortRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShortRevoke(s)
	}
}

func (s *ShortRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShortRevoke(s)
	}
}

func (s *ShortRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShortRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) RevokeStatement() (localctx IRevokeStatementContext) {
	localctx = NewRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, MySqlParserRULE_revokeStatement)
	var _la int

	p.SetState(5391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 800, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDetailRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5321)
			p.Match(MySqlParserREVOKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5322)
			p.PrivelegeClause()
		}
		p.SetState(5327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5323)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5324)
				p.PrivelegeClause()
			}


			p.SetState(5329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5330)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5332)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 790, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5331)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*DetailRevokeContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserPROCEDURE || _la == MySqlParserTABLE || _la == MySqlParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*DetailRevokeContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(5334)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5335)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5336)
			p.UserName()
		}
		p.SetState(5341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5337)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5338)
				p.UserName()
			}


			p.SetState(5343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewShortRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5344)
			p.Match(MySqlParserREVOKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5345)
			p.Match(MySqlParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPRIVILEGES {
			{
				p.SetState(5346)
				p.Match(MySqlParserPRIVILEGES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(5349)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5350)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5351)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5352)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5353)
			p.UserName()
		}
		p.SetState(5358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5354)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5355)
				p.UserName()
			}


			p.SetState(5360)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 3:
		localctx = NewRoleRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5361)
			p.Match(MySqlParserREVOKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 794, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5362)
				p.UserName()
			}


		case 2:
			{
				p.SetState(5363)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5366)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5369)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 795, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5367)
					p.UserName()
				}


			case 2:
				{
					p.SetState(5368)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


			p.SetState(5375)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5376)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 797, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5377)
				p.UserName()
			}


		case 2:
			{
				p.SetState(5378)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5381)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5384)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 798, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5382)
					p.UserName()
				}


			case 2:
				{
					p.SetState(5383)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


			p.SetState(5390)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRevokeProxyContext is an interface to support dynamic dispatch.
type IRevokeProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnUser returns the onUser rule contexts.
	GetOnUser() IUserNameContext

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext


	// SetOnUser sets the onUser rule contexts.
	SetOnUser(IUserNameContext)

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)


	// GetFromOther returns the fromOther rule context list.
	GetFromOther() []IUserNameContext


	// SetFromOther sets the fromOther rule context list.
	SetFromOther([]IUserNameContext) 


	// Getter signatures
	REVOKE() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRevokeProxyContext differentiates from other interfaces.
	IsRevokeProxyContext()
}

type RevokeProxyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	onUser IUserNameContext 
	fromFirst IUserNameContext 
	_userName IUserNameContext 
	fromOther []IUserNameContext
}

func NewEmptyRevokeProxyContext() *RevokeProxyContext {
	var p = new(RevokeProxyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeProxy
	return p
}

func InitEmptyRevokeProxyContext(p *RevokeProxyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeProxy
}

func (*RevokeProxyContext) IsRevokeProxyContext() {}

func NewRevokeProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeProxyContext {
	var p = new(RevokeProxyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_revokeProxy

	return p
}

func (s *RevokeProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeProxyContext) GetOnUser() IUserNameContext { return s.onUser }

func (s *RevokeProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RevokeProxyContext) Get_userName() IUserNameContext { return s._userName }


func (s *RevokeProxyContext) SetOnUser(v IUserNameContext) { s.onUser = v }

func (s *RevokeProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RevokeProxyContext) Set_userName(v IUserNameContext) { s._userName = v }


func (s *RevokeProxyContext) GetFromOther() []IUserNameContext { return s.fromOther }


func (s *RevokeProxyContext) SetFromOther(v []IUserNameContext) { s.fromOther = v }


func (s *RevokeProxyContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *RevokeProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *RevokeProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *RevokeProxyContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *RevokeProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RevokeProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RevokeProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RevokeProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RevokeProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RevokeProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRevokeProxy(s)
	}
}

func (s *RevokeProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRevokeProxy(s)
	}
}

func (s *RevokeProxyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRevokeProxy(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RevokeProxy() (localctx IRevokeProxyContext) {
	localctx = NewRevokeProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, MySqlParserRULE_revokeProxy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5393)
		p.Match(MySqlParserREVOKE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5394)
		p.Match(MySqlParserPROXY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5395)
		p.Match(MySqlParserON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5396)

		var _x = p.UserName()


		localctx.(*RevokeProxyContext).onUser = _x
	}
	{
		p.SetState(5397)
		p.Match(MySqlParserFROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5398)

		var _x = p.UserName()


		localctx.(*RevokeProxyContext).fromFirst = _x
	}
	p.SetState(5403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(5399)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5400)

			var _x = p.UserName()


			localctx.(*RevokeProxyContext)._userName = _x
		}
		localctx.(*RevokeProxyContext).fromOther = append(localctx.(*RevokeProxyContext).fromOther, localctx.(*RevokeProxyContext)._userName)


		p.SetState(5405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetPasswordStatementContext is an interface to support dynamic dispatch.
type ISetPasswordStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	PasswordFunctionClause() IPasswordFunctionClauseContext
	STRING_LITERAL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	UserName() IUserNameContext

	// IsSetPasswordStatementContext differentiates from other interfaces.
	IsSetPasswordStatementContext()
}

type SetPasswordStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetPasswordStatementContext() *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setPasswordStatement
	return p
}

func InitEmptySetPasswordStatementContext(p *SetPasswordStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setPasswordStatement
}

func (*SetPasswordStatementContext) IsSetPasswordStatementContext() {}

func NewSetPasswordStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setPasswordStatement

	return p
}

func (s *SetPasswordStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetPasswordStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetPasswordStatementContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *SetPasswordStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SetPasswordStatementContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *SetPasswordStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SetPasswordStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *SetPasswordStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetPasswordStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SetPasswordStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetPasswordStatement(s)
	}
}

func (s *SetPasswordStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetPasswordStatement(s)
	}
}

func (s *SetPasswordStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetPasswordStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SetPasswordStatement() (localctx ISetPasswordStatementContext) {
	localctx = NewSetPasswordStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, MySqlParserRULE_setPasswordStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5406)
		p.Match(MySqlParserSET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5407)
		p.Match(MySqlParserPASSWORD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserFOR {
		{
			p.SetState(5408)
			p.Match(MySqlParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5409)
			p.UserName()
		}

	}
	{
		p.SetState(5412)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserOLD_PASSWORD, MySqlParserPASSWORD:
		{
			p.SetState(5413)
			p.PasswordFunctionClause()
		}


	case MySqlParserSTRING_LITERAL:
		{
			p.SetState(5414)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUserSpecificationContext is an interface to support dynamic dispatch.
type IUserSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	UserPasswordOption() IUserPasswordOptionContext

	// IsUserSpecificationContext differentiates from other interfaces.
	IsUserSpecificationContext()
}

type UserSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserSpecificationContext() *UserSpecificationContext {
	var p = new(UserSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userSpecification
	return p
}

func InitEmptyUserSpecificationContext(p *UserSpecificationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userSpecification
}

func (*UserSpecificationContext) IsUserSpecificationContext() {}

func NewUserSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserSpecificationContext {
	var p = new(UserSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userSpecification

	return p
}

func (s *UserSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *UserSpecificationContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *UserSpecificationContext) UserPasswordOption() IUserPasswordOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *UserSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UserSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserSpecification(s)
	}
}

func (s *UserSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserSpecification(s)
	}
}

func (s *UserSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UserSpecification() (localctx IUserSpecificationContext) {
	localctx = NewUserSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, MySqlParserRULE_userSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5417)
		p.UserName()
	}
	{
		p.SetState(5418)
		p.UserPasswordOption()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUserAuthOptionContext is an interface to support dynamic dispatch.
type IUserAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserAuthOptionContext differentiates from other interfaces.
	IsUserAuthOptionContext()
}

type UserAuthOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserAuthOptionContext() *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userAuthOption
	return p
}

func InitEmptyUserAuthOptionContext(p *UserAuthOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userAuthOption
}

func (*UserAuthOptionContext) IsUserAuthOptionContext() {}

func NewUserAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userAuthOption

	return p
}

func (s *UserAuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserAuthOptionContext) CopyAll(ctx *UserAuthOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UserAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserAuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SimpleAuthOptionContext struct {
	UserAuthOptionContext
}

func NewSimpleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleAuthOptionContext {
	var p = new(SimpleAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *SimpleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}


func (s *SimpleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleAuthOption(s)
	}
}

func (s *SimpleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleAuthOption(s)
	}
}

func (s *SimpleAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type ModuleAuthOptionContext struct {
	UserAuthOptionContext
}

func NewModuleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleAuthOptionContext {
	var p = new(ModuleAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *ModuleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ModuleAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *ModuleAuthOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *ModuleAuthOptionContext) AuthenticationRule() IAuthenticationRuleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthenticationRuleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthenticationRuleContext)
}


func (s *ModuleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterModuleAuthOption(s)
	}
}

func (s *ModuleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitModuleAuthOption(s)
	}
}

func (s *ModuleAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitModuleAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type RandomAuthOptionContext struct {
	UserAuthOptionContext
}

func NewRandomAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RandomAuthOptionContext {
	var p = new(RandomAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *RandomAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RandomAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RandomAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *RandomAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *RandomAuthOptionContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM, 0)
}

func (s *RandomAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *RandomAuthOptionContext) AuthOptionClause() IAuthOptionClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionClauseContext)
}


func (s *RandomAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRandomAuthOption(s)
	}
}

func (s *RandomAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRandomAuthOption(s)
	}
}

func (s *RandomAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRandomAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type StringAuthOptionContext struct {
	UserAuthOptionContext
}

func NewStringAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringAuthOptionContext {
	var p = new(StringAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *StringAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *StringAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *StringAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *StringAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *StringAuthOptionContext) AuthOptionClause() IAuthOptionClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionClauseContext)
}


func (s *StringAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringAuthOption(s)
	}
}

func (s *StringAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringAuthOption(s)
	}
}

func (s *StringAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type HashAuthOptionContext struct {
	UserAuthOptionContext
	hashed antlr.Token
}

func NewHashAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HashAuthOptionContext {
	var p = new(HashAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}


func (s *HashAuthOptionContext) GetHashed() antlr.Token { return s.hashed }


func (s *HashAuthOptionContext) SetHashed(v antlr.Token) { s.hashed = v }

func (s *HashAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HashAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *HashAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *HashAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *HashAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *HashAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *HashAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHashAuthOption(s)
	}
}

func (s *HashAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHashAuthOption(s)
	}
}

func (s *HashAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHashAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) UserAuthOption() (localctx IUserAuthOptionContext) {
	localctx = NewUserAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, MySqlParserRULE_userAuthOption)
	p.SetState(5445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 804, p.GetParserRuleContext()) {
	case 1:
		localctx = NewHashAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5420)
			p.UserName()
		}
		{
			p.SetState(5421)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5422)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5423)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5424)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*HashAuthOptionContext).hashed = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		localctx = NewRandomAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5426)
			p.UserName()
		}
		{
			p.SetState(5427)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5428)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5429)
			p.Match(MySqlParserRANDOM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5430)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5431)
			p.AuthOptionClause()
		}


	case 3:
		localctx = NewStringAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5433)
			p.UserName()
		}
		{
			p.SetState(5434)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5435)
			p.Match(MySqlParserBY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5436)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5437)
			p.AuthOptionClause()
		}


	case 4:
		localctx = NewModuleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5439)
			p.UserName()
		}
		{
			p.SetState(5440)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5441)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5442)
			p.AuthenticationRule()
		}


	case 5:
		localctx = NewSimpleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5444)
			p.UserName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAuthOptionClauseContext is an interface to support dynamic dispatch.
type IAuthOptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode

	// IsAuthOptionClauseContext differentiates from other interfaces.
	IsAuthOptionClauseContext()
}

type AuthOptionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthOptionClauseContext() *AuthOptionClauseContext {
	var p = new(AuthOptionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authOptionClause
	return p
}

func InitEmptyAuthOptionClauseContext(p *AuthOptionClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authOptionClause
}

func (*AuthOptionClauseContext) IsAuthOptionClauseContext() {}

func NewAuthOptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthOptionClauseContext {
	var p = new(AuthOptionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authOptionClause

	return p
}

func (s *AuthOptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthOptionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *AuthOptionClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AuthOptionClauseContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETAIN, 0)
}

func (s *AuthOptionClauseContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *AuthOptionClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *AuthOptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthOptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AuthOptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAuthOptionClause(s)
	}
}

func (s *AuthOptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAuthOptionClause(s)
	}
}

func (s *AuthOptionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAuthOptionClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AuthOptionClause() (localctx IAuthOptionClauseContext) {
	localctx = NewAuthOptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, MySqlParserRULE_authOptionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5449)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 805, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5447)
			p.Match(MySqlParserREPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5448)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(5454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserRETAIN {
		{
			p.SetState(5451)
			p.Match(MySqlParserRETAIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5452)
			p.Match(MySqlParserCURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5453)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAuthenticationRuleContext is an interface to support dynamic dispatch.
type IAuthenticationRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthenticationRuleContext differentiates from other interfaces.
	IsAuthenticationRuleContext()
}

type AuthenticationRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthenticationRuleContext() *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authenticationRule
	return p
}

func InitEmptyAuthenticationRuleContext(p *AuthenticationRuleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authenticationRule
}

func (*AuthenticationRuleContext) IsAuthenticationRuleContext() {}

func NewAuthenticationRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authenticationRule

	return p
}

func (s *AuthenticationRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthenticationRuleContext) CopyAll(ctx *AuthenticationRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthenticationRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthenticationRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type PasswordModuleOptionContext struct {
	AuthenticationRuleContext
}

func NewPasswordModuleOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordModuleOptionContext {
	var p = new(PasswordModuleOptionContext)

	InitEmptyAuthenticationRuleContext(&p.AuthenticationRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *PasswordModuleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordModuleOptionContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *PasswordModuleOptionContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *PasswordModuleOptionContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}


func (s *PasswordModuleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordModuleOption(s)
	}
}

func (s *PasswordModuleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordModuleOption(s)
	}
}

func (s *PasswordModuleOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordModuleOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type ModuleContext struct {
	AuthenticationRuleContext
}

func NewModuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleContext {
	var p = new(ModuleContext)

	InitEmptyAuthenticationRuleContext(&p.AuthenticationRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *ModuleContext) AuthOptionClause() IAuthOptionClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionClauseContext)
}

func (s *ModuleContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *ModuleContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *ModuleContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *ModuleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ModuleContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM, 0)
}

func (s *ModuleContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}


func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitModule(s)
	}
}

func (s *ModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitModule(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) AuthenticationRule() (localctx IAuthenticationRuleContext) {
	localctx = NewAuthenticationRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, MySqlParserRULE_authenticationRule)
	var _la int

	p.SetState(5470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext()) {
	case 1:
		localctx = NewModuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5456)
			p.AuthPlugin()
		}
		p.SetState(5464)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 808, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5457)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserAS || _la == MySqlParserBY || _la == MySqlParserUSING) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(5461)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSTRING_LITERAL:
				{
					p.SetState(5458)
					p.Match(MySqlParserSTRING_LITERAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case MySqlParserRANDOM:
				{
					p.SetState(5459)
					p.Match(MySqlParserRANDOM)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(5460)
					p.Match(MySqlParserPASSWORD)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(5463)
				p.AuthOptionClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		localctx = NewPasswordModuleOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5466)
			p.AuthPlugin()
		}
		{
			p.SetState(5467)
			p.Match(MySqlParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5468)
			p.PasswordFunctionClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITlsOptionContext is an interface to support dynamic dispatch.
type ITlsOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SSL() antlr.TerminalNode
	X509() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode

	// IsTlsOptionContext differentiates from other interfaces.
	IsTlsOptionContext()
}

type TlsOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTlsOptionContext() *TlsOptionContext {
	var p = new(TlsOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tlsOption
	return p
}

func InitEmptyTlsOptionContext(p *TlsOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tlsOption
}

func (*TlsOptionContext) IsTlsOptionContext() {}

func NewTlsOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TlsOptionContext {
	var p = new(TlsOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tlsOption

	return p
}

func (s *TlsOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TlsOptionContext) SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSSL, 0)
}

func (s *TlsOptionContext) X509() antlr.TerminalNode {
	return s.GetToken(MySqlParserX509, 0)
}

func (s *TlsOptionContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCIPHER, 0)
}

func (s *TlsOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TlsOptionContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSUER, 0)
}

func (s *TlsOptionContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBJECT, 0)
}

func (s *TlsOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TlsOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TlsOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTlsOption(s)
	}
}

func (s *TlsOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTlsOption(s)
	}
}

func (s *TlsOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTlsOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TlsOption() (localctx ITlsOptionContext) {
	localctx = NewTlsOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, MySqlParserRULE_tlsOption)
	p.SetState(5480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSSL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5472)
			p.Match(MySqlParserSSL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserX509:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5473)
			p.Match(MySqlParserX509)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCIPHER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5474)
			p.Match(MySqlParserCIPHER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5475)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserISSUER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5476)
			p.Match(MySqlParserISSUER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5477)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSUBJECT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5478)
			p.Match(MySqlParserSUBJECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5479)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUserResourceOptionContext is an interface to support dynamic dispatch.
type IUserResourceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode

	// IsUserResourceOptionContext differentiates from other interfaces.
	IsUserResourceOptionContext()
}

type UserResourceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserResourceOptionContext() *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userResourceOption
	return p
}

func InitEmptyUserResourceOptionContext(p *UserResourceOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userResourceOption
}

func (*UserResourceOptionContext) IsUserResourceOptionContext() {}

func NewUserResourceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userResourceOption

	return p
}

func (s *UserResourceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserResourceOptionContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserResourceOptionContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_USER_CONNECTIONS, 0)
}

func (s *UserResourceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserResourceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UserResourceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserResourceOption(s)
	}
}

func (s *UserResourceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserResourceOption(s)
	}
}

func (s *UserResourceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserResourceOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UserResourceOption() (localctx IUserResourceOptionContext) {
	localctx = NewUserResourceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, MySqlParserRULE_userResourceOption)
	p.SetState(5490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserMAX_QUERIES_PER_HOUR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5482)
			p.Match(MySqlParserMAX_QUERIES_PER_HOUR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5483)
			p.DecimalLiteral()
		}


	case MySqlParserMAX_UPDATES_PER_HOUR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5484)
			p.Match(MySqlParserMAX_UPDATES_PER_HOUR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5485)
			p.DecimalLiteral()
		}


	case MySqlParserMAX_CONNECTIONS_PER_HOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5486)
			p.Match(MySqlParserMAX_CONNECTIONS_PER_HOUR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5487)
			p.DecimalLiteral()
		}


	case MySqlParserMAX_USER_CONNECTIONS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5488)
			p.Match(MySqlParserMAX_USER_CONNECTIONS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5489)
			p.DecimalLiteral()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUserPasswordOptionContext is an interface to support dynamic dispatch.
type IUserPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExpireType returns the expireType token.
	GetExpireType() antlr.Token 


	// SetExpireType sets the expireType token.
	SetExpireType(antlr.Token) 


	// Getter signatures
	PASSWORD() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	DAY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode

	// IsUserPasswordOptionContext differentiates from other interfaces.
	IsUserPasswordOptionContext()
}

type UserPasswordOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	expireType antlr.Token
}

func NewEmptyUserPasswordOptionContext() *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userPasswordOption
	return p
}

func InitEmptyUserPasswordOptionContext(p *UserPasswordOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userPasswordOption
}

func (*UserPasswordOptionContext) IsUserPasswordOptionContext() {}

func NewUserPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userPasswordOption

	return p
}

func (s *UserPasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPasswordOptionContext) GetExpireType() antlr.Token { return s.expireType }


func (s *UserPasswordOptionContext) SetExpireType(v antlr.Token) { s.expireType = v }


func (s *UserPasswordOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *UserPasswordOptionContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPIRE, 0)
}

func (s *UserPasswordOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserPasswordOptionContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *UserPasswordOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *UserPasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEVER, 0)
}

func (s *UserPasswordOptionContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *UserPasswordOptionContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTORY, 0)
}

func (s *UserPasswordOptionContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREUSE, 0)
}

func (s *UserPasswordOptionContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *UserPasswordOptionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *UserPasswordOptionContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONAL, 0)
}

func (s *UserPasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *UserPasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD_LOCK_TIME, 0)
}

func (s *UserPasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *UserPasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UserPasswordOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserPasswordOption(s)
	}
}

func (s *UserPasswordOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserPasswordOption(s)
	}
}

func (s *UserPasswordOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserPasswordOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UserPasswordOption() (localctx IUserPasswordOptionContext) {
	localctx = NewUserPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, MySqlParserRULE_userPasswordOption)
	var _la int

	p.SetState(5530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 817, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5492)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5493)
			p.Match(MySqlParserEXPIRE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5494)

				var _m = p.Match(MySqlParserDEFAULT)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserNEVER:
			{
				p.SetState(5495)

				var _m = p.Match(MySqlParserNEVER)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserINTERVAL:
			{
				p.SetState(5496)

				var _m = p.Match(MySqlParserINTERVAL)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5497)
				p.DecimalLiteral()
			}
			{
				p.SetState(5498)
				p.Match(MySqlParserDAY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserATTRIBUTE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserACCOUNT, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:



		default:
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5502)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5503)
			p.Match(MySqlParserHISTORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5504)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5505)
				p.DecimalLiteral()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5508)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5509)
			p.Match(MySqlParserREUSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5510)
			p.Match(MySqlParserINTERVAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5511)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5512)
				p.DecimalLiteral()
			}
			{
				p.SetState(5513)
				p.Match(MySqlParserDAY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5517)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5518)
			p.Match(MySqlParserREQUIRE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5519)
			p.Match(MySqlParserCURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT || _la == MySqlParserOPTIONAL {
			{
				p.SetState(5520)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserDEFAULT || _la == MySqlParserOPTIONAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5523)
			p.Match(MySqlParserFAILED_LOGIN_ATTEMPTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5524)
			p.DecimalLiteral()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5525)
			p.Match(MySqlParserPASSWORD_LOCK_TIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5526)
				p.DecimalLiteral()
			}


		case MySqlParserUNBOUNDED:
			{
				p.SetState(5527)
				p.Match(MySqlParserUNBOUNDED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUserLockOptionContext is an interface to support dynamic dispatch.
type IUserLockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token 


	// SetLockType sets the lockType token.
	SetLockType(antlr.Token) 


	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode

	// IsUserLockOptionContext differentiates from other interfaces.
	IsUserLockOptionContext()
}

type UserLockOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	lockType antlr.Token
}

func NewEmptyUserLockOptionContext() *UserLockOptionContext {
	var p = new(UserLockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userLockOption
	return p
}

func InitEmptyUserLockOptionContext(p *UserLockOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userLockOption
}

func (*UserLockOptionContext) IsUserLockOptionContext() {}

func NewUserLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserLockOptionContext {
	var p = new(UserLockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userLockOption

	return p
}

func (s *UserLockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserLockOptionContext) GetLockType() antlr.Token { return s.lockType }


func (s *UserLockOptionContext) SetLockType(v antlr.Token) { s.lockType = v }


func (s *UserLockOptionContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserACCOUNT, 0)
}

func (s *UserLockOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *UserLockOptionContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNLOCK, 0)
}

func (s *UserLockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserLockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UserLockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserLockOption(s)
	}
}

func (s *UserLockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserLockOption(s)
	}
}

func (s *UserLockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UserLockOption() (localctx IUserLockOptionContext) {
	localctx = NewUserLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, MySqlParserRULE_userLockOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5532)
		p.Match(MySqlParserACCOUNT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5533)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*UserLockOptionContext).lockType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserLOCK || _la == MySqlParserUNLOCK) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*UserLockOptionContext).lockType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivelegeClauseContext is an interface to support dynamic dispatch.
type IPrivelegeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Privilege() IPrivilegeContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode

	// IsPrivelegeClauseContext differentiates from other interfaces.
	IsPrivelegeClauseContext()
}

type PrivelegeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivelegeClauseContext() *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privelegeClause
	return p
}

func InitEmptyPrivelegeClauseContext(p *PrivelegeClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privelegeClause
}

func (*PrivelegeClauseContext) IsPrivelegeClauseContext() {}

func NewPrivelegeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privelegeClause

	return p
}

func (s *PrivelegeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivelegeClauseContext) Privilege() IPrivilegeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivelegeClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PrivelegeClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivelegeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivelegeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivelegeClause(s)
	}
}

func (s *PrivelegeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivelegeClause(s)
	}
}

func (s *PrivelegeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrivelegeClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PrivelegeClause() (localctx IPrivelegeClauseContext) {
	localctx = NewPrivelegeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, MySqlParserRULE_privelegeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5535)
		p.Privilege()
	}
	p.SetState(5540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(5536)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5537)
			p.UidList()
		}
		{
			p.SetState(5538)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	USER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode
	AUDIT_ABORT_EXEMPT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_EXEMPT() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode
	FLUSH_STATUS() antlr.TerminalNode
	FLUSH_TABLES() antlr.TerminalNode
	FLUSH_USER_RESOURCES() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INNODB_REDO_LOG_ENABLE() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	SERVICE_CONNECTION_ADMIN() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SKIP_QUERY_REWRITE() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TP_CONNECTION_ADMIN() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	S3() antlr.TerminalNode
	INTO() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *PrivilegeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *PrivilegeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *PrivilegeContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUTINE, 0)
}

func (s *PrivilegeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *PrivilegeContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *PrivilegeContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *PrivilegeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *PrivilegeContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *PrivilegeContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *PrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *PrivilegeContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *PrivilegeContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *PrivilegeContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *PrivilegeContext) FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE, 0)
}

func (s *PrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, 0)
}

func (s *PrivilegeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *PrivilegeContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *PrivilegeContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *PrivilegeContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESS, 0)
}

func (s *PrivilegeContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *PrivilegeContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserREFERENCES, 0)
}

func (s *PrivilegeContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELOAD, 0)
}

func (s *PrivilegeContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *PrivilegeContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLIENT, 0)
}

func (s *PrivilegeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *PrivilegeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *PrivilegeContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASES, 0)
}

func (s *PrivilegeContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *PrivilegeContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUPER, 0)
}

func (s *PrivilegeContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *PrivilegeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *PrivilegeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSAGE, 0)
}

func (s *PrivilegeContext) APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAPPLICATION_PASSWORD_ADMIN, 0)
}

func (s *PrivilegeContext) AUDIT_ABORT_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ABORT_EXEMPT, 0)
}

func (s *PrivilegeContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ADMIN, 0)
}

func (s *PrivilegeContext) AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHENTICATION_POLICY_ADMIN, 0)
}

func (s *PrivilegeContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBACKUP_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLONE_ADMIN, 0)
}

func (s *PrivilegeContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_EXEMPT, 0)
}

func (s *PrivilegeContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_USER, 0)
}

func (s *PrivilegeContext) FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_OPTIMIZER_COSTS, 0)
}

func (s *PrivilegeContext) FLUSH_STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_STATUS, 0)
}

func (s *PrivilegeContext) FLUSH_TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_TABLES, 0)
}

func (s *PrivilegeContext) FLUSH_USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_USER_RESOURCES, 0)
}

func (s *PrivilegeContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ENABLE, 0)
}

func (s *PrivilegeContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB_STORED_USER, 0)
}

func (s *PrivilegeContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *PrivilegeContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_APPLIER, 0)
}

func (s *PrivilegeContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_USER, 0)
}

func (s *PrivilegeContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE_ADMIN, 0)
}

func (s *PrivilegeContext) SERVICE_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVICE_CONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET_USER_ID, 0)
}

func (s *PrivilegeContext) SKIP_QUERY_REWRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSKIP_QUERY_REWRITE, 0)
}

func (s *PrivilegeContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW_ROUTINE, 0)
}

func (s *PrivilegeContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_USER, 0)
}

func (s *PrivilegeContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) TP_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTP_CONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION_TOKEN_ADMIN, 0)
}

func (s *PrivilegeContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA_RECOVER_ADMIN, 0)
}

func (s *PrivilegeContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *PrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *PrivilegeContext) S3() antlr.TerminalNode {
	return s.GetToken(MySqlParserS3, 0)
}

func (s *PrivilegeContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *PrivilegeContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKE, 0)
}

func (s *PrivilegeContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAMBDA, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, MySqlParserRULE_privilege)
	var _la int

	p.SetState(5635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 823, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5542)
			p.Match(MySqlParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPRIVILEGES {
			{
				p.SetState(5543)
				p.Match(MySqlParserPRIVILEGES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5546)
			p.Match(MySqlParserALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserROUTINE {
			{
				p.SetState(5547)
				p.Match(MySqlParserROUTINE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5550)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserTEMPORARY:
			{
				p.SetState(5551)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5552)
				p.Match(MySqlParserTABLES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserROUTINE:
			{
				p.SetState(5553)
				p.Match(MySqlParserROUTINE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserVIEW:
			{
				p.SetState(5554)
				p.Match(MySqlParserVIEW)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserUSER:
			{
				p.SetState(5555)
				p.Match(MySqlParserUSER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserTABLESPACE:
			{
				p.SetState(5556)
				p.Match(MySqlParserTABLESPACE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserROLE:
			{
				p.SetState(5557)
				p.Match(MySqlParserROLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserON, MySqlParserLR_BRACKET, MySqlParserCOMMA:



		default:
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5560)
			p.Match(MySqlParserDELETE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5561)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserROLE {
			{
				p.SetState(5562)
				p.Match(MySqlParserROLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5565)
			p.Match(MySqlParserEVENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5566)
			p.Match(MySqlParserEXECUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5567)
			p.Match(MySqlParserFILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5568)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5569)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5570)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5571)
			p.Match(MySqlParserINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5572)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5573)
			p.Match(MySqlParserTABLES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5574)
			p.Match(MySqlParserPROCESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5575)
			p.Match(MySqlParserPROXY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5576)
			p.Match(MySqlParserREFERENCES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5577)
			p.Match(MySqlParserRELOAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5578)
			p.Match(MySqlParserREPLICATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5579)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCLIENT || _la == MySqlParserSLAVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5580)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5581)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5582)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASES || _la == MySqlParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5583)
			p.Match(MySqlParserSHUTDOWN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5584)
			p.Match(MySqlParserSUPER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(5585)
			p.Match(MySqlParserTRIGGER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(5586)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(5587)
			p.Match(MySqlParserUSAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(5588)
			p.Match(MySqlParserAPPLICATION_PASSWORD_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(5589)
			p.Match(MySqlParserAUDIT_ABORT_EXEMPT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(5590)
			p.Match(MySqlParserAUDIT_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(5591)
			p.Match(MySqlParserAUTHENTICATION_POLICY_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(5592)
			p.Match(MySqlParserBACKUP_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(5593)
			p.Match(MySqlParserBINLOG_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(5594)
			p.Match(MySqlParserBINLOG_ENCRYPTION_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(5595)
			p.Match(MySqlParserCLONE_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(5596)
			p.Match(MySqlParserCONNECTION_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(5597)
			p.Match(MySqlParserENCRYPTION_KEY_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(5598)
			p.Match(MySqlParserFIREWALL_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(5599)
			p.Match(MySqlParserFIREWALL_EXEMPT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(5600)
			p.Match(MySqlParserFIREWALL_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(5601)
			p.Match(MySqlParserFLUSH_OPTIMIZER_COSTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(5602)
			p.Match(MySqlParserFLUSH_STATUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(5603)
			p.Match(MySqlParserFLUSH_TABLES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(5604)
			p.Match(MySqlParserFLUSH_USER_RESOURCES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(5605)
			p.Match(MySqlParserGROUP_REPLICATION_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(5606)
			p.Match(MySqlParserINNODB_REDO_LOG_ARCHIVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(5607)
			p.Match(MySqlParserINNODB_REDO_LOG_ENABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(5608)
			p.Match(MySqlParserNDB_STORED_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(5609)
			p.Match(MySqlParserPASSWORDLESS_USER_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(5610)
			p.Match(MySqlParserPERSIST_RO_VARIABLES_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(5611)
			p.Match(MySqlParserREPLICATION_APPLIER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(5612)
			p.Match(MySqlParserREPLICATION_SLAVE_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(5613)
			p.Match(MySqlParserRESOURCE_GROUP_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(5614)
			p.Match(MySqlParserRESOURCE_GROUP_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(5615)
			p.Match(MySqlParserROLE_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(5616)
			p.Match(MySqlParserSERVICE_CONNECTION_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(5617)
			p.Match(MySqlParserSESSION_VARIABLES_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(5618)
			p.Match(MySqlParserSET_USER_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(5619)
			p.Match(MySqlParserSKIP_QUERY_REWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(5620)
			p.Match(MySqlParserSHOW_ROUTINE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(5621)
			p.Match(MySqlParserSYSTEM_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(5622)
			p.Match(MySqlParserSYSTEM_VARIABLES_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(5623)
			p.Match(MySqlParserTABLE_ENCRYPTION_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(5624)
			p.Match(MySqlParserTP_CONNECTION_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(5625)
			p.Match(MySqlParserVERSION_TOKEN_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(5626)
			p.Match(MySqlParserXA_RECOVER_ADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(5627)
			p.Match(MySqlParserLOAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5628)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5629)
			p.Match(MySqlParserS3)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(5630)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5631)
			p.Match(MySqlParserINTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5632)
			p.Match(MySqlParserS3)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(5633)
			p.Match(MySqlParserINVOKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5634)
			p.Match(MySqlParserLAMBDA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivilegeLevelContext is an interface to support dynamic dispatch.
type IPrivilegeLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrivilegeLevelContext differentiates from other interfaces.
	IsPrivilegeLevelContext()
}

type PrivilegeLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeLevelContext() *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegeLevel
	return p
}

func InitEmptyPrivilegeLevelContext(p *PrivilegeLevelContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegeLevel
}

func (*PrivilegeLevelContext) IsPrivilegeLevelContext() {}

func NewPrivilegeLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilegeLevel

	return p
}

func (s *PrivilegeLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeLevelContext) CopyAll(ctx *PrivilegeLevelContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrivilegeLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type DefiniteSchemaPrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteSchemaPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteSchemaPrivLevelContext {
	var p = new(DefiniteSchemaPrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteSchemaPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteSchemaPrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteSchemaPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DefiniteSchemaPrivLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}


func (s *DefiniteSchemaPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteSchemaPrivLevel(s)
	}
}

func (s *DefiniteSchemaPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteSchemaPrivLevel(s)
	}
}

func (s *DefiniteSchemaPrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteSchemaPrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}


type DefiniteFullTablePrivLevel2Context struct {
	PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevel2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevel2Context {
	var p = new(DefiniteFullTablePrivLevel2Context)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevel2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevel2Context) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevel2Context) DottedId() IDottedIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}


func (s *DefiniteFullTablePrivLevel2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel2(s)
	}
}

func (s *DefiniteFullTablePrivLevel2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel2(s)
	}
}

func (s *DefiniteFullTablePrivLevel2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteFullTablePrivLevel2(s)

	default:
		return t.VisitChildren(s)
	}
}


type DefiniteFullTablePrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevelContext {
	var p = new(DefiniteFullTablePrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevelContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *DefiniteFullTablePrivLevelContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}


func (s *DefiniteFullTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel(s)
	}
}

func (s *DefiniteFullTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel(s)
	}
}

func (s *DefiniteFullTablePrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteFullTablePrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}


type GlobalPrivLevelContext struct {
	PrivilegeLevelContext
}

func NewGlobalPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GlobalPrivLevelContext {
	var p = new(GlobalPrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *GlobalPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalPrivLevelContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTAR)
}

func (s *GlobalPrivLevelContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, i)
}

func (s *GlobalPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}


func (s *GlobalPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGlobalPrivLevel(s)
	}
}

func (s *GlobalPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGlobalPrivLevel(s)
	}
}

func (s *GlobalPrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGlobalPrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}


type DefiniteTablePrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteTablePrivLevelContext {
	var p = new(DefiniteTablePrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteTablePrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *DefiniteTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteTablePrivLevel(s)
	}
}

func (s *DefiniteTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteTablePrivLevel(s)
	}
}

func (s *DefiniteTablePrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteTablePrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}


type CurrentSchemaPriviLevelContext struct {
	PrivilegeLevelContext
}

func NewCurrentSchemaPriviLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentSchemaPriviLevelContext {
	var p = new(CurrentSchemaPriviLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *CurrentSchemaPriviLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentSchemaPriviLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}


func (s *CurrentSchemaPriviLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentSchemaPriviLevel(s)
	}
}

func (s *CurrentSchemaPriviLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentSchemaPriviLevel(s)
	}
}

func (s *CurrentSchemaPriviLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentSchemaPriviLevel(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) PrivilegeLevel() (localctx IPrivilegeLevelContext) {
	localctx = NewPrivilegeLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, MySqlParserRULE_privilegeLevel)
	p.SetState(5653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 824, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentSchemaPriviLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5637)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		localctx = NewGlobalPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5638)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5639)
			p.Match(MySqlParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5640)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		localctx = NewDefiniteSchemaPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5641)
			p.Uid()
		}
		{
			p.SetState(5642)
			p.Match(MySqlParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5643)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		localctx = NewDefiniteFullTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5645)
			p.Uid()
		}
		{
			p.SetState(5646)
			p.Match(MySqlParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5647)
			p.Uid()
		}


	case 5:
		localctx = NewDefiniteFullTablePrivLevel2Context(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5649)
			p.Uid()
		}
		{
			p.SetState(5650)
			p.DottedId()
		}


	case 6:
		localctx = NewDefiniteTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5652)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRenameUserClauseContext is an interface to support dynamic dispatch.
type IRenameUserClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext


	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)


	// Getter signatures
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext

	// IsRenameUserClauseContext differentiates from other interfaces.
	IsRenameUserClauseContext()
}

type RenameUserClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	fromFirst IUserNameContext 
	toFirst IUserNameContext 
}

func NewEmptyRenameUserClauseContext() *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUserClause
	return p
}

func InitEmptyRenameUserClauseContext(p *RenameUserClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUserClause
}

func (*RenameUserClauseContext) IsRenameUserClauseContext() {}

func NewRenameUserClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameUserClause

	return p
}

func (s *RenameUserClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserClauseContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RenameUserClauseContext) GetToFirst() IUserNameContext { return s.toFirst }


func (s *RenameUserClauseContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RenameUserClauseContext) SetToFirst(v IUserNameContext) { s.toFirst = v }


func (s *RenameUserClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RenameUserClauseContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserClauseContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RenameUserClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RenameUserClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameUserClause(s)
	}
}

func (s *RenameUserClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameUserClause(s)
	}
}

func (s *RenameUserClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameUserClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RenameUserClause() (localctx IRenameUserClauseContext) {
	localctx = NewRenameUserClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, MySqlParserRULE_renameUserClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5655)

		var _x = p.UserName()


		localctx.(*RenameUserClauseContext).fromFirst = _x
	}
	{
		p.SetState(5656)
		p.Match(MySqlParserTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5657)

		var _x = p.UserName()


		localctx.(*RenameUserClauseContext).toFirst = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAnalyzeTableContext is an interface to support dynamic dispatch.
type IAnalyzeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token 


	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token) 


	// Getter signatures
	ANALYZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllHISTOGRAM() []antlr.TerminalNode
	HISTOGRAM(i int) antlr.TerminalNode
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	DROP() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	BUCKETS() antlr.TerminalNode

	// IsAnalyzeTableContext differentiates from other interfaces.
	IsAnalyzeTableContext()
}

type AnalyzeTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	actionOption antlr.Token
}

func NewEmptyAnalyzeTableContext() *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_analyzeTable
	return p
}

func InitEmptyAnalyzeTableContext(p *AnalyzeTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_analyzeTable
}

func (*AnalyzeTableContext) IsAnalyzeTableContext() {}

func NewAnalyzeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_analyzeTable

	return p
}

func (s *AnalyzeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeTableContext) GetActionOption() antlr.Token { return s.actionOption }


func (s *AnalyzeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }


func (s *AnalyzeTableContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserANALYZE, 0)
}

func (s *AnalyzeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *AnalyzeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AnalyzeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *AnalyzeTableContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *AnalyzeTableContext) AllHISTOGRAM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserHISTOGRAM)
}

func (s *AnalyzeTableContext) HISTOGRAM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTOGRAM, i)
}

func (s *AnalyzeTableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *AnalyzeTableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *AnalyzeTableContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeTableContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *AnalyzeTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AnalyzeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *AnalyzeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *AnalyzeTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AnalyzeTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AnalyzeTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AnalyzeTableContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AnalyzeTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUCKETS, 0)
}

func (s *AnalyzeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnalyzeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAnalyzeTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AnalyzeTable() (localctx IAnalyzeTableContext) {
	localctx = NewAnalyzeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, MySqlParserRULE_analyzeTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5659)
		p.Match(MySqlParserANALYZE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5660)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AnalyzeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AnalyzeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5663)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5664)
		p.Tables()
	}
	p.SetState(5682)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 828, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5665)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5666)
			p.Match(MySqlParserHISTOGRAM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5667)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5668)
			p.FullColumnName()
		}
		p.SetState(5673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5669)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5670)
				p.FullColumnName()
			}


			p.SetState(5675)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5680)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 827, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5676)
				p.Match(MySqlParserWITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5677)
				p.DecimalLiteral()
			}
			{
				p.SetState(5678)
				p.Match(MySqlParserBUCKETS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(5695)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 830, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5684)
			p.Match(MySqlParserDROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5685)
			p.Match(MySqlParserHISTOGRAM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5686)
			p.Match(MySqlParserON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5687)
			p.FullColumnName()
		}
		p.SetState(5692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5688)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5689)
				p.FullColumnName()
			}


			p.SetState(5694)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICheckTableContext is an interface to support dynamic dispatch.
type ICheckTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	AllCheckTableOption() []ICheckTableOptionContext
	CheckTableOption(i int) ICheckTableOptionContext

	// IsCheckTableContext differentiates from other interfaces.
	IsCheckTableContext()
}

type CheckTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableContext() *CheckTableContext {
	var p = new(CheckTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTable
	return p
}

func InitEmptyCheckTableContext(p *CheckTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTable
}

func (*CheckTableContext) IsCheckTableContext() {}

func NewCheckTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableContext {
	var p = new(CheckTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checkTable

	return p
}

func (s *CheckTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *CheckTableContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *CheckTableContext) AllCheckTableOption() []ICheckTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICheckTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckTableOptionContext); ok {
			tst[i] = t.(ICheckTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CheckTableContext) CheckTableOption(i int) ICheckTableOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableOptionContext)
}

func (s *CheckTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CheckTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTable(s)
	}
}

func (s *CheckTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTable(s)
	}
}

func (s *CheckTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CheckTable() (localctx ICheckTableContext) {
	localctx = NewCheckTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, MySqlParserRULE_checkTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5697)
		p.Match(MySqlParserCHECK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5698)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5699)
		p.Tables()
	}
	p.SetState(5703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserFOR || _la == MySqlParserCHANGED || _la == MySqlParserEXTENDED || _la == MySqlParserFAST || _la == MySqlParserMEDIUM || _la == MySqlParserQUICK {
		{
			p.SetState(5700)
			p.CheckTableOption()
		}


		p.SetState(5705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChecksumTableContext is an interface to support dynamic dispatch.
type IChecksumTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token 


	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token) 


	// Getter signatures
	CHECKSUM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode

	// IsChecksumTableContext differentiates from other interfaces.
	IsChecksumTableContext()
}

type ChecksumTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	actionOption antlr.Token
}

func NewEmptyChecksumTableContext() *ChecksumTableContext {
	var p = new(ChecksumTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checksumTable
	return p
}

func InitEmptyChecksumTableContext(p *ChecksumTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checksumTable
}

func (*ChecksumTableContext) IsChecksumTableContext() {}

func NewChecksumTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChecksumTableContext {
	var p = new(ChecksumTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checksumTable

	return p
}

func (s *ChecksumTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ChecksumTableContext) GetActionOption() antlr.Token { return s.actionOption }


func (s *ChecksumTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }


func (s *ChecksumTableContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *ChecksumTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ChecksumTableContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *ChecksumTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *ChecksumTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *ChecksumTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChecksumTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ChecksumTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChecksumTable(s)
	}
}

func (s *ChecksumTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChecksumTable(s)
	}
}

func (s *ChecksumTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChecksumTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ChecksumTable() (localctx IChecksumTableContext) {
	localctx = NewChecksumTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, MySqlParserRULE_checksumTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5706)
		p.Match(MySqlParserCHECKSUM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5707)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5708)
		p.Tables()
	}
	p.SetState(5710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEXTENDED || _la == MySqlParserQUICK {
		{
			p.SetState(5709)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ChecksumTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserEXTENDED || _la == MySqlParserQUICK) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ChecksumTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOptimizeTableContext is an interface to support dynamic dispatch.
type IOptimizeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token 


	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token) 


	// Getter signatures
	OPTIMIZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsOptimizeTableContext differentiates from other interfaces.
	IsOptimizeTableContext()
}

type OptimizeTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	actionOption antlr.Token
}

func NewEmptyOptimizeTableContext() *OptimizeTableContext {
	var p = new(OptimizeTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_optimizeTable
	return p
}

func InitEmptyOptimizeTableContext(p *OptimizeTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_optimizeTable
}

func (*OptimizeTableContext) IsOptimizeTableContext() {}

func NewOptimizeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeTableContext {
	var p = new(OptimizeTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_optimizeTable

	return p
}

func (s *OptimizeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeTableContext) GetActionOption() antlr.Token { return s.actionOption }


func (s *OptimizeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }


func (s *OptimizeTableContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZE, 0)
}

func (s *OptimizeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *OptimizeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *OptimizeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *OptimizeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *OptimizeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *OptimizeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OptimizeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOptimizeTable(s)
	}
}

func (s *OptimizeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOptimizeTable(s)
	}
}

func (s *OptimizeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOptimizeTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) OptimizeTable() (localctx IOptimizeTableContext) {
	localctx = NewOptimizeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, MySqlParserRULE_optimizeTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5712)
		p.Match(MySqlParserOPTIMIZE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5713)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OptimizeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OptimizeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5716)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5717)
		p.Tables()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRepairTableContext is an interface to support dynamic dispatch.
type IRepairTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token 


	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token) 


	// Getter signatures
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsRepairTableContext differentiates from other interfaces.
	IsRepairTableContext()
}

type RepairTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	actionOption antlr.Token
}

func NewEmptyRepairTableContext() *RepairTableContext {
	var p = new(RepairTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repairTable
	return p
}

func InitEmptyRepairTableContext(p *RepairTableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repairTable
}

func (*RepairTableContext) IsRepairTableContext() {}

func NewRepairTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepairTableContext {
	var p = new(RepairTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_repairTable

	return p
}

func (s *RepairTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RepairTableContext) GetActionOption() antlr.Token { return s.actionOption }


func (s *RepairTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }


func (s *RepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *RepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *RepairTableContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *RepairTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *RepairTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *RepairTableContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE_FRM, 0)
}

func (s *RepairTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *RepairTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *RepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepairTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRepairTable(s)
	}
}

func (s *RepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRepairTable(s)
	}
}

func (s *RepairTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRepairTable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RepairTable() (localctx IRepairTableContext) {
	localctx = NewRepairTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, MySqlParserRULE_repairTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5719)
		p.Match(MySqlParserREPAIR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5720)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RepairTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RepairTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5723)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5724)
		p.Tables()
	}
	p.SetState(5726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserQUICK {
		{
			p.SetState(5725)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(5729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEXTENDED {
		{
			p.SetState(5728)
			p.Match(MySqlParserEXTENDED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(5732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserUSE_FRM {
		{
			p.SetState(5731)
			p.Match(MySqlParserUSE_FRM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICheckTableOptionContext is an interface to support dynamic dispatch.
type ICheckTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	FAST() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	CHANGED() antlr.TerminalNode

	// IsCheckTableOptionContext differentiates from other interfaces.
	IsCheckTableOptionContext()
}

type CheckTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableOptionContext() *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTableOption
	return p
}

func InitEmptyCheckTableOptionContext(p *CheckTableOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTableOption
}

func (*CheckTableOptionContext) IsCheckTableOptionContext() {}

func NewCheckTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checkTableOption

	return p
}

func (s *CheckTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *CheckTableOptionContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *CheckTableOptionContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *CheckTableOptionContext) FAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAST, 0)
}

func (s *CheckTableOptionContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUM, 0)
}

func (s *CheckTableOptionContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *CheckTableOptionContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGED, 0)
}

func (s *CheckTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CheckTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTableOption(s)
	}
}

func (s *CheckTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTableOption(s)
	}
}

func (s *CheckTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CheckTableOption() (localctx ICheckTableOptionContext) {
	localctx = NewCheckTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, MySqlParserRULE_checkTableOption)
	p.SetState(5741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5734)
			p.Match(MySqlParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5735)
			p.Match(MySqlParserUPGRADE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserQUICK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5736)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserFAST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5737)
			p.Match(MySqlParserFAST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMEDIUM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5738)
			p.Match(MySqlParserMEDIUM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserEXTENDED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5739)
			p.Match(MySqlParserEXTENDED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCHANGED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5740)
			p.Match(MySqlParserCHANGED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreateUdfunctionContext is an interface to support dynamic dispatch.
type ICreateUdfunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnType returns the returnType token.
	GetReturnType() antlr.Token 


	// SetReturnType sets the returnType token.
	SetReturnType(antlr.Token) 


	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	Uid() IUidContext
	RETURNS() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext

	// IsCreateUdfunctionContext differentiates from other interfaces.
	IsCreateUdfunctionContext()
}

type CreateUdfunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	returnType antlr.Token
}

func NewEmptyCreateUdfunctionContext() *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUdfunction
	return p
}

func InitEmptyCreateUdfunctionContext(p *CreateUdfunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUdfunction
}

func (*CreateUdfunctionContext) IsCreateUdfunctionContext() {}

func NewCreateUdfunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createUdfunction

	return p
}

func (s *CreateUdfunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUdfunctionContext) GetReturnType() antlr.Token { return s.returnType }


func (s *CreateUdfunctionContext) SetReturnType(v antlr.Token) { s.returnType = v }


func (s *CreateUdfunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUdfunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *CreateUdfunctionContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateUdfunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *CreateUdfunctionContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *CreateUdfunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateUdfunctionContext) STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING, 0)
}

func (s *CreateUdfunctionContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *CreateUdfunctionContext) REAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL, 0)
}

func (s *CreateUdfunctionContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *CreateUdfunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *CreateUdfunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUdfunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUdfunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CreateUdfunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUdfunction(s)
	}
}

func (s *CreateUdfunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUdfunction(s)
	}
}

func (s *CreateUdfunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateUdfunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CreateUdfunction() (localctx ICreateUdfunctionContext) {
	localctx = NewCreateUdfunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, MySqlParserRULE_createUdfunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5743)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserAGGREGATE {
		{
			p.SetState(5744)
			p.Match(MySqlParserAGGREGATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(5747)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(5749)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 840, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5748)
			p.IfNotExists()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(5751)
		p.Uid()
	}
	{
		p.SetState(5752)
		p.Match(MySqlParserRETURNS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5753)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateUdfunctionContext).returnType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 206)) & ^0x3f) == 0 && ((int64(1) << (_la - 206)) & 261) != 0) || _la == MySqlParserSTRING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateUdfunctionContext).returnType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5754)
		p.Match(MySqlParserSONAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5755)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInstallPluginContext is an interface to support dynamic dispatch.
type IInstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsInstallPluginContext differentiates from other interfaces.
	IsInstallPluginContext()
}

type InstallPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginContext() *InstallPluginContext {
	var p = new(InstallPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_installPlugin
	return p
}

func InitEmptyInstallPluginContext(p *InstallPluginContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_installPlugin
}

func (*InstallPluginContext) IsInstallPluginContext() {}

func NewInstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginContext {
	var p = new(InstallPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_installPlugin

	return p
}

func (s *InstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTALL, 0)
}

func (s *InstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *InstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *InstallPluginContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *InstallPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *InstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInstallPlugin(s)
	}
}

func (s *InstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInstallPlugin(s)
	}
}

func (s *InstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) InstallPlugin() (localctx IInstallPluginContext) {
	localctx = NewInstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, MySqlParserRULE_installPlugin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5757)
		p.Match(MySqlParserINSTALL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5758)
		p.Match(MySqlParserPLUGIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5759)
		p.Uid()
	}
	{
		p.SetState(5760)
		p.Match(MySqlParserSONAME)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5761)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUninstallPluginContext is an interface to support dynamic dispatch.
type IUninstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext

	// IsUninstallPluginContext differentiates from other interfaces.
	IsUninstallPluginContext()
}

type UninstallPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginContext() *UninstallPluginContext {
	var p = new(UninstallPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uninstallPlugin
	return p
}

func InitEmptyUninstallPluginContext(p *UninstallPluginContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uninstallPlugin
}

func (*UninstallPluginContext) IsUninstallPluginContext() {}

func NewUninstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginContext {
	var p = new(UninstallPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uninstallPlugin

	return p
}

func (s *UninstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNINSTALL, 0)
}

func (s *UninstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *UninstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UninstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UninstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUninstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UninstallPlugin() (localctx IUninstallPluginContext) {
	localctx = NewUninstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, MySqlParserRULE_uninstallPlugin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5763)
		p.Match(MySqlParserUNINSTALL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5764)
		p.Match(MySqlParserPLUGIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(5765)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) CopyAll(ctx *SetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SetTransactionContext struct {
	SetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SetTransactionStatement() ISetTransactionStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTransactionStatementContext)
}


func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}


type SetCharsetContext struct {
	SetStatementContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *SetCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}


func (s *SetCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetCharset(s)
	}
}

func (s *SetCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetCharset(s)
	}
}

func (s *SetCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetCharset(s)

	default:
		return t.VisitChildren(s)
	}
}


type SetNamesContext struct {
	SetStatementContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAMES, 0)
}

func (s *SetNamesContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetNamesContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *SetNamesContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}


func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

func (s *SetNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetNames(s)

	default:
		return t.VisitChildren(s)
	}
}


type SetPasswordContext struct {
	SetStatementContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) SetPasswordStatement() ISetPasswordStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetPasswordStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetPasswordStatementContext)
}


func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

func (s *SetPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetPassword(s)

	default:
		return t.VisitChildren(s)
	}
}


type SetAutocommitContext struct {
	SetStatementContext
}

func NewSetAutocommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetAutocommitContext {
	var p = new(SetAutocommitContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetAutocommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitContext) SetAutocommitStatement() ISetAutocommitStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAutocommitStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAutocommitStatementContext)
}


func (s *SetAutocommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetAutocommit(s)
	}
}

func (s *SetAutocommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetAutocommit(s)
	}
}

func (s *SetAutocommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetAutocommit(s)

	default:
		return t.VisitChildren(s)
	}
}


type SetNewValueInsideTriggerContext struct {
	SetStatementContext
}

func NewSetNewValueInsideTriggerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNewValueInsideTriggerContext {
	var p = new(SetNewValueInsideTriggerContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetNewValueInsideTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNewValueInsideTriggerContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetNewValueInsideTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SetNewValueInsideTriggerContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNewValueInsideTriggerContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *SetNewValueInsideTriggerContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *SetNewValueInsideTriggerContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserVAR_ASSIGN)
}

func (s *SetNewValueInsideTriggerContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, i)
}

func (s *SetNewValueInsideTriggerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetNewValueInsideTriggerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *SetNewValueInsideTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetNewValueInsideTrigger(s)
	}
}

func (s *SetNewValueInsideTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetNewValueInsideTrigger(s)
	}
}

func (s *SetNewValueInsideTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetNewValueInsideTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}


type SetVariableContext struct {
	SetStatementContext
}

func NewSetVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableContext {
	var p = new(SetVariableContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetVariableContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *SetVariableContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *SetVariableContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *SetVariableContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserVAR_ASSIGN)
}

func (s *SetVariableContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, i)
}

func (s *SetVariableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetVariableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *SetVariableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *SetVariableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetVariableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *SetVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetVariable(s)
	}
}

func (s *SetVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetVariable(s)
	}
}

func (s *SetVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetVariable(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, MySqlParserRULE_setStatement)
	var _la int

	p.SetState(5819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 848, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5767)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5768)
			p.VariableClause()
		}
		{
			p.SetState(5769)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5770)
				p.expression(0)
			}


		case 2:
			{
				p.SetState(5771)
				p.Match(MySqlParserON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5774)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5775)
				p.VariableClause()
			}
			{
				p.SetState(5776)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(5779)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5777)
					p.expression(0)
				}


			case 2:
				{
					p.SetState(5778)
					p.Match(MySqlParserON)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


			p.SetState(5785)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5786)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5787)
			p.CharSet()
		}
		p.SetState(5790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(5788)
				p.CharsetName()
			}


		case MySqlParserDEFAULT:
			{
				p.SetState(5789)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 3:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5792)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5793)
			p.Match(MySqlParserNAMES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(5794)
				p.CharsetName()
			}
			p.SetState(5797)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserCOLLATE {
				{
					p.SetState(5795)
					p.Match(MySqlParserCOLLATE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(5796)
					p.CollationName()
				}

			}


		case MySqlParserDEFAULT:
			{
				p.SetState(5799)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5802)
			p.SetPasswordStatement()
		}


	case 5:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5803)
			p.SetTransactionStatement()
		}


	case 6:
		localctx = NewSetAutocommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5804)
			p.SetAutocommitStatement()
		}


	case 7:
		localctx = NewSetNewValueInsideTriggerContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5805)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5806)
			p.FullId()
		}
		{
			p.SetState(5807)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5808)
			p.expression(0)
		}
		p.SetState(5816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5809)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5810)
				p.FullId()
			}
			{
				p.SetState(5811)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5812)
				p.expression(0)
			}


			p.SetState(5818)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showStatement
	return p
}

func InitEmptyShowStatementContext(p *ShowStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showStatement
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) CopyAll(ctx *ShowStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type ShowOpenTablesContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowOpenTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowOpenTablesContext {
	var p = new(ShowOpenTablesContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowOpenTablesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }


func (s *ShowOpenTablesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowOpenTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowOpenTablesContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *ShowOpenTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *ShowOpenTablesContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowOpenTablesContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowOpenTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowOpenTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}


func (s *ShowOpenTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowOpenTables(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowGlobalInfoContext struct {
	ShowStatementContext
}

func NewShowGlobalInfoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGlobalInfoContext {
	var p = new(ShowGlobalInfoContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGlobalInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowGlobalInfoContext) ShowGlobalInfoClause() IShowGlobalInfoClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGlobalInfoClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGlobalInfoClauseContext)
}


func (s *ShowGlobalInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGlobalInfo(s)
	}
}

func (s *ShowGlobalInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGlobalInfo(s)
	}
}

func (s *ShowGlobalInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowGlobalInfo(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowCreateFullIdObjectContext struct {
	ShowStatementContext
	namedEntity antlr.Token
}

func NewShowCreateFullIdObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFullIdObjectContext {
	var p = new(ShowCreateFullIdObjectContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowCreateFullIdObjectContext) GetNamedEntity() antlr.Token { return s.namedEntity }


func (s *ShowCreateFullIdObjectContext) SetNamedEntity(v antlr.Token) { s.namedEntity = v }

func (s *ShowCreateFullIdObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFullIdObjectContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateFullIdObjectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateFullIdObjectContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowCreateFullIdObjectContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *ShowCreateFullIdObjectContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowCreateFullIdObjectContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowCreateFullIdObjectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ShowCreateFullIdObjectContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *ShowCreateFullIdObjectContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}


func (s *ShowCreateFullIdObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateFullIdObject(s)
	}
}

func (s *ShowCreateFullIdObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateFullIdObject(s)
	}
}

func (s *ShowCreateFullIdObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCreateFullIdObject(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowCreateUserContext struct {
	ShowStatementContext
}

func NewShowCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateUserContext {
	var p = new(ShowCreateUserContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *ShowCreateUserContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}


func (s *ShowCreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateUser(s)
	}
}

func (s *ShowCreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateUser(s)
	}
}

func (s *ShowCreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowErrorsContext struct {
	ShowStatementContext
	errorFormat antlr.Token
	offset IDecimalLiteralContext 
	rowCount IDecimalLiteralContext 
}

func NewShowErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowErrorsContext {
	var p = new(ShowErrorsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }


func (s *ShowErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }


func (s *ShowErrorsContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowErrorsContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }


func (s *ShowErrorsContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowErrorsContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *ShowErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *ShowErrorsContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowErrorsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowErrorsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowErrorsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}


func (s *ShowErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowErrors(s)
	}
}

func (s *ShowErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowErrors(s)
	}
}

func (s *ShowErrorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowErrors(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowCountErrorsContext struct {
	ShowStatementContext
	errorFormat antlr.Token
}

func NewShowCountErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCountErrorsContext {
	var p = new(ShowCountErrorsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowCountErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }


func (s *ShowCountErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }

func (s *ShowCountErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCountErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCountErrorsContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *ShowCountErrorsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *ShowCountErrorsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *ShowCountErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}


func (s *ShowCountErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCountErrors(s)
	}
}

func (s *ShowCountErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCountErrors(s)
	}
}

func (s *ShowCountErrorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCountErrors(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowObjectFilterContext struct {
	ShowStatementContext
}

func NewShowObjectFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowObjectFilterContext {
	var p = new(ShowObjectFilterContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowObjectFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowObjectFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowObjectFilterContext) ShowCommonEntity() IShowCommonEntityContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCommonEntityContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCommonEntityContext)
}

func (s *ShowObjectFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}


func (s *ShowObjectFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowObjectFilter(s)
	}
}

func (s *ShowObjectFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowObjectFilter(s)
	}
}

func (s *ShowObjectFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowObjectFilter(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowCreateDbContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowCreateDbContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDbContext {
	var p = new(ShowCreateDbContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowCreateDbContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }


func (s *ShowCreateDbContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowCreateDbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateDbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateDbContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowCreateDbContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *ShowCreateDbContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *ShowCreateDbContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}


func (s *ShowCreateDbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateDb(s)
	}
}

func (s *ShowCreateDbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateDb(s)
	}
}

func (s *ShowCreateDbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCreateDb(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowEngineContext struct {
	ShowStatementContext
	engineOption antlr.Token
}

func NewShowEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEngineContext {
	var p = new(ShowEngineContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowEngineContext) GetEngineOption() antlr.Token { return s.engineOption }


func (s *ShowEngineContext) SetEngineOption(v antlr.Token) { s.engineOption = v }

func (s *ShowEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEngineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *ShowEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *ShowEngineContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowEngineContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMUTEX, 0)
}


func (s *ShowEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowEngine(s)
	}
}

func (s *ShowEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowEngine(s)
	}
}

func (s *ShowEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowEngine(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowSchemaFilterContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowSchemaFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemaFilterContext {
	var p = new(ShowSchemaFilterContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowSchemaFilterContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }


func (s *ShowSchemaFilterContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowSchemaFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowSchemaFilterContext) ShowSchemaEntity() IShowSchemaEntityContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSchemaEntityContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSchemaEntityContext)
}

func (s *ShowSchemaFilterContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowSchemaFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowSchemaFilterContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowSchemaFilterContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}


func (s *ShowSchemaFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSchemaFilter(s)
	}
}

func (s *ShowSchemaFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSchemaFilter(s)
	}
}

func (s *ShowSchemaFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowSchemaFilter(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowIndexesContext struct {
	ShowStatementContext
	indexFormat antlr.Token
	tableFormat antlr.Token
	schemaFormat antlr.Token
}

func NewShowIndexesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexesContext {
	var p = new(ShowIndexesContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *ShowIndexesContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowIndexesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }


func (s *ShowIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *ShowIndexesContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowIndexesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *ShowIndexesContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEXES, 0)
}

func (s *ShowIndexesContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}

func (s *ShowIndexesContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserFROM)
}

func (s *ShowIndexesContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, i)
}

func (s *ShowIndexesContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIN)
}

func (s *ShowIndexesContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, i)
}

func (s *ShowIndexesContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowIndexesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *ShowIndexesContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *ShowIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowIndexes(s)
	}
}

func (s *ShowIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowIndexes(s)
	}
}

func (s *ShowIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowLogEventsContext struct {
	ShowStatementContext
	logFormat antlr.Token
	filename antlr.Token
	fromPosition IDecimalLiteralContext 
	offset IDecimalLiteralContext 
	rowCount IDecimalLiteralContext 
}

func NewShowLogEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLogEventsContext {
	var p = new(ShowLogEventsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowLogEventsContext) GetLogFormat() antlr.Token { return s.logFormat }

func (s *ShowLogEventsContext) GetFilename() antlr.Token { return s.filename }


func (s *ShowLogEventsContext) SetLogFormat(v antlr.Token) { s.logFormat = v }

func (s *ShowLogEventsContext) SetFilename(v antlr.Token) { s.filename = v }


func (s *ShowLogEventsContext) GetFromPosition() IDecimalLiteralContext { return s.fromPosition }

func (s *ShowLogEventsContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowLogEventsContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }


func (s *ShowLogEventsContext) SetFromPosition(v IDecimalLiteralContext) { s.fromPosition = v }

func (s *ShowLogEventsContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowLogEventsContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowLogEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLogEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowLogEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *ShowLogEventsContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *ShowLogEventsContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAYLOG, 0)
}

func (s *ShowLogEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ShowLogEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowLogEventsContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowLogEventsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowLogEventsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowLogEventsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowLogEventsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}


func (s *ShowLogEventsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowLogEvents(s)
	}
}

func (s *ShowLogEventsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowLogEvents(s)
	}
}

func (s *ShowLogEventsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowLogEvents(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowMasterLogsContext struct {
	ShowStatementContext
	logFormat antlr.Token
}

func NewShowMasterLogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowMasterLogsContext {
	var p = new(ShowMasterLogsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowMasterLogsContext) GetLogFormat() antlr.Token { return s.logFormat }


func (s *ShowMasterLogsContext) SetLogFormat(v antlr.Token) { s.logFormat = v }

func (s *ShowMasterLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMasterLogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowMasterLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *ShowMasterLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *ShowMasterLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}


func (s *ShowMasterLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowMasterLogs(s)
	}
}

func (s *ShowMasterLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowMasterLogs(s)
	}
}

func (s *ShowMasterLogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowMasterLogs(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowGrantsContext struct {
	ShowStatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANTS, 0)
}

func (s *ShowGrantsContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowGrantsContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}


func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

func (s *ShowGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowGrants(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowSlaveStatusContext struct {
	ShowStatementContext
}

func NewShowSlaveStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSlaveStatusContext {
	var p = new(ShowSlaveStatusContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowSlaveStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSlaveStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowSlaveStatusContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ShowSlaveStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowSlaveStatusContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowSlaveStatusContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *ShowSlaveStatusContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *ShowSlaveStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSlaveStatus(s)
	}
}

func (s *ShowSlaveStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSlaveStatus(s)
	}
}

func (s *ShowSlaveStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowSlaveStatus(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowRoutineContext struct {
	ShowStatementContext
	routine antlr.Token
}

func NewShowRoutineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineContext {
	var p = new(ShowRoutineContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowRoutineContext) GetRoutine() antlr.Token { return s.routine }


func (s *ShowRoutineContext) SetRoutine(v antlr.Token) { s.routine = v }

func (s *ShowRoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowRoutineContext) CODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCODE, 0)
}

func (s *ShowRoutineContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowRoutineContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowRoutineContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}


func (s *ShowRoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowRoutine(s)
	}
}

func (s *ShowRoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowRoutine(s)
	}
}

func (s *ShowRoutineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowRoutine(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowProfileContext struct {
	ShowStatementContext
	queryCount IDecimalLiteralContext 
	offset IDecimalLiteralContext 
	rowCount IDecimalLiteralContext 
}

func NewShowProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProfileContext {
	var p = new(ShowProfileContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowProfileContext) GetQueryCount() IDecimalLiteralContext { return s.queryCount }

func (s *ShowProfileContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowProfileContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }


func (s *ShowProfileContext) SetQueryCount(v IDecimalLiteralContext) { s.queryCount = v }

func (s *ShowProfileContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowProfileContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILE, 0)
}

func (s *ShowProfileContext) AllShowProfileType() []IShowProfileTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			len++
		}
	}

	tst := make([]IShowProfileTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShowProfileTypeContext); ok {
			tst[i] = t.(IShowProfileTypeContext)
			i++
		}
	}

	return tst
}

func (s *ShowProfileContext) ShowProfileType(i int) IShowProfileTypeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfileTypeContext)
}

func (s *ShowProfileContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowProfileContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ShowProfileContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ShowProfileContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowProfileContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *ShowProfileContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowProfileContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *ShowProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowProfile(s)
	}
}

func (s *ShowProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowProfile(s)
	}
}

func (s *ShowProfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowProfile(s)

	default:
		return t.VisitChildren(s)
	}
}


type ShowColumnsContext struct {
	ShowStatementContext
	columnsFormat antlr.Token
	tableFormat antlr.Token
	schemaFormat antlr.Token
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}


func (s *ShowColumnsContext) GetColumnsFormat() antlr.Token { return s.columnsFormat }

func (s *ShowColumnsContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowColumnsContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }


func (s *ShowColumnsContext) SetColumnsFormat(v antlr.Token) { s.columnsFormat = v }

func (s *ShowColumnsContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowColumnsContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowColumnsContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, i)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowColumnsContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowColumnsContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}


func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

func (s *ShowColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowColumns(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) ShowStatement() (localctx IShowStatementContext) {
	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, MySqlParserRULE_showStatement)
	var _la int

	p.SetState(5974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 871, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowMasterLogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5821)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5822)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowMasterLogsContext).logFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINARY || _la == MySqlParserMASTER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowMasterLogsContext).logFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5823)
			p.Match(MySqlParserLOGS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		localctx = NewShowLogEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5824)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5825)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowLogEventsContext).logFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINLOG || _la == MySqlParserRELAYLOG) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowLogEventsContext).logFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5826)
			p.Match(MySqlParserEVENTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserIN {
			{
				p.SetState(5827)
				p.Match(MySqlParserIN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5828)

				var _m = p.Match(MySqlParserSTRING_LITERAL)

				localctx.(*ShowLogEventsContext).filename = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(5833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFROM {
			{
				p.SetState(5831)
				p.Match(MySqlParserFROM)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5832)

				var _x = p.DecimalLiteral()


				localctx.(*ShowLogEventsContext).fromPosition = _x
			}

		}
		p.SetState(5842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIMIT {
			{
				p.SetState(5835)
				p.Match(MySqlParserLIMIT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5839)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 851, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5836)

					var _x = p.DecimalLiteral()


					localctx.(*ShowLogEventsContext).offset = _x
				}
				{
					p.SetState(5837)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			{
				p.SetState(5841)

				var _x = p.DecimalLiteral()


				localctx.(*ShowLogEventsContext).rowCount = _x
			}

		}


	case 3:
		localctx = NewShowObjectFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5844)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5845)
			p.ShowCommonEntity()
		}
		p.SetState(5847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5846)
				p.ShowFilter()
			}

		}


	case 4:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5849)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFULL {
			{
				p.SetState(5850)
				p.Match(MySqlParserFULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(5853)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).columnsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).columnsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5854)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5855)
			p.TableName()
		}
		p.SetState(5858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5856)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowColumnsContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowColumnsContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5857)
				p.Uid()
			}

		}
		p.SetState(5861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5860)
				p.ShowFilter()
			}

		}


	case 5:
		localctx = NewShowCreateDbContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5863)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5864)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5865)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateDbContext).schemaFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateDbContext).schemaFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5867)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 857, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5866)
				p.IfNotExists()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(5869)
			p.Uid()
		}


	case 6:
		localctx = NewShowCreateFullIdObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5870)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5871)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5872)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateFullIdObjectContext).namedEntity = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 131)) & ^0x3f) == 0 && ((int64(1) << (_la - 131)) & 72567767433217) != 0) || _la == MySqlParserEVENT || _la == MySqlParserFUNCTION || _la == MySqlParserVIEW) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateFullIdObjectContext).namedEntity = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5873)
			p.FullId()
		}


	case 7:
		localctx = NewShowCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5874)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5875)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5876)
			p.Match(MySqlParserUSER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5877)
			p.UserName()
		}


	case 8:
		localctx = NewShowEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5878)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5879)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5880)
			p.EngineName()
		}
		{
			p.SetState(5881)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowEngineContext).engineOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMUTEX || _la == MySqlParserSTATUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowEngineContext).engineOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 9:
		localctx = NewShowGlobalInfoContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5883)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5884)
			p.ShowGlobalInfoClause()
		}


	case 10:
		localctx = NewShowErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5885)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5886)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserERRORS || _la == MySqlParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIMIT {
			{
				p.SetState(5887)
				p.Match(MySqlParserLIMIT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(5891)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 858, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5888)

					var _x = p.DecimalLiteral()


					localctx.(*ShowErrorsContext).offset = _x
				}
				{
					p.SetState(5889)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			{
				p.SetState(5893)

				var _x = p.DecimalLiteral()


				localctx.(*ShowErrorsContext).rowCount = _x
			}

		}


	case 11:
		localctx = NewShowCountErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5896)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5897)
			p.Match(MySqlParserCOUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5898)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5899)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5900)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5901)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCountErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserERRORS || _la == MySqlParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCountErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 12:
		localctx = NewShowSchemaFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5902)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5903)
			p.ShowSchemaEntity()
		}
		p.SetState(5906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5904)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowSchemaFilterContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowSchemaFilterContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5905)
				p.Uid()
			}

		}
		p.SetState(5909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5908)
				p.ShowFilter()
			}

		}


	case 13:
		localctx = NewShowRoutineContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5911)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5912)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowRoutineContext).routine = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPROCEDURE || _la == MySqlParserFUNCTION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowRoutineContext).routine = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5913)
			p.Match(MySqlParserCODE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5914)
			p.FullId()
		}


	case 14:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5915)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5916)
			p.Match(MySqlParserGRANTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFOR {
			{
				p.SetState(5917)
				p.Match(MySqlParserFOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5918)
				p.UserName()
			}

		}


	case 15:
		localctx = NewShowIndexesContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5921)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5922)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEYS || _la == MySqlParserINDEXES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5923)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5924)
			p.TableName()
		}
		p.SetState(5927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5925)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowIndexesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowIndexesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5926)
				p.Uid()
			}

		}
		p.SetState(5931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserWHERE {
			{
				p.SetState(5929)
				p.Match(MySqlParserWHERE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5930)
				p.expression(0)
			}

		}


	case 16:
		localctx = NewShowOpenTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5933)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5934)
			p.Match(MySqlParserOPEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5935)
			p.Match(MySqlParserTABLES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5936)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowOpenTablesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowOpenTablesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5937)
				p.Uid()
			}

		}
		p.SetState(5941)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5940)
				p.ShowFilter()
			}

		}


	case 17:
		localctx = NewShowProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5943)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5944)
			p.Match(MySqlParserPROFILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5945)
			p.ShowProfileType()
		}
		p.SetState(5950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(5946)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5947)
				p.ShowProfileType()
			}


			p.SetState(5952)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFOR {
			{
				p.SetState(5953)
				p.Match(MySqlParserFOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5954)
				p.Match(MySqlParserQUERY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5955)

				var _x = p.DecimalLiteral()


				localctx.(*ShowProfileContext).queryCount = _x
			}

		}

		{
			p.SetState(5958)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5962)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 869, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5959)

				var _x = p.DecimalLiteral()


				localctx.(*ShowProfileContext).offset = _x
			}
			{
				p.SetState(5960)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(5964)

			var _x = p.DecimalLiteral()


			localctx.(*ShowProfileContext).rowCount = _x
		}



	case 18:
		localctx = NewShowSlaveStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5966)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5967)
			p.Match(MySqlParserSLAVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5968)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(5972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFOR {
			{
				p.SetState(5969)
				p.Match(MySqlParserFOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5970)
				p.Match(MySqlParserCHANNEL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(5971)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVariableClauseContext is an interface to support dynamic dispatch.
type IVariableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode
	Uid() IUidContext
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllAT_SIGN() []antlr.TerminalNode
	AT_SIGN(i int) antlr.TerminalNode

	// IsVariableClauseContext differentiates from other interfaces.
	IsVariableClauseContext()
}

type VariableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableClauseContext() *VariableClauseContext {
	var p = new(VariableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_variableClause
	return p
}

func InitEmptyVariableClauseContext(p *VariableClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_variableClause
}

func (*VariableClauseContext) IsVariableClauseContext() {}

func NewVariableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableClauseContext {
	var p = new(VariableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_variableClause

	return p
}

func (s *VariableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableClauseContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *VariableClauseContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL_ID, 0)
}

func (s *VariableClauseContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *VariableClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *VariableClauseContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *VariableClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *VariableClauseContext) AllAT_SIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAT_SIGN)
}

func (s *VariableClauseContext) AT_SIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAT_SIGN, i)
}

func (s *VariableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VariableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVariableClause(s)
	}
}

func (s *VariableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVariableClause(s)
	}
}

func (s *VariableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitVariableClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) VariableClause() (localctx IVariableClauseContext) {
	localctx = NewVariableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, MySqlParserRULE_variableClause)
	var _la int

	p.SetState(5986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5976)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5977)
			p.Match(MySqlParserGLOBAL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserAT_SIGN, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5983)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 873, p.GetParserRuleContext()) == 1 {
			p.SetState(5980)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserAT_SIGN {
				{
					p.SetState(5978)
					p.Match(MySqlParserAT_SIGN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(5979)
					p.Match(MySqlParserAT_SIGN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(5982)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserGLOBAL || _la == MySqlParserLOCAL || _la == MySqlParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(5985)
			p.Uid()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowCommonEntityContext is an interface to support dynamic dispatch.
type IShowCommonEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsShowCommonEntityContext differentiates from other interfaces.
	IsShowCommonEntityContext()
}

type ShowCommonEntityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCommonEntityContext() *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showCommonEntity
	return p
}

func InitEmptyShowCommonEntityContext(p *ShowCommonEntityContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showCommonEntity
}

func (*ShowCommonEntityContext) IsShowCommonEntityContext() {}

func NewShowCommonEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showCommonEntity

	return p
}

func (s *ShowCommonEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCommonEntityContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *ShowCommonEntityContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ShowCommonEntityContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATION, 0)
}

func (s *ShowCommonEntityContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASES, 0)
}

func (s *ShowCommonEntityContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMAS, 0)
}

func (s *ShowCommonEntityContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowCommonEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowCommonEntityContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowCommonEntityContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIABLES, 0)
}

func (s *ShowCommonEntityContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *ShowCommonEntityContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *ShowCommonEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCommonEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowCommonEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCommonEntity(s)
	}
}

func (s *ShowCommonEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCommonEntity(s)
	}
}

func (s *ShowCommonEntityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCommonEntity(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ShowCommonEntity() (localctx IShowCommonEntityContext) {
	localctx = NewShowCommonEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, MySqlParserRULE_showCommonEntity)
	var _la int

	p.SetState(6001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5988)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5989)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCOLLATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5990)
			p.Match(MySqlParserCOLLATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDATABASES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5991)
			p.Match(MySqlParserDATABASES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSCHEMAS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5992)
			p.Match(MySqlParserSCHEMAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserFUNCTION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5993)
			p.Match(MySqlParserFUNCTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5994)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPROCEDURE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5995)
			p.Match(MySqlParserPROCEDURE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(5996)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserGLOBAL, MySqlParserSESSION, MySqlParserSTATUS, MySqlParserVARIABLES:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(5998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserGLOBAL || _la == MySqlParserSESSION {
			{
				p.SetState(5997)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserGLOBAL || _la == MySqlParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6000)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSTATUS || _la == MySqlParserVARIABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowFilterContext is an interface to support dynamic dispatch.
type IShowFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowFilterContext differentiates from other interfaces.
	IsShowFilterContext()
}

type ShowFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFilterContext() *ShowFilterContext {
	var p = new(ShowFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showFilter
	return p
}

func InitEmptyShowFilterContext(p *ShowFilterContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showFilter
}

func (*ShowFilterContext) IsShowFilterContext() {}

func NewShowFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFilterContext {
	var p = new(ShowFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showFilter

	return p
}

func (s *ShowFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFilterContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *ShowFilterContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowFilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *ShowFilterContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowFilter(s)
	}
}

func (s *ShowFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowFilter(s)
	}
}

func (s *ShowFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowFilter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ShowFilter() (localctx IShowFilterContext) {
	localctx = NewShowFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, MySqlParserRULE_showFilter)
	p.SetState(6007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6003)
			p.Match(MySqlParserLIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6004)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6005)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6006)
			p.expression(0)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowGlobalInfoClauseContext is an interface to support dynamic dispatch.
type IShowGlobalInfoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINES() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode

	// IsShowGlobalInfoClauseContext differentiates from other interfaces.
	IsShowGlobalInfoClauseContext()
}

type ShowGlobalInfoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGlobalInfoClauseContext() *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause
	return p
}

func InitEmptyShowGlobalInfoClauseContext(p *ShowGlobalInfoClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause
}

func (*ShowGlobalInfoClauseContext) IsShowGlobalInfoClauseContext() {}

func NewShowGlobalInfoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause

	return p
}

func (s *ShowGlobalInfoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGlobalInfoClauseContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINES, 0)
}

func (s *ShowGlobalInfoClauseContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *ShowGlobalInfoClauseContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ShowGlobalInfoClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowGlobalInfoClauseContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGINS, 0)
}

func (s *ShowGlobalInfoClauseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *ShowGlobalInfoClauseContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESSLIST, 0)
}

func (s *ShowGlobalInfoClauseContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowGlobalInfoClauseContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILES, 0)
}

func (s *ShowGlobalInfoClauseContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ShowGlobalInfoClauseContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *ShowGlobalInfoClauseContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHORS, 0)
}

func (s *ShowGlobalInfoClauseContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTRIBUTORS, 0)
}

func (s *ShowGlobalInfoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowGlobalInfoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGlobalInfoClause(s)
	}
}

func (s *ShowGlobalInfoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGlobalInfoClause(s)
	}
}

func (s *ShowGlobalInfoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowGlobalInfoClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ShowGlobalInfoClause() (localctx IShowGlobalInfoClauseContext) {
	localctx = NewShowGlobalInfoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, MySqlParserRULE_showGlobalInfoClause)
	var _la int

	p.SetState(6026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserENGINES, MySqlParserSTORAGE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserSTORAGE {
			{
				p.SetState(6009)
				p.Match(MySqlParserSTORAGE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(6012)
			p.Match(MySqlParserENGINES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMASTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6013)
			p.Match(MySqlParserMASTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6014)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPLUGINS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6015)
			p.Match(MySqlParserPLUGINS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPRIVILEGES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6016)
			p.Match(MySqlParserPRIVILEGES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserFULL, MySqlParserPROCESSLIST:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(6018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFULL {
			{
				p.SetState(6017)
				p.Match(MySqlParserFULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(6020)
			p.Match(MySqlParserPROCESSLIST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPROFILES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6021)
			p.Match(MySqlParserPROFILES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSLAVE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6022)
			p.Match(MySqlParserSLAVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6023)
			p.Match(MySqlParserHOSTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserAUTHORS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6024)
			p.Match(MySqlParserAUTHORS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCONTRIBUTORS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6025)
			p.Match(MySqlParserCONTRIBUTORS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowSchemaEntityContext is an interface to support dynamic dispatch.
type IShowSchemaEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENTS() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode

	// IsShowSchemaEntityContext differentiates from other interfaces.
	IsShowSchemaEntityContext()
}

type ShowSchemaEntityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSchemaEntityContext() *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showSchemaEntity
	return p
}

func InitEmptyShowSchemaEntityContext(p *ShowSchemaEntityContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showSchemaEntity
}

func (*ShowSchemaEntityContext) IsShowSchemaEntityContext() {}

func NewShowSchemaEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showSchemaEntity

	return p
}

func (s *ShowSchemaEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSchemaEntityContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *ShowSchemaEntityContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ShowSchemaEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowSchemaEntityContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *ShowSchemaEntityContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowSchemaEntityContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGERS, 0)
}

func (s *ShowSchemaEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowSchemaEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSchemaEntity(s)
	}
}

func (s *ShowSchemaEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSchemaEntity(s)
	}
}

func (s *ShowSchemaEntityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowSchemaEntity(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ShowSchemaEntity() (localctx IShowSchemaEntityContext) {
	localctx = NewShowSchemaEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, MySqlParserRULE_showSchemaEntity)
	var _la int

	p.SetState(6036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserEVENTS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6028)
			p.Match(MySqlParserEVENTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6029)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6030)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserFULL, MySqlParserTABLES:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFULL {
			{
				p.SetState(6031)
				p.Match(MySqlParserFULL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(6034)
			p.Match(MySqlParserTABLES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserTRIGGERS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6035)
			p.Match(MySqlParserTRIGGERS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShowProfileTypeContext is an interface to support dynamic dispatch.
type IShowProfileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	IO() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	CPU() antlr.TerminalNode
	IPC() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SWAPS() antlr.TerminalNode

	// IsShowProfileTypeContext differentiates from other interfaces.
	IsShowProfileTypeContext()
}

type ShowProfileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProfileTypeContext() *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showProfileType
	return p
}

func InitEmptyShowProfileTypeContext(p *ShowProfileTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showProfileType
}

func (*ShowProfileTypeContext) IsShowProfileTypeContext() {}

func NewShowProfileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showProfileType

	return p
}

func (s *ShowProfileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfileTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ShowProfileTypeContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOCK, 0)
}

func (s *ShowProfileTypeContext) IO() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO, 0)
}

func (s *ShowProfileTypeContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTEXT, 0)
}

func (s *ShowProfileTypeContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWITCHES, 0)
}

func (s *ShowProfileTypeContext) CPU() antlr.TerminalNode {
	return s.GetToken(MySqlParserCPU, 0)
}

func (s *ShowProfileTypeContext) IPC() antlr.TerminalNode {
	return s.GetToken(MySqlParserIPC, 0)
}

func (s *ShowProfileTypeContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *ShowProfileTypeContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE, 0)
}

func (s *ShowProfileTypeContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAULTS, 0)
}

func (s *ShowProfileTypeContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOURCE, 0)
}

func (s *ShowProfileTypeContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWAPS, 0)
}

func (s *ShowProfileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShowProfileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowProfileType(s)
	}
}

func (s *ShowProfileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowProfileType(s)
	}
}

func (s *ShowProfileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowProfileType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ShowProfileType() (localctx IShowProfileTypeContext) {
	localctx = NewShowProfileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, MySqlParserRULE_showProfileType)
	p.SetState(6050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6038)
			p.Match(MySqlParserALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6039)
			p.Match(MySqlParserBLOCK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6040)
			p.Match(MySqlParserIO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCONTEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6041)
			p.Match(MySqlParserCONTEXT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6042)
			p.Match(MySqlParserSWITCHES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCPU:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6043)
			p.Match(MySqlParserCPU)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserIPC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6044)
			p.Match(MySqlParserIPC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMEMORY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6045)
			p.Match(MySqlParserMEMORY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserPAGE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6046)
			p.Match(MySqlParserPAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6047)
			p.Match(MySqlParserFAULTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6048)
			p.Match(MySqlParserSOURCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSWAPS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6049)
			p.Match(MySqlParserSWAPS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBinlogStatementContext is an interface to support dynamic dispatch.
type IBinlogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINLOG() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsBinlogStatementContext differentiates from other interfaces.
	IsBinlogStatementContext()
}

type BinlogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinlogStatementContext() *BinlogStatementContext {
	var p = new(BinlogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_binlogStatement
	return p
}

func InitEmptyBinlogStatementContext(p *BinlogStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_binlogStatement
}

func (*BinlogStatementContext) IsBinlogStatementContext() {}

func NewBinlogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinlogStatementContext {
	var p = new(BinlogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_binlogStatement

	return p
}

func (s *BinlogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BinlogStatementContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *BinlogStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *BinlogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinlogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BinlogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinlogStatement(s)
	}
}

func (s *BinlogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinlogStatement(s)
	}
}

func (s *BinlogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinlogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) BinlogStatement() (localctx IBinlogStatementContext) {
	localctx = NewBinlogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, MySqlParserRULE_binlogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6052)
		p.Match(MySqlParserBINLOG)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6053)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICacheIndexStatementContext is an interface to support dynamic dispatch.
type ICacheIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSchema returns the schema rule contexts.
	GetSchema() IUidContext


	// SetSchema sets the schema rule contexts.
	SetSchema(IUidContext)


	// Getter signatures
	CACHE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	AllTableIndexes() []ITableIndexesContext
	TableIndexes(i int) ITableIndexesContext
	IN() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	ALL() antlr.TerminalNode

	// IsCacheIndexStatementContext differentiates from other interfaces.
	IsCacheIndexStatementContext()
}

type CacheIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	schema IUidContext 
}

func NewEmptyCacheIndexStatementContext() *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement
	return p
}

func InitEmptyCacheIndexStatementContext(p *CacheIndexStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement
}

func (*CacheIndexStatementContext) IsCacheIndexStatementContext() {}

func NewCacheIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement

	return p
}

func (s *CacheIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CacheIndexStatementContext) GetSchema() IUidContext { return s.schema }


func (s *CacheIndexStatementContext) SetSchema(v IUidContext) { s.schema = v }


func (s *CacheIndexStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *CacheIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *CacheIndexStatementContext) AllTableIndexes() []ITableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ITableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableIndexesContext); ok {
			tst[i] = t.(ITableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *CacheIndexStatementContext) TableIndexes(i int) ITableIndexesContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIndexesContext)
}

func (s *CacheIndexStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *CacheIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CacheIndexStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CacheIndexStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CacheIndexStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *CacheIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CacheIndexStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *CacheIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CacheIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CacheIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCacheIndexStatement(s)
	}
}

func (s *CacheIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCacheIndexStatement(s)
	}
}

func (s *CacheIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCacheIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CacheIndexStatement() (localctx ICacheIndexStatementContext) {
	localctx = NewCacheIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, MySqlParserRULE_cacheIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6055)
		p.Match(MySqlParserCACHE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6056)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6057)
		p.TableIndexes()
	}
	p.SetState(6062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6058)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6059)
			p.TableIndexes()
		}


		p.SetState(6064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(6072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(6065)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6066)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(6067)
				p.UidList()
			}


		case MySqlParserALL:
			{
				p.SetState(6068)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6071)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(6074)
		p.Match(MySqlParserIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6075)

		var _x = p.Uid()


		localctx.(*CacheIndexStatementContext).schema = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFlushStatementContext is an interface to support dynamic dispatch.
type IFlushStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFlushFormat returns the flushFormat token.
	GetFlushFormat() antlr.Token 


	// SetFlushFormat sets the flushFormat token.
	SetFlushFormat(antlr.Token) 


	// Getter signatures
	FLUSH() antlr.TerminalNode
	AllFlushOption() []IFlushOptionContext
	FlushOption(i int) IFlushOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsFlushStatementContext differentiates from other interfaces.
	IsFlushStatementContext()
}

type FlushStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	flushFormat antlr.Token
}

func NewEmptyFlushStatementContext() *FlushStatementContext {
	var p = new(FlushStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushStatement
	return p
}

func InitEmptyFlushStatementContext(p *FlushStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushStatement
}

func (*FlushStatementContext) IsFlushStatementContext() {}

func NewFlushStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushStatementContext {
	var p = new(FlushStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushStatement

	return p
}

func (s *FlushStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushStatementContext) GetFlushFormat() antlr.Token { return s.flushFormat }


func (s *FlushStatementContext) SetFlushFormat(v antlr.Token) { s.flushFormat = v }


func (s *FlushStatementContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH, 0)
}

func (s *FlushStatementContext) AllFlushOption() []IFlushOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlushOptionContext); ok {
			len++
		}
	}

	tst := make([]IFlushOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlushOptionContext); ok {
			tst[i] = t.(IFlushOptionContext)
			i++
		}
	}

	return tst
}

func (s *FlushStatementContext) FlushOption(i int) IFlushOptionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushOptionContext)
}

func (s *FlushStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FlushStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FlushStatementContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *FlushStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *FlushStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FlushStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFlushStatement(s)
	}
}

func (s *FlushStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFlushStatement(s)
	}
}

func (s *FlushStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFlushStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FlushStatement() (localctx IFlushStatementContext) {
	localctx = NewFlushStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, MySqlParserRULE_flushStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6077)
		p.Match(MySqlParserFLUSH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(6078)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FlushStatementContext).flushFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FlushStatementContext).flushFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6081)
		p.FlushOption()
	}
	p.SetState(6086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6082)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6083)
			p.FlushOption()
		}


		p.SetState(6088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnectionFormat returns the connectionFormat token.
	GetConnectionFormat() antlr.Token 


	// SetConnectionFormat sets the connectionFormat token.
	SetConnectionFormat(antlr.Token) 


	// Getter signatures
	KILL() antlr.TerminalNode
	Expression() IExpressionContext
	CONNECTION() antlr.TerminalNode
	QUERY() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	connectionFormat antlr.Token
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_killStatement
	return p
}

func InitEmptyKillStatementContext(p *KillStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_killStatement
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnectionFormat() antlr.Token { return s.connectionFormat }


func (s *KillStatementContext) SetConnectionFormat(v antlr.Token) { s.connectionFormat = v }


func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(MySqlParserKILL, 0)
}

func (s *KillStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (s *KillStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitKillStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) KillStatement() (localctx IKillStatementContext) {
	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, MySqlParserRULE_killStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6089)
		p.Match(MySqlParserKILL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6091)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6090)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*KillStatementContext).connectionFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCONNECTION || _la == MySqlParserQUERY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*KillStatementContext).connectionFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(6093)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILoadIndexIntoCacheContext is an interface to support dynamic dispatch.
type ILoadIndexIntoCacheContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INTO() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	AllLoadedTableIndexes() []ILoadedTableIndexesContext
	LoadedTableIndexes(i int) ILoadedTableIndexesContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadIndexIntoCacheContext differentiates from other interfaces.
	IsLoadIndexIntoCacheContext()
}

type LoadIndexIntoCacheContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadIndexIntoCacheContext() *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache
	return p
}

func InitEmptyLoadIndexIntoCacheContext(p *LoadIndexIntoCacheContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache
}

func (*LoadIndexIntoCacheContext) IsLoadIndexIntoCacheContext() {}

func NewLoadIndexIntoCacheContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache

	return p
}

func (s *LoadIndexIntoCacheContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadIndexIntoCacheContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadIndexIntoCacheContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *LoadIndexIntoCacheContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadIndexIntoCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *LoadIndexIntoCacheContext) AllLoadedTableIndexes() []ILoadedTableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ILoadedTableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadedTableIndexesContext); ok {
			tst[i] = t.(ILoadedTableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *LoadIndexIntoCacheContext) LoadedTableIndexes(i int) ILoadedTableIndexesContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadedTableIndexesContext)
}

func (s *LoadIndexIntoCacheContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadIndexIntoCacheContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadIndexIntoCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadIndexIntoCacheContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LoadIndexIntoCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadIndexIntoCache(s)
	}
}

func (s *LoadIndexIntoCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadIndexIntoCache(s)
	}
}

func (s *LoadIndexIntoCacheContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadIndexIntoCache(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LoadIndexIntoCache() (localctx ILoadIndexIntoCacheContext) {
	localctx = NewLoadIndexIntoCacheContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, MySqlParserRULE_loadIndexIntoCache)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6095)
		p.Match(MySqlParserLOAD)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6096)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6097)
		p.Match(MySqlParserINTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6098)
		p.Match(MySqlParserCACHE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6099)
		p.LoadedTableIndexes()
	}
	p.SetState(6104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6100)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6101)
			p.LoadedTableIndexes()
		}


		p.SetState(6106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResetStatementContext is an interface to support dynamic dispatch.
type IResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	CACHE() antlr.TerminalNode

	// IsResetStatementContext differentiates from other interfaces.
	IsResetStatementContext()
}

type ResetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStatementContext() *ResetStatementContext {
	var p = new(ResetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetStatement
	return p
}

func InitEmptyResetStatementContext(p *ResetStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetStatement
}

func (*ResetStatementContext) IsResetStatementContext() {}

func NewResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStatementContext {
	var p = new(ResetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetStatement

	return p
}

func (s *ResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStatementContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *ResetStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *ResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetStatement(s)
	}
}

func (s *ResetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetStatement(s)
	}
}

func (s *ResetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ResetStatement() (localctx IResetStatementContext) {
	localctx = NewResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, MySqlParserRULE_resetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6107)
		p.Match(MySqlParserRESET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6108)
		p.Match(MySqlParserQUERY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6109)
		p.Match(MySqlParserCACHE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IShutdownStatementContext is an interface to support dynamic dispatch.
type IShutdownStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHUTDOWN() antlr.TerminalNode

	// IsShutdownStatementContext differentiates from other interfaces.
	IsShutdownStatementContext()
}

type ShutdownStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShutdownStatementContext() *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_shutdownStatement
	return p
}

func InitEmptyShutdownStatementContext(p *ShutdownStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_shutdownStatement
}

func (*ShutdownStatementContext) IsShutdownStatementContext() {}

func NewShutdownStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_shutdownStatement

	return p
}

func (s *ShutdownStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShutdownStatementContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *ShutdownStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShutdownStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ShutdownStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShutdownStatement(s)
	}
}

func (s *ShutdownStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShutdownStatement(s)
	}
}

func (s *ShutdownStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShutdownStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ShutdownStatement() (localctx IShutdownStatementContext) {
	localctx = NewShutdownStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, MySqlParserRULE_shutdownStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6111)
		p.Match(MySqlParserSHUTDOWN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableIndexesContext is an interface to support dynamic dispatch.
type ITableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token 


	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token) 


	// Getter signatures
	TableName() ITableNameContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsTableIndexesContext differentiates from other interfaces.
	IsTableIndexesContext()
}

type TableIndexesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	indexFormat antlr.Token
}

func NewEmptyTableIndexesContext() *TableIndexesContext {
	var p = new(TableIndexesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableIndexes
	return p
}

func InitEmptyTableIndexesContext(p *TableIndexesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableIndexes
}

func (*TableIndexesContext) IsTableIndexesContext() {}

func NewTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIndexesContext {
	var p = new(TableIndexesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableIndexes

	return p
}

func (s *TableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *TableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }


func (s *TableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableIndexesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableIndexesContext) UidList() IUidListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *TableIndexesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *TableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableIndexes(s)
	}
}

func (s *TableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableIndexes(s)
	}
}

func (s *TableIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TableIndexes() (localctx ITableIndexesContext) {
	localctx = NewTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, MySqlParserRULE_tableIndexes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6113)
		p.TableName()
	}
	p.SetState(6121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserINDEX || _la == MySqlParserKEY || _la == MySqlParserLR_BRACKET {
		p.SetState(6115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(6114)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*TableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*TableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6117)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6118)
			p.UidList()
		}
		{
			p.SetState(6119)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFlushOptionContext is an interface to support dynamic dispatch.
type IFlushOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFlushOptionContext differentiates from other interfaces.
	IsFlushOptionContext()
}

type FlushOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushOptionContext() *FlushOptionContext {
	var p = new(FlushOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushOption
	return p
}

func InitEmptyFlushOptionContext(p *FlushOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushOption
}

func (*FlushOptionContext) IsFlushOptionContext() {}

func NewFlushOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushOptionContext {
	var p = new(FlushOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushOption

	return p
}

func (s *FlushOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushOptionContext) CopyAll(ctx *FlushOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type TableFlushOptionContext struct {
	FlushOptionContext
}

func NewTableFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFlushOptionContext {
	var p = new(TableFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *TableFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFlushOptionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TableFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *TableFlushOptionContext) Tables() ITablesContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableFlushOptionContext) FlushTableOption() IFlushTableOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushTableOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushTableOptionContext)
}


func (s *TableFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableFlushOption(s)
	}
}

func (s *TableFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableFlushOption(s)
	}
}

func (s *TableFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type ChannelFlushOptionContext struct {
	FlushOptionContext
}

func NewChannelFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ChannelFlushOptionContext {
	var p = new(ChannelFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *ChannelFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *ChannelFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *ChannelFlushOptionContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}


func (s *ChannelFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChannelFlushOption(s)
	}
}

func (s *ChannelFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChannelFlushOption(s)
	}
}

func (s *ChannelFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChannelFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimpleFlushOptionContext struct {
	FlushOptionContext
}

func NewSimpleFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFlushOptionContext {
	var p = new(SimpleFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *SimpleFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFlushOptionContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_KEY_FILE, 0)
}

func (s *SimpleFlushOptionContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *SimpleFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *SimpleFlushOptionContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZER_COSTS, 0)
}

func (s *SimpleFlushOptionContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *SimpleFlushOptionContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *SimpleFlushOptionContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *SimpleFlushOptionContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *SimpleFlushOptionContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER_RESOURCES, 0)
}

func (s *SimpleFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *SimpleFlushOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *SimpleFlushOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *SimpleFlushOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *SimpleFlushOptionContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *SimpleFlushOptionContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *SimpleFlushOptionContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *SimpleFlushOptionContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERAL, 0)
}

func (s *SimpleFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *SimpleFlushOptionContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLOW, 0)
}


func (s *SimpleFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleFlushOption(s)
	}
}

func (s *SimpleFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleFlushOption(s)
	}
}

func (s *SimpleFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) FlushOption() (localctx IFlushOptionContext) {
	localctx = NewFlushOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, MySqlParserRULE_flushOption)
	var _la int

	p.SetState(6155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 899, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDES_KEY_FILE:
			{
				p.SetState(6123)
				p.Match(MySqlParserDES_KEY_FILE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserHOSTS:
			{
				p.SetState(6124)
				p.Match(MySqlParserHOSTS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserBINARY, MySqlParserENGINE, MySqlParserERROR, MySqlParserGENERAL, MySqlParserLOGS, MySqlParserRELAY, MySqlParserSLOW:
			p.SetState(6126)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserBINARY || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & 536870917) != 0) || _la == MySqlParserRELAY || _la == MySqlParserSLOW {
				{
					p.SetState(6125)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserBINARY || ((int64((_la - 409)) & ^0x3f) == 0 && ((int64(1) << (_la - 409)) & 536870917) != 0) || _la == MySqlParserRELAY || _la == MySqlParserSLOW) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(6128)
				p.Match(MySqlParserLOGS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserOPTIMIZER_COSTS:
			{
				p.SetState(6129)
				p.Match(MySqlParserOPTIMIZER_COSTS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserPRIVILEGES:
			{
				p.SetState(6130)
				p.Match(MySqlParserPRIVILEGES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserQUERY:
			{
				p.SetState(6131)
				p.Match(MySqlParserQUERY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6132)
				p.Match(MySqlParserCACHE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserSTATUS:
			{
				p.SetState(6133)
				p.Match(MySqlParserSTATUS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserUSER_RESOURCES:
			{
				p.SetState(6134)
				p.Match(MySqlParserUSER_RESOURCES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserTABLES:
			{
				p.SetState(6135)
				p.Match(MySqlParserTABLES)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(6139)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 894, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6136)
					p.Match(MySqlParserWITH)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(6137)
					p.Match(MySqlParserREAD)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(6138)
					p.Match(MySqlParserLOCK)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 2:
		localctx = NewChannelFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6143)
			p.Match(MySqlParserRELAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6144)
			p.Match(MySqlParserLOGS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6146)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFOR {
			{
				p.SetState(6145)
				p.ChannelOption()
			}

		}


	case 3:
		localctx = NewTableFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6148)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6150)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 897, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6149)
				p.Tables()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6153)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 898, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6152)
				p.FlushTableOption()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFlushTableOptionContext is an interface to support dynamic dispatch.
type IFlushTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	READ() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	FOR() antlr.TerminalNode
	EXPORT() antlr.TerminalNode

	// IsFlushTableOptionContext differentiates from other interfaces.
	IsFlushTableOptionContext()
}

type FlushTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushTableOptionContext() *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushTableOption
	return p
}

func InitEmptyFlushTableOptionContext(p *FlushTableOptionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushTableOption
}

func (*FlushTableOptionContext) IsFlushTableOptionContext() {}

func NewFlushTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushTableOption

	return p
}

func (s *FlushTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushTableOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *FlushTableOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *FlushTableOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *FlushTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *FlushTableOptionContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT, 0)
}

func (s *FlushTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FlushTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFlushTableOption(s)
	}
}

func (s *FlushTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFlushTableOption(s)
	}
}

func (s *FlushTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFlushTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FlushTableOption() (localctx IFlushTableOptionContext) {
	localctx = NewFlushTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, MySqlParserRULE_flushTableOption)
	p.SetState(6162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6157)
			p.Match(MySqlParserWITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6158)
			p.Match(MySqlParserREAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6159)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6160)
			p.Match(MySqlParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6161)
			p.Match(MySqlParserEXPORT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILoadedTableIndexesContext is an interface to support dynamic dispatch.
type ILoadedTableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token 


	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token) 


	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IUidListContext

	// GetIndexList returns the indexList rule contexts.
	GetIndexList() IUidListContext


	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IUidListContext)

	// SetIndexList sets the indexList rule contexts.
	SetIndexList(IUidListContext)


	// Getter signatures
	TableName() ITableNameContext
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	ALL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsLoadedTableIndexesContext differentiates from other interfaces.
	IsLoadedTableIndexesContext()
}

type LoadedTableIndexesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	partitionList IUidListContext 
	indexFormat antlr.Token
	indexList IUidListContext 
}

func NewEmptyLoadedTableIndexesContext() *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes
	return p
}

func InitEmptyLoadedTableIndexesContext(p *LoadedTableIndexesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes
}

func (*LoadedTableIndexesContext) IsLoadedTableIndexesContext() {}

func NewLoadedTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes

	return p
}

func (s *LoadedTableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadedTableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }


func (s *LoadedTableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }


func (s *LoadedTableIndexesContext) GetPartitionList() IUidListContext { return s.partitionList }

func (s *LoadedTableIndexesContext) GetIndexList() IUidListContext { return s.indexList }


func (s *LoadedTableIndexesContext) SetPartitionList(v IUidListContext) { s.partitionList = v }

func (s *LoadedTableIndexesContext) SetIndexList(v IUidListContext) { s.indexList = v }


func (s *LoadedTableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadedTableIndexesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *LoadedTableIndexesContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *LoadedTableIndexesContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *LoadedTableIndexesContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *LoadedTableIndexesContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVES, 0)
}

func (s *LoadedTableIndexesContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *LoadedTableIndexesContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadedTableIndexesContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *LoadedTableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *LoadedTableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *LoadedTableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadedTableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LoadedTableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadedTableIndexes(s)
	}
}

func (s *LoadedTableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadedTableIndexes(s)
	}
}

func (s *LoadedTableIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadedTableIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LoadedTableIndexes() (localctx ILoadedTableIndexesContext) {
	localctx = NewLoadedTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, MySqlParserRULE_loadedTableIndexes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6164)
		p.TableName()
	}
	p.SetState(6172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(6165)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6166)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6169)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(6167)

				var _x = p.UidList()


				localctx.(*LoadedTableIndexesContext).partitionList = _x
			}


		case MySqlParserALL:
			{
				p.SetState(6168)
				p.Match(MySqlParserALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6171)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(6181)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 904, p.GetParserRuleContext()) == 1 {
		p.SetState(6175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(6174)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*LoadedTableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*LoadedTableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6177)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6178)

			var _x = p.UidList()


			localctx.(*LoadedTableIndexesContext).indexList = _x
		}
		{
			p.SetState(6179)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(6185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserIGNORE {
		{
			p.SetState(6183)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6184)
			p.Match(MySqlParserLEAVES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimpleDescribeStatementContext is an interface to support dynamic dispatch.
type ISimpleDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token 

	// GetPattern returns the pattern token.
	GetPattern() antlr.Token 


	// SetCommand sets the command token.
	SetCommand(antlr.Token) 

	// SetPattern sets the pattern token.
	SetPattern(antlr.Token) 


	// GetColumn returns the column rule contexts.
	GetColumn() IUidContext


	// SetColumn sets the column rule contexts.
	SetColumn(IUidContext)


	// Getter signatures
	TableName() ITableNameContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleDescribeStatementContext differentiates from other interfaces.
	IsSimpleDescribeStatementContext()
}

type SimpleDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	command antlr.Token
	column IUidContext 
	pattern antlr.Token
}

func NewEmptySimpleDescribeStatementContext() *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement
	return p
}

func InitEmptySimpleDescribeStatementContext(p *SimpleDescribeStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement
}

func (*SimpleDescribeStatementContext) IsSimpleDescribeStatementContext() {}

func NewSimpleDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement

	return p
}

func (s *SimpleDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *SimpleDescribeStatementContext) GetPattern() antlr.Token { return s.pattern }


func (s *SimpleDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *SimpleDescribeStatementContext) SetPattern(v antlr.Token) { s.pattern = v }


func (s *SimpleDescribeStatementContext) GetColumn() IUidContext { return s.column }


func (s *SimpleDescribeStatementContext) SetColumn(v IUidContext) { s.column = v }


func (s *SimpleDescribeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SimpleDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPLAIN, 0)
}

func (s *SimpleDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESCRIBE, 0)
}

func (s *SimpleDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *SimpleDescribeStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleDescribeStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SimpleDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleDescribeStatement(s)
	}
}

func (s *SimpleDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleDescribeStatement(s)
	}
}

func (s *SimpleDescribeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleDescribeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SimpleDescribeStatement() (localctx ISimpleDescribeStatementContext) {
	localctx = NewSimpleDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, MySqlParserRULE_simpleDescribeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6187)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SimpleDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 4611791571543654400) != 0)) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SimpleDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6188)
		p.TableName()
	}
	p.SetState(6191)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6189)

			var _x = p.Uid()


			localctx.(*SimpleDescribeStatementContext).column = _x
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6190)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SimpleDescribeStatementContext).pattern = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFullDescribeStatementContext is an interface to support dynamic dispatch.
type IFullDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token 

	// GetFormatType returns the formatType token.
	GetFormatType() antlr.Token 

	// GetFormatValue returns the formatValue token.
	GetFormatValue() antlr.Token 


	// SetCommand sets the command token.
	SetCommand(antlr.Token) 

	// SetFormatType sets the formatType token.
	SetFormatType(antlr.Token) 

	// SetFormatValue sets the formatValue token.
	SetFormatValue(antlr.Token) 


	// Getter signatures
	DescribeObjectClause() IDescribeObjectClauseContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	JSON() antlr.TerminalNode

	// IsFullDescribeStatementContext differentiates from other interfaces.
	IsFullDescribeStatementContext()
}

type FullDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	command antlr.Token
	formatType antlr.Token
	formatValue antlr.Token
}

func NewEmptyFullDescribeStatementContext() *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement
	return p
}

func InitEmptyFullDescribeStatementContext(p *FullDescribeStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement
}

func (*FullDescribeStatementContext) IsFullDescribeStatementContext() {}

func NewFullDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement

	return p
}

func (s *FullDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FullDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *FullDescribeStatementContext) GetFormatType() antlr.Token { return s.formatType }

func (s *FullDescribeStatementContext) GetFormatValue() antlr.Token { return s.formatValue }


func (s *FullDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *FullDescribeStatementContext) SetFormatType(v antlr.Token) { s.formatType = v }

func (s *FullDescribeStatementContext) SetFormatValue(v antlr.Token) { s.formatValue = v }


func (s *FullDescribeStatementContext) DescribeObjectClause() IDescribeObjectClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeObjectClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeObjectClauseContext)
}

func (s *FullDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPLAIN, 0)
}

func (s *FullDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESCRIBE, 0)
}

func (s *FullDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *FullDescribeStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *FullDescribeStatementContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *FullDescribeStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *FullDescribeStatementContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORMAT, 0)
}

func (s *FullDescribeStatementContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRADITIONAL, 0)
}

func (s *FullDescribeStatementContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *FullDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FullDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullDescribeStatement(s)
	}
}

func (s *FullDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullDescribeStatement(s)
	}
}

func (s *FullDescribeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullDescribeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FullDescribeStatement() (localctx IFullDescribeStatementContext) {
	localctx = NewFullDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, MySqlParserRULE_fullDescribeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6193)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*FullDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 4611791571543654400) != 0)) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*FullDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(6197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserEXTENDED || _la == MySqlParserPARTITIONS || _la == MySqlParserFORMAT {
		{
			p.SetState(6194)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserEXTENDED || _la == MySqlParserPARTITIONS || _la == MySqlParserFORMAT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6195)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6196)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJSON || _la == MySqlParserTRADITIONAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6199)
		p.DescribeObjectClause()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_helpStatement
	return p
}

func InitEmptyHelpStatementContext(p *HelpStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_helpStatement
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(MySqlParserHELP, 0)
}

func (s *HelpStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (s *HelpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHelpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HelpStatement() (localctx IHelpStatementContext) {
	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, MySqlParserRULE_helpStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6201)
		p.Match(MySqlParserHELP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6202)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Uid() IUidContext

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_useStatement
	return p
}

func InitEmptyUseStatementContext(p *UseStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_useStatement
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *UseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (s *UseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UseStatement() (localctx IUseStatementContext) {
	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, MySqlParserRULE_useStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6204)
		p.Match(MySqlParserUSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6205)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISignalStatementContext is an interface to support dynamic dispatch.
type ISignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsSignalStatementContext differentiates from other interfaces.
	IsSignalStatementContext()
}

type SignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalStatementContext() *SignalStatementContext {
	var p = new(SignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalStatement
	return p
}

func InitEmptySignalStatementContext(p *SignalStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalStatement
}

func (*SignalStatementContext) IsSignalStatementContext() {}

func NewSignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalStatementContext {
	var p = new(SignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_signalStatement

	return p
}

func (s *SignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalStatementContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNAL, 0)
}

func (s *SignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *SignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *SignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *SignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *SignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *SignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSignalStatement(s)
	}
}

func (s *SignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSignalStatement(s)
	}
}

func (s *SignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SignalStatement() (localctx ISignalStatementContext) {
	localctx = NewSignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, MySqlParserRULE_signalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6207)
		p.Match(MySqlParserSIGNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQLSTATE:
		{
			p.SetState(6208)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserVALUE {
			{
				p.SetState(6209)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(6212)
			p.StringLiteral()
		}



	case MySqlParserID:
		{
			p.SetState(6213)
			p.Match(MySqlParserID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(6214)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6226)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 911, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6217)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6218)
			p.SignalConditionInformation()
		}
		p.SetState(6223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(6219)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6220)
				p.SignalConditionInformation()
			}


			p.SetState(6225)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResignalStatementContext is an interface to support dynamic dispatch.
type IResignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsResignalStatementContext differentiates from other interfaces.
	IsResignalStatementContext()
}

type ResignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignalStatementContext() *ResignalStatementContext {
	var p = new(ResignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resignalStatement
	return p
}

func InitEmptyResignalStatementContext(p *ResignalStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resignalStatement
}

func (*ResignalStatementContext) IsResignalStatementContext() {}

func NewResignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResignalStatementContext {
	var p = new(ResignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resignalStatement

	return p
}

func (s *ResignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResignalStatementContext) RESIGNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESIGNAL, 0)
}

func (s *ResignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *ResignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *ResignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ResignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *ResignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *ResignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *ResignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ResignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ResignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ResignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *ResignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ResignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResignalStatement(s)
	}
}

func (s *ResignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResignalStatement(s)
	}
}

func (s *ResignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ResignalStatement() (localctx IResignalStatementContext) {
	localctx = NewResignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, MySqlParserRULE_resignalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6228)
		p.Match(MySqlParserRESIGNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQLSTATE:
		{
			p.SetState(6229)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserVALUE {
			{
				p.SetState(6230)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(6233)
			p.StringLiteral()
		}



	case MySqlParserID:
		{
			p.SetState(6234)
			p.Match(MySqlParserID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(6235)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:



	default:
	}
	p.SetState(6247)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 915, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6238)
			p.Match(MySqlParserSET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6239)
			p.SignalConditionInformation()
		}
		p.SetState(6244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(6240)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6241)
				p.SignalConditionInformation()
			}


			p.SetState(6246)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISignalConditionInformationContext is an interface to support dynamic dispatch.
type ISignalConditionInformationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DECIMAL_LITERAL() antlr.TerminalNode
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsSignalConditionInformationContext differentiates from other interfaces.
	IsSignalConditionInformationContext()
}

type SignalConditionInformationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalConditionInformationContext() *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalConditionInformation
	return p
}

func InitEmptySignalConditionInformationContext(p *SignalConditionInformationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalConditionInformation
}

func (*SignalConditionInformationContext) IsSignalConditionInformationContext() {}

func NewSignalConditionInformationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_signalConditionInformation

	return p
}

func (s *SignalConditionInformationContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalConditionInformationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SignalConditionInformationContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *SignalConditionInformationContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *SignalConditionInformationContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *SignalConditionInformationContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *SignalConditionInformationContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *SignalConditionInformationContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *SignalConditionInformationContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *SignalConditionInformationContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalConditionInformationContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *SignalConditionInformationContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *SignalConditionInformationContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *SignalConditionInformationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalConditionInformationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SignalConditionInformationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSignalConditionInformation(s)
	}
}

func (s *SignalConditionInformationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSignalConditionInformation(s)
	}
}

func (s *SignalConditionInformationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSignalConditionInformation(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SignalConditionInformation() (localctx ISignalConditionInformationContext) {
	localctx = NewSignalConditionInformationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, MySqlParserRULE_signalConditionInformation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6249)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 359)) & ^0x3f) == 0 && ((int64(1) << (_la - 359)) & 272105729) != 0) || _la == MySqlParserMESSAGE_TEXT || _la == MySqlParserMYSQL_ERRNO || _la == MySqlParserSUBCLASS_ORIGIN || _la == MySqlParserTABLE_NAME || _la == MySqlParserCATALOG_NAME || _la == MySqlParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6250)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTART_NATIONAL_STRING_LITERAL, MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
		{
			p.SetState(6251)
			p.StringLiteral()
		}


	case MySqlParserDECIMAL_LITERAL:
		{
			p.SetState(6252)
			p.Match(MySqlParserDECIMAL_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
		{
			p.SetState(6253)
			p.MysqlVariable()
		}


	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserID:
		{
			p.SetState(6254)
			p.SimpleId()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCommonTableExpressions() []ICommonTableExpressionsContext
	CommonTableExpressions(i int) ICommonTableExpressionsContext
	RECURSIVE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *WithStatementContext) AllCommonTableExpressions() []ICommonTableExpressionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionsContext); ok {
			tst[i] = t.(ICommonTableExpressionsContext)
			i++
		}
	}

	return tst
}

func (s *WithStatementContext) CommonTableExpressions(i int) ICommonTableExpressionsContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *WithStatementContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *WithStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WithStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, MySqlParserRULE_withStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6257)
		p.Match(MySqlParserWITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6259)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 917, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6258)
			p.Match(MySqlParserRECURSIVE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(6261)
		p.CommonTableExpressions()
	}
	p.SetState(6266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6262)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6263)
			p.CommonTableExpressions()
		}


		p.SetState(6268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableStatementContext is an interface to support dynamic dispatch.
type ITableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsTableStatementContext differentiates from other interfaces.
	IsTableStatementContext()
}

type TableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableStatementContext() *TableStatementContext {
	var p = new(TableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableStatement
	return p
}

func InitEmptyTableStatementContext(p *TableStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableStatement
}

func (*TableStatementContext) IsTableStatementContext() {}

func NewTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableStatementContext {
	var p = new(TableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableStatement

	return p
}

func (s *TableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TableStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *TableStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *TableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableStatement(s)
	}
}

func (s *TableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableStatement(s)
	}
}

func (s *TableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TableStatement() (localctx ITableStatementContext) {
	localctx = NewTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, MySqlParserRULE_tableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6269)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6270)
		p.TableName()
	}
	p.SetState(6272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserORDER {
		{
			p.SetState(6271)
			p.OrderByClause()
		}

	}
	p.SetState(6275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserLIMIT {
		{
			p.SetState(6274)
			p.LimitClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDiagnosticsStatementContext is an interface to support dynamic dispatch.
type IDiagnosticsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	AllVariableClause() []IVariableClauseContext
	VariableClause(i int) IVariableClauseContext
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext
	DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	AllROW_COUNT() []antlr.TerminalNode
	ROW_COUNT(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDiagnosticsStatementContext differentiates from other interfaces.
	IsDiagnosticsStatementContext()
}

type DiagnosticsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsStatementContext() *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement
	return p
}

func InitEmptyDiagnosticsStatementContext(p *DiagnosticsStatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement
}

func (*DiagnosticsStatementContext) IsDiagnosticsStatementContext() {}

func NewDiagnosticsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement

	return p
}

func (s *DiagnosticsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsStatementContext) GET() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET, 0)
}

func (s *DiagnosticsStatementContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIAGNOSTICS, 0)
}

func (s *DiagnosticsStatementContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *DiagnosticsStatementContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTACKED, 0)
}

func (s *DiagnosticsStatementContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *DiagnosticsStatementContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *DiagnosticsStatementContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *DiagnosticsStatementContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *DiagnosticsStatementContext) AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			len++
		}
	}

	tst := make([]IDiagnosticsConditionInformationNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			tst[i] = t.(IDiagnosticsConditionInformationNameContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsConditionInformationNameContext)
}

func (s *DiagnosticsStatementContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNUMBER)
}

func (s *DiagnosticsStatementContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMBER, i)
}

func (s *DiagnosticsStatementContext) AllROW_COUNT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserROW_COUNT)
}

func (s *DiagnosticsStatementContext) ROW_COUNT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_COUNT, i)
}

func (s *DiagnosticsStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DiagnosticsStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DiagnosticsStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DiagnosticsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DiagnosticsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDiagnosticsStatement(s)
	}
}

func (s *DiagnosticsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDiagnosticsStatement(s)
	}
}

func (s *DiagnosticsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDiagnosticsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DiagnosticsStatement() (localctx IDiagnosticsStatementContext) {
	localctx = NewDiagnosticsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, MySqlParserRULE_diagnosticsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6277)
		p.Match(MySqlParserGET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCURRENT || _la == MySqlParserSTACKED {
		{
			p.SetState(6278)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCURRENT || _la == MySqlParserSTACKED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6281)
		p.Match(MySqlParserDIAGNOSTICS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 925, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6282)
			p.VariableClause()
		}
		{
			p.SetState(6283)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6284)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNUMBER || _la == MySqlParserROW_COUNT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(6285)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6286)
				p.VariableClause()
			}
			{
				p.SetState(6287)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6288)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserNUMBER || _la == MySqlParserROW_COUNT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


			p.SetState(6294)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	case 2:
		{
			p.SetState(6295)
			p.Match(MySqlParserCONDITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(6296)
				p.DecimalLiteral()
			}


		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserAT_SIGN, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
			{
				p.SetState(6297)
				p.VariableClause()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6300)
			p.VariableClause()
		}
		{
			p.SetState(6301)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6302)
			p.DiagnosticsConditionInformationName()
		}
		p.SetState(6310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(6303)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6304)
				p.VariableClause()
			}
			{
				p.SetState(6305)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6306)
				p.DiagnosticsConditionInformationName()
			}


			p.SetState(6312)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDiagnosticsConditionInformationNameContext is an interface to support dynamic dispatch.
type IDiagnosticsConditionInformationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode

	// IsDiagnosticsConditionInformationNameContext differentiates from other interfaces.
	IsDiagnosticsConditionInformationNameContext()
}

type DiagnosticsConditionInformationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsConditionInformationNameContext() *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName
	return p
}

func InitEmptyDiagnosticsConditionInformationNameContext(p *DiagnosticsConditionInformationNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName
}

func (*DiagnosticsConditionInformationNameContext) IsDiagnosticsConditionInformationNameContext() {}

func NewDiagnosticsConditionInformationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName

	return p
}

func (s *DiagnosticsConditionInformationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsConditionInformationNameContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNED_SQLSTATE, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsConditionInformationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DiagnosticsConditionInformationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDiagnosticsConditionInformationName(s)
	}
}

func (s *DiagnosticsConditionInformationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDiagnosticsConditionInformationName(s)
	}
}

func (s *DiagnosticsConditionInformationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDiagnosticsConditionInformationName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DiagnosticsConditionInformationName() (localctx IDiagnosticsConditionInformationNameContext) {
	localctx = NewDiagnosticsConditionInformationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, MySqlParserRULE_diagnosticsConditionInformationName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6315)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 359)) & ^0x3f) == 0 && ((int64(1) << (_la - 359)) & 272105729) != 0) || _la == MySqlParserMESSAGE_TEXT || _la == MySqlParserMYSQL_ERRNO || ((int64((_la - 592)) & ^0x3f) == 0 && ((int64(1) << (_la - 592)) & 18155135997837313) != 0) || _la == MySqlParserCATALOG_NAME || _la == MySqlParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDescribeObjectClauseContext is an interface to support dynamic dispatch.
type IDescribeObjectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDescribeObjectClauseContext differentiates from other interfaces.
	IsDescribeObjectClauseContext()
}

type DescribeObjectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeObjectClauseContext() *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_describeObjectClause
	return p
}

func InitEmptyDescribeObjectClauseContext(p *DescribeObjectClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_describeObjectClause
}

func (*DescribeObjectClauseContext) IsDescribeObjectClauseContext() {}

func NewDescribeObjectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_describeObjectClause

	return p
}

func (s *DescribeObjectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeObjectClauseContext) CopyAll(ctx *DescribeObjectClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DescribeObjectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeObjectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type DescribeStatementsContext struct {
	DescribeObjectClauseContext
}

func NewDescribeStatementsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStatementsContext {
	var p = new(DescribeStatementsContext)

	InitEmptyDescribeObjectClauseContext(&p.DescribeObjectClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStatementsContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DescribeStatementsContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DescribeStatementsContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DescribeStatementsContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DescribeStatementsContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}


func (s *DescribeStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDescribeStatements(s)
	}
}

func (s *DescribeStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDescribeStatements(s)
	}
}

func (s *DescribeStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDescribeStatements(s)

	default:
		return t.VisitChildren(s)
	}
}


type DescribeConnectionContext struct {
	DescribeObjectClauseContext
}

func NewDescribeConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectionContext {
	var p = new(DescribeConnectionContext)

	InitEmptyDescribeObjectClauseContext(&p.DescribeObjectClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DescribeConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *DescribeConnectionContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}


func (s *DescribeConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDescribeConnection(s)
	}
}

func (s *DescribeConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDescribeConnection(s)
	}
}

func (s *DescribeConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDescribeConnection(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) DescribeObjectClause() (localctx IDescribeObjectClauseContext) {
	localctx = NewDescribeObjectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, MySqlParserRULE_describeObjectClause)
	p.SetState(6327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDELETE, MySqlParserINSERT, MySqlParserREPLACE, MySqlParserSELECT, MySqlParserUPDATE, MySqlParserLR_BRACKET:
		localctx = NewDescribeStatementsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT, MySqlParserLR_BRACKET:
			{
				p.SetState(6317)
				p.SelectStatement()
			}


		case MySqlParserDELETE:
			{
				p.SetState(6318)
				p.DeleteStatement()
			}


		case MySqlParserINSERT:
			{
				p.SetState(6319)
				p.InsertStatement()
			}


		case MySqlParserREPLACE:
			{
				p.SetState(6320)
				p.ReplaceStatement()
			}


		case MySqlParserUPDATE:
			{
				p.SetState(6321)
				p.UpdateStatement()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case MySqlParserFOR:
		localctx = NewDescribeConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6324)
			p.Match(MySqlParserFOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6325)
			p.Match(MySqlParserCONNECTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6326)
			p.Uid()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
	return p
}

func InitEmptyFullIdContext(p *FullIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FullIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullId(s)
	}
}

func (s *FullIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullId(s)
	}
}

func (s *FullIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FullId() (localctx IFullIdContext) {
	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, MySqlParserRULE_fullId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6329)
		p.Uid()
	}
	p.SetState(6333)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 928, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6330)
			p.Match(MySqlParserDOT_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 928, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6331)
			p.Match(MySqlParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6332)
			p.Uid()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullId() IFullIdContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, MySqlParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6335)
		p.FullId()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRoleNameContext is an interface to support dynamic dispatch.
type IRoleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	Uid() IUidContext

	// IsRoleNameContext differentiates from other interfaces.
	IsRoleNameContext()
}

type RoleNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleNameContext() *RoleNameContext {
	var p = new(RoleNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleName
	return p
}

func InitEmptyRoleNameContext(p *RoleNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleName
}

func (*RoleNameContext) IsRoleNameContext() {}

func NewRoleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleNameContext {
	var p = new(RoleNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_roleName

	return p
}

func (s *RoleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleNameContext) UserName() IUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RoleNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleName(s)
	}
}

func (s *RoleNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleName(s)
	}
}

func (s *RoleNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoleName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) RoleName() (localctx IRoleNameContext) {
	localctx = NewRoleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, MySqlParserRULE_roleName)
	p.SetState(6339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 929, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6337)
			p.UserName()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6338)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	AllDottedId() []IDottedIdContext
	DottedId(i int) IDottedIdContext

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
	return p
}

func InitEmptyFullColumnNameContext(p *FullColumnNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnName(s)
	}
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnName(s)
	}
}

func (s *FullColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FullColumnName() (localctx IFullColumnNameContext) {
	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, MySqlParserRULE_fullColumnName)
	p.SetState(6355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 934, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6341)
			p.Uid()
		}
		p.SetState(6346)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6342)
				p.DottedId()
			}
			p.SetState(6344)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 930, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6343)
					p.DottedId()
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6349)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 932, p.GetParserRuleContext()) == 1 {
			p.SetState(6348)
			p.MatchWildcard()


			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(6351)
			p.DottedId()
		}
		p.SetState(6353)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 933, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6352)
				p.DottedId()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexColumnNameContext is an interface to support dynamic dispatch.
type IIndexColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSortType returns the sortType token.
	GetSortType() antlr.Token 


	// SetSortType sets the sortType token.
	SetSortType(antlr.Token) 


	// Getter signatures
	Expression() IExpressionContext
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsIndexColumnNameContext differentiates from other interfaces.
	IsIndexColumnNameContext()
}

type IndexColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	sortType antlr.Token
}

func NewEmptyIndexColumnNameContext() *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnName
	return p
}

func InitEmptyIndexColumnNameContext(p *IndexColumnNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnName
}

func (*IndexColumnNameContext) IsIndexColumnNameContext() {}

func NewIndexColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnName

	return p
}

func (s *IndexColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNameContext) GetSortType() antlr.Token { return s.sortType }


func (s *IndexColumnNameContext) SetSortType(v antlr.Token) { s.sortType = v }


func (s *IndexColumnNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexColumnNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *IndexColumnNameContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexColumnNameContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IndexColumnNameContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexColumnNameContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *IndexColumnNameContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *IndexColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IndexColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IndexColumnName() (localctx IIndexColumnNameContext) {
	localctx = NewIndexColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, MySqlParserRULE_indexColumnName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 937, p.GetParserRuleContext()) {
	case 1:
		p.SetState(6359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 935, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6357)
				p.Uid()
			}


		case 2:
			{
				p.SetState(6358)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(6365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6361)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6362)
				p.DecimalLiteral()
			}
			{
				p.SetState(6363)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case 2:
		{
			p.SetState(6367)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(6371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserASC || _la == MySqlParserDESC {
		{
			p.SetState(6370)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexColumnNameContext).sortType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexColumnNameContext).sortType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimpleUserNameContext is an interface to support dynamic dispatch.
type ISimpleUserNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	KeywordsCanBeId() IKeywordsCanBeIdContext

	// IsSimpleUserNameContext differentiates from other interfaces.
	IsSimpleUserNameContext()
}

type SimpleUserNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleUserNameContext() *SimpleUserNameContext {
	var p = new(SimpleUserNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleUserName
	return p
}

func InitEmptySimpleUserNameContext(p *SimpleUserNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleUserName
}

func (*SimpleUserNameContext) IsSimpleUserNameContext() {}

func NewSimpleUserNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleUserNameContext {
	var p = new(SimpleUserNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleUserName

	return p
}

func (s *SimpleUserNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleUserNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SimpleUserNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleUserNameContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *SimpleUserNameContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleUserNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleUserNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleUserNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleUserName(s)
	}
}

func (s *SimpleUserNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleUserName(s)
	}
}

func (s *SimpleUserNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleUserName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SimpleUserName() (localctx ISimpleUserNameContext) {
	localctx = NewSimpleUserNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, MySqlParserRULE_simpleUserName)
	p.SetState(6377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 939, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6373)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6374)
			p.Match(MySqlParserID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6375)
			p.Match(MySqlParserADMIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6376)
			p.KeywordsCanBeId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHostNameContext is an interface to support dynamic dispatch.
type IHostNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	HOST_IP_ADDRESS() antlr.TerminalNode
	AT_SIGN() antlr.TerminalNode

	// IsHostNameContext differentiates from other interfaces.
	IsHostNameContext()
}

type HostNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostNameContext() *HostNameContext {
	var p = new(HostNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hostName
	return p
}

func InitEmptyHostNameContext(p *HostNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hostName
}

func (*HostNameContext) IsHostNameContext() {}

func NewHostNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostNameContext {
	var p = new(HostNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hostName

	return p
}

func (s *HostNameContext) GetParser() antlr.Parser { return s.parser }

func (s *HostNameContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *HostNameContext) HOST_IP_ADDRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST_IP_ADDRESS, 0)
}

func (s *HostNameContext) AT_SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT_SIGN, 0)
}

func (s *HostNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HostNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHostName(s)
	}
}

func (s *HostNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHostName(s)
	}
}

func (s *HostNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHostName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HostName() (localctx IHostNameContext) {
	localctx = NewHostNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, MySqlParserRULE_hostName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6379)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 1137)) & ^0x3f) == 0 && ((int64(1) << (_la - 1137)) & 6291457) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUserNameContext is an interface to support dynamic dispatch.
type IUserNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleUserName() ISimpleUserNameContext
	HostName() IHostNameContext
	CurrentUserExpression() ICurrentUserExpressionContext

	// IsUserNameContext differentiates from other interfaces.
	IsUserNameContext()
}

type UserNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserNameContext() *UserNameContext {
	var p = new(UserNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userName
	return p
}

func InitEmptyUserNameContext(p *UserNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userName
}

func (*UserNameContext) IsUserNameContext() {}

func NewUserNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserNameContext {
	var p = new(UserNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userName

	return p
}

func (s *UserNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserNameContext) SimpleUserName() ISimpleUserNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleUserNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleUserNameContext)
}

func (s *UserNameContext) HostName() IHostNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostNameContext)
}

func (s *UserNameContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}

func (s *UserNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UserNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserName(s)
	}
}

func (s *UserNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserName(s)
	}
}

func (s *UserNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UserName() (localctx IUserNameContext) {
	localctx = NewUserNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, MySqlParserRULE_userName)
	p.SetState(6386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 940, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6381)
			p.SimpleUserName()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6382)
			p.SimpleUserName()
		}
		{
			p.SetState(6383)
			p.HostName()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6385)
			p.CurrentUserExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMysqlVariableContext is an interface to support dynamic dispatch.
type IMysqlVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode

	// IsMysqlVariableContext differentiates from other interfaces.
	IsMysqlVariableContext()
}

type MysqlVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMysqlVariableContext() *MysqlVariableContext {
	var p = new(MysqlVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_mysqlVariable
	return p
}

func InitEmptyMysqlVariableContext(p *MysqlVariableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_mysqlVariable
}

func (*MysqlVariableContext) IsMysqlVariableContext() {}

func NewMysqlVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlVariableContext {
	var p = new(MysqlVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_mysqlVariable

	return p
}

func (s *MysqlVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlVariableContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *MysqlVariableContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL_ID, 0)
}

func (s *MysqlVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MysqlVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMysqlVariable(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) MysqlVariable() (localctx IMysqlVariableContext) {
	localctx = NewMysqlVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, MySqlParserRULE_mysqlVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6388)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserLOCAL_ID || _la == MySqlParserGLOBAL_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	STRING_LITERAL() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CharsetNameContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *CharsetNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CharsetNameContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, MySqlParserRULE_charsetName)
	p.SetState(6394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 941, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6390)
			p.Match(MySqlParserBINARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6391)
			p.CharsetNameBase()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6392)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6393)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
	return p
}

func InitEmptyCollationNameContext(p *CollationNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CollationName() (localctx ICollationNameContext) {
	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, MySqlParserRULE_collationName)
	p.SetState(6398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 942, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6396)
			p.Uid()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6397)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEngineNameContext is an interface to support dynamic dispatch.
type IEngineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EngineNameBase() IEngineNameBaseContext
	ID() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsEngineNameContext differentiates from other interfaces.
	IsEngineNameContext()
}

type EngineNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameContext() *EngineNameContext {
	var p = new(EngineNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineName
	return p
}

func InitEmptyEngineNameContext(p *EngineNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineName
}

func (*EngineNameContext) IsEngineNameContext() {}

func NewEngineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameContext {
	var p = new(EngineNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_engineName

	return p
}

func (s *EngineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameContext) EngineNameBase() IEngineNameBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameBaseContext)
}

func (s *EngineNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *EngineNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *EngineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EngineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEngineName(s)
	}
}

func (s *EngineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEngineName(s)
	}
}

func (s *EngineNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEngineName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) EngineName() (localctx IEngineNameContext) {
	localctx = NewEngineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, MySqlParserRULE_engineName)
	p.SetState(6403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCONNECT, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6400)
			p.EngineNameBase()
		}


	case MySqlParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6401)
			p.Match(MySqlParserID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6402)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEngineNameBaseContext is an interface to support dynamic dispatch.
type IEngineNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARCHIVE() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CSV() antlr.TerminalNode
	FEDERATED() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MRG_MYISAM() antlr.TerminalNode
	MYISAM() antlr.TerminalNode
	NDB() antlr.TerminalNode
	NDBCLUSTER() antlr.TerminalNode
	PERFORMANCE_SCHEMA() antlr.TerminalNode
	TOKUDB() antlr.TerminalNode

	// IsEngineNameBaseContext differentiates from other interfaces.
	IsEngineNameBaseContext()
}

type EngineNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameBaseContext() *EngineNameBaseContext {
	var p = new(EngineNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineNameBase
	return p
}

func InitEmptyEngineNameBaseContext(p *EngineNameBaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineNameBase
}

func (*EngineNameBaseContext) IsEngineNameBaseContext() {}

func NewEngineNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameBaseContext {
	var p = new(EngineNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_engineNameBase

	return p
}

func (s *EngineNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameBaseContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserARCHIVE, 0)
}

func (s *EngineNameBaseContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLACKHOLE, 0)
}

func (s *EngineNameBaseContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECT, 0)
}

func (s *EngineNameBaseContext) CSV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCSV, 0)
}

func (s *EngineNameBaseContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFEDERATED, 0)
}

func (s *EngineNameBaseContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB, 0)
}

func (s *EngineNameBaseContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *EngineNameBaseContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMRG_MYISAM, 0)
}

func (s *EngineNameBaseContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYISAM, 0)
}

func (s *EngineNameBaseContext) NDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB, 0)
}

func (s *EngineNameBaseContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDBCLUSTER, 0)
}

func (s *EngineNameBaseContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERFORMANCE_SCHEMA, 0)
}

func (s *EngineNameBaseContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOKUDB, 0)
}

func (s *EngineNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EngineNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEngineNameBase(s)
	}
}

func (s *EngineNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEngineNameBase(s)
	}
}

func (s *EngineNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEngineNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) EngineNameBase() (localctx IEngineNameBaseContext) {
	localctx = NewEngineNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, MySqlParserRULE_engineNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6405)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserCONNECT || ((int64((_la - 787)) & ^0x3f) == 0 && ((int64(1) << (_la - 787)) & 4095) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUuidSetContext is an interface to support dynamic dispatch.
type IUuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	AllCOLON_SYMB() []antlr.TerminalNode
	COLON_SYMB(i int) antlr.TerminalNode

	// IsUuidSetContext differentiates from other interfaces.
	IsUuidSetContext()
}

type UuidSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUuidSetContext() *UuidSetContext {
	var p = new(UuidSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uuidSet
	return p
}

func InitEmptyUuidSetContext(p *UuidSetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uuidSet
}

func (*UuidSetContext) IsUuidSetContext() {}

func NewUuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UuidSetContext {
	var p = new(UuidSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uuidSet

	return p
}

func (s *UuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *UuidSetContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *UuidSetContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UuidSetContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *UuidSetContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *UuidSetContext) AllCOLON_SYMB() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOLON_SYMB)
}

func (s *UuidSetContext) COLON_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, i)
}

func (s *UuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUuidSet(s)
	}
}

func (s *UuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUuidSet(s)
	}
}

func (s *UuidSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUuidSet(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UuidSet() (localctx IUuidSetContext) {
	localctx = NewUuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, MySqlParserRULE_uuidSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6407)
		p.DecimalLiteral()
	}
	{
		p.SetState(6408)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6409)
		p.DecimalLiteral()
	}
	{
		p.SetState(6410)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6411)
		p.DecimalLiteral()
	}
	{
		p.SetState(6412)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6413)
		p.DecimalLiteral()
	}
	{
		p.SetState(6414)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6415)
		p.DecimalLiteral()
	}
	p.SetState(6421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == MySqlParserCOLON_SYMB {
		{
			p.SetState(6416)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6417)
			p.DecimalLiteral()
		}
		{
			p.SetState(6418)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6419)
			p.DecimalLiteral()
		}


		p.SetState(6423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXidContext is an interface to support dynamic dispatch.
type IXidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetGlobalTableUid returns the globalTableUid rule contexts.
	GetGlobalTableUid() IXuidStringIdContext

	// GetQualifier returns the qualifier rule contexts.
	GetQualifier() IXuidStringIdContext

	// GetIdFormat returns the idFormat rule contexts.
	GetIdFormat() IDecimalLiteralContext


	// SetGlobalTableUid sets the globalTableUid rule contexts.
	SetGlobalTableUid(IXuidStringIdContext)

	// SetQualifier sets the qualifier rule contexts.
	SetQualifier(IXuidStringIdContext)

	// SetIdFormat sets the idFormat rule contexts.
	SetIdFormat(IDecimalLiteralContext)


	// Getter signatures
	AllXuidStringId() []IXuidStringIdContext
	XuidStringId(i int) IXuidStringIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsXidContext differentiates from other interfaces.
	IsXidContext()
}

type XidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	globalTableUid IXuidStringIdContext 
	qualifier IXuidStringIdContext 
	idFormat IDecimalLiteralContext 
}

func NewEmptyXidContext() *XidContext {
	var p = new(XidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xid
	return p
}

func InitEmptyXidContext(p *XidContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xid
}

func (*XidContext) IsXidContext() {}

func NewXidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XidContext {
	var p = new(XidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xid

	return p
}

func (s *XidContext) GetParser() antlr.Parser { return s.parser }

func (s *XidContext) GetGlobalTableUid() IXuidStringIdContext { return s.globalTableUid }

func (s *XidContext) GetQualifier() IXuidStringIdContext { return s.qualifier }

func (s *XidContext) GetIdFormat() IDecimalLiteralContext { return s.idFormat }


func (s *XidContext) SetGlobalTableUid(v IXuidStringIdContext) { s.globalTableUid = v }

func (s *XidContext) SetQualifier(v IXuidStringIdContext) { s.qualifier = v }

func (s *XidContext) SetIdFormat(v IDecimalLiteralContext) { s.idFormat = v }


func (s *XidContext) AllXuidStringId() []IXuidStringIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			len++
		}
	}

	tst := make([]IXuidStringIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXuidStringIdContext); ok {
			tst[i] = t.(IXuidStringIdContext)
			i++
		}
	}

	return tst
}

func (s *XidContext) XuidStringId(i int) IXuidStringIdContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXuidStringIdContext)
}

func (s *XidContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *XidContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *XidContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *XidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXid(s)
	}
}

func (s *XidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXid(s)
	}
}

func (s *XidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXid(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Xid() (localctx IXidContext) {
	localctx = NewXidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, MySqlParserRULE_xid)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6425)

		var _x = p.XuidStringId()


		localctx.(*XidContext).globalTableUid = _x
	}
	p.SetState(6432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMA {
		{
			p.SetState(6426)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6427)

			var _x = p.XuidStringId()


			localctx.(*XidContext).qualifier = _x
		}
		p.SetState(6430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOMMA {
			{
				p.SetState(6428)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6429)

				var _x = p.DecimalLiteral()


				localctx.(*XidContext).idFormat = _x
			}

		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IXuidStringIdContext is an interface to support dynamic dispatch.
type IXuidStringIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	AllHEXADECIMAL_LITERAL() []antlr.TerminalNode
	HEXADECIMAL_LITERAL(i int) antlr.TerminalNode

	// IsXuidStringIdContext differentiates from other interfaces.
	IsXuidStringIdContext()
}

type XuidStringIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXuidStringIdContext() *XuidStringIdContext {
	var p = new(XuidStringIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xuidStringId
	return p
}

func InitEmptyXuidStringIdContext(p *XuidStringIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xuidStringId
}

func (*XuidStringIdContext) IsXuidStringIdContext() {}

func NewXuidStringIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XuidStringIdContext {
	var p = new(XuidStringIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xuidStringId

	return p
}

func (s *XuidStringIdContext) GetParser() antlr.Parser { return s.parser }

func (s *XuidStringIdContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *XuidStringIdContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *XuidStringIdContext) AllHEXADECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserHEXADECIMAL_LITERAL)
}

func (s *XuidStringIdContext) HEXADECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, i)
}

func (s *XuidStringIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XuidStringIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XuidStringIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXuidStringId(s)
	}
}

func (s *XuidStringIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXuidStringId(s)
	}
}

func (s *XuidStringIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXuidStringId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) XuidStringId() (localctx IXuidStringIdContext) {
	localctx = NewXuidStringIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, MySqlParserRULE_xuidStringId)
	var _la int

	p.SetState(6441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6434)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBIT_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6435)
			p.Match(MySqlParserBIT_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserHEXADECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MySqlParserHEXADECIMAL_LITERAL {
			{
				p.SetState(6436)
				p.Match(MySqlParserHEXADECIMAL_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(6439)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAuthPluginContext is an interface to support dynamic dispatch.
type IAuthPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsAuthPluginContext differentiates from other interfaces.
	IsAuthPluginContext()
}

type AuthPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthPluginContext() *AuthPluginContext {
	var p = new(AuthPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authPlugin
	return p
}

func InitEmptyAuthPluginContext(p *AuthPluginContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authPlugin
}

func (*AuthPluginContext) IsAuthPluginContext() {}

func NewAuthPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthPluginContext {
	var p = new(AuthPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authPlugin

	return p
}

func (s *AuthPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthPluginContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AuthPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AuthPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AuthPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAuthPlugin(s)
	}
}

func (s *AuthPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAuthPlugin(s)
	}
}

func (s *AuthPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAuthPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AuthPlugin() (localctx IAuthPluginContext) {
	localctx = NewAuthPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, MySqlParserRULE_authPlugin)
	p.SetState(6445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 949, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6443)
			p.Uid()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6444)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleId() ISimpleIdContext
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
	return p
}

func InitEmptyUidContext(p *UidContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (s *UidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUid(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Uid() (localctx IUidContext) {
	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, MySqlParserRULE_uid)
	p.SetState(6450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6447)
			p.SimpleId()
		}


	case MySqlParserCHARSET_REVERSE_QOUTE_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6448)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6449)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	TransactionLevelBase() ITransactionLevelBaseContext
	EngineNameBase() IEngineNameBaseContext
	PrivilegesBase() IPrivilegesBaseContext
	IntervalTypeBase() IIntervalTypeBaseContext
	DataTypeBase() IDataTypeBaseContext
	KeywordsCanBeId() IKeywordsCanBeIdContext
	ScalarFunctionName() IScalarFunctionNameContext

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
	return p
}

func InitEmptySimpleIdContext(p *SimpleIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleIdContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *SimpleIdContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *SimpleIdContext) EngineNameBase() IEngineNameBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameBaseContext)
}

func (s *SimpleIdContext) PrivilegesBase() IPrivilegesBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegesBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *SimpleIdContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *SimpleIdContext) DataTypeBase() IDataTypeBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *SimpleIdContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleIdContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (s *SimpleIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SimpleId() (localctx ISimpleIdContext) {
	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, MySqlParserRULE_simpleId)
	p.SetState(6461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 951, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6452)
			p.Match(MySqlParserID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6453)
			p.CharsetNameBase()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6454)
			p.TransactionLevelBase()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6455)
			p.EngineNameBase()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6456)
			p.PrivilegesBase()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6457)
			p.IntervalTypeBase()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6458)
			p.DataTypeBase()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6459)
			p.KeywordsCanBeId()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6460)
			p.ScalarFunctionName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode
	Uid() IUidContext

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
	return p
}

func InitEmptyDottedIdContext(p *DottedIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DottedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDottedId(s)
	}
}

func (s *DottedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDottedId(s)
	}
}

func (s *DottedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDottedId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DottedId() (localctx IDottedIdContext) {
	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, MySqlParserRULE_dottedId)
	p.SetState(6466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6463)
			p.Match(MySqlParserDOT_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6464)
			p.Match(MySqlParserDOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6465)
			p.Uid()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode
	TWO_DECIMAL() antlr.TerminalNode
	REAL_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
	return p
}

func InitEmptyDecimalLiteralContext(p *DecimalLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, MySqlParserRULE_decimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6468)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 1138)) & ^0x3f) == 0 && ((int64(1) << (_la - 1138)) & 10247) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFileSizeLiteralContext is an interface to support dynamic dispatch.
type IFileSizeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILESIZE_LITERAL() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsFileSizeLiteralContext differentiates from other interfaces.
	IsFileSizeLiteralContext()
}

type FileSizeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSizeLiteralContext() *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral
	return p
}

func InitEmptyFileSizeLiteralContext(p *FileSizeLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral
}

func (*FileSizeLiteralContext) IsFileSizeLiteralContext() {}

func NewFileSizeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral

	return p
}

func (s *FileSizeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSizeLiteralContext) FILESIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILESIZE_LITERAL, 0)
}

func (s *FileSizeLiteralContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *FileSizeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSizeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FileSizeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFileSizeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FileSizeLiteral() (localctx IFileSizeLiteralContext) {
	localctx = NewFileSizeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, MySqlParserRULE_fileSizeLiteral)
	p.SetState(6472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFILESIZE_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6470)
			p.Match(MySqlParserFILESIZE_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6471)
			p.DecimalLiteral()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	START_NATIONAL_STRING_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, MySqlParserRULE_stringLiteral)
	var _la int

	var _alt int

	p.SetState(6497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 960, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(6475)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(6474)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(6477)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6478)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(6482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(6481)
						p.Match(MySqlParserSTRING_LITERAL)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(6484)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 956, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(6487)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(6486)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			}
			{
				p.SetState(6489)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6490)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(6495)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 959, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6493)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6494)
				p.CollationName()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, MySqlParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6499)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
	return p
}

func InitEmptyHexadecimalLiteralContext(p *HexadecimalLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHexadecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, MySqlParserRULE_hexadecimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserSTRING_CHARSET_NAME {
		{
			p.SetState(6501)
			p.Match(MySqlParserSTRING_CHARSET_NAME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(6504)
		p.Match(MySqlParserHEXADECIMAL_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNullNotnullContext differentiates from other interfaces.
	IsNullNotnullContext()
}

type NullNotnullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext {
	var p = new(NullNotnullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nullNotnull
	return p
}

func InitEmptyNullNotnullContext(p *NullNotnullContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nullNotnull
}

func (*NullNotnullContext) IsNullNotnullContext() {}

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext {
	var p = new(NullNotnullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_nullNotnull

	return p
}

func (s *NullNotnullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}

func (s *NullNotnullContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNullNotnull(s)
	}
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNullNotnull(s)
	}
}

func (s *NullNotnullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNullNotnull(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) NullNotnull() (localctx INullNotnullContext) {
	localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, MySqlParserRULE_nullNotnull)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserNOT {
		{
			p.SetState(6506)
			p.Match(MySqlParserNOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(6509)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullLiteral returns the nullLiteral token.
	GetNullLiteral() antlr.Token 


	// SetNullLiteral sets the nullLiteral token.
	SetNullLiteral(antlr.Token) 


	// Getter signatures
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	MINUS() antlr.TerminalNode
	HexadecimalLiteral() IHexadecimalLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	REAL_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	nullLiteral antlr.Token
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) GetNullLiteral() antlr.Token { return s.nullLiteral }


func (s *ConstantContext) SetNullLiteral(v antlr.Token) { s.nullLiteral = v }


func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *ConstantContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *ConstantContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}

func (s *ConstantContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, MySqlParserRULE_constant)
	var _la int

	p.SetState(6523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 964, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6511)
			p.StringLiteral()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6512)
			p.DecimalLiteral()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6513)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6514)
			p.DecimalLiteral()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6515)
			p.HexadecimalLiteral()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6516)
			p.BooleanLiteral()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6517)
			p.Match(MySqlParserREAL_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6518)
			p.Match(MySqlParserBIT_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(6520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(6519)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(6522)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConstantContext).nullLiteral = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConstantContext).nullLiteral = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SpatialDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSpatialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpatialDataTypeContext {
	var p = new(SpatialDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *SpatialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *SpatialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpatialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialDataTypeContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) GEOMCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *SpatialDataTypeContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *SpatialDataTypeContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *SpatialDataTypeContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *SpatialDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *SpatialDataTypeContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRY, 0)
}

func (s *SpatialDataTypeContext) SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSRID, 0)
}

func (s *SpatialDataTypeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *SpatialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpatialDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type LongVarbinaryDataTypeContext struct {
	DataTypeContext
}

func NewLongVarbinaryDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarbinaryDataTypeContext {
	var p = new(LongVarbinaryDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarbinaryDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarbinaryDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarbinaryDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}


func (s *LongVarbinaryDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLongVarbinaryDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type CollectionDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewCollectionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionDataTypeContext {
	var p = new(CollectionDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *CollectionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *CollectionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *CollectionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionDataTypeContext) CollectionOptions() ICollectionOptionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionOptionsContext)
}

func (s *CollectionDataTypeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *CollectionDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *CollectionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CollectionDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CollectionDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}


func (s *CollectionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollectionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type NationalVaryingStringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewNationalVaryingStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalVaryingStringDataTypeContext {
	var p = new(NationalVaryingStringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *NationalVaryingStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *NationalVaryingStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalVaryingStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalVaryingStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalVaryingStringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARYING, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalVaryingStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalVaryingStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}


func (s *NationalVaryingStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNationalVaryingStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type DimensionDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewDimensionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DimensionDataTypeContext {
	var p = new(DimensionDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *DimensionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *DimensionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *DimensionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionDataTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYINT, 0)
}

func (s *DimensionDataTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSMALLINT, 0)
}

func (s *DimensionDataTypeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMINT, 0)
}

func (s *DimensionDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT, 0)
}

func (s *DimensionDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *DimensionDataTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIGINT, 0)
}

func (s *DimensionDataTypeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIDDLEINT, 0)
}

func (s *DimensionDataTypeContext) INT1() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT1, 0)
}

func (s *DimensionDataTypeContext) INT2() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT2, 0)
}

func (s *DimensionDataTypeContext) INT3() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT3, 0)
}

func (s *DimensionDataTypeContext) INT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT4, 0)
}

func (s *DimensionDataTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT8, 0)
}

func (s *DimensionDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *DimensionDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSIGNED)
}

func (s *DimensionDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, i)
}

func (s *DimensionDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserUNSIGNED)
}

func (s *DimensionDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, i)
}

func (s *DimensionDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserZEROFILL)
}

func (s *DimensionDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserZEROFILL, i)
}

func (s *DimensionDataTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL, 0)
}

func (s *DimensionDataTypeContext) LengthTwoDimension() ILengthTwoDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *DimensionDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOUBLE, 0)
}

func (s *DimensionDataTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECISION, 0)
}

func (s *DimensionDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *DimensionDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC, 0)
}

func (s *DimensionDataTypeContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *DimensionDataTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMERIC, 0)
}

func (s *DimensionDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT, 0)
}

func (s *DimensionDataTypeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT4, 0)
}

func (s *DimensionDataTypeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT8, 0)
}

func (s *DimensionDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *DimensionDataTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *DimensionDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DimensionDataTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DimensionDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DimensionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *DimensionDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}

func (s *DimensionDataTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOB, 0)
}

func (s *DimensionDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}


func (s *DimensionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDimensionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type StringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringDataTypeContext {
	var p = new(StringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *StringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *StringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *StringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *StringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *StringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *StringDataTypeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYTEXT, 0)
}

func (s *StringDataTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *StringDataTypeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMTEXT, 0)
}

func (s *StringDataTypeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGTEXT, 0)
}

func (s *StringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *StringDataTypeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNVARCHAR, 0)
}

func (s *StringDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *StringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARYING, 0)
}

func (s *StringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *StringDataTypeContext) AllBINARY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBINARY)
}

func (s *StringDataTypeContext) BINARY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, i)
}

func (s *StringDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *StringDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *StringDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}


func (s *StringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringDataType(s)
	}
}

func (s *StringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringDataType(s)
	}
}

func (s *StringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type LongVarcharDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewLongVarcharDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarcharDataTypeContext {
	var p = new(LongVarcharDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *LongVarcharDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *LongVarcharDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *LongVarcharDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarcharDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarcharDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *LongVarcharDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *LongVarcharDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *LongVarcharDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LongVarcharDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *LongVarcharDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}


func (s *LongVarcharDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLongVarcharDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type NationalStringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewNationalStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalStringDataTypeContext {
	var p = new(NationalStringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *NationalStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *NationalStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalStringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *NationalStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *NationalStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *NationalStringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}


func (s *NationalStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNationalStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimpleDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSimpleDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleDataTypeContext {
	var p = new(SimpleDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}


func (s *SimpleDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *SimpleDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SimpleDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *SimpleDataTypeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYBLOB, 0)
}

func (s *SimpleDataTypeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMBLOB, 0)
}

func (s *SimpleDataTypeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGBLOB, 0)
}

func (s *SimpleDataTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *SimpleDataTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *SimpleDataTypeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}


func (s *SimpleDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleDataType(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, MySqlParserRULE_dataType)
	var _la int

	var _alt int

	p.SetState(6651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 993, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6525)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || ((int64((_la - 222)) & ^0x3f) == 0 && ((int64(1) << (_la - 222)) & 31239) != 0) || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserVARYING {
			{
				p.SetState(6526)
				p.Match(MySqlParserVARYING)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(6530)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 966, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6529)
				p.LengthOneDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6533)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 967, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6532)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6538)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 968, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6535)
				p.CharSet()
			}
			{
				p.SetState(6536)
				p.CharsetName()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6543)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 969, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6540)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6541)
				p.CollationName()
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 969, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6542)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		localctx = NewNationalVaryingStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6545)
			p.Match(MySqlParserNATIONAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6546)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalVaryingStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalVaryingStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6547)
			p.Match(MySqlParserVARYING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6549)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 970, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6548)
				p.LengthOneDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6552)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 971, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6551)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6554)
			p.Match(MySqlParserNATIONAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6555)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserCHAR || _la == MySqlParserVARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6557)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 972, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6556)
				p.LengthOneDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6560)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 973, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6559)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6562)
			p.Match(MySqlParserNCHAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6563)

			var _m = p.Match(MySqlParserVARCHAR)

			localctx.(*NationalStringDataTypeContext).typeName = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6565)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 974, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6564)
				p.LengthOneDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6568)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 975, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6567)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 5:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6570)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 196)) & ^0x3f) == 0 && ((int64(1) << (_la - 196)) & 4095) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6572)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 976, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6571)
				p.LengthOneDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 977, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6574)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			}
			p.SetState(6579)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 977, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 6:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6580)

			var _m = p.Match(MySqlParserREAL)

			localctx.(*DimensionDataTypeContext).typeName = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6582)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 978, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6581)
				p.LengthTwoDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 979, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6584)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			}
			p.SetState(6589)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 979, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 7:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6590)

			var _m = p.Match(MySqlParserDOUBLE)

			localctx.(*DimensionDataTypeContext).typeName = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserPRECISION {
			{
				p.SetState(6591)
				p.Match(MySqlParserPRECISION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(6595)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 981, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6594)
				p.LengthTwoDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 982, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6597)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			}
			p.SetState(6602)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 982, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 8:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6603)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 211)) & ^0x3f) == 0 && ((int64(1) << (_la - 211)) & 63) != 0) || _la == MySqlParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6605)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 983, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6604)
				p.LengthTwoOptionalDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 984, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6607)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			}
			p.SetState(6612)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 984, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case 9:
		localctx = NewSimpleDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6613)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & 4237313) != 0) || _la == MySqlParserBOOL || _la == MySqlParserBOOLEAN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 10:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6614)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 218)) & ^0x3f) == 0 && ((int64(1) << (_la - 218)) & 2831) != 0) || _la == MySqlParserBIT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6616)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 985, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6615)
				p.LengthOneDimension()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 11:
		localctx = NewCollectionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6618)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CollectionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSET || _la == MySqlParserENUM) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CollectionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6619)
			p.CollectionOptions()
		}
		p.SetState(6621)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 986, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6620)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6626)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 987, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6623)
				p.CharSet()
			}
			{
				p.SetState(6624)
				p.CharsetName()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 12:
		localctx = NewSpatialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6628)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpatialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJSON || ((int64((_la - 803)) & ^0x3f) == 0 && ((int64(1) << (_la - 803)) & 511) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpatialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6631)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 988, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6629)
				p.Match(MySqlParserSRID)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6630)
				p.DecimalLiteral()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 13:
		localctx = NewLongVarcharDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6633)

			var _m = p.Match(MySqlParserLONG)

			localctx.(*LongVarcharDataTypeContext).typeName = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserVARCHAR {
			{
				p.SetState(6634)
				p.Match(MySqlParserVARCHAR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(6638)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 990, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6637)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6643)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 991, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6640)
				p.CharSet()
			}
			{
				p.SetState(6641)
				p.CharsetName()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(6647)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 992, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6645)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6646)
				p.CollationName()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 14:
		localctx = NewLongVarbinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6649)
			p.Match(MySqlParserLONG)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6650)
			p.Match(MySqlParserVARBINARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICollectionOptionsContext is an interface to support dynamic dispatch.
type ICollectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCollectionOptionsContext differentiates from other interfaces.
	IsCollectionOptionsContext()
}

type CollectionOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOptionsContext() *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collectionOptions
	return p
}

func InitEmptyCollectionOptionsContext(p *CollectionOptionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collectionOptions
}

func (*CollectionOptionsContext) IsCollectionOptionsContext() {}

func NewCollectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collectionOptions

	return p
}

func (s *CollectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOptionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CollectionOptionsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CollectionOptionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CollectionOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CollectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CollectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollectionOptions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CollectionOptions() (localctx ICollectionOptionsContext) {
	localctx = NewCollectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, MySqlParserRULE_collectionOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6653)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6654)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6655)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6656)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(6661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6662)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConvertedDataTypeContext is an interface to support dynamic dispatch.
type IConvertedDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTypeName returns the typeName token.
	GetTypeName() antlr.Token 


	// SetTypeName sets the typeName token.
	SetTypeName(antlr.Token) 


	// Getter signatures
	CHAR() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	JSON() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DEC() antlr.TerminalNode
	LengthOneDimension() ILengthOneDimensionContext
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext

	// IsConvertedDataTypeContext differentiates from other interfaces.
	IsConvertedDataTypeContext()
}

type ConvertedDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	typeName antlr.Token
}

func NewEmptyConvertedDataTypeContext() *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_convertedDataType
	return p
}

func InitEmptyConvertedDataTypeContext(p *ConvertedDataTypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_convertedDataType
}

func (*ConvertedDataTypeContext) IsConvertedDataTypeContext() {}

func NewConvertedDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_convertedDataType

	return p
}

func (s *ConvertedDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertedDataTypeContext) GetTypeName() antlr.Token { return s.typeName }


func (s *ConvertedDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }


func (s *ConvertedDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *ConvertedDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *ConvertedDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, 0)
}

func (s *ConvertedDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserARRAY, 0)
}

func (s *ConvertedDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *ConvertedDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *ConvertedDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT, 0)
}

func (s *ConvertedDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *ConvertedDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *ConvertedDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *ConvertedDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *ConvertedDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *ConvertedDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT, 0)
}

func (s *ConvertedDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *ConvertedDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOUBLE, 0)
}

func (s *ConvertedDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *ConvertedDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC, 0)
}

func (s *ConvertedDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *ConvertedDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ConvertedDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *ConvertedDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConvertedDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConvertedDataType(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ConvertedDataType() (localctx IConvertedDataTypeContext) {
	localctx = NewConvertedDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, MySqlParserRULE_convertedDataType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFLOAT, MySqlParserBINARY, MySqlParserNCHAR:
		{
			p.SetState(6664)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFLOAT || _la == MySqlParserBINARY || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6665)
				p.LengthOneDimension()
			}

		}


	case MySqlParserCHAR:
		{
			p.SetState(6668)

			var _m = p.Match(MySqlParserCHAR)

			localctx.(*ConvertedDataTypeContext).typeName = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6669)
				p.LengthOneDimension()
			}

		}
		p.SetState(6675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCHARACTER || _la == MySqlParserCHAR || _la == MySqlParserCHARSET {
			{
				p.SetState(6672)
				p.CharSet()
			}
			{
				p.SetState(6673)
				p.CharsetName()
			}

		}


	case MySqlParserINT, MySqlParserINTEGER, MySqlParserDOUBLE, MySqlParserDATE, MySqlParserTIME, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserJSON:
		{
			p.SetState(6677)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 200)) & ^0x3f) == 0 && ((int64(1) << (_la - 200)) & 3539521) != 0) || _la == MySqlParserJSON) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case MySqlParserDECIMAL, MySqlParserDEC:
		{
			p.SetState(6678)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDECIMAL || _la == MySqlParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6679)
				p.LengthTwoOptionalDimension()
			}

		}


	case MySqlParserUNSIGNED, MySqlParserSIGNED:
		{
			p.SetState(6682)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserINT || _la == MySqlParserINTEGER {
			{
				p.SetState(6683)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINT || _la == MySqlParserINTEGER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserARRAY {
		{
			p.SetState(6688)
			p.Match(MySqlParserARRAY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthOneDimension
	return p
}

func InitEmptyLengthOneDimensionContext(p *LengthOneDimensionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthOneDimension
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthOneDimension(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, MySqlParserRULE_lengthOneDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6691)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6692)
		p.DecimalLiteral()
	}
	{
		p.SetState(6693)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILengthTwoDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsLengthTwoDimensionContext differentiates from other interfaces.
	IsLengthTwoDimensionContext()
}

type LengthTwoDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoDimensionContext() *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension
	return p
}

func InitEmptyLengthTwoDimensionContext(p *LengthTwoDimensionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension
}

func (*LengthTwoDimensionContext) IsLengthTwoDimensionContext() {}

func NewLengthTwoDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension

	return p
}

func (s *LengthTwoDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LengthTwoDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthTwoDimension(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LengthTwoDimension() (localctx ILengthTwoDimensionContext) {
	localctx = NewLengthTwoDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, MySqlParserRULE_lengthTwoDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6695)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6696)
		p.DecimalLiteral()
	}
	{
		p.SetState(6697)
		p.Match(MySqlParserCOMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6698)
		p.DecimalLiteral()
	}
	{
		p.SetState(6699)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension
	return p
}

func InitEmptyLengthTwoOptionalDimensionContext(p *LengthTwoOptionalDimensionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthTwoOptionalDimension(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, MySqlParserRULE_lengthTwoOptionalDimension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6701)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6702)
		p.DecimalLiteral()
	}
	p.SetState(6705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserCOMMA {
		{
			p.SetState(6703)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6704)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(6707)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUidListContext differentiates from other interfaces.
	IsUidListContext()
}

type UidListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext {
	var p = new(UidListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uidList
	return p
}

func InitEmptyUidListContext(p *UidListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uidList
}

func (*UidListContext) IsUidListContext() {}

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext {
	var p = new(UidListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uidList

	return p
}

func (s *UidListContext) GetParser() antlr.Parser { return s.parser }

func (s *UidListContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UidListContext) Uid(i int) IUidContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *UidListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *UidListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUidList(s)
	}
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUidList(s)
	}
}

func (s *UidListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUidList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UidList() (localctx IUidListContext) {
	localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, MySqlParserRULE_uidList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6709)
		p.Uid()
	}
	p.SetState(6714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1003, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6710)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6711)
				p.Uid()
			}


		}
		p.SetState(6716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1003, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFullColumnNameListContext is an interface to support dynamic dispatch.
type IFullColumnNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFullColumnNameListContext differentiates from other interfaces.
	IsFullColumnNameListContext()
}

type FullColumnNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameListContext() *FullColumnNameListContext {
	var p = new(FullColumnNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnNameList
	return p
}

func InitEmptyFullColumnNameListContext(p *FullColumnNameListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnNameList
}

func (*FullColumnNameListContext) IsFullColumnNameListContext() {}

func NewFullColumnNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameListContext {
	var p = new(FullColumnNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnNameList

	return p
}

func (s *FullColumnNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameListContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameListContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FullColumnNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FullColumnNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FullColumnNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnNameList(s)
	}
}

func (s *FullColumnNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnNameList(s)
	}
}

func (s *FullColumnNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnNameList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FullColumnNameList() (localctx IFullColumnNameListContext) {
	localctx = NewFullColumnNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, MySqlParserRULE_fullColumnNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6717)
		p.FullColumnName()
	}
	p.SetState(6722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6718)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6719)
			p.FullColumnName()
		}


		p.SetState(6724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITablesContext is an interface to support dynamic dispatch.
type ITablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTablesContext differentiates from other interfaces.
	IsTablesContext()
}

type TablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesContext() *TablesContext {
	var p = new(TablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tables
	return p
}

func InitEmptyTablesContext(p *TablesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tables
}

func (*TablesContext) IsTablesContext() {}

func NewTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablesContext {
	var p = new(TablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tables

	return p
}

func (s *TablesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablesContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablesContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTables(s)
	}
}

func (s *TablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTables(s)
	}
}

func (s *TablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTables(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Tables() (localctx ITablesContext) {
	localctx = NewTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, MySqlParserRULE_tables)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6725)
		p.TableName()
	}
	p.SetState(6730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1005, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6726)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6727)
				p.TableName()
			}


		}
		p.SetState(6732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1005, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndexColumnNamesContext is an interface to support dynamic dispatch.
type IIndexColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllIndexColumnName() []IIndexColumnNameContext
	IndexColumnName(i int) IIndexColumnNameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexColumnNamesContext differentiates from other interfaces.
	IsIndexColumnNamesContext()
}

type IndexColumnNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnNamesContext() *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnNames
	return p
}

func InitEmptyIndexColumnNamesContext(p *IndexColumnNamesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnNames
}

func (*IndexColumnNamesContext) IsIndexColumnNamesContext() {}

func NewIndexColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnNames

	return p
}

func (s *IndexColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNamesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllIndexColumnName() []IIndexColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexColumnNameContext); ok {
			tst[i] = t.(IIndexColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *IndexColumnNamesContext) IndexColumnName(i int) IIndexColumnNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNameContext)
}

func (s *IndexColumnNamesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *IndexColumnNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *IndexColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IndexColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexColumnNames(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IndexColumnNames() (localctx IIndexColumnNamesContext) {
	localctx = NewIndexColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, MySqlParserRULE_indexColumnNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6733)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6734)
		p.IndexColumnName()
	}
	p.SetState(6739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6735)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6736)
			p.IndexColumnName()
		}


		p.SetState(6741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6742)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
	return p
}

func InitEmptyExpressionsContext(p *ExpressionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Expressions() (localctx IExpressionsContext) {
	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, MySqlParserRULE_expressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6744)
		p.expression(0)
	}
	p.SetState(6749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6745)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6746)
			p.expression(0)
		}


		p.SetState(6751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionsWithDefaultsContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsWithDefaultsContext differentiates from other interfaces.
	IsExpressionsWithDefaultsContext()
}

type ExpressionsWithDefaultsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultsContext() *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults
	return p
}

func InitEmptyExpressionsWithDefaultsContext(p *ExpressionsWithDefaultsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults
}

func (*ExpressionsWithDefaultsContext) IsExpressionsWithDefaultsContext() {}

func NewExpressionsWithDefaultsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults

	return p
}

func (s *ExpressionsWithDefaultsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultsContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultsContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsWithDefaultsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsWithDefaultsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionsWithDefaultsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionsWithDefaults(s)
	}
}

func (s *ExpressionsWithDefaultsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionsWithDefaults(s)
	}
}

func (s *ExpressionsWithDefaultsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionsWithDefaults(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ExpressionsWithDefaults() (localctx IExpressionsWithDefaultsContext) {
	localctx = NewExpressionsWithDefaultsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, MySqlParserRULE_expressionsWithDefaults)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6752)
		p.ExpressionOrDefault()
	}
	p.SetState(6757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6753)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6754)
			p.ExpressionOrDefault()
		}


		p.SetState(6759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConstantsContext is an interface to support dynamic dispatch.
type IConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstantsContext differentiates from other interfaces.
	IsConstantsContext()
}

type ConstantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantsContext() *ConstantsContext {
	var p = new(ConstantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constants
	return p
}

func InitEmptyConstantsContext(p *ConstantsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constants
}

func (*ConstantsContext) IsConstantsContext() {}

func NewConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantsContext {
	var p = new(ConstantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constants

	return p
}

func (s *ConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstants(s)
	}
}

func (s *ConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstants(s)
	}
}

func (s *ConstantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstants(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) Constants() (localctx IConstantsContext) {
	localctx = NewConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, MySqlParserRULE_constants)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6760)
		p.Constant()
	}
	p.SetState(6765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6761)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6762)
			p.Constant()
		}


		p.SetState(6767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimpleStringsContext is an interface to support dynamic dispatch.
type ISimpleStringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleStringsContext differentiates from other interfaces.
	IsSimpleStringsContext()
}

type SimpleStringsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStringsContext() *SimpleStringsContext {
	var p = new(SimpleStringsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleStrings
	return p
}

func InitEmptySimpleStringsContext(p *SimpleStringsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleStrings
}

func (*SimpleStringsContext) IsSimpleStringsContext() {}

func NewSimpleStringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStringsContext {
	var p = new(SimpleStringsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleStrings

	return p
}

func (s *SimpleStringsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStringsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *SimpleStringsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *SimpleStringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SimpleStringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SimpleStringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleStringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleStrings(s)
	}
}

func (s *SimpleStringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleStrings(s)
	}
}

func (s *SimpleStringsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleStrings(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) SimpleStrings() (localctx ISimpleStringsContext) {
	localctx = NewSimpleStringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, MySqlParserRULE_simpleStrings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6768)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6769)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6770)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(6775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUserVariablesContext is an interface to support dynamic dispatch.
type IUserVariablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOCAL_ID() []antlr.TerminalNode
	LOCAL_ID(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUserVariablesContext differentiates from other interfaces.
	IsUserVariablesContext()
}

type UserVariablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariablesContext() *UserVariablesContext {
	var p = new(UserVariablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userVariables
	return p
}

func InitEmptyUserVariablesContext(p *UserVariablesContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userVariables
}

func (*UserVariablesContext) IsUserVariablesContext() {}

func NewUserVariablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariablesContext {
	var p = new(UserVariablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userVariables

	return p
}

func (s *UserVariablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariablesContext) AllLOCAL_ID() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCAL_ID)
}

func (s *UserVariablesContext) LOCAL_ID(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, i)
}

func (s *UserVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *UserVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *UserVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UserVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserVariables(s)
	}
}

func (s *UserVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserVariables(s)
	}
}

func (s *UserVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserVariables(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UserVariables() (localctx IUserVariablesContext) {
	localctx = NewUserVariablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, MySqlParserRULE_userVariables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6776)
		p.Match(MySqlParserLOCAL_ID)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(6781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(6777)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6778)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(6783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	CAST() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	ConvertedDataType() IConvertedDataTypeContext
	RR_BRACKET() antlr.TerminalNode
	Constant() IConstantContext
	UnaryOperator() IUnaryOperatorContext
	AllCurrentTimestamp() []ICurrentTimestampContext
	CurrentTimestamp(i int) ICurrentTimestampContext
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	FullId() IFullIdContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *DefaultValueContext) CAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCAST, 0)
}

func (s *DefaultValueContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *DefaultValueContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DefaultValueContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DefaultValueContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *DefaultValueContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *DefaultValueContext) AllCurrentTimestamp() []ICurrentTimestampContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			len++
		}
	}

	tst := make([]ICurrentTimestampContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICurrentTimestampContext); ok {
			tst[i] = t.(ICurrentTimestampContext)
			i++
		}
	}

	return tst
}

func (s *DefaultValueContext) CurrentTimestamp(i int) ICurrentTimestampContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *DefaultValueContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DefaultValueContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *DefaultValueContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, MySqlParserRULE_defaultValue)
	p.SetState(6810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1014, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6784)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6785)
			p.Match(MySqlParserCAST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6786)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6787)
			p.expression(0)
		}
		{
			p.SetState(6788)
			p.Match(MySqlParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6789)
			p.ConvertedDataType()
		}
		{
			p.SetState(6790)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6793)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1012, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6792)
				p.UnaryOperator()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(6795)
			p.Constant()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6796)
			p.CurrentTimestamp()
		}
		p.SetState(6800)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1013, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6797)
				p.Match(MySqlParserON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6798)
				p.Match(MySqlParserUPDATE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6799)
				p.CurrentTimestamp()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6802)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6803)
			p.expression(0)
		}
		{
			p.SetState(6804)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6806)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6807)
			p.FullId()
		}
		{
			p.SetState(6808)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICurrentTimestampContext is an interface to support dynamic dispatch.
type ICurrentTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOW() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsCurrentTimestampContext differentiates from other interfaces.
	IsCurrentTimestampContext()
}

type CurrentTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentTimestampContext() *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentTimestamp
	return p
}

func InitEmptyCurrentTimestampContext(p *CurrentTimestampContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentTimestamp
}

func (*CurrentTimestampContext) IsCurrentTimestampContext() {}

func NewCurrentTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_currentTimestamp

	return p
}

func (s *CurrentTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentTimestampContext) NOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOW, 0)
}

func (s *CurrentTimestampContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CurrentTimestampContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *CurrentTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIMESTAMP, 0)
}

func (s *CurrentTimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentTimestamp(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CurrentTimestamp() (localctx ICurrentTimestampContext) {
	localctx = NewCurrentTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, MySqlParserRULE_currentTimestamp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserLOCALTIMESTAMP:
		{
			p.SetState(6812)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 315)) & ^0x3f) == 0 && ((int64(1) << (_la - 315)) & 131) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6818)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1016, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6813)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(6815)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if ((int64((_la - 1138)) & ^0x3f) == 0 && ((int64(1) << (_la - 1138)) & 10247) != 0) {
				{
					p.SetState(6814)
					p.DecimalLiteral()
				}

			}
			{
				p.SetState(6817)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserNOW:
		{
			p.SetState(6820)
			p.Match(MySqlParserNOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6821)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 1138)) & ^0x3f) == 0 && ((int64(1) << (_la - 1138)) & 10247) != 0) {
			{
				p.SetState(6822)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(6825)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, MySqlParserRULE_expressionOrDefault)
	p.SetState(6830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1019, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6828)
			p.expression(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6829)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *IfExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (s *IfExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIfExists(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, MySqlParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6832)
		p.Match(MySqlParserIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6833)
		p.Match(MySqlParserEXISTS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, MySqlParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6835)
		p.Match(MySqlParserIF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6836)
		p.Match(MySqlParserNOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6837)
		p.Match(MySqlParserEXISTS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (s *OrReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrReplace(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, MySqlParserRULE_orReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6839)
		p.Match(MySqlParserOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(6840)
		p.Match(MySqlParserREPLACE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWaitNowaitClauseContext is an interface to support dynamic dispatch.
type IWaitNowaitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WAIT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	NOWAIT() antlr.TerminalNode

	// IsWaitNowaitClauseContext differentiates from other interfaces.
	IsWaitNowaitClauseContext()
}

type WaitNowaitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitNowaitClauseContext() *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_waitNowaitClause
	return p
}

func InitEmptyWaitNowaitClauseContext(p *WaitNowaitClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_waitNowaitClause
}

func (*WaitNowaitClauseContext) IsWaitNowaitClauseContext() {}

func NewWaitNowaitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_waitNowaitClause

	return p
}

func (s *WaitNowaitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitNowaitClauseContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *WaitNowaitClauseContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WaitNowaitClauseContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOWAIT, 0)
}

func (s *WaitNowaitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitNowaitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WaitNowaitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWaitNowaitClause(s)
	}
}

func (s *WaitNowaitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWaitNowaitClause(s)
	}
}

func (s *WaitNowaitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWaitNowaitClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) WaitNowaitClause() (localctx IWaitNowaitClauseContext) {
	localctx = NewWaitNowaitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, MySqlParserRULE_waitNowaitClause)
	p.SetState(6845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserWAIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6842)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6843)
			p.DecimalLiteral()
		}


	case MySqlParserNOWAIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6844)
			p.Match(MySqlParserNOWAIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyAll(ctx *FunctionCallContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SpecificFunctionCallContext struct {
	FunctionCallContext
}

func NewSpecificFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecificFunctionCallContext {
	var p = new(SpecificFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecificFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionCallContext) SpecificFunction() ISpecificFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecificFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecificFunctionContext)
}


func (s *SpecificFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpecificFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type PasswordFunctionCallContext struct {
	FunctionCallContext
}

func NewPasswordFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordFunctionCallContext {
	var p = new(PasswordFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *PasswordFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionCallContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}


func (s *PasswordFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type UdfFunctionCallContext struct {
	FunctionCallContext
}

func NewUdfFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UdfFunctionCallContext {
	var p = new(UdfFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *UdfFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfFunctionCallContext) FullId() IFullIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *UdfFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}


func (s *UdfFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUdfFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type NonAggregateFunctionCallContext struct {
	FunctionCallContext
}

func NewNonAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonAggregateFunctionCallContext {
	var p = new(NonAggregateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *NonAggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateFunctionCallContext) NonAggregateWindowedFunction() INonAggregateWindowedFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonAggregateWindowedFunctionContext)
}


func (s *NonAggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNonAggregateFunctionCall(s)
	}
}

func (s *NonAggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNonAggregateFunctionCall(s)
	}
}

func (s *NonAggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNonAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type AggregateFunctionCallContext struct {
	FunctionCallContext
}

func NewAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateFunctionCallContext {
	var p = new(AggregateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionCallContext) AggregateWindowedFunction() IAggregateWindowedFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateWindowedFunctionContext)
}


func (s *AggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type ScalarFunctionCallContext struct {
	FunctionCallContext
}

func NewScalarFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarFunctionCallContext {
	var p = new(ScalarFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *ScalarFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionCallContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *ScalarFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}


func (s *ScalarFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitScalarFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, MySqlParserRULE_functionCall)
	p.SetState(6865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1023, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSpecificFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6847)
			p.SpecificFunction()
		}


	case 2:
		localctx = NewAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6848)
			p.AggregateWindowedFunction()
		}


	case 3:
		localctx = NewNonAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6849)
			p.NonAggregateWindowedFunction()
		}


	case 4:
		localctx = NewScalarFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6850)
			p.ScalarFunctionName()
		}
		{
			p.SetState(6851)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6853)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1021, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6852)
				p.FunctionArgs()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(6855)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		localctx = NewUdfFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6857)
			p.FullId()
		}
		{
			p.SetState(6858)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6860)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1022, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6859)
				p.FunctionArgs()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(6862)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		localctx = NewPasswordFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6864)
			p.PasswordFunctionClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISpecificFunctionContext is an interface to support dynamic dispatch.
type ISpecificFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSpecificFunctionContext differentiates from other interfaces.
	IsSpecificFunctionContext()
}

type SpecificFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecificFunctionContext() *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_specificFunction
	return p
}

func InitEmptySpecificFunctionContext(p *SpecificFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_specificFunction
}

func (*SpecificFunctionContext) IsSpecificFunctionContext() {}

func NewSpecificFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_specificFunction

	return p
}

func (s *SpecificFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificFunctionContext) CopyAll(ctx *SpecificFunctionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SpecificFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type PositionFunctionCallContext struct {
	SpecificFunctionContext
	positionString IStringLiteralContext 
	positionExpression IExpressionContext 
	inString IStringLiteralContext 
	inExpression IExpressionContext 
}

func NewPositionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionFunctionCallContext {
	var p = new(PositionFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *PositionFunctionCallContext) GetPositionString() IStringLiteralContext { return s.positionString }

func (s *PositionFunctionCallContext) GetPositionExpression() IExpressionContext { return s.positionExpression }

func (s *PositionFunctionCallContext) GetInString() IStringLiteralContext { return s.inString }

func (s *PositionFunctionCallContext) GetInExpression() IExpressionContext { return s.inExpression }


func (s *PositionFunctionCallContext) SetPositionString(v IStringLiteralContext) { s.positionString = v }

func (s *PositionFunctionCallContext) SetPositionExpression(v IExpressionContext) { s.positionExpression = v }

func (s *PositionFunctionCallContext) SetInString(v IStringLiteralContext) { s.inString = v }

func (s *PositionFunctionCallContext) SetInExpression(v IExpressionContext) { s.inExpression = v }

func (s *PositionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionFunctionCallContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *PositionFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PositionFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PositionFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *PositionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPositionFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type TrimFunctionCallContext struct {
	SpecificFunctionContext
	positioinForm antlr.Token
	sourceString IStringLiteralContext 
	sourceExpression IExpressionContext 
	fromString IStringLiteralContext 
	fromExpression IExpressionContext 
}

func NewTrimFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TrimFunctionCallContext {
	var p = new(TrimFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *TrimFunctionCallContext) GetPositioinForm() antlr.Token { return s.positioinForm }


func (s *TrimFunctionCallContext) SetPositioinForm(v antlr.Token) { s.positioinForm = v }


func (s *TrimFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *TrimFunctionCallContext) GetSourceExpression() IExpressionContext { return s.sourceExpression }

func (s *TrimFunctionCallContext) GetFromString() IStringLiteralContext { return s.fromString }

func (s *TrimFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }


func (s *TrimFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *TrimFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *TrimFunctionCallContext) SetFromString(v IStringLiteralContext) { s.fromString = v }

func (s *TrimFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *TrimFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionCallContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *TrimFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *TrimFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) BOTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOTH, 0)
}

func (s *TrimFunctionCallContext) LEADING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEADING, 0)
}

func (s *TrimFunctionCallContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRAILING, 0)
}

func (s *TrimFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TrimFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *TrimFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTrimFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type JsonValueFunctionCallContext struct {
	SpecificFunctionContext
}

func NewJsonValueFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonValueFunctionCallContext {
	var p = new(JsonValueFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *JsonValueFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueFunctionCallContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALUE, 0)
}

func (s *JsonValueFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *JsonValueFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JsonValueFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *JsonValueFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNING, 0)
}

func (s *JsonValueFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *JsonValueFunctionCallContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonValueFunctionCallContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}


func (s *JsonValueFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonValueFunctionCall(s)
	}
}

func (s *JsonValueFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonValueFunctionCall(s)
	}
}

func (s *JsonValueFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonValueFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type CaseFunctionCallContext struct {
	SpecificFunctionContext
	elseArg IFunctionArgContext 
}

func NewCaseFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseFunctionCallContext {
	var p = new(CaseFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *CaseFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }


func (s *CaseFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, 0)
}

func (s *CaseFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}


func (s *CaseFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type ExtractFunctionCallContext struct {
	SpecificFunctionContext
	sourceString IStringLiteralContext 
	sourceExpression IExpressionContext 
}

func NewExtractFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractFunctionCallContext {
	var p = new(ExtractFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *ExtractFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *ExtractFunctionCallContext) GetSourceExpression() IExpressionContext { return s.sourceExpression }


func (s *ExtractFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *ExtractFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *ExtractFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionCallContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACT, 0)
}

func (s *ExtractFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *ExtractFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ExtractFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ExtractFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *ExtractFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExtractFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type DataTypeFunctionCallContext struct {
	SpecificFunctionContext
	separator antlr.Token
}

func NewDataTypeFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataTypeFunctionCallContext {
	var p = new(DataTypeFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *DataTypeFunctionCallContext) GetSeparator() antlr.Token { return s.separator }


func (s *DataTypeFunctionCallContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataTypeFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeFunctionCallContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *DataTypeFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataTypeFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DataTypeFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *DataTypeFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *DataTypeFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *DataTypeFunctionCallContext) CAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCAST, 0)
}

func (s *DataTypeFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}


func (s *DataTypeFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDataTypeFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type ValuesFunctionCallContext struct {
	SpecificFunctionContext
}

func NewValuesFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesFunctionCallContext {
	var p = new(ValuesFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ValuesFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesFunctionCallContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *ValuesFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ValuesFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *ValuesFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitValuesFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type CaseExpressionFunctionCallContext struct {
	SpecificFunctionContext
	elseArg IFunctionArgContext 
}

func NewCaseExpressionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExpressionFunctionCallContext {
	var p = new(CaseExpressionFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *CaseExpressionFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }


func (s *CaseExpressionFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseExpressionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, 0)
}

func (s *CaseExpressionFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseExpressionFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseExpressionFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseExpressionFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}


func (s *CaseExpressionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseExpressionFunctionCall(s)
	}
}

func (s *CaseExpressionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseExpressionFunctionCall(s)
	}
}

func (s *CaseExpressionFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseExpressionFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type CurrentUserContext struct {
	SpecificFunctionContext
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}


func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

func (s *CurrentUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentUser(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimpleFunctionCallContext struct {
	SpecificFunctionContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *SimpleFunctionCallContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *SimpleFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SimpleFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type CharFunctionCallContext struct {
	SpecificFunctionContext
}

func NewCharFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionCallContext {
	var p = new(CharFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CharFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *CharFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CharFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *CharFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CharFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *CharFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}


func (s *CharFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type WeightFunctionCallContext struct {
	SpecificFunctionContext
	stringFormat antlr.Token
}

func NewWeightFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WeightFunctionCallContext {
	var p = new(WeightFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *WeightFunctionCallContext) GetStringFormat() antlr.Token { return s.stringFormat }


func (s *WeightFunctionCallContext) SetStringFormat(v antlr.Token) { s.stringFormat = v }

func (s *WeightFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightFunctionCallContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *WeightFunctionCallContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *WeightFunctionCallContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *WeightFunctionCallContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *WeightFunctionCallContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *WeightFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *WeightFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WeightFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *WeightFunctionCallContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WeightFunctionCallContext) LevelsInWeightString() ILevelsInWeightStringContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelsInWeightStringContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelsInWeightStringContext)
}

func (s *WeightFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *WeightFunctionCallContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}


func (s *WeightFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWeightFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type GetFormatFunctionCallContext struct {
	SpecificFunctionContext
	datetimeFormat antlr.Token
}

func NewGetFormatFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GetFormatFunctionCallContext {
	var p = new(GetFormatFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *GetFormatFunctionCallContext) GetDatetimeFormat() antlr.Token { return s.datetimeFormat }


func (s *GetFormatFunctionCallContext) SetDatetimeFormat(v antlr.Token) { s.datetimeFormat = v }

func (s *GetFormatFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetFormatFunctionCallContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *GetFormatFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *GetFormatFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *GetFormatFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *GetFormatFunctionCallContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *GetFormatFunctionCallContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}


func (s *GetFormatFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGetFormatFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}


type SubstrFunctionCallContext struct {
	SpecificFunctionContext
	sourceString IStringLiteralContext 
	sourceExpression IExpressionContext 
	fromDecimal IDecimalLiteralContext 
	fromExpression IExpressionContext 
	forDecimal IDecimalLiteralContext 
	forExpression IExpressionContext 
}

func NewSubstrFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstrFunctionCallContext {
	var p = new(SubstrFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}


func (s *SubstrFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *SubstrFunctionCallContext) GetSourceExpression() IExpressionContext { return s.sourceExpression }

func (s *SubstrFunctionCallContext) GetFromDecimal() IDecimalLiteralContext { return s.fromDecimal }

func (s *SubstrFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *SubstrFunctionCallContext) GetForDecimal() IDecimalLiteralContext { return s.forDecimal }

func (s *SubstrFunctionCallContext) GetForExpression() IExpressionContext { return s.forExpression }


func (s *SubstrFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *SubstrFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *SubstrFunctionCallContext) SetFromDecimal(v IDecimalLiteralContext) { s.fromDecimal = v }

func (s *SubstrFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *SubstrFunctionCallContext) SetForDecimal(v IDecimalLiteralContext) { s.forDecimal = v }

func (s *SubstrFunctionCallContext) SetForExpression(v IExpressionContext) { s.forExpression = v }

func (s *SubstrFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstrFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *SubstrFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *SubstrFunctionCallContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *SubstrFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SubstrFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubstrFunctionCallContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SubstrFunctionCallContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}


func (s *SubstrFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubstrFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) SpecificFunction() (localctx ISpecificFunctionContext) {
	localctx = NewSpecificFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, MySqlParserRULE_specificFunction)
	var _la int

	p.SetState(7046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1047, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6867)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSCHEMA || ((int64((_la - 313)) & ^0x3f) == 0 && ((int64(1) << (_la - 313)) & 262159) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6870)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1024, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6868)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6869)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		localctx = NewCurrentUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6872)
			p.CurrentUserExpression()
		}


	case 3:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6873)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6874)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6875)
			p.expression(0)
		}
		{
			p.SetState(6876)

			var _m = p.Match(MySqlParserCOMMA)

			localctx.(*DataTypeFunctionCallContext).separator = _m
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6877)
			p.ConvertedDataType()
		}
		{
			p.SetState(6878)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6880)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6881)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6882)
			p.expression(0)
		}
		{
			p.SetState(6883)
			p.Match(MySqlParserUSING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6884)
			p.CharsetName()
		}
		{
			p.SetState(6885)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6887)
			p.Match(MySqlParserCAST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6888)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6889)
			p.expression(0)
		}
		{
			p.SetState(6890)
			p.Match(MySqlParserAS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6891)
			p.ConvertedDataType()
		}
		{
			p.SetState(6892)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		localctx = NewValuesFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6894)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6895)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6896)
			p.FullColumnName()
		}
		{
			p.SetState(6897)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		localctx = NewCaseExpressionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6899)
			p.Match(MySqlParserCASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6900)
			p.expression(0)
		}
		p.SetState(6902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(6901)
				p.CaseFuncAlternative()
			}


			p.SetState(6904)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserELSE {
			{
				p.SetState(6906)
				p.Match(MySqlParserELSE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6907)

				var _x = p.FunctionArg()


				localctx.(*CaseExpressionFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6910)
			p.Match(MySqlParserEND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		localctx = NewCaseFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6912)
			p.Match(MySqlParserCASE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(6913)
				p.CaseFuncAlternative()
			}


			p.SetState(6916)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserELSE {
			{
				p.SetState(6918)
				p.Match(MySqlParserELSE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6919)

				var _x = p.FunctionArg()


				localctx.(*CaseFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6922)
			p.Match(MySqlParserEND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		localctx = NewCharFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6924)
			p.Match(MySqlParserCHAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6925)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6926)
			p.FunctionArgs()
		}
		p.SetState(6929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserUSING {
			{
				p.SetState(6927)
				p.Match(MySqlParserUSING)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(6928)
				p.CharsetName()
			}

		}
		{
			p.SetState(6931)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		localctx = NewPositionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6933)
			p.Match(MySqlParserPOSITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6934)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1030, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6935)

				var _x = p.StringLiteral()


				localctx.(*PositionFunctionCallContext).positionString = _x
			}


		case 2:
			{
				p.SetState(6936)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).positionExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6939)
			p.Match(MySqlParserIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1031, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6940)

				var _x = p.StringLiteral()


				localctx.(*PositionFunctionCallContext).inString = _x
			}


		case 2:
			{
				p.SetState(6941)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).inExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6944)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		localctx = NewSubstrFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6946)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSUBSTR || _la == MySqlParserSUBSTRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6947)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1032, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6948)

				var _x = p.StringLiteral()


				localctx.(*SubstrFunctionCallContext).sourceString = _x
			}


		case 2:
			{
				p.SetState(6949)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6952)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1033, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6953)

				var _x = p.DecimalLiteral()


				localctx.(*SubstrFunctionCallContext).fromDecimal = _x
			}


		case 2:
			{
				p.SetState(6954)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(6962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserFOR {
			{
				p.SetState(6957)
				p.Match(MySqlParserFOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(6960)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1034, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(6958)

					var _x = p.DecimalLiteral()


					localctx.(*SubstrFunctionCallContext).forDecimal = _x
				}


			case 2:
				{
					p.SetState(6959)

					var _x = p.expression(0)

					localctx.(*SubstrFunctionCallContext).forExpression = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		{
			p.SetState(6964)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6966)
			p.Match(MySqlParserTRIM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6967)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6968)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TrimFunctionCallContext).positioinForm = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBOTH || _la == MySqlParserLEADING || _la == MySqlParserTRAILING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TrimFunctionCallContext).positioinForm = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6971)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1036, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6969)

				var _x = p.StringLiteral()


				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1036, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6970)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(6973)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1037, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6974)

				var _x = p.StringLiteral()


				localctx.(*TrimFunctionCallContext).fromString = _x
			}


		case 2:
			{
				p.SetState(6975)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6978)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 13:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6980)
			p.Match(MySqlParserTRIM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6981)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1038, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6982)

				var _x = p.StringLiteral()


				localctx.(*TrimFunctionCallContext).sourceString = _x
			}


		case 2:
			{
				p.SetState(6983)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6986)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1039, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6987)

				var _x = p.StringLiteral()


				localctx.(*TrimFunctionCallContext).fromString = _x
			}


		case 2:
			{
				p.SetState(6988)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6991)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 14:
		localctx = NewWeightFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6993)
			p.Match(MySqlParserWEIGHT_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(6994)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(6997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1040, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6995)
				p.StringLiteral()
			}


		case 2:
			{
				p.SetState(6996)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(7005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserAS {
			{
				p.SetState(6999)
				p.Match(MySqlParserAS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7000)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*WeightFunctionCallContext).stringFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCHAR || _la == MySqlParserBINARY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*WeightFunctionCallContext).stringFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7001)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7002)
				p.DecimalLiteral()
			}
			{
				p.SetState(7003)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(7008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserLEVEL {
			{
				p.SetState(7007)
				p.LevelsInWeightString()
			}

		}
		{
			p.SetState(7010)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		localctx = NewExtractFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7012)
			p.Match(MySqlParserEXTRACT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7013)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7014)
			p.IntervalType()
		}
		{
			p.SetState(7015)
			p.Match(MySqlParserFROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1043, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7016)

				var _x = p.StringLiteral()


				localctx.(*ExtractFunctionCallContext).sourceString = _x
			}


		case 2:
			{
				p.SetState(7017)

				var _x = p.expression(0)

				localctx.(*ExtractFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7020)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 16:
		localctx = NewGetFormatFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7022)
			p.Match(MySqlParserGET_FORMAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7023)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7024)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GetFormatFunctionCallContext).datetimeFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & 11) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GetFormatFunctionCallContext).datetimeFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7025)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7026)
			p.StringLiteral()
		}
		{
			p.SetState(7027)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 17:
		localctx = NewJsonValueFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7029)
			p.Match(MySqlParserJSON_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7030)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7031)
			p.expression(0)
		}
		{
			p.SetState(7032)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7033)
			p.expression(0)
		}
		p.SetState(7036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserRETURNING {
			{
				p.SetState(7034)
				p.Match(MySqlParserRETURNING)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7035)
				p.ConvertedDataType()
			}

		}
		p.SetState(7039)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1045, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7038)
				p.JsonOnEmpty()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(7042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserDEFAULT || _la == MySqlParserNULL_LITERAL || _la == MySqlParserERROR {
			{
				p.SetState(7041)
				p.JsonOnError()
			}

		}
		{
			p.SetState(7044)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICaseFuncAlternativeContext is an interface to support dynamic dispatch.
type ICaseFuncAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IFunctionArgContext

	// GetConsequent returns the consequent rule contexts.
	GetConsequent() IFunctionArgContext


	// SetCondition sets the condition rule contexts.
	SetCondition(IFunctionArgContext)

	// SetConsequent sets the consequent rule contexts.
	SetConsequent(IFunctionArgContext)


	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllFunctionArg() []IFunctionArgContext
	FunctionArg(i int) IFunctionArgContext

	// IsCaseFuncAlternativeContext differentiates from other interfaces.
	IsCaseFuncAlternativeContext()
}

type CaseFuncAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	condition IFunctionArgContext 
	consequent IFunctionArgContext 
}

func NewEmptyCaseFuncAlternativeContext() *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative
	return p
}

func InitEmptyCaseFuncAlternativeContext(p *CaseFuncAlternativeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative
}

func (*CaseFuncAlternativeContext) IsCaseFuncAlternativeContext() {}

func NewCaseFuncAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative

	return p
}

func (s *CaseFuncAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseFuncAlternativeContext) GetCondition() IFunctionArgContext { return s.condition }

func (s *CaseFuncAlternativeContext) GetConsequent() IFunctionArgContext { return s.consequent }


func (s *CaseFuncAlternativeContext) SetCondition(v IFunctionArgContext) { s.condition = v }

func (s *CaseFuncAlternativeContext) SetConsequent(v IFunctionArgContext) { s.consequent = v }


func (s *CaseFuncAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHEN, 0)
}

func (s *CaseFuncAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *CaseFuncAlternativeContext) AllFunctionArg() []IFunctionArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgContext); ok {
			tst[i] = t.(IFunctionArgContext)
			i++
		}
	}

	return tst
}

func (s *CaseFuncAlternativeContext) FunctionArg(i int) IFunctionArgContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFuncAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFuncAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CaseFuncAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseFuncAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CaseFuncAlternative() (localctx ICaseFuncAlternativeContext) {
	localctx = NewCaseFuncAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, MySqlParserRULE_caseFuncAlternative)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7048)
		p.Match(MySqlParserWHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(7049)

		var _x = p.FunctionArg()


		localctx.(*CaseFuncAlternativeContext).condition = _x
	}
	{
		p.SetState(7050)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(7051)

		var _x = p.FunctionArg()


		localctx.(*CaseFuncAlternativeContext).consequent = _x
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILevelsInWeightStringContext is an interface to support dynamic dispatch.
type ILevelsInWeightStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLevelsInWeightStringContext differentiates from other interfaces.
	IsLevelsInWeightStringContext()
}

type LevelsInWeightStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelsInWeightStringContext() *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelsInWeightString
	return p
}

func InitEmptyLevelsInWeightStringContext(p *LevelsInWeightStringContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelsInWeightString
}

func (*LevelsInWeightStringContext) IsLevelsInWeightStringContext() {}

func NewLevelsInWeightStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelsInWeightString

	return p
}

func (s *LevelsInWeightStringContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelsInWeightStringContext) CopyAll(ctx *LevelsInWeightStringContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LevelsInWeightStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelsInWeightStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type LevelWeightRangeContext struct {
	LevelsInWeightStringContext
	firstLevel IDecimalLiteralContext 
	lastLevel IDecimalLiteralContext 
}

func NewLevelWeightRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightRangeContext {
	var p = new(LevelWeightRangeContext)

	InitEmptyLevelsInWeightStringContext(&p.LevelsInWeightStringContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelsInWeightStringContext))

	return p
}


func (s *LevelWeightRangeContext) GetFirstLevel() IDecimalLiteralContext { return s.firstLevel }

func (s *LevelWeightRangeContext) GetLastLevel() IDecimalLiteralContext { return s.lastLevel }


func (s *LevelWeightRangeContext) SetFirstLevel(v IDecimalLiteralContext) { s.firstLevel = v }

func (s *LevelWeightRangeContext) SetLastLevel(v IDecimalLiteralContext) { s.lastLevel = v }

func (s *LevelWeightRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightRangeContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightRangeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *LevelWeightRangeContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightRangeContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}


func (s *LevelWeightRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelWeightRange(s)

	default:
		return t.VisitChildren(s)
	}
}


type LevelWeightListContext struct {
	LevelsInWeightStringContext
}

func NewLevelWeightListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightListContext {
	var p = new(LevelWeightListContext)

	InitEmptyLevelsInWeightStringContext(&p.LevelsInWeightStringContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightListContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightListContext) AllLevelInWeightListElement() []ILevelInWeightListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			len++
		}
	}

	tst := make([]ILevelInWeightListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILevelInWeightListElementContext); ok {
			tst[i] = t.(ILevelInWeightListElementContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightListContext) LevelInWeightListElement(i int) ILevelInWeightListElementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelInWeightListElementContext)
}

func (s *LevelWeightListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LevelWeightListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *LevelWeightListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelWeightList(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) LevelsInWeightString() (localctx ILevelsInWeightStringContext) {
	localctx = NewLevelsInWeightStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, MySqlParserRULE_levelsInWeightString)
	var _la int

	p.SetState(7067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1049, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLevelWeightListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7053)
			p.Match(MySqlParserLEVEL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7054)
			p.LevelInWeightListElement()
		}
		p.SetState(7059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(7055)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7056)
				p.LevelInWeightListElement()
			}


			p.SetState(7061)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		localctx = NewLevelWeightRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7062)
			p.Match(MySqlParserLEVEL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7063)

			var _x = p.DecimalLiteral()


			localctx.(*LevelWeightRangeContext).firstLevel = _x
		}
		{
			p.SetState(7064)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7065)

			var _x = p.DecimalLiteral()


			localctx.(*LevelWeightRangeContext).lastLevel = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILevelInWeightListElementContext is an interface to support dynamic dispatch.
type ILevelInWeightListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrderType returns the orderType token.
	GetOrderType() antlr.Token 


	// SetOrderType sets the orderType token.
	SetOrderType(antlr.Token) 


	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	REVERSE() antlr.TerminalNode

	// IsLevelInWeightListElementContext differentiates from other interfaces.
	IsLevelInWeightListElementContext()
}

type LevelInWeightListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	orderType antlr.Token
}

func NewEmptyLevelInWeightListElementContext() *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement
	return p
}

func InitEmptyLevelInWeightListElementContext(p *LevelInWeightListElementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement
}

func (*LevelInWeightListElementContext) IsLevelInWeightListElementContext() {}

func NewLevelInWeightListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement

	return p
}

func (s *LevelInWeightListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelInWeightListElementContext) GetOrderType() antlr.Token { return s.orderType }


func (s *LevelInWeightListElementContext) SetOrderType(v antlr.Token) { s.orderType = v }


func (s *LevelInWeightListElementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelInWeightListElementContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *LevelInWeightListElementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *LevelInWeightListElementContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *LevelInWeightListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelInWeightListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LevelInWeightListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelInWeightListElement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LevelInWeightListElement() (localctx ILevelInWeightListElementContext) {
	localctx = NewLevelInWeightListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, MySqlParserRULE_levelInWeightListElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7069)
		p.DecimalLiteral()
	}
	p.SetState(7071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE {
		{
			p.SetState(7070)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LevelInWeightListElementContext).orderType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LevelInWeightListElementContext).orderType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type IAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAggregator returns the aggregator token.
	GetAggregator() antlr.Token 

	// GetStarArg returns the starArg token.
	GetStarArg() antlr.Token 

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token 


	// SetAggregator sets the aggregator token.
	SetAggregator(antlr.Token) 

	// SetStarArg sets the starArg token.
	SetStarArg(antlr.Token) 

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token) 


	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	AVG() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	OverClause() IOverClauseContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	STAR() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	SEPARATOR() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAggregateWindowedFunctionContext differentiates from other interfaces.
	IsAggregateWindowedFunctionContext()
}

type AggregateWindowedFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	aggregator antlr.Token
	starArg antlr.Token
	separator antlr.Token
}

func NewEmptyAggregateWindowedFunctionContext() *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
	return p
}

func InitEmptyAggregateWindowedFunctionContext(p *AggregateWindowedFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
}

func (*AggregateWindowedFunctionContext) IsAggregateWindowedFunctionContext() {}

func NewAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction

	return p
}

func (s *AggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateWindowedFunctionContext) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunctionContext) GetStarArg() antlr.Token { return s.starArg }

func (s *AggregateWindowedFunctionContext) GetSeparator() antlr.Token { return s.separator }


func (s *AggregateWindowedFunctionContext) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunctionContext) SetStarArg(v antlr.Token) { s.starArg = v }

func (s *AggregateWindowedFunctionContext) SetSeparator(v antlr.Token) { s.separator = v }


func (s *AggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *AggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG, 0)
}

func (s *AggregateWindowedFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX, 0)
}

func (s *AggregateWindowedFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN, 0)
}

func (s *AggregateWindowedFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUM, 0)
}

func (s *AggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *AggregateWindowedFunctionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AggregateWindowedFunctionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *AggregateWindowedFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *AggregateWindowedFunctionContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR, 0)
}

func (s *AggregateWindowedFunctionContext) STD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTD, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_POP, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_POP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIANCE, 0)
}

func (s *AggregateWindowedFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_CONCAT, 0)
}

func (s *AggregateWindowedFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *AggregateWindowedFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AggregateWindowedFunctionContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregateWindowedFunctionContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *AggregateWindowedFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEPARATOR, 0)
}

func (s *AggregateWindowedFunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction(s)
	}
}

func (s *AggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction(s)
	}
}

func (s *AggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AggregateWindowedFunction() (localctx IAggregateWindowedFunctionContext) {
	localctx = NewAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, MySqlParserRULE_aggregateWindowedFunction)
	var _la int

	p.SetState(7132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAVG, MySqlParserMAX, MySqlParserMIN, MySqlParserSUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7073)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 286)) & ^0x3f) == 0 && ((int64(1) << (_la - 286)) & 8400897) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7074)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7076)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1051, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7075)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(7078)
			p.FunctionArg()
		}
		{
			p.SetState(7079)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7081)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1052, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7080)
				p.OverClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserCOUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7083)
			p.Match(MySqlParserCOUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7084)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1054, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7085)

				var _m = p.Match(MySqlParserSTAR)

				localctx.(*AggregateWindowedFunctionContext).starArg = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case 2:
			p.SetState(7087)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1053, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7086)

					var _m = p.Match(MySqlParserALL)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _m
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			{
				p.SetState(7089)
				p.FunctionArg()
			}


		case 3:
			{
				p.SetState(7090)

				var _m = p.Match(MySqlParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7091)
				p.FunctionArgs()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7094)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7096)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1055, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7095)
				p.OverClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7098)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 287)) & ^0x3f) == 0 && ((int64(1) << (_la - 287)) & 62652423) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7099)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7101)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1056, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7100)

				var _m = p.Match(MySqlParserALL)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(7103)
			p.FunctionArg()
		}
		{
			p.SetState(7104)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7106)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1057, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7105)
				p.OverClause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case MySqlParserGROUP_CONCAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7108)
			p.Match(MySqlParserGROUP_CONCAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7109)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7111)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1058, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7110)

				var _m = p.Match(MySqlParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(7113)
			p.FunctionArgs()
		}
		p.SetState(7124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserORDER {
			{
				p.SetState(7114)
				p.Match(MySqlParserORDER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7115)
				p.Match(MySqlParserBY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7116)
				p.OrderByExpression()
			}
			p.SetState(7121)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == MySqlParserCOMMA {
				{
					p.SetState(7117)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7118)
					p.OrderByExpression()
				}


				p.SetState(7123)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(7128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserSEPARATOR {
			{
				p.SetState(7126)
				p.Match(MySqlParserSEPARATOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7127)

				var _m = p.Match(MySqlParserSTRING_LITERAL)

				localctx.(*AggregateWindowedFunctionContext).separator = _m
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(7130)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INonAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type INonAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	RR_BRACKET() antlr.TerminalNode
	OverClause() IOverClauseContext
	LAG() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	RANK() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode

	// IsNonAggregateWindowedFunctionContext differentiates from other interfaces.
	IsNonAggregateWindowedFunctionContext()
}

type NonAggregateWindowedFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonAggregateWindowedFunctionContext() *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction
	return p
}

func InitEmptyNonAggregateWindowedFunctionContext(p *NonAggregateWindowedFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction
}

func (*NonAggregateWindowedFunctionContext) IsNonAggregateWindowedFunctionContext() {}

func NewNonAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction

	return p
}

func (s *NonAggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *NonAggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NonAggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *NonAggregateWindowedFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAG, 0)
}

func (s *NonAggregateWindowedFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAD, 0)
}

func (s *NonAggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NonAggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NonAggregateWindowedFunctionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *NonAggregateWindowedFunctionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *NonAggregateWindowedFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCUME_DIST, 0)
}

func (s *NonAggregateWindowedFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDENSE_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERCENT_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_NUMBER, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTH_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTILE, 0)
}

func (s *NonAggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NonAggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNonAggregateWindowedFunction(s)
	}
}

func (s *NonAggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNonAggregateWindowedFunction(s)
	}
}

func (s *NonAggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNonAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) NonAggregateWindowedFunction() (localctx INonAggregateWindowedFunctionContext) {
	localctx = NewNonAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, MySqlParserRULE_nonAggregateWindowedFunction)
	var _la int

	p.SetState(7172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLAG, MySqlParserLEAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7134)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLAG || _la == MySqlParserLEAD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7135)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7136)
			p.expression(0)
		}
		p.SetState(7139)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1063, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7137)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7138)
				p.DecimalLiteral()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(7143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserCOMMA {
			{
				p.SetState(7141)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7142)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(7145)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7146)
			p.OverClause()
		}


	case MySqlParserFIRST_VALUE, MySqlParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7148)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST_VALUE || _la == MySqlParserLAST_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7149)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7150)
			p.expression(0)
		}
		{
			p.SetState(7151)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7152)
			p.OverClause()
		}


	case MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7154)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la - 291)) & ^0x3f) == 0 && ((int64(1) << (_la - 291)) & 14339) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7155)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7156)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7157)
			p.OverClause()
		}


	case MySqlParserNTH_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7158)
			p.Match(MySqlParserNTH_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7159)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7160)
			p.expression(0)
		}
		{
			p.SetState(7161)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7162)
			p.DecimalLiteral()
		}
		{
			p.SetState(7163)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7164)
			p.OverClause()
		}


	case MySqlParserNTILE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7166)
			p.Match(MySqlParserNTILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7167)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7168)
			p.DecimalLiteral()
		}
		{
			p.SetState(7169)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7170)
			p.OverClause()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOverClauseContext is an interface to support dynamic dispatch.
type IOverClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	RR_BRACKET() antlr.TerminalNode
	WindowName() IWindowNameContext

	// IsOverClauseContext differentiates from other interfaces.
	IsOverClauseContext()
}

type OverClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverClauseContext() *OverClauseContext {
	var p = new(OverClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_overClause
	return p
}

func InitEmptyOverClauseContext(p *OverClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_overClause
}

func (*OverClauseContext) IsOverClauseContext() {}

func NewOverClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverClauseContext {
	var p = new(OverClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_overClause

	return p
}

func (s *OverClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OverClauseContext) OVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOVER, 0)
}

func (s *OverClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *OverClauseContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *OverClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *OverClauseContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *OverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOverClause(s)
	}
}

func (s *OverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOverClause(s)
	}
}

func (s *OverClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOverClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) OverClause() (localctx IOverClauseContext) {
	localctx = NewOverClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, MySqlParserRULE_overClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7174)
		p.Match(MySqlParserOVER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(7180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLR_BRACKET:
		{
			p.SetState(7175)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7176)
			p.WindowSpec()
		}
		{
			p.SetState(7177)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		{
			p.SetState(7179)
			p.WindowName()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	PartitionClause() IPartitionClauseContext
	OrderByClause() IOrderByClauseContext
	FrameClause() IFrameClauseContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *WindowSpecContext) FrameClause() IFrameClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameClauseContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (s *WindowSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWindowSpec(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, MySqlParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7183)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1067, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7182)
			p.WindowName()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(7186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserPARTITION {
		{
			p.SetState(7185)
			p.PartitionClause()
		}

	}
	p.SetState(7189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserORDER {
		{
			p.SetState(7188)
			p.OrderByClause()
		}

	}
	p.SetState(7192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == MySqlParserRANGE || _la == MySqlParserROWS {
		{
			p.SetState(7191)
			p.FrameClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWindowNameContext is an interface to support dynamic dispatch.
type IWindowNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsWindowNameContext differentiates from other interfaces.
	IsWindowNameContext()
}

type WindowNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowNameContext() *WindowNameContext {
	var p = new(WindowNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowName
	return p
}

func InitEmptyWindowNameContext(p *WindowNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowName
}

func (*WindowNameContext) IsWindowNameContext() {}

func NewWindowNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowNameContext {
	var p = new(WindowNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowName

	return p
}

func (s *WindowNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowNameContext) Uid() IUidContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WindowNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WindowNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowName(s)
	}
}

func (s *WindowNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowName(s)
	}
}

func (s *WindowNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWindowName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) WindowName() (localctx IWindowNameContext) {
	localctx = NewWindowNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, MySqlParserRULE_windowName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7194)
		p.Uid()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrameClauseContext is an interface to support dynamic dispatch.
type IFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	FrameExtent() IFrameExtentContext

	// IsFrameClauseContext differentiates from other interfaces.
	IsFrameClauseContext()
}

type FrameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameClauseContext() *FrameClauseContext {
	var p = new(FrameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameClause
	return p
}

func InitEmptyFrameClauseContext(p *FrameClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameClause
}

func (*FrameClauseContext) IsFrameClauseContext() {}

func NewFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameClauseContext {
	var p = new(FrameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameClause

	return p
}

func (s *FrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameClauseContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *FrameClauseContext) FrameExtent() IFrameExtentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameExtentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameExtentContext)
}

func (s *FrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameClause(s)
	}
}

func (s *FrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameClause(s)
	}
}

func (s *FrameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FrameClause() (localctx IFrameClauseContext) {
	localctx = NewFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, MySqlParserRULE_frameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7196)
		p.FrameUnits()
	}
	{
		p.SetState(7197)
		p.FrameExtent()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameUnits
	return p
}

func InitEmptyFrameUnitsContext(p *FrameUnitsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameUnits
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameUnits(s)
	}
}

func (s *FrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameUnits(s)
	}
}

func (s *FrameUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameUnits(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FrameUnits() (localctx IFrameUnitsContext) {
	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, MySqlParserRULE_frameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7199)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserRANGE || _la == MySqlParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrameExtentContext is an interface to support dynamic dispatch.
type IFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameRange() IFrameRangeContext
	FrameBetween() IFrameBetweenContext

	// IsFrameExtentContext differentiates from other interfaces.
	IsFrameExtentContext()
}

type FrameExtentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameExtentContext() *FrameExtentContext {
	var p = new(FrameExtentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameExtent
	return p
}

func InitEmptyFrameExtentContext(p *FrameExtentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameExtent
}

func (*FrameExtentContext) IsFrameExtentContext() {}

func NewFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameExtentContext {
	var p = new(FrameExtentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameExtent

	return p
}

func (s *FrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameExtentContext) FrameRange() IFrameRangeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameExtentContext) FrameBetween() IFrameBetweenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBetweenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBetweenContext)
}

func (s *FrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameExtent(s)
	}
}

func (s *FrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameExtent(s)
	}
}

func (s *FrameExtentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameExtent(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FrameExtent() (localctx IFrameExtentContext) {
	localctx = NewFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, MySqlParserRULE_frameExtent)
	p.SetState(7203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1071, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7201)
			p.FrameRange()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7202)
			p.FrameBetween()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrameBetweenContext is an interface to support dynamic dispatch.
type IFrameBetweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AllFrameRange() []IFrameRangeContext
	FrameRange(i int) IFrameRangeContext
	AND() antlr.TerminalNode

	// IsFrameBetweenContext differentiates from other interfaces.
	IsFrameBetweenContext()
}

type FrameBetweenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBetweenContext() *FrameBetweenContext {
	var p = new(FrameBetweenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameBetween
	return p
}

func InitEmptyFrameBetweenContext(p *FrameBetweenContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameBetween
}

func (*FrameBetweenContext) IsFrameBetweenContext() {}

func NewFrameBetweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBetweenContext {
	var p = new(FrameBetweenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameBetween

	return p
}

func (s *FrameBetweenContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBETWEEN, 0)
}

func (s *FrameBetweenContext) AllFrameRange() []IFrameRangeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameRangeContext); ok {
			len++
		}
	}

	tst := make([]IFrameRangeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameRangeContext); ok {
			tst[i] = t.(IFrameRangeContext)
			i++
		}
	}

	return tst
}

func (s *FrameBetweenContext) FrameRange(i int) IFrameRangeContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *FrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBetweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameBetween(s)
	}
}

func (s *FrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameBetween(s)
	}
}

func (s *FrameBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameBetween(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FrameBetween() (localctx IFrameBetweenContext) {
	localctx = NewFrameBetweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, MySqlParserRULE_frameBetween)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7205)
		p.Match(MySqlParserBETWEEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(7206)
		p.FrameRange()
	}
	{
		p.SetState(7207)
		p.Match(MySqlParserAND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(7208)
		p.FrameRange()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrameRangeContext is an interface to support dynamic dispatch.
type IFrameRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameRangeContext differentiates from other interfaces.
	IsFrameRangeContext()
}

type FrameRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameRangeContext() *FrameRangeContext {
	var p = new(FrameRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameRange
	return p
}

func InitEmptyFrameRangeContext(p *FrameRangeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameRange
}

func (*FrameRangeContext) IsFrameRangeContext() {}

func NewFrameRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameRangeContext {
	var p = new(FrameRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameRange

	return p
}

func (s *FrameRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameRangeContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *FrameRangeContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *FrameRangeContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *FrameRangeContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDING, 0)
}

func (s *FrameRangeContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWING, 0)
}

func (s *FrameRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FrameRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameRange(s)
	}
}

func (s *FrameRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameRange(s)
	}
}

func (s *FrameRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameRange(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FrameRange() (localctx IFrameRangeContext) {
	localctx = NewFrameRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, MySqlParserRULE_frameRange)
	var _la int

	p.SetState(7217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1072, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7210)
			p.Match(MySqlParserCURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7211)
			p.Match(MySqlParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7212)
			p.Match(MySqlParserUNBOUNDED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7213)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWING || _la == MySqlParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7214)
			p.expression(0)
		}
		{
			p.SetState(7215)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWING || _la == MySqlParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (s *PartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, MySqlParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7219)
		p.Match(MySqlParserPARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(7220)
		p.Match(MySqlParserBY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(7221)
		p.expression(0)
	}
	p.SetState(7226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(7222)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7223)
			p.expression(0)
		}


		p.SetState(7228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IScalarFunctionNameContext is an interface to support dynamic dispatch.
type IScalarFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionNameBase() IFunctionNameBaseContext
	ASCII() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATE_SUB() antlr.TerminalNode
	IF() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	MID() antlr.TerminalNode
	NOW() antlr.TerminalNode
	REPEAT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYSDATE() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	UTC_DATE() antlr.TerminalNode
	UTC_TIME() antlr.TerminalNode
	UTC_TIMESTAMP() antlr.TerminalNode

	// IsScalarFunctionNameContext differentiates from other interfaces.
	IsScalarFunctionNameContext()
}

type ScalarFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarFunctionNameContext() *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scalarFunctionName
	return p
}

func InitEmptyScalarFunctionNameContext(p *ScalarFunctionNameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scalarFunctionName
}

func (*ScalarFunctionNameContext) IsScalarFunctionNameContext() {}

func NewScalarFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_scalarFunctionName

	return p
}

func (s *ScalarFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarFunctionNameContext) FunctionNameBase() IFunctionNameBaseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameBaseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *ScalarFunctionNameContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *ScalarFunctionNameContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURDATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURTIME, 0)
}

func (s *ScalarFunctionNameContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_ADD, 0)
}

func (s *ScalarFunctionNameContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_SUB, 0)
}

func (s *ScalarFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *ScalarFunctionNameContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *ScalarFunctionNameContext) NOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOW, 0)
}

func (s *ScalarFunctionNameContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEAT, 0)
}

func (s *ScalarFunctionNameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *ScalarFunctionNameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *ScalarFunctionNameContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *ScalarFunctionNameContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSDATE, 0)
}

func (s *ScalarFunctionNameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *ScalarFunctionNameContext) UTC_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_DATE, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIME, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ScalarFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitScalarFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ScalarFunctionName() (localctx IScalarFunctionNameContext) {
	localctx = NewScalarFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, MySqlParserRULE_scalarFunctionName)
	p.SetState(7253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDATABASE, MySqlParserLEFT, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserYEAR, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserPOSITION, MySqlParserINVISIBLE, MySqlParserVISIBLE, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7229)
			p.FunctionNameBase()
		}


	case MySqlParserASCII:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7230)
			p.Match(MySqlParserASCII)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCURDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7231)
			p.Match(MySqlParserCURDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7232)
			p.Match(MySqlParserCURRENT_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7233)
			p.Match(MySqlParserCURRENT_TIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7234)
			p.Match(MySqlParserCURRENT_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserCURTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7235)
			p.Match(MySqlParserCURTIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDATE_ADD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7236)
			p.Match(MySqlParserDATE_ADD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserDATE_SUB:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7237)
			p.Match(MySqlParserDATE_SUB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserIF:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7238)
			p.Match(MySqlParserIF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7239)
			p.Match(MySqlParserINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserLOCALTIME:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7240)
			p.Match(MySqlParserLOCALTIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7241)
			p.Match(MySqlParserLOCALTIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserMID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7242)
			p.Match(MySqlParserMID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserNOW:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7243)
			p.Match(MySqlParserNOW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPEAT:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7244)
			p.Match(MySqlParserREPEAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserREPLACE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7245)
			p.Match(MySqlParserREPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSUBSTR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7246)
			p.Match(MySqlParserSUBSTR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSUBSTRING:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7247)
			p.Match(MySqlParserSUBSTRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserSYSDATE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7248)
			p.Match(MySqlParserSYSDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserTRIM:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7249)
			p.Match(MySqlParserTRIM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserUTC_DATE:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(7250)
			p.Match(MySqlParserUTC_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserUTC_TIME:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(7251)
			p.Match(MySqlParserUTC_TIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserUTC_TIMESTAMP:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(7252)
			p.Match(MySqlParserUTC_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPasswordFunctionClauseContext is an interface to support dynamic dispatch.
type IPasswordFunctionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName token.
	GetFunctionName() antlr.Token 


	// SetFunctionName sets the functionName token.
	SetFunctionName(antlr.Token) 


	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode

	// IsPasswordFunctionClauseContext differentiates from other interfaces.
	IsPasswordFunctionClauseContext()
}

type PasswordFunctionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	functionName antlr.Token
}

func NewEmptyPasswordFunctionClauseContext() *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause
	return p
}

func InitEmptyPasswordFunctionClauseContext(p *PasswordFunctionClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause
}

func (*PasswordFunctionClauseContext) IsPasswordFunctionClauseContext() {}

func NewPasswordFunctionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause

	return p
}

func (s *PasswordFunctionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordFunctionClauseContext) GetFunctionName() antlr.Token { return s.functionName }


func (s *PasswordFunctionClauseContext) SetFunctionName(v antlr.Token) { s.functionName = v }


func (s *PasswordFunctionClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *PasswordFunctionClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PasswordFunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordFunctionClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PasswordFunctionClause() (localctx IPasswordFunctionClauseContext) {
	localctx = NewPasswordFunctionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, MySqlParserRULE_passwordFunctionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7255)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PasswordFunctionClauseContext).functionName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserOLD_PASSWORD || _la == MySqlParserPASSWORD) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PasswordFunctionClauseContext).functionName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7256)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(7257)
		p.FunctionArg()
	}
	{
		p.SetState(7258)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArgs
	return p
}

func InitEmptyFunctionArgsContext(p *FunctionArgsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArgs
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgsContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgsContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FunctionArgsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionArgs(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FunctionArgs() (localctx IFunctionArgsContext) {
	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, MySqlParserRULE_functionArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1075, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7260)
			p.Constant()
		}


	case 2:
		{
			p.SetState(7261)
			p.FullColumnName()
		}


	case 3:
		{
			p.SetState(7262)
			p.FunctionCall()
		}


	case 4:
		{
			p.SetState(7263)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(7275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == MySqlParserCOMMA {
		{
			p.SetState(7266)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1076, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7267)
				p.Constant()
			}


		case 2:
			{
				p.SetState(7268)
				p.FullColumnName()
			}


		case 3:
			{
				p.SetState(7269)
				p.FunctionCall()
			}


		case 4:
			{
				p.SetState(7270)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}


		p.SetState(7277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionArgContext is an interface to support dynamic dispatch.
type IFunctionArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	FullColumnName() IFullColumnNameContext
	FunctionCall() IFunctionCallContext
	Expression() IExpressionContext

	// IsFunctionArgContext differentiates from other interfaces.
	IsFunctionArgContext()
}

type FunctionArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgContext() *FunctionArgContext {
	var p = new(FunctionArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArg
	return p
}

func InitEmptyFunctionArgContext(p *FunctionArgContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArg
}

func (*FunctionArgContext) IsFunctionArgContext() {}

func NewFunctionArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgContext {
	var p = new(FunctionArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArg

	return p
}

func (s *FunctionArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArg(s)
	}
}

func (s *FunctionArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArg(s)
	}
}

func (s *FunctionArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionArg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FunctionArg() (localctx IFunctionArgContext) {
	localctx = NewFunctionArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, MySqlParserRULE_functionArg)
	p.SetState(7282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1078, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7278)
			p.Constant()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7279)
			p.FullColumnName()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7280)
			p.FunctionCall()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7281)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type IsExpressionContext struct {
	ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}


func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }


func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}


func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsExpression(s)
	}
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsExpression(s)
	}
}

func (s *IsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type NotExpressionContext struct {
	ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}


func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }


func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}


func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type LogicalExpressionContext struct {
	ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}


func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type PredicateExpressionContext struct {
	ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}


func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPredicateExpression(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MySqlParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 696
	p.EnterRecursionRule(localctx, 696, MySqlParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1080, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7285)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNOT || _la == MySqlParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7286)
			p.expression(4)
		}


	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7287)
			p.predicate(0)
		}
		{
			p.SetState(7288)
			p.Match(MySqlParserIS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(7290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == MySqlParserNOT {
			{
				p.SetState(7289)
				p.Match(MySqlParserNOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(7292)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE || _la == MySqlParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7294)
			p.predicate(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1081, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expression)
			p.SetState(7297)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			{
				p.SetState(7298)
				p.LogicalOperator()
			}
			{
				p.SetState(7299)
				p.expression(4)
			}


		}
		p.SetState(7305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1081, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyAll(ctx *PredicateContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type SoundsLikePredicateContext struct {
	PredicateContext
}

func NewSoundsLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoundsLikePredicateContext {
	var p = new(SoundsLikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *SoundsLikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoundsLikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *SoundsLikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SoundsLikePredicateContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *SoundsLikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}


func (s *SoundsLikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSoundsLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type ExpressionAtomPredicateContext struct {
	PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}


func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionAtomPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type SubqueryComparisonPredicateContext struct {
	PredicateContext
	quantifier antlr.Token
}

func NewSubqueryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryComparisonPredicateContext {
	var p = new(SubqueryComparisonPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}


func (s *SubqueryComparisonPredicateContext) GetQuantifier() antlr.Token { return s.quantifier }


func (s *SubqueryComparisonPredicateContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *SubqueryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryComparisonPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SubqueryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *SubqueryComparisonPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryComparisonPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SubqueryComparisonPredicateContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *SubqueryComparisonPredicateContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}


func (s *SubqueryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryComparisonPredicate(s)
	}
}

func (s *SubqueryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryComparisonPredicate(s)
	}
}

func (s *SubqueryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type JsonMemberOfPredicateContext struct {
	PredicateContext
}

func NewJsonMemberOfPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonMemberOfPredicateContext {
	var p = new(JsonMemberOfPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *JsonMemberOfPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonMemberOfPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *JsonMemberOfPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *JsonMemberOfPredicateContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *JsonMemberOfPredicateContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *JsonMemberOfPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *JsonMemberOfPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonMemberOfPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type BinaryComparisonPredicateContext struct {
	PredicateContext
	left IPredicateContext 
	right IPredicateContext 
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}


func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }


func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}


func (s *BinaryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type InPredicateContext struct {
	PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext {
	var p = new(InPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *InPredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InPredicateContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *InPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}


func (s *InPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInPredicate(s)
	}
}

func (s *InPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInPredicate(s)
	}
}

func (s *InPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type BetweenPredicateContext struct {
	PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext {
	var p = new(BetweenPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBETWEEN, 0)
}

func (s *BetweenPredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}


func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBetweenPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type IsNullPredicateContext struct {
	PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext {
	var p = new(IsNullPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}


func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type LikePredicateContext struct {
	PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext {
	var p = new(LikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *LikePredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *LikePredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *LikePredicateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}


func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

func (s *LikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}


type RegexpPredicateContext struct {
	PredicateContext
	regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext {
	var p = new(RegexpPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}


func (s *RegexpPredicateContext) GetRegex() antlr.Token { return s.regex }


func (s *RegexpPredicateContext) SetRegex(v antlr.Token) { s.regex = v }

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserREGEXP, 0)
}

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRLIKE, 0)
}

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}


func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRegexpPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *MySqlParser) predicate(_p int) (localctx IPredicateContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 698
	p.EnterRecursionRule(localctx, 698, MySqlParserRULE_predicate, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(7307)
		p.expressionAtom(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1089, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7371)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1088, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx


				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7309)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(7310)
					p.ComparisonOperator()
				}
				{
					p.SetState(7311)

					var _x = p.predicate(9)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}


			case 2:
				localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7313)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				p.SetState(7315)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserNOT {
					{
						p.SetState(7314)
						p.Match(MySqlParserNOT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(7317)
					p.Match(MySqlParserBETWEEN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7318)
					p.predicate(0)
				}
				{
					p.SetState(7319)
					p.Match(MySqlParserAND)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7320)
					p.predicate(7)
				}


			case 3:
				localctx = NewSoundsLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7322)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(7323)
					p.Match(MySqlParserSOUNDS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7324)
					p.Match(MySqlParserLIKE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7325)
					p.predicate(6)
				}


			case 4:
				localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7326)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				p.SetState(7328)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserNOT {
					{
						p.SetState(7327)
						p.Match(MySqlParserNOT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(7330)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexpPredicateContext).regex = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserREGEXP || _la == MySqlParserRLIKE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexpPredicateContext).regex = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7331)
					p.predicate(4)
				}


			case 5:
				localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7332)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				p.SetState(7334)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserNOT {
					{
						p.SetState(7333)
						p.Match(MySqlParserNOT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(7336)
					p.Match(MySqlParserIN)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7337)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(7340)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1085, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(7338)
						p.SelectStatement()
					}


				case 2:
					{
						p.SetState(7339)
						p.Expressions()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(7342)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 6:
				localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7344)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(7345)
					p.Match(MySqlParserIS)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7346)
					p.NullNotnull()
				}


			case 7:
				localctx = NewSubqueryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7347)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(7348)
					p.ComparisonOperator()
				}
				{
					p.SetState(7349)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SubqueryComparisonPredicateContext).quantifier = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserANY || _la == MySqlParserSOME) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SubqueryComparisonPredicateContext).quantifier = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7350)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7351)
					p.SelectStatement()
				}
				{
					p.SetState(7352)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			case 8:
				localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7354)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(7356)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == MySqlParserNOT {
					{
						p.SetState(7355)
						p.Match(MySqlParserNOT)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(7358)
					p.Match(MySqlParserLIKE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7359)
					p.predicate(0)
				}
				p.SetState(7362)
				p.GetErrorHandler().Sync(p)


				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1087, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(7360)
						p.Match(MySqlParserESCAPE)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(7361)
						p.Match(MySqlParserSTRING_LITERAL)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

					} else if p.HasError() { // JIM
						goto errorExit
				}


			case 9:
				localctx = NewJsonMemberOfPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7364)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(7365)
					p.Match(MySqlParserMEMBER)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7366)
					p.Match(MySqlParserOF)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7367)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7368)
					p.predicate(0)
				}
				{
					p.SetState(7369)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(7375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1089, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
	return p
}

func InitEmptyExpressionAtomContext(p *ExpressionAtomContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyAll(ctx *ExpressionAtomContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type UnaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}


func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type CollateExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewCollateExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateExpressionAtomContext {
	var p = new(CollateExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *CollateExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *CollateExpressionAtomContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CollateExpressionAtomContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}


func (s *CollateExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollateExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type VariableAssignExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewVariableAssignExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableAssignExpressionAtomContext {
	var p = new(VariableAssignExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *VariableAssignExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableAssignExpressionAtomContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *VariableAssignExpressionAtomContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *VariableAssignExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}


func (s *VariableAssignExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVariableAssignExpressionAtom(s)
	}
}

func (s *VariableAssignExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVariableAssignExpressionAtom(s)
	}
}

func (s *VariableAssignExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitVariableAssignExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type MysqlVariableExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewMysqlVariableExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlVariableExpressionAtomContext {
	var p = new(MysqlVariableExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MysqlVariableExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableExpressionAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}


func (s *MysqlVariableExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMysqlVariableExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type NestedExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type NestedRowExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedRowExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedRowExpressionAtomContext {
	var p = new(NestedRowExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedRowExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedRowExpressionAtomContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *NestedRowExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedRowExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedRowExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedRowExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}


func (s *NestedRowExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedRowExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type MathExpressionAtomContext struct {
	ExpressionAtomContext
	left IExpressionAtomContext 
	right IExpressionAtomContext 
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext {
	var p = new(MathExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}


func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }


func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathExpressionAtomContext) MultOperator() IMultOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultOperatorContext)
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *MathExpressionAtomContext) AddOperator() IAddOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddOperatorContext)
}


func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMathExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type ExistsExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewExistsExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsExpressionAtomContext {
	var p = new(ExistsExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ExistsExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsExpressionAtomContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *ExistsExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExistsExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ExistsExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *ExistsExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExistsExpressionAtom(s)
	}
}

func (s *ExistsExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExistsExpressionAtom(s)
	}
}

func (s *ExistsExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExistsExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type IntervalExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewIntervalExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExpressionAtomContext {
	var p = new(IntervalExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *IntervalExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionAtomContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *IntervalExpressionAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionAtomContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}


func (s *IntervalExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type JsonExpressionAtomContext struct {
	ExpressionAtomContext
	left IExpressionAtomContext 
	right IExpressionAtomContext 
}

func NewJsonExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExpressionAtomContext {
	var p = new(JsonExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}


func (s *JsonExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *JsonExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }


func (s *JsonExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *JsonExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *JsonExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExpressionAtomContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *JsonExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *JsonExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}


func (s *JsonExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type SubqueryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewSubqueryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionAtomContext {
	var p = new(SubqueryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *SubqueryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}


func (s *SubqueryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryExpressionAtom(s)
	}
}

func (s *SubqueryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryExpressionAtom(s)
	}
}

func (s *SubqueryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type ConstantExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}


func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstantExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type FunctionCallExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewFunctionCallExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionAtomContext {
	var p = new(FunctionCallExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FunctionCallExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionAtomContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}


func (s *FunctionCallExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionCallExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type BinaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewBinaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExpressionAtomContext {
	var p = new(BinaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BinaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionAtomContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *BinaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}


func (s *BinaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type FullColumnNameExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}


func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnNameExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}


type BitExpressionAtomContext struct {
	ExpressionAtomContext
	left IExpressionAtomContext 
	right IExpressionAtomContext 
}

func NewBitExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionAtomContext {
	var p = new(BitExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}


func (s *BitExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *BitExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }


func (s *BitExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *BitExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *BitExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionAtomContext) BitOperator() IBitOperatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitOperatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitOperatorContext)
}

func (s *BitExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}


func (s *BitExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBitExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *MySqlParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	return p.expressionAtom(0)
}

func (p *MySqlParser) expressionAtom(_p int) (localctx IExpressionAtomContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionAtomContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 700
	p.EnterRecursionRule(localctx, 700, MySqlParserRULE_expressionAtom, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1092, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7377)
			p.Constant()
		}


	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7378)
			p.FullColumnName()
		}


	case 3:
		localctx = NewFunctionCallExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7379)
			p.FunctionCall()
		}


	case 4:
		localctx = NewMysqlVariableExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7380)
			p.MysqlVariable()
		}


	case 5:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7381)
			p.UnaryOperator()
		}
		{
			p.SetState(7382)
			p.expressionAtom(12)
		}


	case 6:
		localctx = NewBinaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7384)
			p.Match(MySqlParserBINARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7385)
			p.expressionAtom(11)
		}


	case 7:
		localctx = NewVariableAssignExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7386)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7387)
			p.Match(MySqlParserVAR_ASSIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7388)
			p.expressionAtom(10)
		}


	case 8:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7389)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7390)
			p.expression(0)
		}
		p.SetState(7395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == MySqlParserCOMMA {
			{
				p.SetState(7391)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7392)
				p.expression(0)
			}


			p.SetState(7397)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7398)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		localctx = NewNestedRowExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7400)
			p.Match(MySqlParserROW)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7401)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7402)
			p.expression(0)
		}
		p.SetState(7405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == MySqlParserCOMMA {
			{
				p.SetState(7403)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(7404)
				p.expression(0)
			}


			p.SetState(7407)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7409)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		localctx = NewExistsExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7411)
			p.Match(MySqlParserEXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7412)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7413)
			p.SelectStatement()
		}
		{
			p.SetState(7414)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		localctx = NewSubqueryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7416)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7417)
			p.SelectStatement()
		}
		{
			p.SetState(7418)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		localctx = NewIntervalExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7420)
			p.Match(MySqlParserINTERVAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7421)
			p.expression(0)
		}
		{
			p.SetState(7422)
			p.IntervalType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1094, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7445)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1093, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*BitExpressionAtomContext).left = _prevctx


				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7426)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(7427)
					p.BitOperator()
				}
				{
					p.SetState(7428)

					var _x = p.expressionAtom(5)

					localctx.(*BitExpressionAtomContext).right = _x
				}


			case 2:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx


				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7430)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(7431)
					p.MultOperator()
				}
				{
					p.SetState(7432)

					var _x = p.expressionAtom(4)

					localctx.(*MathExpressionAtomContext).right = _x
				}


			case 3:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx


				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7434)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(7435)
					p.AddOperator()
				}
				{
					p.SetState(7436)

					var _x = p.expressionAtom(3)

					localctx.(*MathExpressionAtomContext).right = _x
				}


			case 4:
				localctx = NewJsonExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*JsonExpressionAtomContext).left = _prevctx


				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7438)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(7439)
					p.JsonOperator()
				}
				{
					p.SetState(7440)

					var _x = p.expressionAtom(2)

					localctx.(*JsonExpressionAtomContext).right = _x
				}


			case 5:
				localctx = NewCollateExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7442)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(7443)
					p.Match(MySqlParserCOLLATE)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(7444)
					p.CollationName()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(7449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1094, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLAMATION_SYMBOL() antlr.TerminalNode
	BIT_NOT_OP() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
	return p
}

func InitEmptyUnaryOperatorContext(p *UnaryOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, MySqlParserRULE_unaryOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7450)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNOT || ((int64((_la - 1120)) & ^0x3f) == 0 && ((int64(1) << (_la - 1120)) & 387) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	EXCLAMATION_SYMBOL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, MySqlParserRULE_comparisonOperator)
	p.SetState(7466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1095, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7452)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7453)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7454)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7455)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7456)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7457)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7458)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7459)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7460)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7461)
			p.Match(MySqlParserEXCLAMATION_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7462)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7463)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7464)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7465)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AND() antlr.TerminalNode
	AllBIT_AND_OP() []antlr.TerminalNode
	BIT_AND_OP(i int) antlr.TerminalNode
	XOR() antlr.TerminalNode
	OR() antlr.TerminalNode
	AllBIT_OR_OP() []antlr.TerminalNode
	BIT_OR_OP(i int) antlr.TerminalNode

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
	return p
}

func InitEmptyLogicalOperatorContext(p *LogicalOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserXOR, 0)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, MySqlParserRULE_logicalOperator)
	p.SetState(7475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7468)
			p.Match(MySqlParserAND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7469)
			p.Match(MySqlParserBIT_AND_OP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7470)
			p.Match(MySqlParserBIT_AND_OP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserXOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7471)
			p.Match(MySqlParserXOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7472)
			p.Match(MySqlParserOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7473)
			p.Match(MySqlParserBIT_OR_OP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7474)
			p.Match(MySqlParserBIT_OR_OP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLESS_SYMBOL() []antlr.TerminalNode
	LESS_SYMBOL(i int) antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode
	BIT_AND_OP() antlr.TerminalNode
	BIT_XOR_OP() antlr.TerminalNode
	BIT_OR_OP() antlr.TerminalNode

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_bitOperator
	return p
}

func InitEmptyBitOperatorContext(p *BitOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_bitOperator
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (s *BitOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBitOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) BitOperator() (localctx IBitOperatorContext) {
	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, MySqlParserRULE_bitOperator)
	p.SetState(7484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7477)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7478)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7479)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7480)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7481)
			p.Match(MySqlParserBIT_AND_OP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7482)
			p.Match(MySqlParserBIT_XOR_OP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7483)
			p.Match(MySqlParserBIT_OR_OP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMultOperatorContext is an interface to support dynamic dispatch.
type IMultOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultOperatorContext differentiates from other interfaces.
	IsMultOperatorContext()
}

type MultOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultOperatorContext() *MultOperatorContext {
	var p = new(MultOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multOperator
	return p
}

func InitEmptyMultOperatorContext(p *MultOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multOperator
}

func (*MultOperatorContext) IsMultOperatorContext() {}

func NewMultOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultOperatorContext {
	var p = new(MultOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multOperator

	return p
}

func (s *MultOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *MultOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIVIDE, 0)
}

func (s *MultOperatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODULE, 0)
}

func (s *MultOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIV, 0)
}

func (s *MultOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMOD, 0)
}

func (s *MultOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MultOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultOperator(s)
	}
}

func (s *MultOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultOperator(s)
	}
}

func (s *MultOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMultOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) MultOperator() (localctx IMultOperatorContext) {
	localctx = NewMultOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, MySqlParserRULE_multOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7486)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 1117)) & ^0x3f) == 0 && ((int64(1) << (_la - 1117)) & 103) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAddOperatorContext is an interface to support dynamic dispatch.
type IAddOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsAddOperatorContext differentiates from other interfaces.
	IsAddOperatorContext()
}

type AddOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOperatorContext() *AddOperatorContext {
	var p = new(AddOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_addOperator
	return p
}

func InitEmptyAddOperatorContext(p *AddOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_addOperator
}

func (*AddOperatorContext) IsAddOperatorContext() {}

func NewAddOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOperatorContext {
	var p = new(AddOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_addOperator

	return p
}

func (s *AddOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AddOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *AddOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *AddOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AddOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAddOperator(s)
	}
}

func (s *AddOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAddOperator(s)
	}
}

func (s *AddOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAddOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) AddOperator() (localctx IAddOperatorContext) {
	localctx = NewAddOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, MySqlParserRULE_addOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7488)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserPLUS || _la == MySqlParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOperator
	return p
}

func InitEmptyJsonOperatorContext(p *JsonOperatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOperator
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *JsonOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *JsonOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (s *JsonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) JsonOperator() (localctx IJsonOperatorContext) {
	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, MySqlParserRULE_jsonOperator)
	p.SetState(7495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1098, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7490)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7491)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7492)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7493)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(7494)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICharsetNameBaseContext is an interface to support dynamic dispatch.
type ICharsetNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARMSCII8() antlr.TerminalNode
	ASCII() antlr.TerminalNode
	BIG5() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	CP1250() antlr.TerminalNode
	CP1251() antlr.TerminalNode
	CP1256() antlr.TerminalNode
	CP1257() antlr.TerminalNode
	CP850() antlr.TerminalNode
	CP852() antlr.TerminalNode
	CP866() antlr.TerminalNode
	CP932() antlr.TerminalNode
	DEC8() antlr.TerminalNode
	EUCJPMS() antlr.TerminalNode
	EUCKR() antlr.TerminalNode
	GB18030() antlr.TerminalNode
	GB2312() antlr.TerminalNode
	GBK() antlr.TerminalNode
	GEOSTD8() antlr.TerminalNode
	GREEK() antlr.TerminalNode
	HEBREW() antlr.TerminalNode
	HP8() antlr.TerminalNode
	KEYBCS2() antlr.TerminalNode
	KOI8R() antlr.TerminalNode
	KOI8U() antlr.TerminalNode
	LATIN1() antlr.TerminalNode
	LATIN2() antlr.TerminalNode
	LATIN5() antlr.TerminalNode
	LATIN7() antlr.TerminalNode
	MACCE() antlr.TerminalNode
	MACROMAN() antlr.TerminalNode
	SJIS() antlr.TerminalNode
	SWE7() antlr.TerminalNode
	TIS620() antlr.TerminalNode
	UCS2() antlr.TerminalNode
	UJIS() antlr.TerminalNode
	UTF16() antlr.TerminalNode
	UTF16LE() antlr.TerminalNode
	UTF32() antlr.TerminalNode
	UTF8() antlr.TerminalNode
	UTF8MB3() antlr.TerminalNode
	UTF8MB4() antlr.TerminalNode

	// IsCharsetNameBaseContext differentiates from other interfaces.
	IsCharsetNameBaseContext()
}

type CharsetNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameBaseContext() *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetNameBase
	return p
}

func InitEmptyCharsetNameBaseContext(p *CharsetNameBaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetNameBase
}

func (*CharsetNameBaseContext) IsCharsetNameBaseContext() {}

func NewCharsetNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetNameBase

	return p
}

func (s *CharsetNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameBaseContext) ARMSCII8() antlr.TerminalNode {
	return s.GetToken(MySqlParserARMSCII8, 0)
}

func (s *CharsetNameBaseContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *CharsetNameBaseContext) BIG5() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIG5, 0)
}

func (s *CharsetNameBaseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CharsetNameBaseContext) CP1250() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1250, 0)
}

func (s *CharsetNameBaseContext) CP1251() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1251, 0)
}

func (s *CharsetNameBaseContext) CP1256() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1256, 0)
}

func (s *CharsetNameBaseContext) CP1257() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1257, 0)
}

func (s *CharsetNameBaseContext) CP850() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP850, 0)
}

func (s *CharsetNameBaseContext) CP852() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP852, 0)
}

func (s *CharsetNameBaseContext) CP866() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP866, 0)
}

func (s *CharsetNameBaseContext) CP932() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP932, 0)
}

func (s *CharsetNameBaseContext) DEC8() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC8, 0)
}

func (s *CharsetNameBaseContext) EUCJPMS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCJPMS, 0)
}

func (s *CharsetNameBaseContext) EUCKR() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCKR, 0)
}

func (s *CharsetNameBaseContext) GB18030() antlr.TerminalNode {
	return s.GetToken(MySqlParserGB18030, 0)
}

func (s *CharsetNameBaseContext) GB2312() antlr.TerminalNode {
	return s.GetToken(MySqlParserGB2312, 0)
}

func (s *CharsetNameBaseContext) GBK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGBK, 0)
}

func (s *CharsetNameBaseContext) GEOSTD8() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOSTD8, 0)
}

func (s *CharsetNameBaseContext) GREEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREEK, 0)
}

func (s *CharsetNameBaseContext) HEBREW() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEBREW, 0)
}

func (s *CharsetNameBaseContext) HP8() antlr.TerminalNode {
	return s.GetToken(MySqlParserHP8, 0)
}

func (s *CharsetNameBaseContext) KEYBCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYBCS2, 0)
}

func (s *CharsetNameBaseContext) KOI8R() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8R, 0)
}

func (s *CharsetNameBaseContext) KOI8U() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8U, 0)
}

func (s *CharsetNameBaseContext) LATIN1() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN1, 0)
}

func (s *CharsetNameBaseContext) LATIN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN2, 0)
}

func (s *CharsetNameBaseContext) LATIN5() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN5, 0)
}

func (s *CharsetNameBaseContext) LATIN7() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN7, 0)
}

func (s *CharsetNameBaseContext) MACCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACCE, 0)
}

func (s *CharsetNameBaseContext) MACROMAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACROMAN, 0)
}

func (s *CharsetNameBaseContext) SJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSJIS, 0)
}

func (s *CharsetNameBaseContext) SWE7() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWE7, 0)
}

func (s *CharsetNameBaseContext) TIS620() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIS620, 0)
}

func (s *CharsetNameBaseContext) UCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCS2, 0)
}

func (s *CharsetNameBaseContext) UJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUJIS, 0)
}

func (s *CharsetNameBaseContext) UTF16() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16, 0)
}

func (s *CharsetNameBaseContext) UTF16LE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16LE, 0)
}

func (s *CharsetNameBaseContext) UTF32() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF32, 0)
}

func (s *CharsetNameBaseContext) UTF8() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8, 0)
}

func (s *CharsetNameBaseContext) UTF8MB3() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB3, 0)
}

func (s *CharsetNameBaseContext) UTF8MB4() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB4, 0)
}

func (s *CharsetNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CharsetNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharsetNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) CharsetNameBase() (localctx ICharsetNameBaseContext) {
	localctx = NewCharsetNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, MySqlParserRULE_charsetNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7497)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBINARY || ((int64((_la - 746)) & ^0x3f) == 0 && ((int64(1) << (_la - 746)) & 2199023255551) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITransactionLevelBaseContext is an interface to support dynamic dispatch.
type ITransactionLevelBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelBaseContext differentiates from other interfaces.
	IsTransactionLevelBaseContext()
}

type TransactionLevelBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelBaseContext() *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevelBase
	return p
}

func InitEmptyTransactionLevelBaseContext(p *TransactionLevelBaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevelBase
}

func (*TransactionLevelBaseContext) IsTransactionLevelBaseContext() {}

func NewTransactionLevelBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionLevelBase

	return p
}

func (s *TransactionLevelBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelBaseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEATABLE, 0)
}

func (s *TransactionLevelBaseContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIALIZABLE, 0)
}

func (s *TransactionLevelBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TransactionLevelBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionLevelBase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) TransactionLevelBase() (localctx ITransactionLevelBaseContext) {
	localctx = NewTransactionLevelBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, MySqlParserRULE_transactionLevelBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7499)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 799)) & ^0x3f) == 0 && ((int64(1) << (_la - 799)) & 15) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrivilegesBaseContext is an interface to support dynamic dispatch.
type IPrivilegesBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLES() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsPrivilegesBaseContext differentiates from other interfaces.
	IsPrivilegesBaseContext()
}

type PrivilegesBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesBaseContext() *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegesBase
	return p
}

func InitEmptyPrivilegesBaseContext(p *PrivilegesBaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegesBase
}

func (*PrivilegesBaseContext) IsPrivilegesBaseContext() {}

func NewPrivilegesBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilegesBase

	return p
}

func (s *PrivilegesBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesBaseContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *PrivilegesBaseContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUTINE, 0)
}

func (s *PrivilegesBaseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *PrivilegesBaseContext) FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE, 0)
}

func (s *PrivilegesBaseContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESS, 0)
}

func (s *PrivilegesBaseContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELOAD, 0)
}

func (s *PrivilegesBaseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *PrivilegesBaseContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUPER, 0)
}

func (s *PrivilegesBaseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *PrivilegesBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrivilegesBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrivilegesBase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) PrivilegesBase() (localctx IPrivilegesBaseContext) {
	localctx = NewPrivilegesBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, MySqlParserRULE_privilegesBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7501)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 708)) & ^0x3f) == 0 && ((int64(1) << (_la - 708)) & 23656792067) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalTypeBaseContext is an interface to support dynamic dispatch.
type IIntervalTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeBaseContext differentiates from other interfaces.
	IsIntervalTypeBaseContext()
}

type IntervalTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeBaseContext() *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalTypeBase
	return p
}

func InitEmptyIntervalTypeBaseContext(p *IntervalTypeBaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalTypeBase
}

func (*IntervalTypeBaseContext) IsIntervalTypeBaseContext() {}

func NewIntervalTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalTypeBase

	return p
}

func (s *IntervalTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *IntervalTypeBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *IntervalTypeBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *IntervalTypeBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *IntervalTypeBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *IntervalTypeBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *IntervalTypeBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *IntervalTypeBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *IntervalTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) IntervalTypeBase() (localctx IIntervalTypeBaseContext) {
	localctx = NewIntervalTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, MySqlParserRULE_intervalTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7503)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 689)) & ^0x3f) == 0 && ((int64(1) << (_la - 689)) & 255) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDataTypeBaseContext is an interface to support dynamic dispatch.
type IDataTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	TEXT() antlr.TerminalNode

	// IsDataTypeBaseContext differentiates from other interfaces.
	IsDataTypeBaseContext()
}

type DataTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeBaseContext() *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataTypeBase
	return p
}

func InitEmptyDataTypeBaseContext(p *DataTypeBaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataTypeBase
}

func (*DataTypeBaseContext) IsDataTypeBaseContext() {}

func NewDataTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataTypeBase

	return p
}

func (s *DataTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *DataTypeBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DataTypeBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DataTypeBaseContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DataTypeBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *DataTypeBaseContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *DataTypeBaseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *DataTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DataTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDataTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) DataTypeBase() (localctx IDataTypeBaseContext) {
	localctx = NewDataTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, MySqlParserRULE_dataTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7505)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & 1179679) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeywordsCanBeIdContext is an interface to support dynamic dispatch.
type IKeywordsCanBeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALGORITHM() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	AUDIT_ABORT_EXEMPT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode
	AVG() antlr.TerminalNode
	AVG_ROW_LENGTH() antlr.TerminalNode
	ATTRIBUTE() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	BIT() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHANGED() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	CHECKSUM() antlr.TerminalNode
	PAGE_CHECKSUM() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CLOSE() antlr.TerminalNode
	CLUSTERING() antlr.TerminalNode
	COALESCE() antlr.TerminalNode
	CODE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COLUMN_FORMAT() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETION() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	COMPRESSION() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CPU() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFAULT_AUTH() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELAY_KEY_WRITE() antlr.TerminalNode
	DES_KEY_FILE() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DO() antlr.TerminalNode
	DUMPFILE() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTION() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EUR() antlr.TerminalNode
	EVEN() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_EXEMPT() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FIXED() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWS() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERAL() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORED() antlr.TerminalNode
	IGNORE_SERVER_IDS() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INPLACE() antlr.TerminalNode
	INSERT_METHOD() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	INSTANT() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IO() antlr.TerminalNode
	IO_THREAD() antlr.TerminalNode
	IPC() antlr.TerminalNode
	ISO() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	JIS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY_BLOCK_SIZE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_PORT() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	MEMBER() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MID() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MUTEX() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	NESTED() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOCOPY() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NOWAIT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	ODBC() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OF() antlr.TerminalNode
	OJ() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZER_COSTS() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PACK_KEYS() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	PARTITIONING() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	PHASE() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PLUGIN_DIR() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PORT() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	PREV() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	REBUILD() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	REDUNDANT() antlr.TerminalNode
	RELAY() antlr.TerminalNode
	RELAYLOG() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REORGANIZE() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPLICATE_DO_DB() antlr.TerminalNode
	REPLICATE_DO_TABLE() antlr.TerminalNode
	REPLICATE_IGNORE_DB() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE() antlr.TerminalNode
	REPLICATE_REWRITE_DB() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	RTREE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	SERIAL() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	SHARED() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SLOW() antlr.TerminalNode
	SKIP_QUERY_REWRITE() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SOUNDS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SQL_AFTER_GTIDS() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS() antlr.TerminalNode
	SQL_BEFORE_GTIDS() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS_AUTO_RECALC() antlr.TerminalNode
	STATS_PERSISTENT() antlr.TerminalNode
	STATS_SAMPLE_PAGES() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	SUM() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SWAPS() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TABLE_TYPE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TP_CONNECTION_ADMIN() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRANSACTIONAL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	USA() antlr.TerminalNode
	USER() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	USER_RESOURCES() antlr.TerminalNode
	VALIDATION() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	X509() antlr.TerminalNode
	XA() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	XML() antlr.TerminalNode

	// IsKeywordsCanBeIdContext differentiates from other interfaces.
	IsKeywordsCanBeIdContext()
}

type KeywordsCanBeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsCanBeIdContext() *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId
	return p
}

func InitEmptyKeywordsCanBeIdContext(p *KeywordsCanBeIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId
}

func (*KeywordsCanBeIdContext) IsKeywordsCanBeIdContext() {}

func NewKeywordsCanBeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId

	return p
}

func (s *KeywordsCanBeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsCanBeIdContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserACCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserACTION, 0)
}

func (s *KeywordsCanBeIdContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *KeywordsCanBeIdContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *KeywordsCanBeIdContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *KeywordsCanBeIdContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *KeywordsCanBeIdContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserARRAY, 0)
}

func (s *KeywordsCanBeIdContext) AT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ABORT_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ABORT_EXEMPT, 0)
}

func (s *KeywordsCanBeIdContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHORS, 0)
}

func (s *KeywordsCanBeIdContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHENTICATION_POLICY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG, 0)
}

func (s *KeywordsCanBeIdContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG_ROW_LENGTH, 0)
}

func (s *KeywordsCanBeIdContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBACKUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *KeywordsCanBeIdContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND, 0)
}

func (s *KeywordsCanBeIdContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR, 0)
}

func (s *KeywordsCanBeIdContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR, 0)
}

func (s *KeywordsCanBeIdContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOCK, 0)
}

func (s *KeywordsCanBeIdContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *KeywordsCanBeIdContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *KeywordsCanBeIdContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBTREE, 0)
}

func (s *KeywordsCanBeIdContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUCKETS, 0)
}

func (s *KeywordsCanBeIdContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *KeywordsCanBeIdContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *KeywordsCanBeIdContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *KeywordsCanBeIdContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGED, 0)
}

func (s *KeywordsCanBeIdContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *KeywordsCanBeIdContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_CHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCIPHER, 0)
}

func (s *KeywordsCanBeIdContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLIENT, 0)
}

func (s *KeywordsCanBeIdContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLONE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *KeywordsCanBeIdContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLUSTERING, 0)
}

func (s *KeywordsCanBeIdContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOALESCE, 0)
}

func (s *KeywordsCanBeIdContext) CODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCODE, 0)
}

func (s *KeywordsCanBeIdContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *KeywordsCanBeIdContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *KeywordsCanBeIdContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPACT, 0)
}

func (s *KeywordsCanBeIdContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSED, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSION, 0)
}

func (s *KeywordsCanBeIdContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *KeywordsCanBeIdContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTAINS, 0)
}

func (s *KeywordsCanBeIdContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTEXT, 0)
}

func (s *KeywordsCanBeIdContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTRIBUTORS, 0)
}

func (s *KeywordsCanBeIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, 0)
}

func (s *KeywordsCanBeIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) CPU() antlr.TerminalNode {
	return s.GetToken(MySqlParserCPU, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *KeywordsCanBeIdContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *KeywordsCanBeIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *KeywordsCanBeIdContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *KeywordsCanBeIdContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEALLOCATE, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT_AUTH, 0)
}

func (s *KeywordsCanBeIdContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *KeywordsCanBeIdContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAY_KEY_WRITE, 0)
}

func (s *KeywordsCanBeIdContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_KEY_FILE, 0)
}

func (s *KeywordsCanBeIdContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIAGNOSTICS, 0)
}

func (s *KeywordsCanBeIdContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *KeywordsCanBeIdContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *KeywordsCanBeIdContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *KeywordsCanBeIdContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *KeywordsCanBeIdContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *KeywordsCanBeIdContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *KeywordsCanBeIdContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUPLICATE, 0)
}

func (s *KeywordsCanBeIdContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *KeywordsCanBeIdContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEMPTY, 0)
}

func (s *KeywordsCanBeIdContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *KeywordsCanBeIdContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDS, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINES, 0)
}

func (s *KeywordsCanBeIdContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *KeywordsCanBeIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *KeywordsCanBeIdContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *KeywordsCanBeIdContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *KeywordsCanBeIdContext) EUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUR, 0)
}

func (s *KeywordsCanBeIdContext) EVEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVEN, 0)
}

func (s *KeywordsCanBeIdContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *KeywordsCanBeIdContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *KeywordsCanBeIdContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVERY, 0)
}

func (s *KeywordsCanBeIdContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCEPT, 0)
}

func (s *KeywordsCanBeIdContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCHANGE, 0)
}

func (s *KeywordsCanBeIdContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, 0)
}

func (s *KeywordsCanBeIdContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPIRE, 0)
}

func (s *KeywordsCanBeIdContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT, 0)
}

func (s *KeywordsCanBeIdContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *KeywordsCanBeIdContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENT_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *KeywordsCanBeIdContext) FAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAST, 0)
}

func (s *KeywordsCanBeIdContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAULTS, 0)
}

func (s *KeywordsCanBeIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *KeywordsCanBeIdContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILTER, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_EXEMPT, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_USER, 0)
}

func (s *KeywordsCanBeIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *KeywordsCanBeIdContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *KeywordsCanBeIdContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH, 0)
}

func (s *KeywordsCanBeIdContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWS, 0)
}

func (s *KeywordsCanBeIdContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND, 0)
}

func (s *KeywordsCanBeIdContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *KeywordsCanBeIdContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *KeywordsCanBeIdContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERAL, 0)
}

func (s *KeywordsCanBeIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *KeywordsCanBeIdContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANTS, 0)
}

func (s *KeywordsCanBeIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_CONCAT, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *KeywordsCanBeIdContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *KeywordsCanBeIdContext) HELP() antlr.TerminalNode {
	return s.GetToken(MySqlParserHELP, 0)
}

func (s *KeywordsCanBeIdContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTORY, 0)
}

func (s *KeywordsCanBeIdContext) HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST, 0)
}

func (s *KeywordsCanBeIdContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *KeywordsCanBeIdContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE_SERVER_IDS, 0)
}

func (s *KeywordsCanBeIdContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *KeywordsCanBeIdContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEXES, 0)
}

func (s *KeywordsCanBeIdContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *KeywordsCanBeIdContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, 0)
}

func (s *KeywordsCanBeIdContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT_METHOD, 0)
}

func (s *KeywordsCanBeIdContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANCE, 0)
}

func (s *KeywordsCanBeIdContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANT, 0)
}

func (s *KeywordsCanBeIdContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERNAL, 0)
}

func (s *KeywordsCanBeIdContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKE, 0)
}

func (s *KeywordsCanBeIdContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *KeywordsCanBeIdContext) IO() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO, 0)
}

func (s *KeywordsCanBeIdContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) IPC() antlr.TerminalNode {
	return s.GetToken(MySqlParserIPC, 0)
}

func (s *KeywordsCanBeIdContext) ISO() antlr.TerminalNode {
	return s.GetToken(MySqlParserISO, 0)
}

func (s *KeywordsCanBeIdContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserISOLATION, 0)
}

func (s *KeywordsCanBeIdContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSUER, 0)
}

func (s *KeywordsCanBeIdContext) JIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJIS, 0)
}

func (s *KeywordsCanBeIdContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *KeywordsCanBeIdContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAMBDA, 0)
}

func (s *KeywordsCanBeIdContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLANGUAGE, 0)
}

func (s *KeywordsCanBeIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *KeywordsCanBeIdContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *KeywordsCanBeIdContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVES, 0)
}

func (s *KeywordsCanBeIdContext) LESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS, 0)
}

func (s *KeywordsCanBeIdContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *KeywordsCanBeIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIST, 0)
}

func (s *KeywordsCanBeIdContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *KeywordsCanBeIdContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *KeywordsCanBeIdContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_AUTO_POSITION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_CONNECT_RETRY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_DELAY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HOST, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PORT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_RETRY_COUNT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CA, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CAPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CERT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CIPHER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRLPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_KEY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_TLS_VERSION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_USER, 0)
}

func (s *KeywordsCanBeIdContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX, 0)
}

func (s *KeywordsCanBeIdContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_USER_CONNECTIONS, 0)
}

func (s *KeywordsCanBeIdContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUM, 0)
}

func (s *KeywordsCanBeIdContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *KeywordsCanBeIdContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *KeywordsCanBeIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *KeywordsCanBeIdContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *KeywordsCanBeIdContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *KeywordsCanBeIdContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIGRATE, 0)
}

func (s *KeywordsCanBeIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN, 0)
}

func (s *KeywordsCanBeIdContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *KeywordsCanBeIdContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFY, 0)
}

func (s *KeywordsCanBeIdContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMUTEX, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *KeywordsCanBeIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME, 0)
}

func (s *KeywordsCanBeIdContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAMES, 0)
}

func (s *KeywordsCanBeIdContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *KeywordsCanBeIdContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB_STORED_USER, 0)
}

func (s *KeywordsCanBeIdContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserNESTED, 0)
}

func (s *KeywordsCanBeIdContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEVER, 0)
}

func (s *KeywordsCanBeIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *KeywordsCanBeIdContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *KeywordsCanBeIdContext) NOCOPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOCOPY, 0)
}

func (s *KeywordsCanBeIdContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *KeywordsCanBeIdContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *KeywordsCanBeIdContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOWAIT, 0)
}

func (s *KeywordsCanBeIdContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMBER, 0)
}

func (s *KeywordsCanBeIdContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MySqlParserODBC, 0)
}

func (s *KeywordsCanBeIdContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *KeywordsCanBeIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *KeywordsCanBeIdContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *KeywordsCanBeIdContext) OJ() antlr.TerminalNode {
	return s.GetToken(MySqlParserOJ, 0)
}

func (s *KeywordsCanBeIdContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) ONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE, 0)
}

func (s *KeywordsCanBeIdContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *KeywordsCanBeIdContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *KeywordsCanBeIdContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *KeywordsCanBeIdContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZER_COSTS, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *KeywordsCanBeIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *KeywordsCanBeIdContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDINALITY, 0)
}

func (s *KeywordsCanBeIdContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOWNER, 0)
}

func (s *KeywordsCanBeIdContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPACK_KEYS, 0)
}

func (s *KeywordsCanBeIdContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE, 0)
}

func (s *KeywordsCanBeIdContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARSER, 0)
}

func (s *KeywordsCanBeIdContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTIAL, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD_LOCK_TIME, 0)
}

func (s *KeywordsCanBeIdContext) PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserPATH, 0)
}

func (s *KeywordsCanBeIdContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPHASE, 0)
}

func (s *KeywordsCanBeIdContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGINS, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN_DIR, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *KeywordsCanBeIdContext) PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPORT, 0)
}

func (s *KeywordsCanBeIdContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDES, 0)
}

func (s *KeywordsCanBeIdContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *KeywordsCanBeIdContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *KeywordsCanBeIdContext) PREV() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREV, 0)
}

func (s *KeywordsCanBeIdContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *KeywordsCanBeIdContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESSLIST, 0)
}

func (s *KeywordsCanBeIdContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILE, 0)
}

func (s *KeywordsCanBeIdContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILES, 0)
}

func (s *KeywordsCanBeIdContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *KeywordsCanBeIdContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *KeywordsCanBeIdContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MySqlParserREBUILD, 0)
}

func (s *KeywordsCanBeIdContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECOVER, 0)
}

func (s *KeywordsCanBeIdContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *KeywordsCanBeIdContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDUNDANT, 0)
}

func (s *KeywordsCanBeIdContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *KeywordsCanBeIdContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAYLOG, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREMOVE, 0)
}

func (s *KeywordsCanBeIdContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREORGANIZE, 0)
}

func (s *KeywordsCanBeIdContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_REWRITE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_APPLIER, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_USER, 0)
}

func (s *KeywordsCanBeIdContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESUME, 0)
}

func (s *KeywordsCanBeIdContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNED_SQLSTATE, 0)
}

func (s *KeywordsCanBeIdContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNING, 0)
}

func (s *KeywordsCanBeIdContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *KeywordsCanBeIdContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREUSE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *KeywordsCanBeIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *KeywordsCanBeIdContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROTATE, 0)
}

func (s *KeywordsCanBeIdContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *KeywordsCanBeIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *KeywordsCanBeIdContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) RTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRTREE, 0)
}

func (s *KeywordsCanBeIdContext) S3() antlr.TerminalNode {
	return s.GetToken(MySqlParserS3, 0)
}

func (s *KeywordsCanBeIdContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *KeywordsCanBeIdContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *KeywordsCanBeIdContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *KeywordsCanBeIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *KeywordsCanBeIdContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *KeywordsCanBeIdContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *KeywordsCanBeIdContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *KeywordsCanBeIdContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET_USER_ID, 0)
}

func (s *KeywordsCanBeIdContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *KeywordsCanBeIdContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, 0)
}

func (s *KeywordsCanBeIdContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW_ROUTINE, 0)
}

func (s *KeywordsCanBeIdContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *KeywordsCanBeIdContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIMPLE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *KeywordsCanBeIdContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLOW, 0)
}

func (s *KeywordsCanBeIdContext) SKIP_QUERY_REWRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSKIP_QUERY_REWRITE, 0)
}

func (s *KeywordsCanBeIdContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSNAPSHOT, 0)
}

func (s *KeywordsCanBeIdContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOCKET, 0)
}

func (s *KeywordsCanBeIdContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}

func (s *KeywordsCanBeIdContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *KeywordsCanBeIdContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *KeywordsCanBeIdContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOURCE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BEFORE_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *KeywordsCanBeIdContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTACKED, 0)
}

func (s *KeywordsCanBeIdContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *KeywordsCanBeIdContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTS, 0)
}

func (s *KeywordsCanBeIdContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_AUTO_RECALC, 0)
}

func (s *KeywordsCanBeIdContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_PERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_SAMPLE_PAGES, 0)
}

func (s *KeywordsCanBeIdContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *KeywordsCanBeIdContext) STD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTD, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_POP, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *KeywordsCanBeIdContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *KeywordsCanBeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING, 0)
}

func (s *KeywordsCanBeIdContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBJECT, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUM, 0)
}

func (s *KeywordsCanBeIdContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUSPEND, 0)
}

func (s *KeywordsCanBeIdContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWAPS, 0)
}

func (s *KeywordsCanBeIdContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWITCHES, 0)
}

func (s *KeywordsCanBeIdContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *KeywordsCanBeIdContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_TYPE, 0)
}

func (s *KeywordsCanBeIdContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *KeywordsCanBeIdContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *KeywordsCanBeIdContext) THAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHAN, 0)
}

func (s *KeywordsCanBeIdContext) TP_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTP_CONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRADITIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGERS, 0)
}

func (s *KeywordsCanBeIdContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *KeywordsCanBeIdContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *KeywordsCanBeIdContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *KeywordsCanBeIdContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *KeywordsCanBeIdContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *KeywordsCanBeIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *KeywordsCanBeIdContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *KeywordsCanBeIdContext) USA() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSA, 0)
}

func (s *KeywordsCanBeIdContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *KeywordsCanBeIdContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE_FRM, 0)
}

func (s *KeywordsCanBeIdContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER_RESOURCES, 0)
}

func (s *KeywordsCanBeIdContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *KeywordsCanBeIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *KeywordsCanBeIdContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_POP, 0)
}

func (s *KeywordsCanBeIdContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIABLES, 0)
}

func (s *KeywordsCanBeIdContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIANCE, 0)
}

func (s *KeywordsCanBeIdContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION_TOKEN_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *KeywordsCanBeIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIRTUAL, 0)
}

func (s *KeywordsCanBeIdContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *KeywordsCanBeIdContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *KeywordsCanBeIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *KeywordsCanBeIdContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *KeywordsCanBeIdContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRAPPER, 0)
}

func (s *KeywordsCanBeIdContext) X509() antlr.TerminalNode {
	return s.GetToken(MySqlParserX509, 0)
}

func (s *KeywordsCanBeIdContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *KeywordsCanBeIdContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA_RECOVER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) XML() antlr.TerminalNode {
	return s.GetToken(MySqlParserXML, 0)
}

func (s *KeywordsCanBeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsCanBeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeywordsCanBeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitKeywordsCanBeId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) KeywordsCanBeId() (localctx IKeywordsCanBeIdContext) {
	localctx = NewKeywordsCanBeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, MySqlParserRULE_keywordsCanBeId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7507)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 756890782757308416) != 0) || ((int64((_la - 73)) & ^0x3f) == 0 && ((int64(1) << (_la - 73)) & 146666055054393409) != 0) || _la == MySqlParserSKIP_QUERY_REWRITE || _la == MySqlParserSTACKED || ((int64((_la - 239)) & ^0x3f) == 0 && ((int64(1) << (_la - 239)) & 1769897061370560513) != 0) || ((int64((_la - 305)) & ^0x3f) == 0 && ((int64(1) << (_la - 305)) & -134217473) != 0) || ((int64((_la - 369)) & ^0x3f) == 0 && ((int64(1) << (_la - 369)) & -171798822913) != 0) || ((int64((_la - 434)) & ^0x3f) == 0 && ((int64(1) << (_la - 434)) & -33685505) != 0) || ((int64((_la - 498)) & ^0x3f) == 0 && ((int64(1) << (_la - 498)) & -2306265222165299201) != 0) || ((int64((_la - 562)) & ^0x3f) == 0 && ((int64(1) << (_la - 562)) & -35184640524289) != 0) || ((int64((_la - 626)) & ^0x3f) == 0 && ((int64(1) << (_la - 626)) & 9077990211383719935) != 0) || ((int64((_la - 697)) & ^0x3f) == 0 && ((int64(1) << (_la - 697)) & 514225960183805) != 0) || _la == MySqlParserMEMORY || _la == MySqlParserCATALOG_NAME || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserSCHEMA_NAME || _la == MySqlParserTP_CONNECTION_ADMIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionNameBaseContext is an interface to support dynamic dispatch.
type IFunctionNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABS() antlr.TerminalNode
	ACOS() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	ADDTIME() antlr.TerminalNode
	AES_DECRYPT() antlr.TerminalNode
	AES_ENCRYPT() antlr.TerminalNode
	AREA() antlr.TerminalNode
	ASBINARY() antlr.TerminalNode
	ASIN() antlr.TerminalNode
	ASTEXT() antlr.TerminalNode
	ASWKB() antlr.TerminalNode
	ASWKT() antlr.TerminalNode
	ASYMMETRIC_DECRYPT() antlr.TerminalNode
	ASYMMETRIC_DERIVE() antlr.TerminalNode
	ASYMMETRIC_ENCRYPT() antlr.TerminalNode
	ASYMMETRIC_SIGN() antlr.TerminalNode
	ASYMMETRIC_VERIFY() antlr.TerminalNode
	ATAN() antlr.TerminalNode
	ATAN2() antlr.TerminalNode
	BENCHMARK() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BIT_COUNT() antlr.TerminalNode
	BIT_LENGTH() antlr.TerminalNode
	BUFFER() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CEILING() antlr.TerminalNode
	CENTROID() antlr.TerminalNode
	CHARACTER_LENGTH() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR_LENGTH() antlr.TerminalNode
	COERCIBILITY() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COMPRESS() antlr.TerminalNode
	CONCAT() antlr.TerminalNode
	CONCAT_WS() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONV() antlr.TerminalNode
	CONVERT_TZ() antlr.TerminalNode
	COS() antlr.TerminalNode
	COT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CRC32() antlr.TerminalNode
	CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode
	CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode
	CREATE_DH_PARAMETERS() antlr.TerminalNode
	CREATE_DIGEST() antlr.TerminalNode
	CROSSES() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATE_FORMAT() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYNAME() antlr.TerminalNode
	DAYOFMONTH() antlr.TerminalNode
	DAYOFWEEK() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	DECODE() antlr.TerminalNode
	DEGREES() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	DES_DECRYPT() antlr.TerminalNode
	DES_ENCRYPT() antlr.TerminalNode
	DIMENSION() antlr.TerminalNode
	DISJOINT() antlr.TerminalNode
	ELT() antlr.TerminalNode
	ENCODE() antlr.TerminalNode
	ENCRYPT() antlr.TerminalNode
	ENDPOINT() antlr.TerminalNode
	ENVELOPE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	EXP() antlr.TerminalNode
	EXPORT_SET() antlr.TerminalNode
	EXTERIORRING() antlr.TerminalNode
	EXTRACTVALUE() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	FIND_IN_SET() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FOUND_ROWS() antlr.TerminalNode
	FROM_BASE64() antlr.TerminalNode
	FROM_DAYS() antlr.TerminalNode
	FROM_UNIXTIME() antlr.TerminalNode
	GEOMCOLLFROMTEXT() antlr.TerminalNode
	GEOMCOLLFROMWKB() antlr.TerminalNode
	GEOMETRYCOLLECTION() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	GEOMETRYFROMTEXT() antlr.TerminalNode
	GEOMETRYFROMWKB() antlr.TerminalNode
	GEOMETRYN() antlr.TerminalNode
	GEOMETRYTYPE() antlr.TerminalNode
	GEOMFROMTEXT() antlr.TerminalNode
	GEOMFROMWKB() antlr.TerminalNode
	GET_FORMAT() antlr.TerminalNode
	GET_LOCK() antlr.TerminalNode
	GLENGTH() antlr.TerminalNode
	GREATEST() antlr.TerminalNode
	GTID_SUBSET() antlr.TerminalNode
	GTID_SUBTRACT() antlr.TerminalNode
	HEX() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IFNULL() antlr.TerminalNode
	INET6_ATON() antlr.TerminalNode
	INET6_NTOA() antlr.TerminalNode
	INET_ATON() antlr.TerminalNode
	INET_NTOA() antlr.TerminalNode
	INSTR() antlr.TerminalNode
	INTERIORRINGN() antlr.TerminalNode
	INTERSECTS() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ISCLOSED() antlr.TerminalNode
	ISEMPTY() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISSIMPLE() antlr.TerminalNode
	IS_FREE_LOCK() antlr.TerminalNode
	IS_IPV4() antlr.TerminalNode
	IS_IPV4_COMPAT() antlr.TerminalNode
	IS_IPV4_MAPPED() antlr.TerminalNode
	IS_IPV6() antlr.TerminalNode
	IS_USED_LOCK() antlr.TerminalNode
	LAG() antlr.TerminalNode
	LAST_INSERT_ID() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	LCASE() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	LEAST() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LENGTH() antlr.TerminalNode
	LINEFROMTEXT() antlr.TerminalNode
	LINEFROMWKB() antlr.TerminalNode
	LINESTRING() antlr.TerminalNode
	LINESTRINGFROMTEXT() antlr.TerminalNode
	LINESTRINGFROMWKB() antlr.TerminalNode
	LN() antlr.TerminalNode
	LOAD_FILE() antlr.TerminalNode
	LOCATE() antlr.TerminalNode
	LOG() antlr.TerminalNode
	LOG10() antlr.TerminalNode
	LOG2() antlr.TerminalNode
	LOWER() antlr.TerminalNode
	LPAD() antlr.TerminalNode
	LTRIM() antlr.TerminalNode
	MAKEDATE() antlr.TerminalNode
	MAKETIME() antlr.TerminalNode
	MAKE_SET() antlr.TerminalNode
	MASTER_POS_WAIT() antlr.TerminalNode
	MBRCONTAINS() antlr.TerminalNode
	MBRDISJOINT() antlr.TerminalNode
	MBREQUAL() antlr.TerminalNode
	MBRINTERSECTS() antlr.TerminalNode
	MBROVERLAPS() antlr.TerminalNode
	MBRTOUCHES() antlr.TerminalNode
	MBRWITHIN() antlr.TerminalNode
	MD5() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MLINEFROMTEXT() antlr.TerminalNode
	MLINEFROMWKB() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHNAME() antlr.TerminalNode
	MPOINTFROMTEXT() antlr.TerminalNode
	MPOINTFROMWKB() antlr.TerminalNode
	MPOLYFROMTEXT() antlr.TerminalNode
	MPOLYFROMWKB() antlr.TerminalNode
	MULTILINESTRING() antlr.TerminalNode
	MULTILINESTRINGFROMTEXT() antlr.TerminalNode
	MULTILINESTRINGFROMWKB() antlr.TerminalNode
	MULTIPOINT() antlr.TerminalNode
	MULTIPOINTFROMTEXT() antlr.TerminalNode
	MULTIPOINTFROMWKB() antlr.TerminalNode
	MULTIPOLYGON() antlr.TerminalNode
	MULTIPOLYGONFROMTEXT() antlr.TerminalNode
	MULTIPOLYGONFROMWKB() antlr.TerminalNode
	NAME_CONST() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	NULLIF() antlr.TerminalNode
	NUMGEOMETRIES() antlr.TerminalNode
	NUMINTERIORRINGS() antlr.TerminalNode
	NUMPOINTS() antlr.TerminalNode
	OCT() antlr.TerminalNode
	OCTET_LENGTH() antlr.TerminalNode
	ORD() antlr.TerminalNode
	OVERLAPS() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PERIOD_ADD() antlr.TerminalNode
	PERIOD_DIFF() antlr.TerminalNode
	PI() antlr.TerminalNode
	POINT() antlr.TerminalNode
	POINTFROMTEXT() antlr.TerminalNode
	POINTFROMWKB() antlr.TerminalNode
	POINTN() antlr.TerminalNode
	POLYFROMTEXT() antlr.TerminalNode
	POLYFROMWKB() antlr.TerminalNode
	POLYGON() antlr.TerminalNode
	POLYGONFROMTEXT() antlr.TerminalNode
	POLYGONFROMWKB() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	POW() antlr.TerminalNode
	POWER() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUOTE() antlr.TerminalNode
	RADIANS() antlr.TerminalNode
	RAND() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RANDOM_BYTES() antlr.TerminalNode
	RELEASE_LOCK() antlr.TerminalNode
	REVERSE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROUND() antlr.TerminalNode
	ROW_COUNT() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	RPAD() antlr.TerminalNode
	RTRIM() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SEC_TO_TIME() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SHA() antlr.TerminalNode
	SHA1() antlr.TerminalNode
	SHA2() antlr.TerminalNode
	SIGN() antlr.TerminalNode
	SIN() antlr.TerminalNode
	SLEEP() antlr.TerminalNode
	SOUNDEX() antlr.TerminalNode
	SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode
	SQRT() antlr.TerminalNode
	SRID() antlr.TerminalNode
	STARTPOINT() antlr.TerminalNode
	STRCMP() antlr.TerminalNode
	STR_TO_DATE() antlr.TerminalNode
	ST_AREA() antlr.TerminalNode
	ST_ASBINARY() antlr.TerminalNode
	ST_ASTEXT() antlr.TerminalNode
	ST_ASWKB() antlr.TerminalNode
	ST_ASWKT() antlr.TerminalNode
	ST_BUFFER() antlr.TerminalNode
	ST_CENTROID() antlr.TerminalNode
	ST_CONTAINS() antlr.TerminalNode
	ST_CROSSES() antlr.TerminalNode
	ST_DIFFERENCE() antlr.TerminalNode
	ST_DIMENSION() antlr.TerminalNode
	ST_DISJOINT() antlr.TerminalNode
	ST_DISTANCE() antlr.TerminalNode
	ST_ENDPOINT() antlr.TerminalNode
	ST_ENVELOPE() antlr.TerminalNode
	ST_EQUALS() antlr.TerminalNode
	ST_EXTERIORRING() antlr.TerminalNode
	ST_GEOMCOLLFROMTEXT() antlr.TerminalNode
	ST_GEOMCOLLFROMTXT() antlr.TerminalNode
	ST_GEOMCOLLFROMWKB() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	ST_GEOMETRYFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYFROMWKB() antlr.TerminalNode
	ST_GEOMETRYN() antlr.TerminalNode
	ST_GEOMETRYTYPE() antlr.TerminalNode
	ST_GEOMFROMTEXT() antlr.TerminalNode
	ST_GEOMFROMWKB() antlr.TerminalNode
	ST_INTERIORRINGN() antlr.TerminalNode
	ST_INTERSECTION() antlr.TerminalNode
	ST_INTERSECTS() antlr.TerminalNode
	ST_ISCLOSED() antlr.TerminalNode
	ST_ISEMPTY() antlr.TerminalNode
	ST_ISSIMPLE() antlr.TerminalNode
	ST_LINEFROMTEXT() antlr.TerminalNode
	ST_LINEFROMWKB() antlr.TerminalNode
	ST_LINESTRINGFROMTEXT() antlr.TerminalNode
	ST_LINESTRINGFROMWKB() antlr.TerminalNode
	ST_NUMGEOMETRIES() antlr.TerminalNode
	ST_NUMINTERIORRING() antlr.TerminalNode
	ST_NUMINTERIORRINGS() antlr.TerminalNode
	ST_NUMPOINTS() antlr.TerminalNode
	ST_OVERLAPS() antlr.TerminalNode
	ST_POINTFROMTEXT() antlr.TerminalNode
	ST_POINTFROMWKB() antlr.TerminalNode
	ST_POINTN() antlr.TerminalNode
	ST_POLYFROMTEXT() antlr.TerminalNode
	ST_POLYFROMWKB() antlr.TerminalNode
	ST_POLYGONFROMTEXT() antlr.TerminalNode
	ST_POLYGONFROMWKB() antlr.TerminalNode
	ST_SRID() antlr.TerminalNode
	ST_STARTPOINT() antlr.TerminalNode
	ST_SYMDIFFERENCE() antlr.TerminalNode
	ST_TOUCHES() antlr.TerminalNode
	ST_UNION() antlr.TerminalNode
	ST_WITHIN() antlr.TerminalNode
	ST_X() antlr.TerminalNode
	ST_Y() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	SUBSTRING_INDEX() antlr.TerminalNode
	SUBTIME() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	TAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMEDIFF() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TIME_FORMAT() antlr.TerminalNode
	TIME_TO_SEC() antlr.TerminalNode
	TOUCHES() antlr.TerminalNode
	TO_BASE64() antlr.TerminalNode
	TO_DAYS() antlr.TerminalNode
	TO_SECONDS() antlr.TerminalNode
	UCASE() antlr.TerminalNode
	UNCOMPRESS() antlr.TerminalNode
	UNCOMPRESSED_LENGTH() antlr.TerminalNode
	UNHEX() antlr.TerminalNode
	UNIX_TIMESTAMP() antlr.TerminalNode
	UPDATEXML() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	UUID() antlr.TerminalNode
	UUID_SHORT() antlr.TerminalNode
	VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKDAY() antlr.TerminalNode
	WEEKOFYEAR() antlr.TerminalNode
	WEIGHT_STRING() antlr.TerminalNode
	WITHIN() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARWEEK() antlr.TerminalNode
	Y_FUNCTION() antlr.TerminalNode
	X_FUNCTION() antlr.TerminalNode
	JSON_ARRAY() antlr.TerminalNode
	JSON_OBJECT() antlr.TerminalNode
	JSON_QUOTE() antlr.TerminalNode
	JSON_CONTAINS() antlr.TerminalNode
	JSON_CONTAINS_PATH() antlr.TerminalNode
	JSON_EXTRACT() antlr.TerminalNode
	JSON_KEYS() antlr.TerminalNode
	JSON_OVERLAPS() antlr.TerminalNode
	JSON_SEARCH() antlr.TerminalNode
	JSON_VALUE() antlr.TerminalNode
	JSON_ARRAY_APPEND() antlr.TerminalNode
	JSON_ARRAY_INSERT() antlr.TerminalNode
	JSON_INSERT() antlr.TerminalNode
	JSON_MERGE() antlr.TerminalNode
	JSON_MERGE_PATCH() antlr.TerminalNode
	JSON_MERGE_PRESERVE() antlr.TerminalNode
	JSON_REMOVE() antlr.TerminalNode
	JSON_REPLACE() antlr.TerminalNode
	JSON_SET() antlr.TerminalNode
	JSON_UNQUOTE() antlr.TerminalNode
	JSON_DEPTH() antlr.TerminalNode
	JSON_LENGTH() antlr.TerminalNode
	JSON_TYPE() antlr.TerminalNode
	JSON_VALID() antlr.TerminalNode
	JSON_TABLE() antlr.TerminalNode
	JSON_SCHEMA_VALID() antlr.TerminalNode
	JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode
	JSON_PRETTY() antlr.TerminalNode
	JSON_STORAGE_FREE() antlr.TerminalNode
	JSON_STORAGE_SIZE() antlr.TerminalNode
	JSON_ARRAYAGG() antlr.TerminalNode
	JSON_OBJECTAGG() antlr.TerminalNode

	// IsFunctionNameBaseContext differentiates from other interfaces.
	IsFunctionNameBaseContext()
}

type FunctionNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameBaseContext() *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionNameBase
	return p
}

func InitEmptyFunctionNameBaseContext(p *FunctionNameBaseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionNameBase
}

func (*FunctionNameBaseContext) IsFunctionNameBaseContext() {}

func NewFunctionNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionNameBase

	return p
}

func (s *FunctionNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameBaseContext) ABS() antlr.TerminalNode {
	return s.GetToken(MySqlParserABS, 0)
}

func (s *FunctionNameBaseContext) ACOS() antlr.TerminalNode {
	return s.GetToken(MySqlParserACOS, 0)
}

func (s *FunctionNameBaseContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDDATE, 0)
}

func (s *FunctionNameBaseContext) ADDTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDTIME, 0)
}

func (s *FunctionNameBaseContext) AES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) AES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserAREA, 0)
}

func (s *FunctionNameBaseContext) ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASBINARY, 0)
}

func (s *FunctionNameBaseContext) ASIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASIN, 0)
}

func (s *FunctionNameBaseContext) ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASTEXT, 0)
}

func (s *FunctionNameBaseContext) ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKB, 0)
}

func (s *FunctionNameBaseContext) ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DERIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DERIVE, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_SIGN, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_VERIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_VERIFY, 0)
}

func (s *FunctionNameBaseContext) ATAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN, 0)
}

func (s *FunctionNameBaseContext) ATAN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN2, 0)
}

func (s *FunctionNameBaseContext) BENCHMARK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBENCHMARK, 0)
}

func (s *FunctionNameBaseContext) BIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIN, 0)
}

func (s *FunctionNameBaseContext) BIT_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_COUNT, 0)
}

func (s *FunctionNameBaseContext) BIT_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_LENGTH, 0)
}

func (s *FunctionNameBaseContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUFFER, 0)
}

func (s *FunctionNameBaseContext) CEIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEIL, 0)
}

func (s *FunctionNameBaseContext) CEILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEILING, 0)
}

func (s *FunctionNameBaseContext) CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCENTROID, 0)
}

func (s *FunctionNameBaseContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER_LENGTH, 0)
}

func (s *FunctionNameBaseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *FunctionNameBaseContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR_LENGTH, 0)
}

func (s *FunctionNameBaseContext) COERCIBILITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOERCIBILITY, 0)
}

func (s *FunctionNameBaseContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATION, 0)
}

func (s *FunctionNameBaseContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT, 0)
}

func (s *FunctionNameBaseContext) CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT_WS, 0)
}

func (s *FunctionNameBaseContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ID, 0)
}

func (s *FunctionNameBaseContext) CONV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONV, 0)
}

func (s *FunctionNameBaseContext) CONVERT_TZ() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT_TZ, 0)
}

func (s *FunctionNameBaseContext) COS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOS, 0)
}

func (s *FunctionNameBaseContext) COT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOT, 0)
}

func (s *FunctionNameBaseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *FunctionNameBaseContext) CRC32() antlr.TerminalNode {
	return s.GetToken(MySqlParserCRC32, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PUB_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_DH_PARAMETERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DH_PARAMETERS, 0)
}

func (s *FunctionNameBaseContext) CREATE_DIGEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DIGEST, 0)
}

func (s *FunctionNameBaseContext) CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSSES, 0)
}

func (s *FunctionNameBaseContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCUME_DIST, 0)
}

func (s *FunctionNameBaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *FunctionNameBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *FunctionNameBaseContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATEDIFF, 0)
}

func (s *FunctionNameBaseContext) DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_FORMAT, 0)
}

func (s *FunctionNameBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *FunctionNameBaseContext) DAYNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYNAME, 0)
}

func (s *FunctionNameBaseContext) DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFMONTH, 0)
}

func (s *FunctionNameBaseContext) DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFWEEK, 0)
}

func (s *FunctionNameBaseContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFYEAR, 0)
}

func (s *FunctionNameBaseContext) DECODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECODE, 0)
}

func (s *FunctionNameBaseContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEGREES, 0)
}

func (s *FunctionNameBaseContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDENSE_RANK, 0)
}

func (s *FunctionNameBaseContext) DES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) DES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIMENSION, 0)
}

func (s *FunctionNameBaseContext) DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISJOINT, 0)
}

func (s *FunctionNameBaseContext) ELT() antlr.TerminalNode {
	return s.GetToken(MySqlParserELT, 0)
}

func (s *FunctionNameBaseContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCODE, 0)
}

func (s *FunctionNameBaseContext) ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENVELOPE, 0)
}

func (s *FunctionNameBaseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUALS, 0)
}

func (s *FunctionNameBaseContext) EXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXP, 0)
}

func (s *FunctionNameBaseContext) EXPORT_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT_SET, 0)
}

func (s *FunctionNameBaseContext) EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) EXTRACTVALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACTVALUE, 0)
}

func (s *FunctionNameBaseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELD, 0)
}

func (s *FunctionNameBaseContext) FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIND_IN_SET, 0)
}

func (s *FunctionNameBaseContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST_VALUE, 0)
}

func (s *FunctionNameBaseContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOOR, 0)
}

func (s *FunctionNameBaseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORMAT, 0)
}

func (s *FunctionNameBaseContext) FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND_ROWS, 0)
}

func (s *FunctionNameBaseContext) FROM_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_BASE64, 0)
}

func (s *FunctionNameBaseContext) FROM_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_DAYS, 0)
}

func (s *FunctionNameBaseContext) FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_UNIXTIME, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *FunctionNameBaseContext) GET_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_LOCK, 0)
}

func (s *FunctionNameBaseContext) GLENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLENGTH, 0)
}

func (s *FunctionNameBaseContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATEST, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBSET, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBTRACT, 0)
}

func (s *FunctionNameBaseContext) HEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEX, 0)
}

func (s *FunctionNameBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *FunctionNameBaseContext) IFNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserIFNULL, 0)
}

func (s *FunctionNameBaseContext) INET6_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_ATON, 0)
}

func (s *FunctionNameBaseContext) INET6_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_NTOA, 0)
}

func (s *FunctionNameBaseContext) INET_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_ATON, 0)
}

func (s *FunctionNameBaseContext) INET_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_NTOA, 0)
}

func (s *FunctionNameBaseContext) INSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTR, 0)
}

func (s *FunctionNameBaseContext) INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *FunctionNameBaseContext) ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserISNULL, 0)
}

func (s *FunctionNameBaseContext) ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) IS_FREE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_FREE_LOCK, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_COMPAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_COMPAT, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_MAPPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_MAPPED, 0)
}

func (s *FunctionNameBaseContext) IS_IPV6() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV6, 0)
}

func (s *FunctionNameBaseContext) IS_USED_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_USED_LOCK, 0)
}

func (s *FunctionNameBaseContext) LAG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAG, 0)
}

func (s *FunctionNameBaseContext) LAST_INSERT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_INSERT_ID, 0)
}

func (s *FunctionNameBaseContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_VALUE, 0)
}

func (s *FunctionNameBaseContext) LCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLCASE, 0)
}

func (s *FunctionNameBaseContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAD, 0)
}

func (s *FunctionNameBaseContext) LEAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAST, 0)
}

func (s *FunctionNameBaseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *FunctionNameBaseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserLENGTH, 0)
}

func (s *FunctionNameBaseContext) LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LN() antlr.TerminalNode {
	return s.GetToken(MySqlParserLN, 0)
}

func (s *FunctionNameBaseContext) LOAD_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD_FILE, 0)
}

func (s *FunctionNameBaseContext) LOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCATE, 0)
}

func (s *FunctionNameBaseContext) LOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG, 0)
}

func (s *FunctionNameBaseContext) LOG10() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG10, 0)
}

func (s *FunctionNameBaseContext) LOG2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG2, 0)
}

func (s *FunctionNameBaseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOWER, 0)
}

func (s *FunctionNameBaseContext) LPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLPAD, 0)
}

func (s *FunctionNameBaseContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserLTRIM, 0)
}

func (s *FunctionNameBaseContext) MAKEDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKEDATE, 0)
}

func (s *FunctionNameBaseContext) MAKETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKETIME, 0)
}

func (s *FunctionNameBaseContext) MAKE_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKE_SET, 0)
}

func (s *FunctionNameBaseContext) MASTER_POS_WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_POS_WAIT, 0)
}

func (s *FunctionNameBaseContext) MBRCONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRCONTAINS, 0)
}

func (s *FunctionNameBaseContext) MBRDISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRDISJOINT, 0)
}

func (s *FunctionNameBaseContext) MBREQUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBREQUAL, 0)
}

func (s *FunctionNameBaseContext) MBRINTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) MBROVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBROVERLAPS, 0)
}

func (s *FunctionNameBaseContext) MBRTOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRTOUCHES, 0)
}

func (s *FunctionNameBaseContext) MBRWITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRWITHIN, 0)
}

func (s *FunctionNameBaseContext) MD5() antlr.TerminalNode {
	return s.GetToken(MySqlParserMD5, 0)
}

func (s *FunctionNameBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *FunctionNameBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMOD, 0)
}

func (s *FunctionNameBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *FunctionNameBaseContext) MONTHNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTHNAME, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) NAME_CONST() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME_CONST, 0)
}

func (s *FunctionNameBaseContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTH_VALUE, 0)
}

func (s *FunctionNameBaseContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTILE, 0)
}

func (s *FunctionNameBaseContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULLIF, 0)
}

func (s *FunctionNameBaseContext) NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) OCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCT, 0)
}

func (s *FunctionNameBaseContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCTET_LENGTH, 0)
}

func (s *FunctionNameBaseContext) ORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserORD, 0)
}

func (s *FunctionNameBaseContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOVERLAPS, 0)
}

func (s *FunctionNameBaseContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERCENT_RANK, 0)
}

func (s *FunctionNameBaseContext) PERIOD_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_ADD, 0)
}

func (s *FunctionNameBaseContext) PERIOD_DIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_DIFF, 0)
}

func (s *FunctionNameBaseContext) PI() antlr.TerminalNode {
	return s.GetToken(MySqlParserPI, 0)
}

func (s *FunctionNameBaseContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTN, 0)
}

func (s *FunctionNameBaseContext) POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *FunctionNameBaseContext) POW() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOW, 0)
}

func (s *FunctionNameBaseContext) POWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOWER, 0)
}

func (s *FunctionNameBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *FunctionNameBaseContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUOTE, 0)
}

func (s *FunctionNameBaseContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRADIANS, 0)
}

func (s *FunctionNameBaseContext) RAND() antlr.TerminalNode {
	return s.GetToken(MySqlParserRAND, 0)
}

func (s *FunctionNameBaseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM, 0)
}

func (s *FunctionNameBaseContext) RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANK, 0)
}

func (s *FunctionNameBaseContext) RANDOM_BYTES() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM_BYTES, 0)
}

func (s *FunctionNameBaseContext) RELEASE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE_LOCK, 0)
}

func (s *FunctionNameBaseContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *FunctionNameBaseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *FunctionNameBaseContext) ROUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUND, 0)
}

func (s *FunctionNameBaseContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_COUNT, 0)
}

func (s *FunctionNameBaseContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_NUMBER, 0)
}

func (s *FunctionNameBaseContext) RPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRPAD, 0)
}

func (s *FunctionNameBaseContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRTRIM, 0)
}

func (s *FunctionNameBaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *FunctionNameBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *FunctionNameBaseContext) SEC_TO_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEC_TO_TIME, 0)
}

func (s *FunctionNameBaseContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_USER, 0)
}

func (s *FunctionNameBaseContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *FunctionNameBaseContext) SHA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA, 0)
}

func (s *FunctionNameBaseContext) SHA1() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA1, 0)
}

func (s *FunctionNameBaseContext) SHA2() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA2, 0)
}

func (s *FunctionNameBaseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGN, 0)
}

func (s *FunctionNameBaseContext) SIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIN, 0)
}

func (s *FunctionNameBaseContext) SLEEP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLEEP, 0)
}

func (s *FunctionNameBaseContext) SOUNDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDEX, 0)
}

func (s *FunctionNameBaseContext) SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) SQRT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQRT, 0)
}

func (s *FunctionNameBaseContext) SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSRID, 0)
}

func (s *FunctionNameBaseContext) STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTPOINT, 0)
}

func (s *FunctionNameBaseContext) STRCMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRCMP, 0)
}

func (s *FunctionNameBaseContext) STR_TO_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTR_TO_DATE, 0)
}

func (s *FunctionNameBaseContext) ST_AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_AREA, 0)
}

func (s *FunctionNameBaseContext) ST_ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASBINARY, 0)
}

func (s *FunctionNameBaseContext) ST_ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKB, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKT, 0)
}

func (s *FunctionNameBaseContext) ST_BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_BUFFER, 0)
}

func (s *FunctionNameBaseContext) ST_CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CENTROID, 0)
}

func (s *FunctionNameBaseContext) ST_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) ST_CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CROSSES, 0)
}

func (s *FunctionNameBaseContext) ST_DIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIMENSION, 0)
}

func (s *FunctionNameBaseContext) ST_DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISJOINT, 0)
}

func (s *FunctionNameBaseContext) ST_DISTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISTANCE, 0)
}

func (s *FunctionNameBaseContext) ST_ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENVELOPE, 0)
}

func (s *FunctionNameBaseContext) ST_EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EQUALS, 0)
}

func (s *FunctionNameBaseContext) ST_EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTION, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTS, 0)
}

func (s *FunctionNameBaseContext) ST_ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ST_ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ST_ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) ST_NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) ST_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTN, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SRID, 0)
}

func (s *FunctionNameBaseContext) ST_STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_STARTPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_SYMDIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SYMDIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_TOUCHES, 0)
}

func (s *FunctionNameBaseContext) ST_UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_UNION, 0)
}

func (s *FunctionNameBaseContext) ST_WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_WITHIN, 0)
}

func (s *FunctionNameBaseContext) ST_X() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_X, 0)
}

func (s *FunctionNameBaseContext) ST_Y() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_Y, 0)
}

func (s *FunctionNameBaseContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBDATE, 0)
}

func (s *FunctionNameBaseContext) SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING_INDEX, 0)
}

func (s *FunctionNameBaseContext) SUBTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBTIME, 0)
}

func (s *FunctionNameBaseContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_USER, 0)
}

func (s *FunctionNameBaseContext) TAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTAN, 0)
}

func (s *FunctionNameBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *FunctionNameBaseContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMEDIFF, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPADD, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPDIFF, 0)
}

func (s *FunctionNameBaseContext) TIME_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_FORMAT, 0)
}

func (s *FunctionNameBaseContext) TIME_TO_SEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_TO_SEC, 0)
}

func (s *FunctionNameBaseContext) TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOUCHES, 0)
}

func (s *FunctionNameBaseContext) TO_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_BASE64, 0)
}

func (s *FunctionNameBaseContext) TO_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_DAYS, 0)
}

func (s *FunctionNameBaseContext) TO_SECONDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_SECONDS, 0)
}

func (s *FunctionNameBaseContext) UCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCASE, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESSED_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESSED_LENGTH, 0)
}

func (s *FunctionNameBaseContext) UNHEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNHEX, 0)
}

func (s *FunctionNameBaseContext) UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIX_TIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) UPDATEXML() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATEXML, 0)
}

func (s *FunctionNameBaseContext) UPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPPER, 0)
}

func (s *FunctionNameBaseContext) UUID() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID, 0)
}

func (s *FunctionNameBaseContext) UUID_SHORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID_SHORT, 0)
}

func (s *FunctionNameBaseContext) VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATE_PASSWORD_STRENGTH, 0)
}

func (s *FunctionNameBaseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION, 0)
}

func (s *FunctionNameBaseContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *FunctionNameBaseContext) WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *FunctionNameBaseContext) WEEKDAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKDAY, 0)
}

func (s *FunctionNameBaseContext) WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKOFYEAR, 0)
}

func (s *FunctionNameBaseContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *FunctionNameBaseContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHIN, 0)
}

func (s *FunctionNameBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *FunctionNameBaseContext) YEARWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEARWEEK, 0)
}

func (s *FunctionNameBaseContext) Y_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserY_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) X_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserX_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OBJECT, 0)
}

func (s *FunctionNameBaseContext) JSON_QUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_QUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS_PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_CONTAINS_PATH, 0)
}

func (s *FunctionNameBaseContext) JSON_EXTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_EXTRACT, 0)
}

func (s *FunctionNameBaseContext) JSON_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_KEYS, 0)
}

func (s *FunctionNameBaseContext) JSON_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) JSON_SEARCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SEARCH, 0)
}

func (s *FunctionNameBaseContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALUE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_APPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY_APPEND, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PATCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE_PATCH, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE_PRESERVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_REMOVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_REPLACE, 0)
}

func (s *FunctionNameBaseContext) JSON_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SET, 0)
}

func (s *FunctionNameBaseContext) JSON_UNQUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_UNQUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_DEPTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_DEPTH, 0)
}

func (s *FunctionNameBaseContext) JSON_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_LENGTH, 0)
}

func (s *FunctionNameBaseContext) JSON_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TYPE, 0)
}

func (s *FunctionNameBaseContext) JSON_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TABLE, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SCHEMA_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SCHEMA_VALIDATION_REPORT, 0)
}

func (s *FunctionNameBaseContext) JSON_PRETTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_PRETTY, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_FREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_STORAGE_FREE, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_STORAGE_SIZE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAYAGG() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAYAGG, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECTAGG() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OBJECTAGG, 0)
}

func (s *FunctionNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *MySqlParser) FunctionNameBase() (localctx IFunctionNameBaseContext) {
	localctx = NewFunctionNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, MySqlParserRULE_functionNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7509)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || ((int64((_la - 97)) & ^0x3f) == 0 && ((int64(1) << (_la - 97)) & 11258999068426241) != 0) || ((int64((_la - 217)) & ^0x3f) == 0 && ((int64(1) << (_la - 217)) & -17179869161) != 0) || ((int64((_la - 281)) & ^0x3f) == 0 && ((int64(1) << (_la - 281)) & 8796109397507) != 0) || _la == MySqlParserINVISIBLE || ((int64((_la - 673)) & ^0x3f) == 0 && ((int64(1) << (_la - 673)) & -9223372036838064127) != 0) || ((int64((_la - 803)) & ^0x3f) == 0 && ((int64(1) << (_la - 803)) & -8589934599) != 0) || ((int64((_la - 867)) & ^0x3f) == 0 && ((int64(1) << (_la - 867)) & -257) != 0) || ((int64((_la - 931)) & ^0x3f) == 0 && ((int64(1) << (_la - 931)) & -1) != 0) || ((int64((_la - 995)) & ^0x3f) == 0 && ((int64(1) << (_la - 995)) & -1057) != 0) || ((int64((_la - 1059)) & ^0x3f) == 0 && ((int64(1) << (_la - 1059)) & 562949416550399) != 0) || _la == MySqlParserMOD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


func (p *MySqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 348:
			var t *ExpressionContext = nil
			if localctx != nil { t = localctx.(*ExpressionContext) }
			return p.Expression_Sempred(t, predIndex)

	case 349:
			var t *PredicateContext = nil
			if localctx != nil { t = localctx.(*PredicateContext) }
			return p.Predicate_Sempred(t, predIndex)

	case 350:
			var t *ExpressionAtomContext = nil
			if localctx != nil { t = localctx.(*ExpressionAtomContext) }
			return p.ExpressionAtom_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MySqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
			return p.Precpred(p.GetParserRuleContext(), 8)

	case 2:
			return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
			return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
			return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
			return p.Precpred(p.GetParserRuleContext(), 7)

	case 8:
			return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
			return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
			return p.Precpred(p.GetParserRuleContext(), 4)

	case 11:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 12:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 13:
			return p.Precpred(p.GetParserRuleContext(), 1)

	case 14:
			return p.Precpred(p.GetParserRuleContext(), 14)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

