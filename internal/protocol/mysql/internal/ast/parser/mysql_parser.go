// Code generated from /Users/zhuwenliang/dbproxy/internal/protocol/mysql/internal/ast/MySqlParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // MySqlParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MySqlParser struct {
	*antlr.BaseParser
}

var MySqlParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func mysqlparserParserInit() {
	staticData := &MySqlParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'",
		"'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'",
		"'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'",
		"'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'",
		"'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", "'DATABASES'",
		"'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", "'DESCRIBE'",
		"'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'",
		"'EACH'", "'ELSE'", "'ELSEIF'", "'EMPTY'", "'ENCLOSED'", "'ENFORCED'",
		"'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'FALSE'",
		"'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", "'FROM'", "'FULLTEXT'",
		"'GENERATED'", "'GET'", "'GRANT'", "'GROUP'", "'HAVING'", "'HIGH_PRIORITY'",
		"'HISTOGRAM'", "'IF'", "'IGNORE'", "'IGNORED'", "'IN'", "'INDEX'", "'INFILE'",
		"'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'",
		"'JOIN'", "'KEY'", "'KEYS'", "'KILL'", "'LATERAL'", "'LEADING'", "'LEAVE'",
		"'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'",
		"'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'",
		"'MATCH'", "'MAXVALUE'", "'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'",
		"'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'",
		"'OPTION'", "'OPTIONAL'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'",
		"'OUTER'", "'OUTFILE'", "'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'",
		"'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'",
		"'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'",
		"'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'",
		"'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'",
		"'SIGNAL'", "'SKIP'", "'SKIP_QUERY_REWRITE'", "'SPATIAL'", "'SQL'",
		"'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'",
		"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'",
		"'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'",
		"'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'",
		"'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'",
		"'USING'", "'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'", "'WRITE'",
		"'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'",
		"'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'",
		"'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'",
		"'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'",
		"'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'",
		"'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'",
		"'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'",
		"'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'",
		"'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'",
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'",
		"'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_ARRAY_APPEND'",
		"'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", "'JSON_DEPTH'",
		"'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'", "'JSON_MERGE'",
		"'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'", "'JSON_OBJECTAGG'",
		"'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'", "'JSON_REMOVE'",
		"'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_SEARCH'", "'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'",
		"'JSON_TABLE'", "'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'",
		"'NESTED'", "'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'",
		"'BIT_XOR'", "'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'",
		"'GROUP_CONCAT'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'",
		"'NTILE'", "'NTH_VALUE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'",
		"'STD'", "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'",
		"'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'LOCALTIME'", "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'",
		"'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'",
		"'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'",
		"'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'",
		"'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'",
		"'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'",
		"'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'",
		"'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'",
		"'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'",
		"'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'",
		"'COMPLETION'", "'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", "'CONNECT'",
		"'CONNECTION'", "'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'",
		"'CONSTRAINT_NAME'", "'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'",
		"'CPU'", "'CYCLE'", "'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'",
		"'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'",
		"'DIRECTORY'", "'DISABLE'", "'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'",
		"'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'",
		"'ENCRYPTION_KEY_ID'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'",
		"'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'",
		"'EXCHANGE'", "'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'",
		"'FAILED_LOGIN_ATTEMPTS'", "'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'",
		"'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'",
		"'FOUND'", "'FULL'", "'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'",
		"'GROUP_REPLICATION'", "'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'",
		"'HOST'", "'HOSTS'", "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'",
		"'INCREMENT'", "'INDEXES'", "'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'",
		"'INSTALL'", "'INSTANCE'", "'INSTANT'", "'INVISIBLE'", "'INVOKER'",
		"'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'", "'ISSUER'", "'JSON'",
		"'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'",
		"'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'",
		"'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'",
		"'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'", "'MASTER_PASSWORD'",
		"'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'", "'MASTER_SSL_CA'",
		"'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'",
		"'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'",
		"'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'",
		"'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'",
		"'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'",
		"'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'",
		"'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NOCACHE'",
		"'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", "'NOWAIT'",
		"'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", "'OF'",
		"'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'",
		"'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PAGE_COMPRESSED'",
		"'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'",
		"'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", "'PHASE'", "'PLUGIN'",
		"'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", "'PRECEDING'",
		"'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", "'PROFILE'", "'PROFILES'",
		"'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", "'RECURSIVE'",
		"'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'",
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'",
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'",
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'",
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'",
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'",
		"'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'",
		"'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'",
		"'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'",
		"'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'",
		"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'",
		"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'",
		"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'",
		"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'",
		"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'",
		"'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
		"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'",
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'",
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'",
		"'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'",
		"'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'",
		"'MICROSECOND'", "'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ABORT_EXEMPT'",
		"'AUDIT_ADMIN'", "'AUTHENTICATION_POLICY_ADMIN'", "'BACKUP_ADMIN'",
		"'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'", "'CONNECTION_ADMIN'",
		"'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", "'FILE'", "'FIREWALL_ADMIN'",
		"'FIREWALL_EXEMPT'", "'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'",
		"'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'", "'GROUP_REPLICATION_ADMIN'",
		"'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'", "'INVOKE'",
		"'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'",
		"'PRIVILEGES'", "'PROCESS'", "'RELOAD'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'",
		"'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'",
		"'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'", "'SHOW_ROUTINE'",
		"'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLES'", "'TABLE_ENCRYPTION_ADMIN'",
		"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'",
		"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'",
		"'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'",
		"'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'",
		"'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'",
		"'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'",
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'",
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'",
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'",
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'",
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'",
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'",
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'",
		"'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'",
		"'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'",
		"'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'",
		"'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'",
		"'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'",
		"'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'",
		"'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'",
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'",
		"'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'",
		"'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'",
		"'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'",
		"'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'",
		"'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'",
		"'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'",
		"'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'",
		"'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'",
		"'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM'", "'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'",
		"'ROW_COUNT'", "'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'TP_CONNECTION_ADMIN'", "'UCASE'", "'UNCOMPRESS'",
		"'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'",
		"'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'",
		"'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'",
		"'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='",
		"'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'",
		"'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'",
		"'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'",
		"'1'", "'2'", "'''", "'\"'", "'`'", "':'",
	}
	staticData.SymbolicNames = []string{
		"", "PROXY_HINT", "SPACE", "LINE_COMMENT", "ADD", "ALL", "ALTER", "ALWAYS",
		"ANALYZE", "AND", "ARRAY", "AS", "ASC", "ATTRIBUTE", "BEFORE", "BETWEEN",
		"BOTH", "BUCKETS", "BY", "CALL", "CASCADE", "CASE", "CAST", "CHANGE",
		"CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT",
		"CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_ROLE",
		"CURRENT_USER", "CURSOR", "DATABASE", "DATABASES", "DECLARE", "DEFAULT",
		"DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", "DIAGNOSTICS",
		"DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF", "EMPTY",
		"ENCLOSED", "ENFORCED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN",
		"FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED",
		"GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF",
		"IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT",
		"INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL",
		"LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES",
		"LOAD", "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT",
		"MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG",
		"NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY",
		"OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY",
		"PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP",
		"RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT",
		"RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS",
		"SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", "SKIP_QUERY_REWRITE",
		"SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT",
		"SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING",
		"STATEMENT", "STRAIGHT_JOIN", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING",
		"TRIGGER", "TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED",
		"UPDATE", "USAGE", "USE", "USING", "VALUES", "WHEN", "WHERE", "WHILE",
		"WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT", "SMALLINT", "MEDIUMINT",
		"MIDDLEINT", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER",
		"BIGINT", "REAL", "DOUBLE", "PRECISION", "FLOAT", "FLOAT4", "FLOAT8",
		"DECIMAL", "DEC", "NUMERIC", "DATE", "TIME", "TIMESTAMP", "DATETIME",
		"YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL", "BINARY", "VARBINARY",
		"TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB", "TINYTEXT", "TEXT",
		"MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH",
		"DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND",
		"MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "HOUR_MICROSECOND",
		"DAY_MICROSECOND", "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_ARRAY_APPEND",
		"JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH",
		"JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MERGE",
		"JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG",
		"JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE",
		"JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_SEARCH",
		"JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_TABLE",
		"JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE", "NESTED", "ORDINALITY",
		"PATH", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "CUME_DIST",
		"DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", "LAG", "LAST_VALUE", "LEAD",
		"MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK", "RANK", "ROW_NUMBER",
		"STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP",
		"VARIANCE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME",
		"CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP",
		"NOW", "POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE",
		"UTC_TIME", "UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE",
		"ALGORITHM", "ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE",
		"AUTO_INCREMENT", "AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK",
		"BOOL", "BOOLEAN", "BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED",
		"CHANNEL", "CHECKSUM", "PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT",
		"CLOSE", "CLUSTERING", "COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT",
		"COLUMN_NAME", "COMMENT", "COMMIT", "COMPACT", "COMPLETION", "COMPRESSED",
		"COMPRESSION", "CONCURRENT", "CONNECT", "CONNECTION", "CONSISTENT",
		"CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", "CONSTRAINT_NAME", "CONTAINS",
		"CONTEXT", "CONTRIBUTORS", "COPY", "CPU", "CYCLE", "CURSOR_NAME", "DATA",
		"DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE",
		"DES_KEY_FILE", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE",
		"DUPLICATE", "DYNAMIC", "ENABLE", "ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID",
		"END", "ENDS", "ENGINE", "ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN",
		"EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT",
		"EXTENDED", "EXTENT_SIZE", "FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS",
		"FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING",
		"FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS",
		"GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS",
		"IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES",
		"INITIAL_SIZE", "INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT",
		"INVISIBLE", "INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER",
		"JSON", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL",
		"LIST", "LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION",
		"MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST",
		"MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT",
		"MASTER_RETRY_COUNT", "MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH",
		"MASTER_SSL_CERT", "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH",
		"MASTER_SSL_KEY", "MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR",
		"MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR",
		"MAX_USER_CONNECTIONS", "MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT",
		"MID", "MIGRATE", "MIN_ROWS", "MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO",
		"NAME", "NAMES", "NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY",
		"NOCYCLE", "NOMAXVALUE", "NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE",
		"ODBC", "OFFLINE", "OFFSET", "OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE",
		"ONLY", "OPEN", "OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS",
		"PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL", "PARSER", "PARTIAL",
		"PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", "PHASE",
		"PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING",
		"PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES",
		"PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE",
		"REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG",
		"REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE",
		"REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB",
		"REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION",
		"RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", "RETURNS",
		"REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT",
		"RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER",
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT",
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS",
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE",
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT",
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING",
		"SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND",
		"SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY",
		"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL",
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE",
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML",
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY",
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN",
		"AUDIT_ABORT_EXEMPT", "AUDIT_ADMIN", "AUTHENTICATION_POLICY_ADMIN",
		"BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN",
		"CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "EXECUTE", "FILE", "FIREWALL_ADMIN",
		"FIREWALL_EXEMPT", "FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS",
		"FLUSH_TABLES", "FLUSH_USER_RESOURCES", "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE",
		"INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA", "NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN",
		"PERSIST_RO_VARIABLES_ADMIN", "PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER",
		"REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER",
		"ROLE_ADMIN", "ROUTINE", "S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN",
		"SET_USER_ID", "SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN",
		"TABLES", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM",
		"RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD",
		"RTRIM", "SEC_TO_TIME", "SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER",
		"SHA", "SHA1", "SHA2", "SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX",
		"SQL_THREAD_WAIT_AFTER_GTIDS", "SQRT", "SRID", "STARTPOINT", "STRCMP",
		"STR_TO_DATE", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_ASWKB", "ST_ASWKT",
		"ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CROSSES", "ST_DIFFERENCE",
		"ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE",
		"ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", "ST_GEOMCOLLFROMTXT",
		"ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", "ST_GEOMETRYCOLLECTIONFROMWKB",
		"ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYN", "ST_GEOMETRYTYPE",
		"ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", "ST_INTERIORRINGN", "ST_INTERSECTION",
		"ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT",
		"ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT", "ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES",
		"ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", "ST_NUMPOINTS", "ST_OVERLAPS",
		"ST_POINTFROMTEXT", "ST_POINTFROMWKB", "ST_POINTN", "ST_POLYFROMTEXT",
		"ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", "ST_POLYGONFROMWKB", "ST_SRID",
		"ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN",
		"ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", "SUBTIME", "SYSTEM_USER",
		"TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_FORMAT", "TIME_TO_SEC",
		"TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "TP_CONNECTION_ADMIN",
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP",
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH",
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR",
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN",
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE",
		"PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL",
		"EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP",
		"DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL",
		"ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB",
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING",
		"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
		"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
		"BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID",
		"HOST_IP_ADDRESS", "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION",
	}
	staticData.RuleNames = []string{
		"root", "sqlStatements", "sqlStatement", "emptyStatement_", "ddlStatement",
		"dmlStatement", "transactionStatement", "replicationStatement", "preparedStatement",
		"compoundStatement", "administrationStatement", "utilityStatement",
		"createDatabase", "createEvent", "createIndex", "createLogfileGroup",
		"createProcedure", "createFunction", "createRole", "createServer", "createTable",
		"createTablespaceInnodb", "createTablespaceNdb", "createTrigger", "withClause",
		"commonTableExpressions", "cteName", "cteColumnName", "createView",
		"createDatabaseOption", "charSet", "currentUserExpression", "ownerStatement",
		"scheduleExpression", "timestampValue", "intervalExpr", "intervalType",
		"enableType", "indexType", "indexOption", "procedureParameter", "functionParameter",
		"routineOption", "serverOption", "createDefinitions", "createDefinition",
		"columnDefinition", "columnConstraint", "tableConstraint", "referenceDefinition",
		"referenceAction", "referenceControlType", "indexColumnDefinition",
		"tableOption", "tableType", "tablespaceStorage", "partitionDefinitions",
		"partitionFunctionDefinition", "subpartitionFunctionDefinition", "partitionDefinition",
		"partitionDefinerAtom", "partitionDefinerVector", "subpartitionDefinition",
		"partitionOption", "alterDatabase", "alterEvent", "alterFunction", "alterInstance",
		"alterLogfileGroup", "alterProcedure", "alterServer", "alterTable",
		"alterTablespace", "alterView", "alterSpecification", "alterPartitionSpecification",
		"dropDatabase", "dropEvent", "dropIndex", "dropLogfileGroup", "dropProcedure",
		"dropFunction", "dropServer", "dropTable", "dropTablespace", "dropTrigger",
		"dropView", "dropRole", "setRole", "renameTable", "renameTableClause",
		"truncateTable", "callStatement", "deleteStatement", "doStatement",
		"handlerStatement", "insertStatement", "loadDataStatement", "loadXmlStatement",
		"replaceStatement", "selectStatement", "updateStatement", "valuesStatement",
		"insertStatementValue", "updatedElement", "assignmentField", "lockClause",
		"singleDeleteStatement", "multipleDeleteStatement", "handlerOpenStatement",
		"handlerReadIndexStatement", "handlerReadStatement", "handlerCloseStatement",
		"singleUpdateStatement", "multipleUpdateStatement", "orderByClause",
		"orderByExpression", "tableSources", "tableSource", "tableSourceItem",
		"indexHint", "indexHintType", "joinPart", "joinSpec", "queryExpression",
		"queryExpressionNointo", "querySpecification", "proxyHint", "querySpecificationNointo",
		"unionParenthesis", "unionStatement", "lateralStatement", "jsonTable",
		"jsonColumnList", "jsonColumn", "jsonOnEmpty", "jsonOnError", "selectSpec",
		"selectElements", "selectElement", "selectIntoExpression", "selectFieldsInto",
		"selectLinesInto", "fromClause", "groupByClause", "havingClause", "windowClause",
		"groupByItem", "limitClause", "limitClauseAtom", "startTransaction",
		"beginWork", "commitWork", "rollbackWork", "savepointStatement", "rollbackStatement",
		"releaseStatement", "lockTables", "unlockTables", "setAutocommitStatement",
		"setTransactionStatement", "transactionMode", "lockTableElement", "lockAction",
		"transactionOption", "transactionLevel", "changeMaster", "changeReplicationFilter",
		"purgeBinaryLogs", "resetMaster", "resetSlave", "startSlave", "stopSlave",
		"startGroupReplication", "stopGroupReplication", "masterOption", "stringMasterOption",
		"decimalMasterOption", "boolMasterOption", "channelOption", "replicationFilter",
		"tablePair", "threadType", "untilOption", "connectionOption", "gtuidSet",
		"xaStartTransaction", "xaEndTransaction", "xaPrepareStatement", "xaCommitWork",
		"xaRollbackWork", "xaRecoverWork", "prepareStatement", "executeStatement",
		"deallocatePrepare", "routineBody", "blockStatement", "caseStatement",
		"ifStatement", "iterateStatement", "leaveStatement", "loopStatement",
		"repeatStatement", "returnStatement", "whileStatement", "cursorStatement",
		"declareVariable", "declareCondition", "declareCursor", "declareHandler",
		"handlerConditionValue", "procedureSqlStatement", "caseAlternative",
		"elifAlternative", "alterUser", "createUser", "dropUser", "grantStatement",
		"roleOption", "grantProxy", "renameUser", "revokeStatement", "revokeProxy",
		"setPasswordStatement", "userSpecification", "userAuthOption", "authOptionClause",
		"authenticationRule", "tlsOption", "userResourceOption", "userPasswordOption",
		"userLockOption", "privelegeClause", "privilege", "privilegeLevel",
		"renameUserClause", "analyzeTable", "checkTable", "checksumTable", "optimizeTable",
		"repairTable", "checkTableOption", "createUdfunction", "installPlugin",
		"uninstallPlugin", "setStatement", "showStatement", "variableClause",
		"showCommonEntity", "showFilter", "showGlobalInfoClause", "showSchemaEntity",
		"showProfileType", "binlogStatement", "cacheIndexStatement", "flushStatement",
		"killStatement", "loadIndexIntoCache", "resetStatement", "shutdownStatement",
		"tableIndexes", "flushOption", "flushTableOption", "loadedTableIndexes",
		"simpleDescribeStatement", "fullDescribeStatement", "helpStatement",
		"useStatement", "signalStatement", "resignalStatement", "signalConditionInformation",
		"withStatement", "tableStatement", "diagnosticsStatement", "diagnosticsConditionInformationName",
		"describeObjectClause", "fullId", "tableName", "roleName", "fullColumnName",
		"indexColumnName", "simpleUserName", "hostName", "userName", "mysqlVariable",
		"charsetName", "collationName", "engineName", "engineNameBase", "uuidSet",
		"xid", "xuidStringId", "authPlugin", "uid", "simpleId", "dottedId",
		"decimalLiteral", "fileSizeLiteral", "stringLiteral", "booleanLiteral",
		"hexadecimalLiteral", "nullNotnull", "constant", "dataType", "collectionOptions",
		"convertedDataType", "lengthOneDimension", "lengthTwoDimension", "lengthTwoOptionalDimension",
		"uidList", "fullColumnNameList", "tables", "indexColumnNames", "expressions",
		"expressionsWithDefaults", "constants", "simpleStrings", "userVariables",
		"defaultValue", "currentTimestamp", "expressionOrDefault", "ifExists",
		"ifNotExists", "orReplace", "waitNowaitClause", "functionCall", "specificFunction",
		"caseFuncAlternative", "levelsInWeightString", "levelInWeightListElement",
		"aggregateWindowedFunction", "nonAggregateWindowedFunction", "overClause",
		"windowSpec", "windowName", "frameClause", "frameUnits", "frameExtent",
		"frameBetween", "frameRange", "partitionClause", "scalarFunctionName",
		"passwordFunctionClause", "functionArgs", "functionArg", "expression",
		"predicate", "expressionAtom", "unaryOperator", "comparisonOperator",
		"logicalOperator", "bitOperator", "multOperator", "addOperator", "jsonOperator",
		"charsetNameBase", "transactionLevelBase", "privilegesBase", "intervalTypeBase",
		"dataTypeBase", "keywordsCanBeId", "functionNameBase",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1160, 7481, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 1, 0, 3, 0, 726, 8, 0, 1, 0, 1, 0, 3, 0, 730, 8, 0,
		1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 3, 1, 737, 8, 1, 1, 1, 3, 1, 740, 8, 1, 1,
		1, 5, 1, 743, 8, 1, 10, 1, 12, 1, 746, 9, 1, 1, 1, 1, 1, 1, 1, 3, 1, 751,
		8, 1, 1, 1, 3, 1, 754, 8, 1, 1, 1, 3, 1, 757, 8, 1, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 3, 2, 766, 8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 808,
		8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 823, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 3, 6, 834, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 851, 8, 7, 1, 8,
		1, 8, 1, 8, 3, 8, 856, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 871, 8, 9, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 3, 10, 898, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 907, 8, 11, 1, 12, 1, 12, 1, 12, 3, 12, 912, 8, 12, 1, 12, 1,
		12, 5, 12, 916, 8, 12, 10, 12, 12, 12, 919, 9, 12, 1, 13, 1, 13, 3, 13,
		923, 8, 13, 1, 13, 1, 13, 3, 13, 927, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 3, 13, 936, 8, 13, 1, 13, 3, 13, 939, 8, 13, 1, 13,
		3, 13, 942, 8, 13, 1, 13, 1, 13, 3, 13, 946, 8, 13, 1, 13, 1, 13, 1, 13,
		1, 14, 1, 14, 3, 14, 953, 8, 14, 1, 14, 3, 14, 956, 8, 14, 1, 14, 1, 14,
		1, 14, 3, 14, 961, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 967, 8, 14,
		10, 14, 12, 14, 970, 9, 14, 1, 14, 1, 14, 3, 14, 974, 8, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 979, 8, 14, 1, 14, 5, 14, 982, 8, 14, 10, 14, 12, 14,
		985, 9, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 3, 15, 996, 8, 15, 1, 15, 3, 15, 999, 8, 15, 1, 15, 1, 15, 3, 15, 1003,
		8, 15, 1, 15, 3, 15, 1006, 8, 15, 1, 15, 1, 15, 3, 15, 1010, 8, 15, 1,
		15, 3, 15, 1013, 8, 15, 1, 15, 1, 15, 3, 15, 1017, 8, 15, 1, 15, 3, 15,
		1020, 8, 15, 1, 15, 3, 15, 1023, 8, 15, 1, 15, 1, 15, 3, 15, 1027, 8, 15,
		1, 15, 3, 15, 1030, 8, 15, 1, 15, 1, 15, 3, 15, 1034, 8, 15, 1, 15, 1,
		15, 1, 16, 1, 16, 3, 16, 1040, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16,
		1046, 8, 16, 1, 16, 1, 16, 5, 16, 1050, 8, 16, 10, 16, 12, 16, 1053, 9,
		16, 1, 16, 1, 16, 5, 16, 1057, 8, 16, 10, 16, 12, 16, 1060, 9, 16, 1, 16,
		1, 16, 1, 17, 1, 17, 3, 17, 1066, 8, 17, 1, 17, 3, 17, 1069, 8, 17, 1,
		17, 1, 17, 3, 17, 1073, 8, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1078, 8, 17,
		1, 17, 1, 17, 5, 17, 1082, 8, 17, 10, 17, 12, 17, 1085, 9, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 5, 17, 1091, 8, 17, 10, 17, 12, 17, 1094, 9, 17, 1, 17,
		1, 17, 3, 17, 1098, 8, 17, 1, 18, 1, 18, 1, 18, 3, 18, 1103, 8, 18, 1,
		18, 1, 18, 1, 18, 5, 18, 1108, 8, 18, 10, 18, 12, 18, 1111, 9, 18, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 5, 19, 1125, 8, 19, 10, 19, 12, 19, 1128, 9, 19, 1, 19, 1, 19, 1, 20,
		1, 20, 3, 20, 1134, 8, 20, 1, 20, 1, 20, 3, 20, 1138, 8, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1148, 8, 20, 1, 20,
		1, 20, 3, 20, 1152, 8, 20, 1, 20, 1, 20, 3, 20, 1156, 8, 20, 1, 20, 1,
		20, 3, 20, 1160, 8, 20, 1, 20, 1, 20, 3, 20, 1164, 8, 20, 1, 20, 5, 20,
		1167, 8, 20, 10, 20, 12, 20, 1170, 9, 20, 3, 20, 1172, 8, 20, 1, 20, 3,
		20, 1175, 8, 20, 1, 20, 3, 20, 1178, 8, 20, 1, 20, 3, 20, 1181, 8, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1187, 8, 20, 1, 20, 1, 20, 3, 20, 1191,
		8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1197, 8, 20, 1, 20, 5, 20, 1200,
		8, 20, 10, 20, 12, 20, 1203, 9, 20, 3, 20, 1205, 8, 20, 1, 20, 3, 20, 1208,
		8, 20, 3, 20, 1210, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 3, 21, 1221, 8, 21, 1, 21, 1, 21, 3, 21, 1225, 8, 21,
		1, 21, 3, 21, 1228, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1242, 8, 22, 1, 22, 3, 22,
		1245, 8, 22, 1, 22, 1, 22, 3, 22, 1249, 8, 22, 1, 22, 3, 22, 1252, 8, 22,
		1, 22, 1, 22, 3, 22, 1256, 8, 22, 1, 22, 3, 22, 1259, 8, 22, 1, 22, 1,
		22, 3, 22, 1263, 8, 22, 1, 22, 3, 22, 1266, 8, 22, 1, 22, 1, 22, 3, 22,
		1270, 8, 22, 1, 22, 3, 22, 1273, 8, 22, 1, 22, 3, 22, 1276, 8, 22, 1, 22,
		1, 22, 3, 22, 1280, 8, 22, 1, 22, 3, 22, 1283, 8, 22, 1, 22, 1, 22, 3,
		22, 1287, 8, 22, 1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 1293, 8, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3,
		23, 1306, 8, 23, 1, 23, 1, 23, 1, 24, 1, 24, 3, 24, 1312, 8, 24, 1, 24,
		1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 1321, 8, 25, 10, 25, 12,
		25, 1324, 9, 25, 1, 25, 1, 25, 3, 25, 1328, 8, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 3, 25, 1336, 8, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1,
		28, 1, 28, 3, 28, 1344, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1349, 8, 28,
		1, 28, 3, 28, 1352, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1357, 8, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1365, 8, 28, 1, 28, 1, 28,
		1, 28, 3, 28, 1370, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1376, 8,
		28, 1, 28, 1, 28, 1, 28, 3, 28, 1381, 8, 28, 1, 28, 1, 28, 3, 28, 1385,
		8, 28, 3, 28, 1387, 8, 28, 1, 29, 3, 29, 1390, 8, 29, 1, 29, 1, 29, 3,
		29, 1394, 8, 29, 1, 29, 1, 29, 3, 29, 1398, 8, 29, 1, 29, 3, 29, 1401,
		8, 29, 1, 29, 1, 29, 3, 29, 1405, 8, 29, 1, 29, 1, 29, 3, 29, 1409, 8,
		29, 1, 29, 1, 29, 3, 29, 1413, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29,
		1419, 8, 29, 1, 29, 3, 29, 1422, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1429, 8, 30, 1, 31, 1, 31, 1, 31, 3, 31, 1434, 8, 31, 1, 32,
		1, 32, 1, 32, 1, 32, 3, 32, 1440, 8, 32, 1, 33, 1, 33, 1, 33, 5, 33, 1445,
		8, 33, 10, 33, 12, 33, 1448, 9, 33, 1, 33, 1, 33, 1, 33, 3, 33, 1453, 8,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1459, 8, 33, 10, 33, 12, 33, 1462,
		9, 33, 3, 33, 1464, 8, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1469, 8, 33, 10,
		33, 12, 33, 1472, 9, 33, 3, 33, 1474, 8, 33, 3, 33, 1476, 8, 33, 1, 34,
		1, 34, 1, 34, 1, 34, 3, 34, 1482, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 3,
		35, 1488, 8, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 1505, 8, 36, 1,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1512, 8, 37, 1, 38, 1, 38, 1, 38,
		1, 39, 1, 39, 3, 39, 1519, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 1531, 8, 39, 1, 39, 1, 39, 1, 39,
		3, 39, 1536, 8, 39, 1, 39, 3, 39, 1539, 8, 39, 1, 40, 3, 40, 1542, 8, 40,
		1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 3, 42, 1555, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1568, 8, 42, 1, 42, 1, 42, 1, 42, 3,
		42, 1573, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1589, 8, 43, 1, 44, 1,
		44, 1, 44, 1, 44, 5, 44, 1595, 8, 44, 10, 44, 12, 44, 1598, 9, 44, 1, 44,
		1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1607, 8, 45, 1, 45, 3,
		45, 1610, 8, 45, 1, 45, 3, 45, 1613, 8, 45, 1, 46, 1, 46, 5, 46, 1617,
		8, 46, 10, 46, 12, 46, 1620, 9, 46, 1, 46, 3, 46, 1623, 8, 46, 1, 46, 3,
		46, 1626, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 3, 47, 1637, 8, 47, 1, 47, 3, 47, 1640, 8, 47, 1, 47, 1, 47, 1,
		47, 3, 47, 1645, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1658, 8, 47, 1, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 3, 47, 1665, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47,
		1672, 8, 47, 3, 47, 1674, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3,
		47, 1681, 8, 47, 1, 48, 1, 48, 3, 48, 1685, 8, 48, 3, 48, 1687, 8, 48,
		1, 48, 1, 48, 1, 48, 3, 48, 1692, 8, 48, 1, 48, 3, 48, 1695, 8, 48, 1,
		48, 1, 48, 5, 48, 1699, 8, 48, 10, 48, 12, 48, 1702, 9, 48, 1, 48, 1, 48,
		3, 48, 1706, 8, 48, 3, 48, 1708, 8, 48, 1, 48, 1, 48, 3, 48, 1712, 8, 48,
		1, 48, 3, 48, 1715, 8, 48, 1, 48, 3, 48, 1718, 8, 48, 1, 48, 1, 48, 5,
		48, 1722, 8, 48, 10, 48, 12, 48, 1725, 9, 48, 1, 48, 1, 48, 3, 48, 1729,
		8, 48, 3, 48, 1731, 8, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1736, 8, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1743, 8, 48, 3, 48, 1745, 8, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1752, 8, 48, 1, 49, 1, 49, 1,
		49, 3, 49, 1757, 8, 49, 1, 49, 1, 49, 3, 49, 1761, 8, 49, 1, 49, 3, 49,
		1764, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1772, 8,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1780, 8, 50, 3, 50,
		1782, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3,
		51, 1792, 8, 51, 1, 52, 1, 52, 3, 52, 1796, 8, 52, 1, 52, 3, 52, 1799,
		8, 52, 1, 52, 1, 52, 5, 52, 1803, 8, 52, 10, 52, 12, 52, 1806, 9, 52, 1,
		52, 1, 52, 3, 52, 1810, 8, 52, 1, 52, 3, 52, 1813, 8, 52, 1, 52, 1, 52,
		5, 52, 1817, 8, 52, 10, 52, 12, 52, 1820, 9, 52, 3, 52, 1822, 8, 52, 1,
		53, 1, 53, 3, 53, 1826, 8, 53, 1, 53, 3, 53, 1829, 8, 53, 1, 53, 1, 53,
		3, 53, 1833, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1838, 8, 53, 1, 53, 1,
		53, 1, 53, 3, 53, 1843, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1848, 8, 53,
		1, 53, 1, 53, 3, 53, 1852, 8, 53, 1, 53, 1, 53, 3, 53, 1856, 8, 53, 1,
		53, 1, 53, 3, 53, 1860, 8, 53, 1, 53, 1, 53, 3, 53, 1864, 8, 53, 1, 53,
		1, 53, 3, 53, 1868, 8, 53, 1, 53, 1, 53, 3, 53, 1872, 8, 53, 1, 53, 1,
		53, 1, 53, 3, 53, 1877, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1882, 8, 53,
		1, 53, 1, 53, 1, 53, 3, 53, 1887, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3,
		53, 1893, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1898, 8, 53, 1, 53, 1, 53,
		1, 53, 3, 53, 1903, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1908, 8, 53, 1,
		53, 1, 53, 1, 53, 3, 53, 1913, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1918,
		8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1924, 8, 53, 1, 53, 1, 53, 1,
		53, 3, 53, 1929, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1934, 8, 53, 1, 53,
		1, 53, 1, 53, 3, 53, 1939, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1944, 8,
		53, 1, 53, 1, 53, 1, 53, 3, 53, 1949, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53,
		1954, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1959, 8, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 3, 53, 1966, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1971,
		8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1976, 8, 53, 1, 53, 1, 53, 1, 53, 3,
		53, 1981, 8, 53, 1, 53, 1, 53, 3, 53, 1985, 8, 53, 1, 53, 1, 53, 1, 53,
		3, 53, 1990, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1998,
		8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 2003, 8, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 3, 53, 2009, 8, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 2021, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 3, 56, 2028, 8, 56, 3, 56, 2030, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		5, 56, 2036, 8, 56, 10, 56, 12, 56, 2039, 9, 56, 1, 56, 1, 56, 3, 56, 2043,
		8, 56, 1, 57, 3, 57, 2046, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 3, 57, 2054, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2060, 8, 57,
		1, 57, 1, 57, 3, 57, 2064, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2077, 8, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2089, 8,
		57, 3, 57, 2091, 8, 57, 1, 58, 3, 58, 2094, 8, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 3, 58, 2102, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3,
		58, 2108, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 2114, 8, 58, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2125, 8,
		59, 10, 59, 12, 59, 2128, 9, 59, 1, 59, 1, 59, 5, 59, 2132, 8, 59, 10,
		59, 12, 59, 2135, 9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2141, 8, 59,
		10, 59, 12, 59, 2144, 9, 59, 1, 59, 1, 59, 3, 59, 2148, 8, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2157, 8, 59, 10, 59, 12,
		59, 2160, 9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2166, 8, 59, 10, 59,
		12, 59, 2169, 9, 59, 1, 59, 1, 59, 3, 59, 2173, 8, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2183, 8, 59, 10, 59, 12,
		59, 2186, 9, 59, 1, 59, 1, 59, 5, 59, 2190, 8, 59, 10, 59, 12, 59, 2193,
		9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2199, 8, 59, 10, 59, 12, 59,
		2202, 9, 59, 1, 59, 1, 59, 3, 59, 2206, 8, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2216, 8, 59, 10, 59, 12, 59, 2219,
		9, 59, 1, 59, 1, 59, 5, 59, 2223, 8, 59, 10, 59, 12, 59, 2226, 9, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 5, 59, 2232, 8, 59, 10, 59, 12, 59, 2235, 9, 59,
		1, 59, 1, 59, 3, 59, 2239, 8, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2244, 8,
		59, 10, 59, 12, 59, 2247, 9, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2253,
		8, 59, 10, 59, 12, 59, 2256, 9, 59, 1, 59, 1, 59, 3, 59, 2260, 8, 59, 3,
		59, 2262, 8, 59, 1, 60, 1, 60, 1, 60, 3, 60, 2267, 8, 60, 1, 61, 1, 61,
		1, 61, 1, 61, 4, 61, 2273, 8, 61, 11, 61, 12, 61, 2274, 1, 61, 1, 61, 1,
		62, 1, 62, 1, 62, 5, 62, 2282, 8, 62, 10, 62, 12, 62, 2285, 9, 62, 1, 63,
		3, 63, 2288, 8, 63, 1, 63, 3, 63, 2291, 8, 63, 1, 63, 1, 63, 3, 63, 2295,
		8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2300, 8, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 3, 63, 2306, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2312, 8, 63,
		1, 63, 1, 63, 1, 63, 3, 63, 2317, 8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2322,
		8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2327, 8, 63, 1, 63, 1, 63, 1, 63, 3,
		63, 2332, 8, 63, 1, 63, 3, 63, 2335, 8, 63, 1, 64, 1, 64, 1, 64, 3, 64,
		2340, 8, 64, 1, 64, 4, 64, 2343, 8, 64, 11, 64, 12, 64, 2344, 1, 64, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2355, 8, 64, 1, 65,
		1, 65, 3, 65, 2359, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2366,
		8, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2371, 8, 65, 1, 65, 3, 65, 2374, 8,
		65, 1, 65, 1, 65, 1, 65, 3, 65, 2379, 8, 65, 1, 65, 3, 65, 2382, 8, 65,
		1, 65, 1, 65, 3, 65, 2386, 8, 65, 1, 65, 1, 65, 3, 65, 2390, 8, 65, 1,
		66, 1, 66, 1, 66, 1, 66, 5, 66, 2396, 8, 66, 10, 66, 12, 66, 2399, 9, 66,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 2417, 8, 68, 1, 68, 3, 68,
		2420, 8, 68, 1, 68, 3, 68, 2423, 8, 68, 1, 68, 1, 68, 3, 68, 2427, 8, 68,
		1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 5, 69, 2435, 8, 69, 10, 69, 12,
		69, 2438, 9, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		5, 70, 2448, 8, 70, 10, 70, 12, 70, 2451, 9, 70, 1, 70, 1, 70, 1, 71, 1,
		71, 3, 71, 2457, 8, 71, 1, 71, 3, 71, 2460, 8, 71, 1, 71, 1, 71, 1, 71,
		3, 71, 2465, 8, 71, 1, 71, 1, 71, 1, 71, 5, 71, 2470, 8, 71, 10, 71, 12,
		71, 2473, 9, 71, 3, 71, 2475, 8, 71, 1, 71, 3, 71, 2478, 8, 71, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2489, 8,
		72, 1, 72, 3, 72, 2492, 8, 72, 1, 72, 1, 72, 3, 72, 2496, 8, 72, 1, 72,
		1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2504, 8, 73, 1, 73, 3, 73, 2507,
		8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2512, 8, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 3, 73, 2520, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73,
		2526, 8, 73, 1, 73, 1, 73, 3, 73, 2530, 8, 73, 1, 74, 1, 74, 3, 74, 2534,
		8, 74, 1, 74, 5, 74, 2537, 8, 74, 10, 74, 12, 74, 2540, 9, 74, 1, 74, 1,
		74, 3, 74, 2544, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2551,
		8, 74, 1, 74, 1, 74, 3, 74, 2555, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 5, 74, 2564, 8, 74, 10, 74, 12, 74, 2567, 9, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2574, 8, 74, 1, 74, 3, 74, 2577, 8,
		74, 1, 74, 1, 74, 5, 74, 2581, 8, 74, 10, 74, 12, 74, 2584, 9, 74, 1, 74,
		1, 74, 1, 74, 3, 74, 2589, 8, 74, 3, 74, 2591, 8, 74, 1, 74, 1, 74, 1,
		74, 3, 74, 2596, 8, 74, 1, 74, 3, 74, 2599, 8, 74, 1, 74, 1, 74, 5, 74,
		2603, 8, 74, 10, 74, 12, 74, 2606, 9, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2611,
		8, 74, 3, 74, 2613, 8, 74, 1, 74, 1, 74, 3, 74, 2617, 8, 74, 1, 74, 3,
		74, 2620, 8, 74, 1, 74, 3, 74, 2623, 8, 74, 1, 74, 1, 74, 5, 74, 2627,
		8, 74, 10, 74, 12, 74, 2630, 9, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2635, 8,
		74, 1, 74, 3, 74, 2638, 8, 74, 1, 74, 1, 74, 5, 74, 2642, 8, 74, 10, 74,
		12, 74, 2645, 9, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2650, 8, 74, 3, 74, 2652,
		8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2657, 8, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 3, 74, 2665, 8, 74, 3, 74, 2667, 8, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2676, 8, 74, 1, 74, 3, 74, 2679,
		8, 74, 1, 74, 3, 74, 2682, 8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2687, 8,
		74, 3, 74, 2689, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		3, 74, 2698, 8, 74, 1, 74, 3, 74, 2701, 8, 74, 1, 74, 3, 74, 2704, 8, 74,
		1, 74, 1, 74, 1, 74, 3, 74, 2709, 8, 74, 3, 74, 2711, 8, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2720, 8, 74, 1, 74, 1, 74,
		1, 74, 3, 74, 2725, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3,
		74, 2733, 8, 74, 1, 74, 1, 74, 3, 74, 2737, 8, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 3, 74, 2745, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 3, 74, 2755, 8, 74, 1, 74, 1, 74, 1, 74, 3, 74,
		2760, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2767, 8, 74, 1,
		74, 1, 74, 3, 74, 2771, 8, 74, 1, 74, 1, 74, 3, 74, 2775, 8, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2794, 8, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2804, 8, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 3, 74, 2810, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3,
		74, 2827, 8, 74, 1, 74, 1, 74, 3, 74, 2831, 8, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2841, 8, 74, 1, 74, 1, 74, 1,
		74, 3, 74, 2846, 8, 74, 1, 74, 3, 74, 2849, 8, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2858, 8, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2869, 8, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 5, 74, 2875, 8, 74, 10, 74, 12, 74, 2878, 9, 74, 1, 74, 1,
		74, 1, 74, 3, 74, 2883, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		5, 75, 2891, 8, 75, 10, 75, 12, 75, 2894, 9, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2905, 8, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 3, 75, 2912, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 3, 75, 2919, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 5, 75, 2932, 8, 75, 10, 75, 12, 75, 2935, 9,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		3, 75, 2947, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2953, 8, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 3, 75, 2959, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		3, 75, 2965, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2971, 8, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 3, 75, 2977, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		3, 75, 2983, 8, 75, 1, 76, 1, 76, 1, 76, 3, 76, 2988, 8, 76, 1, 76, 1,
		76, 1, 77, 1, 77, 1, 77, 3, 77, 2995, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78,
		1, 78, 3, 78, 3002, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 3009,
		8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 3014, 8, 78, 1, 78, 5, 78, 3017, 8,
		78, 10, 78, 12, 78, 3020, 9, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 3, 80, 3033, 8, 80, 1, 80, 1, 80,
		1, 81, 1, 81, 1, 81, 3, 81, 3040, 8, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1,
		82, 3, 82, 3047, 8, 82, 1, 82, 1, 82, 1, 83, 1, 83, 3, 83, 3053, 8, 83,
		1, 83, 1, 83, 3, 83, 3057, 8, 83, 1, 83, 1, 83, 3, 83, 3061, 8, 83, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 3068, 8, 84, 1, 84, 3, 84, 3071,
		8, 84, 1, 85, 1, 85, 1, 85, 3, 85, 3076, 8, 85, 1, 85, 1, 85, 1, 86, 1,
		86, 1, 86, 3, 86, 3083, 8, 86, 1, 86, 1, 86, 1, 86, 5, 86, 3088, 8, 86,
		10, 86, 12, 86, 3091, 9, 86, 1, 86, 3, 86, 3094, 8, 86, 1, 87, 1, 87, 1,
		87, 3, 87, 3099, 8, 87, 1, 87, 1, 87, 1, 87, 5, 87, 3104, 8, 87, 10, 87,
		12, 87, 3107, 9, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1,
		88, 5, 88, 3117, 8, 88, 10, 88, 12, 88, 3120, 9, 88, 3, 88, 3122, 8, 88,
		1, 88, 1, 88, 1, 88, 3, 88, 3127, 8, 88, 1, 88, 1, 88, 1, 88, 3, 88, 3132,
		8, 88, 5, 88, 3134, 8, 88, 10, 88, 12, 88, 3137, 9, 88, 1, 88, 1, 88, 1,
		88, 3, 88, 3142, 8, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 3149,
		8, 89, 10, 89, 12, 89, 3152, 9, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91,
		1, 91, 3, 91, 3160, 8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 3, 92, 3169, 8, 92, 1, 92, 3, 92, 3172, 8, 92, 1, 93, 1, 93, 3, 93,
		3176, 8, 93, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 3185,
		8, 95, 1, 96, 1, 96, 3, 96, 3189, 8, 96, 1, 96, 3, 96, 3192, 8, 96, 1,
		96, 3, 96, 3195, 8, 96, 1, 96, 3, 96, 3198, 8, 96, 1, 96, 1, 96, 1, 96,
		1, 96, 3, 96, 3204, 8, 96, 1, 96, 3, 96, 3207, 8, 96, 1, 96, 1, 96, 3,
		96, 3211, 8, 96, 1, 96, 3, 96, 3214, 8, 96, 1, 96, 1, 96, 3, 96, 3218,
		8, 96, 1, 96, 3, 96, 3221, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 3227,
		8, 96, 10, 96, 12, 96, 3230, 9, 96, 3, 96, 3232, 8, 96, 1, 96, 1, 96, 1,
		96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 3241, 8, 96, 10, 96, 12, 96, 3244,
		9, 96, 3, 96, 3246, 8, 96, 1, 97, 1, 97, 1, 97, 3, 97, 3251, 8, 97, 1,
		97, 3, 97, 3254, 8, 97, 1, 97, 1, 97, 1, 97, 3, 97, 3259, 8, 97, 1, 97,
		1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 3269, 8, 97, 1,
		97, 1, 97, 1, 97, 3, 97, 3274, 8, 97, 1, 97, 1, 97, 4, 97, 3278, 8, 97,
		11, 97, 12, 97, 3279, 3, 97, 3282, 8, 97, 1, 97, 1, 97, 4, 97, 3286, 8,
		97, 11, 97, 12, 97, 3287, 3, 97, 3290, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97,
		3, 97, 3296, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97, 3302, 8, 97, 10,
		97, 12, 97, 3305, 9, 97, 1, 97, 1, 97, 3, 97, 3309, 8, 97, 1, 97, 1, 97,
		1, 97, 1, 97, 5, 97, 3315, 8, 97, 10, 97, 12, 97, 3318, 9, 97, 3, 97, 3320,
		8, 97, 1, 98, 1, 98, 1, 98, 3, 98, 3325, 8, 98, 1, 98, 3, 98, 3328, 8,
		98, 1, 98, 1, 98, 1, 98, 3, 98, 3333, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98,
		1, 98, 1, 98, 3, 98, 3341, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1,
		98, 3, 98, 3349, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 3355, 8, 98,
		1, 98, 1, 98, 1, 98, 1, 98, 5, 98, 3361, 8, 98, 10, 98, 12, 98, 3364, 9,
		98, 1, 98, 1, 98, 3, 98, 3368, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 5, 98,
		3374, 8, 98, 10, 98, 12, 98, 3377, 9, 98, 3, 98, 3379, 8, 98, 1, 99, 1,
		99, 3, 99, 3383, 8, 99, 1, 99, 3, 99, 3386, 8, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 3, 99, 3394, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3,
		99, 3400, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 5, 99, 3407, 8, 99,
		10, 99, 12, 99, 3410, 9, 99, 3, 99, 3412, 8, 99, 1, 100, 1, 100, 3, 100,
		3416, 8, 100, 1, 100, 1, 100, 3, 100, 3420, 8, 100, 1, 100, 1, 100, 3,
		100, 3424, 8, 100, 1, 100, 4, 100, 3427, 8, 100, 11, 100, 12, 100, 3428,
		1, 100, 1, 100, 3, 100, 3433, 8, 100, 1, 100, 1, 100, 3, 100, 3437, 8,
		100, 3, 100, 3439, 8, 100, 1, 100, 3, 100, 3442, 8, 100, 1, 100, 3, 100,
		3445, 8, 100, 1, 100, 3, 100, 3448, 8, 100, 1, 100, 1, 100, 4, 100, 3452,
		8, 100, 11, 100, 12, 100, 3453, 1, 100, 1, 100, 3, 100, 3458, 8, 100, 1,
		100, 3, 100, 3461, 8, 100, 1, 100, 3, 100, 3464, 8, 100, 1, 100, 3, 100,
		3467, 8, 100, 1, 100, 3, 100, 3470, 8, 100, 1, 100, 1, 100, 1, 100, 4,
		100, 3475, 8, 100, 11, 100, 12, 100, 3476, 3, 100, 3479, 8, 100, 1, 101,
		1, 101, 3, 101, 3483, 8, 101, 1, 102, 1, 102, 1, 102, 3, 102, 3488, 8,
		102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 3494, 8, 102, 1, 102, 5, 102,
		3497, 8, 102, 10, 102, 12, 102, 3500, 9, 102, 1, 103, 1, 103, 1, 103, 1,
		103, 3, 103, 3506, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 3512,
		8, 103, 1, 103, 5, 103, 3515, 8, 103, 10, 103, 12, 103, 3518, 9, 103, 3,
		103, 3520, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 3526, 8, 104,
		1, 105, 1, 105, 3, 105, 3530, 8, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 106, 3, 106, 3538, 8, 106, 1, 107, 1, 107, 3, 107, 3542, 8, 107,
		1, 107, 3, 107, 3545, 8, 107, 1, 107, 3, 107, 3548, 8, 107, 1, 107, 3,
		107, 3551, 8, 107, 1, 107, 1, 107, 1, 107, 3, 107, 3556, 8, 107, 1, 107,
		3, 107, 3559, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 3566,
		8, 107, 1, 107, 1, 107, 3, 107, 3570, 8, 107, 1, 107, 3, 107, 3573, 8,
		107, 1, 107, 1, 107, 3, 107, 3577, 8, 107, 1, 108, 1, 108, 3, 108, 3581,
		8, 108, 1, 108, 3, 108, 3584, 8, 108, 1, 108, 3, 108, 3587, 8, 108, 1,
		108, 3, 108, 3590, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3595, 8, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3601, 8, 108, 5, 108, 3603, 8,
		108, 10, 108, 12, 108, 3606, 9, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1,
		108, 1, 108, 1, 108, 3, 108, 3615, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108,
		3, 108, 3621, 8, 108, 5, 108, 3623, 8, 108, 10, 108, 12, 108, 3626, 9,
		108, 1, 108, 1, 108, 1, 108, 3, 108, 3631, 8, 108, 1, 108, 1, 108, 3, 108,
		3635, 8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 3641, 8, 109, 1,
		109, 3, 109, 3644, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110,
		1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 3656, 8, 110, 1, 110, 1, 110, 3,
		110, 3660, 8, 110, 1, 110, 1, 110, 3, 110, 3664, 8, 110, 1, 111, 1, 111,
		1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 3672, 8, 111, 1, 111, 1, 111, 3,
		111, 3676, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 3, 113,
		3684, 8, 113, 1, 113, 3, 113, 3687, 8, 113, 1, 113, 3, 113, 3690, 8, 113,
		1, 113, 1, 113, 3, 113, 3694, 8, 113, 1, 113, 3, 113, 3697, 8, 113, 1,
		113, 1, 113, 1, 113, 1, 113, 5, 113, 3703, 8, 113, 10, 113, 12, 113, 3706,
		9, 113, 1, 113, 1, 113, 3, 113, 3710, 8, 113, 1, 113, 3, 113, 3713, 8,
		113, 1, 113, 3, 113, 3716, 8, 113, 1, 114, 1, 114, 3, 114, 3720, 8, 114,
		1, 114, 3, 114, 3723, 8, 114, 1, 114, 3, 114, 3726, 8, 114, 1, 114, 1,
		114, 1, 114, 1, 114, 1, 114, 5, 114, 3733, 8, 114, 10, 114, 12, 114, 3736,
		9, 114, 1, 114, 1, 114, 3, 114, 3740, 8, 114, 1, 115, 1, 115, 1, 115, 1,
		115, 1, 115, 5, 115, 3747, 8, 115, 10, 115, 12, 115, 3750, 9, 115, 1, 116,
		1, 116, 3, 116, 3754, 8, 116, 1, 117, 1, 117, 1, 117, 5, 117, 3759, 8,
		117, 10, 117, 12, 117, 3762, 9, 117, 1, 118, 1, 118, 5, 118, 3766, 8, 118,
		10, 118, 12, 118, 3769, 9, 118, 1, 118, 1, 118, 1, 118, 5, 118, 3774, 8,
		118, 10, 118, 12, 118, 3777, 9, 118, 1, 118, 1, 118, 1, 118, 3, 118, 3782,
		8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 3790, 8,
		119, 1, 119, 3, 119, 3793, 8, 119, 1, 119, 3, 119, 3796, 8, 119, 1, 119,
		1, 119, 1, 119, 5, 119, 3801, 8, 119, 10, 119, 12, 119, 3804, 9, 119, 3,
		119, 3806, 8, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 3813,
		8, 119, 1, 119, 3, 119, 3816, 8, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 3, 119, 3824, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120,
		3830, 8, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121, 1,
		121, 1, 121, 3, 121, 3841, 8, 121, 1, 122, 3, 122, 3844, 8, 122, 1, 122,
		1, 122, 3, 122, 3848, 8, 122, 1, 122, 1, 122, 5, 122, 3852, 8, 122, 10,
		122, 12, 122, 3855, 9, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 3861,
		8, 122, 10, 122, 12, 122, 3864, 9, 122, 1, 122, 1, 122, 3, 122, 3868, 8,
		122, 1, 122, 1, 122, 3, 122, 3872, 8, 122, 1, 122, 1, 122, 5, 122, 3876,
		8, 122, 10, 122, 12, 122, 3879, 9, 122, 1, 122, 1, 122, 1, 122, 3, 122,
		3884, 8, 122, 3, 122, 3886, 8, 122, 1, 122, 1, 122, 3, 122, 3890, 8, 122,
		1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 3899, 8,
		123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3,
		124, 3909, 8, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125,
		1, 125, 3, 125, 3919, 8, 125, 1, 126, 1, 126, 3, 126, 3923, 8, 126, 1,
		126, 5, 126, 3926, 8, 126, 10, 126, 12, 126, 3929, 9, 126, 1, 126, 1, 126,
		3, 126, 3933, 8, 126, 1, 126, 1, 126, 3, 126, 3937, 8, 126, 1, 126, 3,
		126, 3940, 8, 126, 1, 126, 3, 126, 3943, 8, 126, 1, 126, 3, 126, 3946,
		8, 126, 1, 126, 3, 126, 3949, 8, 126, 1, 126, 1, 126, 3, 126, 3953, 8,
		126, 1, 126, 5, 126, 3956, 8, 126, 10, 126, 12, 126, 3959, 9, 126, 1, 126,
		1, 126, 1, 126, 3, 126, 3964, 8, 126, 1, 126, 3, 126, 3967, 8, 126, 1,
		126, 3, 126, 3970, 8, 126, 1, 126, 3, 126, 3973, 8, 126, 1, 126, 3, 126,
		3976, 8, 126, 1, 126, 3, 126, 3979, 8, 126, 3, 126, 3981, 8, 126, 1, 127,
		1, 127, 1, 128, 1, 128, 5, 128, 3987, 8, 128, 10, 128, 12, 128, 3990, 9,
		128, 1, 128, 1, 128, 1, 128, 3, 128, 3995, 8, 128, 1, 128, 3, 128, 3998,
		8, 128, 1, 128, 3, 128, 4001, 8, 128, 1, 128, 3, 128, 4004, 8, 128, 1,
		128, 3, 128, 4007, 8, 128, 1, 128, 3, 128, 4010, 8, 128, 1, 129, 1, 129,
		3, 129, 4014, 8, 129, 1, 129, 1, 129, 1, 130, 1, 130, 3, 130, 4020, 8,
		130, 1, 130, 1, 130, 3, 130, 4024, 8, 130, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 3, 131, 4032, 8, 131, 1, 131, 1, 131, 3, 131, 4036, 8,
		131, 1, 131, 3, 131, 4039, 8, 131, 3, 131, 4041, 8, 131, 1, 132, 1, 132,
		1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132,
		3, 132, 4054, 8, 132, 1, 132, 3, 132, 4057, 8, 132, 1, 133, 1, 133, 1,
		133, 5, 133, 4062, 8, 133, 10, 133, 12, 133, 4065, 9, 133, 1, 134, 1, 134,
		1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 4074, 8, 134, 1, 134, 3,
		134, 4077, 8, 134, 1, 134, 1, 134, 1, 134, 3, 134, 4082, 8, 134, 3, 134,
		4084, 8, 134, 1, 134, 1, 134, 3, 134, 4088, 8, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 3, 134, 4096, 8, 134, 1, 135, 1, 135, 1, 135,
		1, 135, 3, 135, 4102, 8, 135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 1,
		136, 1, 136, 3, 136, 4111, 8, 136, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137,
		1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 4124, 8, 137, 1,
		138, 1, 138, 3, 138, 4128, 8, 138, 1, 138, 1, 138, 5, 138, 4132, 8, 138,
		10, 138, 12, 138, 4135, 9, 138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139,
		1, 139, 3, 139, 4143, 8, 139, 1, 139, 3, 139, 4146, 8, 139, 1, 139, 1,
		139, 3, 139, 4150, 8, 139, 1, 139, 3, 139, 4153, 8, 139, 1, 139, 1, 139,
		3, 139, 4157, 8, 139, 1, 139, 1, 139, 3, 139, 4161, 8, 139, 1, 139, 3,
		139, 4164, 8, 139, 3, 139, 4166, 8, 139, 1, 140, 1, 140, 1, 140, 1, 140,
		5, 140, 4172, 8, 140, 10, 140, 12, 140, 4175, 9, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 4186, 8, 140,
		1, 140, 1, 140, 4, 140, 4190, 8, 140, 11, 140, 12, 140, 4191, 3, 140, 4194,
		8, 140, 1, 140, 1, 140, 4, 140, 4198, 8, 140, 11, 140, 12, 140, 4199, 3,
		140, 4202, 8, 140, 3, 140, 4204, 8, 140, 1, 141, 1, 141, 1, 141, 1, 141,
		3, 141, 4210, 8, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3,
		141, 4218, 8, 141, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 3, 142,
		4226, 8, 142, 1, 143, 1, 143, 3, 143, 4230, 8, 143, 1, 143, 1, 143, 3,
		143, 4234, 8, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 5, 144, 4241,
		8, 144, 10, 144, 12, 144, 4244, 9, 144, 1, 144, 1, 144, 3, 144, 4248, 8,
		144, 1, 145, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1,
		146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 5, 146, 4266,
		8, 146, 10, 146, 12, 146, 4269, 9, 146, 1, 147, 1, 147, 3, 147, 4273, 8,
		147, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 4279, 8, 148, 1, 148, 1, 148,
		1, 148, 1, 148, 1, 148, 3, 148, 4286, 8, 148, 1, 149, 1, 149, 1, 149, 3,
		149, 4291, 8, 149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 5, 150, 4298,
		8, 150, 10, 150, 12, 150, 4301, 9, 150, 3, 150, 4303, 8, 150, 1, 151, 1,
		151, 3, 151, 4307, 8, 151, 1, 151, 3, 151, 4310, 8, 151, 1, 152, 1, 152,
		3, 152, 4314, 8, 152, 1, 152, 1, 152, 3, 152, 4318, 8, 152, 1, 152, 3,
		152, 4321, 8, 152, 1, 152, 3, 152, 4324, 8, 152, 1, 152, 3, 152, 4327,
		8, 152, 1, 152, 3, 152, 4330, 8, 152, 1, 153, 1, 153, 3, 153, 4334, 8,
		153, 1, 153, 1, 153, 3, 153, 4338, 8, 153, 1, 153, 3, 153, 4341, 8, 153,
		1, 153, 3, 153, 4344, 8, 153, 1, 153, 3, 153, 4347, 8, 153, 1, 153, 3,
		153, 4350, 8, 153, 1, 154, 1, 154, 1, 154, 1, 155, 1, 155, 3, 155, 4357,
		8, 155, 1, 155, 1, 155, 3, 155, 4361, 8, 155, 1, 155, 1, 155, 1, 156, 1,
		156, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 5, 157, 4374,
		8, 157, 10, 157, 12, 157, 4377, 9, 157, 1, 157, 3, 157, 4380, 8, 157, 1,
		158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 160, 1,
		160, 3, 160, 4392, 8, 160, 1, 160, 1, 160, 1, 160, 1, 160, 5, 160, 4398,
		8, 160, 10, 160, 12, 160, 4401, 9, 160, 1, 161, 1, 161, 1, 161, 1, 161,
		1, 161, 1, 161, 1, 161, 3, 161, 4410, 8, 161, 1, 162, 1, 162, 3, 162, 4414,
		8, 162, 1, 162, 3, 162, 4417, 8, 162, 1, 162, 1, 162, 1, 163, 1, 163, 3,
		163, 4423, 8, 163, 1, 163, 3, 163, 4426, 8, 163, 1, 163, 3, 163, 4429,
		8, 163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 3, 164,
		4438, 8, 164, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 3,
		165, 4447, 8, 165, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 5, 166,
		4455, 8, 166, 10, 166, 12, 166, 4458, 9, 166, 1, 166, 3, 166, 4461, 8,
		166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 5, 167, 4469, 8, 167,
		10, 167, 12, 167, 4472, 9, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168,
		1, 168, 1, 168, 3, 168, 4481, 8, 168, 1, 169, 1, 169, 1, 169, 1, 170, 1,
		170, 1, 170, 3, 170, 4489, 8, 170, 1, 170, 3, 170, 4492, 8, 170, 1, 171,
		1, 171, 1, 171, 1, 171, 1, 171, 5, 171, 4499, 8, 171, 10, 171, 12, 171,
		4502, 9, 171, 3, 171, 4504, 8, 171, 1, 171, 1, 171, 3, 171, 4508, 8, 171,
		1, 171, 5, 171, 4511, 8, 171, 10, 171, 12, 171, 4514, 9, 171, 1, 171, 3,
		171, 4517, 8, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 5, 172, 4524,
		8, 172, 10, 172, 12, 172, 4527, 9, 172, 3, 172, 4529, 8, 172, 1, 173, 1,
		173, 1, 173, 1, 174, 1, 174, 1, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1,
		175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1,
		175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 5, 175, 4558,
		8, 175, 10, 175, 12, 175, 4561, 9, 175, 3, 175, 4563, 8, 175, 1, 175, 3,
		175, 4566, 8, 175, 1, 176, 1, 176, 1, 177, 1, 177, 1, 178, 1, 178, 1, 179,
		1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		5, 180, 4620, 8, 180, 10, 180, 12, 180, 4623, 9, 180, 1, 180, 1, 180, 3,
		180, 4627, 8, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 182,
		1, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183,
		1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183,
		1, 183, 3, 183, 4655, 8, 183, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1,
		184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 3, 184, 4669, 8, 184,
		1, 185, 1, 185, 1, 185, 5, 185, 4674, 8, 185, 10, 185, 12, 185, 4677, 9,
		185, 1, 185, 3, 185, 4680, 8, 185, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186,
		4686, 8, 186, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 3, 187, 4694,
		8, 187, 3, 187, 4696, 8, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 189, 1,
		189, 1, 189, 1, 189, 1, 189, 3, 189, 4707, 8, 189, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 4717, 8, 191, 1, 192, 1,
		192, 1, 192, 1, 192, 1, 192, 3, 192, 4724, 8, 192, 1, 193, 1, 193, 1, 193,
		1, 193, 3, 193, 4730, 8, 193, 1, 194, 1, 194, 1, 194, 1, 194, 1, 195, 1,
		195, 3, 195, 4738, 8, 195, 1, 196, 1, 196, 1, 196, 3, 196, 4743, 8, 196,
		1, 196, 1, 196, 1, 196, 1, 196, 5, 196, 4749, 8, 196, 10, 196, 12, 196,
		4752, 9, 196, 1, 196, 1, 196, 1, 196, 5, 196, 4757, 8, 196, 10, 196, 12,
		196, 4760, 9, 196, 1, 196, 1, 196, 1, 196, 5, 196, 4765, 8, 196, 10, 196,
		12, 196, 4768, 9, 196, 1, 196, 1, 196, 1, 196, 5, 196, 4773, 8, 196, 10,
		196, 12, 196, 4776, 9, 196, 1, 196, 5, 196, 4779, 8, 196, 10, 196, 12,
		196, 4782, 9, 196, 1, 196, 1, 196, 3, 196, 4786, 8, 196, 1, 197, 1, 197,
		1, 197, 3, 197, 4791, 8, 197, 1, 197, 4, 197, 4794, 8, 197, 11, 197, 12,
		197, 4795, 1, 197, 1, 197, 4, 197, 4800, 8, 197, 11, 197, 12, 197, 4801,
		3, 197, 4804, 8, 197, 1, 197, 1, 197, 1, 197, 1, 198, 1, 198, 1, 198, 1,
		198, 4, 198, 4813, 8, 198, 11, 198, 12, 198, 4814, 1, 198, 5, 198, 4818,
		8, 198, 10, 198, 12, 198, 4821, 9, 198, 1, 198, 1, 198, 4, 198, 4825, 8,
		198, 11, 198, 12, 198, 4826, 3, 198, 4829, 8, 198, 1, 198, 1, 198, 1, 198,
		1, 199, 1, 199, 1, 199, 1, 200, 1, 200, 1, 200, 1, 201, 1, 201, 1, 201,
		3, 201, 4843, 8, 201, 1, 201, 1, 201, 4, 201, 4847, 8, 201, 11, 201, 12,
		201, 4848, 1, 201, 1, 201, 1, 201, 3, 201, 4854, 8, 201, 1, 202, 1, 202,
		1, 202, 3, 202, 4859, 8, 202, 1, 202, 1, 202, 4, 202, 4863, 8, 202, 11,
		202, 12, 202, 4864, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 4872,
		8, 202, 1, 203, 1, 203, 1, 203, 1, 204, 1, 204, 1, 204, 3, 204, 4880, 8,
		204, 1, 204, 1, 204, 1, 204, 1, 204, 4, 204, 4886, 8, 204, 11, 204, 12,
		204, 4887, 1, 204, 1, 204, 1, 204, 3, 204, 4893, 8, 204, 1, 205, 1, 205,
		1, 205, 1, 205, 3, 205, 4899, 8, 205, 1, 205, 3, 205, 4902, 8, 205, 1,
		205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 4910, 8, 205, 1, 206,
		1, 206, 1, 206, 1, 206, 1, 206, 3, 206, 4917, 8, 206, 1, 207, 1, 207, 1,
		207, 1, 207, 1, 207, 1, 207, 1, 207, 3, 207, 4926, 8, 207, 1, 207, 3, 207,
		4929, 8, 207, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 5, 209, 4944, 8, 209, 10,
		209, 12, 209, 4947, 9, 209, 1, 209, 1, 209, 1, 210, 1, 210, 1, 210, 3,
		210, 4954, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210,
		4962, 8, 210, 1, 211, 1, 211, 3, 211, 4966, 8, 211, 1, 211, 1, 211, 1,
		212, 1, 212, 1, 212, 3, 212, 4973, 8, 212, 1, 212, 1, 212, 4, 212, 4977,
		8, 212, 11, 212, 12, 212, 4978, 1, 213, 1, 213, 1, 213, 1, 213, 4, 213,
		4985, 8, 213, 11, 213, 12, 213, 4986, 1, 214, 1, 214, 1, 214, 1, 214, 1,
		214, 5, 214, 4994, 8, 214, 10, 214, 12, 214, 4997, 9, 214, 1, 214, 1, 214,
		1, 214, 3, 214, 5002, 8, 214, 1, 214, 1, 214, 1, 214, 5, 214, 5007, 8,
		214, 10, 214, 12, 214, 5010, 9, 214, 1, 214, 1, 214, 1, 214, 1, 214, 3,
		214, 5016, 8, 214, 1, 214, 5, 214, 5019, 8, 214, 10, 214, 12, 214, 5022,
		9, 214, 3, 214, 5024, 8, 214, 3, 214, 5026, 8, 214, 1, 214, 1, 214, 4,
		214, 5030, 8, 214, 11, 214, 12, 214, 5031, 3, 214, 5034, 8, 214, 1, 214,
		1, 214, 5, 214, 5038, 8, 214, 10, 214, 12, 214, 5041, 9, 214, 1, 214, 1,
		214, 1, 214, 1, 214, 3, 214, 5047, 8, 214, 1, 214, 1, 214, 1, 214, 3, 214,
		5052, 8, 214, 1, 214, 1, 214, 3, 214, 5056, 8, 214, 1, 214, 1, 214, 1,
		214, 1, 214, 3, 214, 5062, 8, 214, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215,
		5, 215, 5069, 8, 215, 10, 215, 12, 215, 5072, 9, 215, 1, 215, 1, 215, 1,
		215, 3, 215, 5077, 8, 215, 1, 215, 1, 215, 1, 215, 5, 215, 5082, 8, 215,
		10, 215, 12, 215, 5085, 9, 215, 1, 215, 1, 215, 1, 215, 3, 215, 5090, 8,
		215, 1, 215, 1, 215, 1, 215, 1, 215, 3, 215, 5096, 8, 215, 1, 215, 5, 215,
		5099, 8, 215, 10, 215, 12, 215, 5102, 9, 215, 3, 215, 5104, 8, 215, 3,
		215, 5106, 8, 215, 1, 215, 1, 215, 4, 215, 5110, 8, 215, 11, 215, 12, 215,
		5111, 3, 215, 5114, 8, 215, 1, 215, 1, 215, 5, 215, 5118, 8, 215, 10, 215,
		12, 215, 5121, 9, 215, 1, 215, 1, 215, 1, 215, 1, 215, 3, 215, 5127, 8,
		215, 3, 215, 5129, 8, 215, 1, 216, 1, 216, 1, 216, 3, 216, 5134, 8, 216,
		1, 216, 1, 216, 1, 216, 5, 216, 5139, 8, 216, 10, 216, 12, 216, 5142, 9,
		216, 1, 217, 1, 217, 1, 217, 1, 217, 5, 217, 5148, 8, 217, 10, 217, 12,
		217, 5151, 9, 217, 1, 217, 1, 217, 3, 217, 5155, 8, 217, 1, 217, 1, 217,
		1, 217, 1, 217, 1, 217, 5, 217, 5162, 8, 217, 10, 217, 12, 217, 5165, 9,
		217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 5171, 8, 217, 1, 217, 5, 217,
		5174, 8, 217, 10, 217, 12, 217, 5177, 9, 217, 3, 217, 5179, 8, 217, 3,
		217, 5181, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 5, 217, 5187, 8, 217,
		10, 217, 12, 217, 5190, 9, 217, 3, 217, 5192, 8, 217, 1, 217, 1, 217, 1,
		217, 1, 217, 1, 217, 1, 217, 3, 217, 5200, 8, 217, 1, 217, 1, 217, 1, 217,
		3, 217, 5205, 8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 5210, 8, 217, 5,
		217, 5212, 8, 217, 10, 217, 12, 217, 5215, 9, 217, 1, 217, 1, 217, 1, 217,
		3, 217, 5220, 8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 5225, 8, 217, 5,
		217, 5227, 8, 217, 10, 217, 12, 217, 5230, 9, 217, 1, 217, 1, 217, 1, 217,
		3, 217, 5235, 8, 217, 3, 217, 5237, 8, 217, 1, 218, 1, 218, 1, 218, 1,
		218, 1, 218, 1, 218, 1, 218, 5, 218, 5246, 8, 218, 10, 218, 12, 218, 5249,
		9, 218, 3, 218, 5251, 8, 218, 1, 218, 1, 218, 1, 218, 5, 218, 5256, 8,
		218, 10, 218, 12, 218, 5259, 9, 218, 3, 218, 5261, 8, 218, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 5, 219, 5271, 8, 219, 10,
		219, 12, 219, 5274, 9, 219, 1, 219, 1, 219, 1, 219, 3, 219, 5279, 8, 219,
		1, 220, 1, 220, 1, 220, 1, 220, 1, 220, 5, 220, 5286, 8, 220, 10, 220,
		12, 220, 5289, 9, 220, 1, 221, 1, 221, 1, 221, 1, 221, 5, 221, 5295, 8,
		221, 10, 221, 12, 221, 5298, 9, 221, 1, 221, 1, 221, 3, 221, 5302, 8, 221,
		1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 5, 221, 5309, 8, 221, 10, 221,
		12, 221, 5312, 9, 221, 1, 221, 1, 221, 1, 221, 3, 221, 5317, 8, 221, 1,
		221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 5, 221, 5326, 8, 221,
		10, 221, 12, 221, 5329, 9, 221, 1, 221, 1, 221, 1, 221, 3, 221, 5334, 8,
		221, 1, 221, 1, 221, 1, 221, 3, 221, 5339, 8, 221, 5, 221, 5341, 8, 221,
		10, 221, 12, 221, 5344, 9, 221, 1, 221, 1, 221, 1, 221, 3, 221, 5349, 8,
		221, 1, 221, 1, 221, 1, 221, 3, 221, 5354, 8, 221, 5, 221, 5356, 8, 221,
		10, 221, 12, 221, 5359, 9, 221, 3, 221, 5361, 8, 221, 1, 222, 1, 222, 1,
		222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 5, 222, 5371, 8, 222, 10,
		222, 12, 222, 5374, 9, 222, 1, 223, 1, 223, 1, 223, 1, 223, 3, 223, 5380,
		8, 223, 1, 223, 1, 223, 1, 223, 3, 223, 5385, 8, 223, 1, 224, 1, 224, 1,
		224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1,
		225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1,
		225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 3, 225, 5415,
		8, 225, 1, 226, 1, 226, 3, 226, 5419, 8, 226, 1, 226, 1, 226, 1, 226, 3,
		226, 5424, 8, 226, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 3, 227, 5431,
		8, 227, 1, 227, 3, 227, 5434, 8, 227, 1, 227, 1, 227, 1, 227, 1, 227, 3,
		227, 5440, 8, 227, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228,
		1, 228, 3, 228, 5450, 8, 228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1,
		229, 1, 229, 1, 229, 3, 229, 5460, 8, 229, 1, 230, 1, 230, 1, 230, 1, 230,
		1, 230, 1, 230, 1, 230, 1, 230, 3, 230, 5470, 8, 230, 1, 230, 1, 230, 1,
		230, 1, 230, 3, 230, 5476, 8, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230,
		1, 230, 1, 230, 3, 230, 5485, 8, 230, 1, 230, 1, 230, 1, 230, 1, 230, 3,
		230, 5491, 8, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 3, 230, 5498,
		8, 230, 3, 230, 5500, 8, 230, 1, 231, 1, 231, 1, 231, 1, 232, 1, 232, 1,
		232, 1, 232, 1, 232, 3, 232, 5510, 8, 232, 1, 233, 1, 233, 3, 233, 5514,
		8, 233, 1, 233, 1, 233, 3, 233, 5518, 8, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 5528, 8, 233, 1, 233, 1, 233,
		1, 233, 3, 233, 5533, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 3, 233, 5605, 8, 233, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234,
		1, 234, 1, 234, 3, 234, 5623, 8, 234, 1, 235, 1, 235, 1, 235, 1, 235, 1,
		236, 1, 236, 3, 236, 5631, 8, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236,
		1, 236, 1, 236, 1, 236, 5, 236, 5641, 8, 236, 10, 236, 12, 236, 5644, 9,
		236, 1, 236, 1, 236, 1, 236, 1, 236, 3, 236, 5650, 8, 236, 3, 236, 5652,
		8, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 5, 236, 5660, 8,
		236, 10, 236, 12, 236, 5663, 9, 236, 3, 236, 5665, 8, 236, 1, 237, 1, 237,
		1, 237, 1, 237, 5, 237, 5671, 8, 237, 10, 237, 12, 237, 5674, 9, 237, 1,
		238, 1, 238, 1, 238, 1, 238, 3, 238, 5680, 8, 238, 1, 239, 1, 239, 3, 239,
		5684, 8, 239, 1, 239, 1, 239, 1, 239, 1, 240, 1, 240, 3, 240, 5691, 8,
		240, 1, 240, 1, 240, 1, 240, 3, 240, 5696, 8, 240, 1, 240, 3, 240, 5699,
		8, 240, 1, 240, 3, 240, 5702, 8, 240, 1, 241, 1, 241, 1, 241, 1, 241, 1,
		241, 1, 241, 1, 241, 3, 241, 5711, 8, 241, 1, 242, 1, 242, 3, 242, 5715,
		8, 242, 1, 242, 1, 242, 3, 242, 5719, 8, 242, 1, 242, 1, 242, 1, 242, 1,
		242, 1, 242, 1, 242, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1,
		244, 1, 244, 1, 244, 1, 244, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 3,
		245, 5742, 8, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 3, 245, 5749,
		8, 245, 5, 245, 5751, 8, 245, 10, 245, 12, 245, 5754, 9, 245, 1, 245, 1,
		245, 1, 245, 1, 245, 3, 245, 5760, 8, 245, 1, 245, 1, 245, 1, 245, 1, 245,
		1, 245, 3, 245, 5767, 8, 245, 1, 245, 3, 245, 5770, 8, 245, 1, 245, 1,
		245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1,
		245, 1, 245, 5, 245, 5784, 8, 245, 10, 245, 12, 245, 5787, 9, 245, 3, 245,
		5789, 8, 245, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1,
		246, 3, 246, 5799, 8, 246, 1, 246, 1, 246, 3, 246, 5803, 8, 246, 1, 246,
		1, 246, 1, 246, 1, 246, 3, 246, 5809, 8, 246, 1, 246, 3, 246, 5812, 8,
		246, 1, 246, 1, 246, 1, 246, 3, 246, 5817, 8, 246, 1, 246, 1, 246, 3, 246,
		5821, 8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 5828, 8,
		246, 1, 246, 3, 246, 5831, 8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246,
		5837, 8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1,
		246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1,
		246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 5861, 8, 246, 1, 246,
		3, 246, 5864, 8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1,
		246, 1, 246, 1, 246, 1, 246, 3, 246, 5876, 8, 246, 1, 246, 3, 246, 5879,
		8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246,
		3, 246, 5889, 8, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3,
		246, 5897, 8, 246, 1, 246, 1, 246, 3, 246, 5901, 8, 246, 1, 246, 1, 246,
		1, 246, 1, 246, 1, 246, 3, 246, 5908, 8, 246, 1, 246, 3, 246, 5911, 8,
		246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 5, 246, 5918, 8, 246, 10,
		246, 12, 246, 5921, 9, 246, 1, 246, 1, 246, 1, 246, 3, 246, 5926, 8, 246,
		1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 5932, 8, 246, 1, 246, 1, 246, 1,
		246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 5942, 8, 246, 3, 246,
		5944, 8, 246, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 5950, 8, 247, 1,
		247, 3, 247, 5953, 8, 247, 1, 247, 3, 247, 5956, 8, 247, 1, 248, 1, 248,
		1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 248,
		5968, 8, 248, 1, 248, 3, 248, 5971, 8, 248, 1, 249, 1, 249, 1, 249, 1,
		249, 3, 249, 5977, 8, 249, 1, 250, 3, 250, 5980, 8, 250, 1, 250, 1, 250,
		1, 250, 1, 250, 1, 250, 1, 250, 3, 250, 5988, 8, 250, 1, 250, 1, 250, 1,
		250, 1, 250, 1, 250, 1, 250, 3, 250, 5996, 8, 250, 1, 251, 1, 251, 1, 251,
		1, 251, 3, 251, 6002, 8, 251, 1, 251, 1, 251, 3, 251, 6006, 8, 251, 1,
		252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1,
		252, 1, 252, 1, 252, 3, 252, 6020, 8, 252, 1, 253, 1, 253, 1, 253, 1, 254,
		1, 254, 1, 254, 1, 254, 1, 254, 5, 254, 6030, 8, 254, 10, 254, 12, 254,
		6033, 9, 254, 1, 254, 1, 254, 1, 254, 1, 254, 3, 254, 6039, 8, 254, 1,
		254, 3, 254, 6042, 8, 254, 1, 254, 1, 254, 1, 254, 1, 255, 1, 255, 3, 255,
		6049, 8, 255, 1, 255, 1, 255, 1, 255, 5, 255, 6054, 8, 255, 10, 255, 12,
		255, 6057, 9, 255, 1, 256, 1, 256, 3, 256, 6061, 8, 256, 1, 256, 1, 256,
		1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 5, 257, 6072, 8,
		257, 10, 257, 12, 257, 6075, 9, 257, 1, 258, 1, 258, 1, 258, 1, 258, 1,
		259, 1, 259, 1, 260, 1, 260, 3, 260, 6085, 8, 260, 1, 260, 1, 260, 1, 260,
		1, 260, 3, 260, 6091, 8, 260, 1, 261, 1, 261, 1, 261, 3, 261, 6096, 8,
		261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1,
		261, 1, 261, 1, 261, 3, 261, 6109, 8, 261, 3, 261, 6111, 8, 261, 1, 261,
		1, 261, 1, 261, 3, 261, 6116, 8, 261, 1, 261, 1, 261, 3, 261, 6120, 8,
		261, 1, 261, 3, 261, 6123, 8, 261, 3, 261, 6125, 8, 261, 1, 262, 1, 262,
		1, 262, 1, 262, 1, 262, 3, 262, 6132, 8, 262, 1, 263, 1, 263, 1, 263, 1,
		263, 1, 263, 3, 263, 6139, 8, 263, 1, 263, 3, 263, 6142, 8, 263, 1, 263,
		3, 263, 6145, 8, 263, 1, 263, 1, 263, 1, 263, 1, 263, 3, 263, 6151, 8,
		263, 1, 263, 1, 263, 3, 263, 6155, 8, 263, 1, 264, 1, 264, 1, 264, 1, 264,
		3, 264, 6161, 8, 264, 1, 265, 1, 265, 1, 265, 1, 265, 3, 265, 6167, 8,
		265, 1, 265, 1, 265, 1, 266, 1, 266, 1, 266, 1, 267, 1, 267, 1, 267, 1,
		268, 1, 268, 1, 268, 3, 268, 6180, 8, 268, 1, 268, 1, 268, 1, 268, 3, 268,
		6185, 8, 268, 1, 268, 1, 268, 1, 268, 1, 268, 5, 268, 6191, 8, 268, 10,
		268, 12, 268, 6194, 9, 268, 3, 268, 6196, 8, 268, 1, 269, 1, 269, 1, 269,
		3, 269, 6201, 8, 269, 1, 269, 1, 269, 1, 269, 3, 269, 6206, 8, 269, 1,
		269, 1, 269, 1, 269, 1, 269, 5, 269, 6212, 8, 269, 10, 269, 12, 269, 6215,
		9, 269, 3, 269, 6217, 8, 269, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1,
		270, 3, 270, 6225, 8, 270, 1, 271, 1, 271, 3, 271, 6229, 8, 271, 1, 271,
		1, 271, 1, 271, 5, 271, 6234, 8, 271, 10, 271, 12, 271, 6237, 9, 271, 1,
		272, 1, 272, 1, 272, 3, 272, 6242, 8, 272, 1, 272, 3, 272, 6245, 8, 272,
		1, 273, 1, 273, 3, 273, 6249, 8, 273, 1, 273, 1, 273, 1, 273, 1, 273, 1,
		273, 1, 273, 1, 273, 1, 273, 1, 273, 5, 273, 6260, 8, 273, 10, 273, 12,
		273, 6263, 9, 273, 1, 273, 1, 273, 1, 273, 3, 273, 6268, 8, 273, 1, 273,
		1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 5, 273, 6278, 8,
		273, 10, 273, 12, 273, 6281, 9, 273, 3, 273, 6283, 8, 273, 1, 274, 1, 274,
		1, 275, 1, 275, 1, 275, 1, 275, 1, 275, 3, 275, 6292, 8, 275, 1, 275, 1,
		275, 1, 275, 3, 275, 6297, 8, 275, 1, 276, 1, 276, 1, 276, 1, 276, 3, 276,
		6303, 8, 276, 1, 277, 1, 277, 1, 278, 1, 278, 3, 278, 6309, 8, 278, 1,
		279, 1, 279, 1, 279, 3, 279, 6314, 8, 279, 3, 279, 6316, 8, 279, 1, 279,
		3, 279, 6319, 8, 279, 1, 279, 1, 279, 3, 279, 6323, 8, 279, 3, 279, 6325,
		8, 279, 1, 280, 1, 280, 3, 280, 6329, 8, 280, 1, 280, 1, 280, 1, 280, 1,
		280, 3, 280, 6335, 8, 280, 1, 280, 3, 280, 6338, 8, 280, 1, 280, 3, 280,
		6341, 8, 280, 1, 281, 1, 281, 1, 281, 1, 281, 3, 281, 6347, 8, 281, 1,
		282, 1, 282, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 6356, 8, 283,
		1, 284, 1, 284, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 6364, 8, 285, 1,
		286, 1, 286, 3, 286, 6368, 8, 286, 1, 287, 1, 287, 1, 287, 3, 287, 6373,
		8, 287, 1, 288, 1, 288, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289,
		1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 1, 289, 4, 289,
		6391, 8, 289, 11, 289, 12, 289, 6392, 1, 290, 1, 290, 1, 290, 1, 290, 1,
		290, 3, 290, 6400, 8, 290, 3, 290, 6402, 8, 290, 1, 291, 1, 291, 1, 291,
		4, 291, 6407, 8, 291, 11, 291, 12, 291, 6408, 3, 291, 6411, 8, 291, 1,
		292, 1, 292, 3, 292, 6415, 8, 292, 1, 293, 1, 293, 1, 293, 3, 293, 6420,
		8, 293, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294,
		1, 294, 3, 294, 6431, 8, 294, 1, 295, 1, 295, 1, 295, 3, 295, 6436, 8,
		295, 1, 296, 1, 296, 1, 297, 1, 297, 3, 297, 6442, 8, 297, 1, 298, 3, 298,
		6445, 8, 298, 1, 298, 1, 298, 3, 298, 6449, 8, 298, 1, 298, 4, 298, 6452,
		8, 298, 11, 298, 12, 298, 6453, 1, 298, 3, 298, 6457, 8, 298, 1, 298, 1,
		298, 3, 298, 6461, 8, 298, 1, 298, 1, 298, 3, 298, 6465, 8, 298, 3, 298,
		6467, 8, 298, 1, 299, 1, 299, 1, 300, 3, 300, 6472, 8, 300, 1, 300, 1,
		300, 1, 301, 3, 301, 6477, 8, 301, 1, 301, 1, 301, 1, 302, 1, 302, 1, 302,
		1, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 302, 3, 302, 6490, 8, 302, 1,
		302, 3, 302, 6493, 8, 302, 1, 303, 1, 303, 3, 303, 6497, 8, 303, 1, 303,
		3, 303, 6500, 8, 303, 1, 303, 3, 303, 6503, 8, 303, 1, 303, 1, 303, 1,
		303, 3, 303, 6508, 8, 303, 1, 303, 1, 303, 1, 303, 3, 303, 6513, 8, 303,
		1, 303, 1, 303, 1, 303, 1, 303, 3, 303, 6519, 8, 303, 1, 303, 3, 303, 6522,
		8, 303, 1, 303, 1, 303, 1, 303, 3, 303, 6527, 8, 303, 1, 303, 3, 303, 6530,
		8, 303, 1, 303, 1, 303, 1, 303, 3, 303, 6535, 8, 303, 1, 303, 3, 303, 6538,
		8, 303, 1, 303, 1, 303, 3, 303, 6542, 8, 303, 1, 303, 5, 303, 6545, 8,
		303, 10, 303, 12, 303, 6548, 9, 303, 1, 303, 1, 303, 3, 303, 6552, 8, 303,
		1, 303, 5, 303, 6555, 8, 303, 10, 303, 12, 303, 6558, 9, 303, 1, 303, 1,
		303, 3, 303, 6562, 8, 303, 1, 303, 3, 303, 6565, 8, 303, 1, 303, 5, 303,
		6568, 8, 303, 10, 303, 12, 303, 6571, 9, 303, 1, 303, 1, 303, 3, 303, 6575,
		8, 303, 1, 303, 5, 303, 6578, 8, 303, 10, 303, 12, 303, 6581, 9, 303, 1,
		303, 1, 303, 1, 303, 3, 303, 6586, 8, 303, 1, 303, 1, 303, 1, 303, 3, 303,
		6591, 8, 303, 1, 303, 1, 303, 1, 303, 3, 303, 6596, 8, 303, 1, 303, 1,
		303, 1, 303, 3, 303, 6601, 8, 303, 1, 303, 1, 303, 3, 303, 6605, 8, 303,
		1, 303, 3, 303, 6608, 8, 303, 1, 303, 1, 303, 1, 303, 3, 303, 6613, 8,
		303, 1, 303, 1, 303, 3, 303, 6617, 8, 303, 1, 303, 1, 303, 3, 303, 6621,
		8, 303, 1, 304, 1, 304, 1, 304, 1, 304, 5, 304, 6627, 8, 304, 10, 304,
		12, 304, 6630, 9, 304, 1, 304, 1, 304, 1, 305, 1, 305, 3, 305, 6636, 8,
		305, 1, 305, 1, 305, 3, 305, 6640, 8, 305, 1, 305, 1, 305, 1, 305, 3, 305,
		6645, 8, 305, 1, 305, 1, 305, 1, 305, 3, 305, 6650, 8, 305, 1, 305, 1,
		305, 3, 305, 6654, 8, 305, 3, 305, 6656, 8, 305, 1, 305, 3, 305, 6659,
		8, 305, 1, 306, 1, 306, 1, 306, 1, 306, 1, 307, 1, 307, 1, 307, 1, 307,
		1, 307, 1, 307, 1, 308, 1, 308, 1, 308, 1, 308, 3, 308, 6675, 8, 308, 1,
		308, 1, 308, 1, 309, 1, 309, 1, 309, 5, 309, 6682, 8, 309, 10, 309, 12,
		309, 6685, 9, 309, 1, 310, 1, 310, 1, 310, 5, 310, 6690, 8, 310, 10, 310,
		12, 310, 6693, 9, 310, 1, 311, 1, 311, 1, 311, 5, 311, 6698, 8, 311, 10,
		311, 12, 311, 6701, 9, 311, 1, 312, 1, 312, 1, 312, 1, 312, 5, 312, 6707,
		8, 312, 10, 312, 12, 312, 6710, 9, 312, 1, 312, 1, 312, 1, 313, 1, 313,
		1, 313, 5, 313, 6717, 8, 313, 10, 313, 12, 313, 6720, 9, 313, 1, 314, 1,
		314, 1, 314, 5, 314, 6725, 8, 314, 10, 314, 12, 314, 6728, 9, 314, 1, 315,
		1, 315, 1, 315, 5, 315, 6733, 8, 315, 10, 315, 12, 315, 6736, 9, 315, 1,
		316, 1, 316, 1, 316, 5, 316, 6741, 8, 316, 10, 316, 12, 316, 6744, 9, 316,
		1, 317, 1, 317, 1, 317, 5, 317, 6749, 8, 317, 10, 317, 12, 317, 6752, 9,
		317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1,
		318, 3, 318, 6763, 8, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 3, 318,
		6770, 8, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1,
		318, 3, 318, 6780, 8, 318, 1, 319, 1, 319, 1, 319, 3, 319, 6785, 8, 319,
		1, 319, 3, 319, 6788, 8, 319, 1, 319, 1, 319, 1, 319, 3, 319, 6793, 8,
		319, 1, 319, 3, 319, 6796, 8, 319, 1, 320, 1, 320, 3, 320, 6800, 8, 320,
		1, 321, 1, 321, 1, 321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 323, 1, 323,
		1, 323, 1, 324, 1, 324, 1, 324, 3, 324, 6815, 8, 324, 1, 325, 1, 325, 1,
		325, 1, 325, 1, 325, 1, 325, 3, 325, 6823, 8, 325, 1, 325, 1, 325, 1, 325,
		1, 325, 1, 325, 3, 325, 6830, 8, 325, 1, 325, 1, 325, 1, 325, 3, 325, 6835,
		8, 325, 1, 326, 1, 326, 1, 326, 3, 326, 6840, 8, 326, 1, 326, 1, 326, 1,
		326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 4, 326, 6872, 8, 326, 11, 326, 12, 326, 6873, 1, 326, 1, 326, 3, 326,
		6878, 8, 326, 1, 326, 1, 326, 1, 326, 1, 326, 4, 326, 6884, 8, 326, 11,
		326, 12, 326, 6885, 1, 326, 1, 326, 3, 326, 6890, 8, 326, 1, 326, 1, 326,
		1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 3, 326, 6899, 8, 326, 1, 326, 1,
		326, 1, 326, 1, 326, 1, 326, 1, 326, 3, 326, 6907, 8, 326, 1, 326, 1, 326,
		1, 326, 3, 326, 6912, 8, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 3, 326, 6920, 8, 326, 1, 326, 1, 326, 1, 326, 3, 326, 6925, 8, 326,
		1, 326, 1, 326, 1, 326, 3, 326, 6930, 8, 326, 3, 326, 6932, 8, 326, 1,
		326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 3, 326, 6941, 8, 326,
		1, 326, 1, 326, 1, 326, 3, 326, 6946, 8, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 1, 326, 1, 326, 3, 326, 6954, 8, 326, 1, 326, 1, 326, 1, 326, 3, 326,
		6959, 8, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 3, 326, 6967,
		8, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 3, 326, 6975, 8,
		326, 1, 326, 3, 326, 6978, 8, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326,
		1, 326, 1, 326, 1, 326, 3, 326, 6988, 8, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 1, 326, 1, 326, 1, 326, 3, 326, 7006, 8, 326, 1, 326, 3, 326, 7009,
		8, 326, 1, 326, 3, 326, 7012, 8, 326, 1, 326, 1, 326, 3, 326, 7016, 8,
		326, 1, 327, 1, 327, 1, 327, 1, 327, 1, 327, 1, 328, 1, 328, 1, 328, 1,
		328, 5, 328, 7027, 8, 328, 10, 328, 12, 328, 7030, 9, 328, 1, 328, 1, 328,
		1, 328, 1, 328, 1, 328, 3, 328, 7037, 8, 328, 1, 329, 1, 329, 3, 329, 7041,
		8, 329, 1, 330, 1, 330, 1, 330, 3, 330, 7046, 8, 330, 1, 330, 1, 330, 1,
		330, 3, 330, 7051, 8, 330, 1, 330, 1, 330, 1, 330, 1, 330, 3, 330, 7057,
		8, 330, 1, 330, 1, 330, 1, 330, 3, 330, 7062, 8, 330, 1, 330, 1, 330, 3,
		330, 7066, 8, 330, 1, 330, 1, 330, 1, 330, 3, 330, 7071, 8, 330, 1, 330,
		1, 330, 1, 330, 3, 330, 7076, 8, 330, 1, 330, 1, 330, 1, 330, 3, 330, 7081,
		8, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 5, 330, 7089, 8,
		330, 10, 330, 12, 330, 7092, 9, 330, 3, 330, 7094, 8, 330, 1, 330, 1, 330,
		3, 330, 7098, 8, 330, 1, 330, 1, 330, 3, 330, 7102, 8, 330, 1, 331, 1,
		331, 1, 331, 1, 331, 1, 331, 3, 331, 7109, 8, 331, 1, 331, 1, 331, 3, 331,
		7113, 8, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1,
		331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1,
		331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1,
		331, 1, 331, 3, 331, 7142, 8, 331, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332,
		1, 332, 3, 332, 7150, 8, 332, 1, 333, 3, 333, 7153, 8, 333, 1, 333, 3,
		333, 7156, 8, 333, 1, 333, 3, 333, 7159, 8, 333, 1, 333, 3, 333, 7162,
		8, 333, 1, 334, 1, 334, 1, 335, 1, 335, 1, 335, 1, 336, 1, 336, 1, 337,
		1, 337, 3, 337, 7173, 8, 337, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1,
		339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 3, 339, 7187, 8, 339,
		1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 5, 340, 7194, 8, 340, 10, 340,
		12, 340, 7197, 9, 340, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341,
		1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341,
		1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341,
		3, 341, 7223, 8, 341, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342, 1, 343, 1,
		343, 1, 343, 1, 343, 3, 343, 7234, 8, 343, 1, 343, 1, 343, 1, 343, 1, 343,
		1, 343, 3, 343, 7241, 8, 343, 5, 343, 7243, 8, 343, 10, 343, 12, 343, 7246,
		9, 343, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 7252, 8, 344, 1, 345, 1,
		345, 1, 345, 1, 345, 1, 345, 1, 345, 3, 345, 7260, 8, 345, 1, 345, 1, 345,
		1, 345, 3, 345, 7265, 8, 345, 1, 345, 1, 345, 1, 345, 1, 345, 5, 345, 7271,
		8, 345, 10, 345, 12, 345, 7274, 9, 345, 1, 346, 1, 346, 1, 346, 1, 346,
		1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346, 7285, 8, 346, 1, 346, 1,
		346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1,
		346, 3, 346, 7298, 8, 346, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346, 7304,
		8, 346, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346, 7310, 8, 346, 1, 346, 1,
		346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1,
		346, 1, 346, 1, 346, 1, 346, 3, 346, 7326, 8, 346, 1, 346, 1, 346, 1, 346,
		1, 346, 3, 346, 7332, 8, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1, 346, 1,
		346, 1, 346, 5, 346, 7341, 8, 346, 10, 346, 12, 346, 7344, 9, 346, 1, 347,
		1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347,
		1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 5, 347, 7363, 8,
		347, 10, 347, 12, 347, 7366, 9, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1,
		347, 1, 347, 1, 347, 4, 347, 7375, 8, 347, 11, 347, 12, 347, 7376, 1, 347,
		1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347,
		1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 7394, 8, 347, 1, 347, 1,
		347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1,
		347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 5,
		347, 7415, 8, 347, 10, 347, 12, 347, 7418, 9, 347, 1, 348, 1, 348, 1, 349,
		1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349,
		1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 7436, 8, 349, 1, 350, 1, 350, 1,
		350, 1, 350, 1, 350, 1, 350, 1, 350, 3, 350, 7445, 8, 350, 1, 351, 1, 351,
		1, 351, 1, 351, 1, 351, 1, 351, 1, 351, 3, 351, 7454, 8, 351, 1, 352, 1,
		352, 1, 353, 1, 353, 1, 354, 1, 354, 1, 354, 1, 354, 1, 354, 3, 354, 7465,
		8, 354, 1, 355, 1, 355, 1, 356, 1, 356, 1, 357, 1, 357, 1, 358, 1, 358,
		1, 359, 1, 359, 1, 360, 1, 360, 1, 361, 1, 361, 1, 361, 0, 3, 690, 692,
		694, 362, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
		34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68,
		70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
		166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
		196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
		226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
		256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
		286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314,
		316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344,
		346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374,
		376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404,
		406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434,
		436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464,
		466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494,
		496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524,
		526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554,
		556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584,
		586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614,
		616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644,
		646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674,
		676, 678, 680, 682, 684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704,
		706, 708, 710, 712, 714, 716, 718, 720, 722, 0, 144, 2, 0, 38, 38, 149,
		149, 2, 0, 530, 530, 536, 536, 3, 0, 68, 68, 158, 158, 180, 180, 3, 0,
		41, 41, 383, 383, 453, 453, 4, 0, 41, 41, 418, 418, 528, 528, 610, 610,
		2, 0, 513, 513, 1147, 1147, 2, 0, 77, 77, 140, 140, 2, 0, 14, 14, 333,
		333, 3, 0, 43, 43, 84, 84, 183, 183, 2, 0, 433, 433, 557, 557, 3, 0, 505,
		505, 649, 649, 657, 657, 2, 0, 391, 391, 459, 459, 2, 0, 351, 351, 473,
		473, 2, 0, 41, 41, 1137, 1138, 2, 0, 349, 349, 442, 442, 2, 0, 458, 458,
		672, 672, 3, 0, 79, 79, 83, 83, 124, 124, 3, 0, 41, 41, 401, 401, 430,
		430, 3, 0, 41, 41, 397, 397, 791, 791, 2, 0, 636, 636, 671, 671, 2, 0,
		80, 80, 90, 90, 3, 0, 435, 435, 547, 547, 612, 612, 2, 0, 68, 68, 158,
		158, 1, 0, 355, 356, 1, 0, 1137, 1138, 2, 0, 1147, 1147, 1155, 1155, 2,
		0, 80, 80, 387, 387, 2, 0, 544, 544, 1147, 1147, 2, 0, 545, 545, 1147,
		1147, 3, 0, 429, 429, 468, 468, 520, 520, 7, 0, 41, 41, 369, 369, 371,
		371, 401, 401, 430, 430, 572, 572, 1155, 1155, 2, 0, 513, 513, 529, 529,
		1, 0, 1138, 1139, 2, 0, 4, 4, 50, 50, 4, 0, 41, 41, 383, 383, 453, 453,
		457, 457, 2, 0, 25, 25, 29, 29, 2, 0, 11, 11, 174, 174, 2, 0, 191, 191,
		676, 676, 2, 0, 20, 20, 143, 143, 3, 0, 42, 42, 74, 74, 105, 105, 2, 0,
		105, 105, 373, 373, 2, 0, 364, 364, 426, 426, 2, 0, 100, 100, 600, 600,
		2, 0, 42, 42, 105, 105, 2, 0, 5, 5, 48, 48, 2, 0, 187, 187, 668, 668, 4,
		0, 429, 429, 468, 468, 519, 519, 561, 561, 2, 0, 429, 429, 519, 519, 2,
		0, 12, 12, 44, 44, 3, 0, 65, 65, 77, 77, 185, 185, 2, 0, 33, 33, 82, 82,
		2, 0, 96, 96, 147, 147, 2, 0, 5, 5, 48, 49, 1, 0, 625, 626, 2, 0, 171,
		171, 741, 741, 2, 0, 438, 438, 608, 608, 2, 0, 225, 225, 476, 476, 5, 0,
		106, 106, 481, 482, 484, 484, 488, 496, 574, 574, 4, 0, 478, 479, 483,
		483, 485, 486, 575, 575, 3, 0, 107, 107, 477, 477, 487, 487, 2, 0, 461,
		461, 627, 627, 2, 0, 621, 621, 623, 623, 2, 0, 343, 343, 628, 628, 2, 0,
		89, 89, 590, 590, 2, 0, 50, 50, 389, 389, 3, 0, 30, 30, 60, 60, 178, 178,
		3, 0, 130, 130, 171, 171, 436, 436, 3, 0, 11, 11, 18, 18, 186, 186, 2,
		0, 41, 41, 120, 120, 2, 0, 102, 102, 181, 181, 2, 0, 359, 359, 613, 613,
		2, 0, 39, 39, 670, 670, 2, 0, 114, 114, 473, 473, 2, 0, 421, 421, 567,
		567, 4, 0, 205, 205, 207, 207, 213, 213, 637, 637, 2, 0, 1107, 1107, 1123,
		1123, 2, 0, 344, 344, 576, 576, 2, 0, 67, 67, 79, 79, 6, 0, 130, 130, 171,
		171, 176, 176, 414, 414, 436, 436, 670, 670, 2, 0, 512, 512, 633, 633,
		2, 0, 411, 411, 674, 674, 2, 0, 130, 130, 436, 436, 3, 0, 80, 80, 91, 91,
		451, 451, 3, 0, 438, 438, 473, 473, 608, 608, 2, 0, 633, 633, 669, 669,
		2, 0, 375, 375, 566, 566, 6, 0, 225, 225, 408, 408, 410, 410, 437, 437,
		573, 573, 614, 614, 2, 0, 44, 45, 61, 61, 3, 0, 421, 421, 549, 549, 884,
		884, 2, 0, 465, 465, 651, 651, 10, 0, 358, 358, 366, 366, 377, 379, 386,
		386, 506, 506, 514, 514, 638, 638, 645, 645, 835, 835, 1004, 1004, 2, 0,
		34, 34, 167, 167, 2, 0, 116, 116, 995, 995, 11, 0, 358, 358, 366, 366,
		377, 379, 386, 386, 506, 506, 514, 514, 591, 591, 638, 638, 645, 645, 835,
		835, 1004, 1004, 2, 0, 1136, 1136, 1157, 1158, 1, 0, 1158, 1159, 2, 0,
		374, 374, 786, 797, 3, 0, 1137, 1139, 1148, 1148, 1150, 1150, 2, 0, 62,
		62, 177, 177, 2, 0, 115, 115, 1151, 1151, 5, 0, 24, 24, 221, 223, 230,
		230, 232, 235, 517, 517, 2, 0, 24, 24, 221, 221, 2, 0, 24, 24, 221, 222,
		1, 0, 195, 206, 3, 0, 182, 182, 194, 194, 611, 611, 2, 0, 210, 215, 430,
		430, 6, 0, 216, 216, 227, 227, 229, 229, 231, 231, 238, 238, 347, 348,
		4, 0, 217, 220, 225, 226, 228, 228, 345, 345, 2, 0, 152, 152, 236, 236,
		2, 0, 465, 465, 802, 810, 3, 0, 210, 210, 225, 225, 517, 517, 6, 0, 199,
		199, 205, 205, 208, 208, 216, 217, 219, 220, 465, 465, 1, 0, 213, 214,
		2, 0, 182, 182, 611, 611, 2, 0, 199, 199, 205, 205, 2, 0, 314, 315, 321,
		321, 3, 0, 149, 149, 312, 315, 330, 330, 1, 0, 324, 325, 3, 0, 16, 16,
		94, 94, 175, 175, 2, 0, 221, 221, 225, 225, 2, 0, 216, 217, 219, 219, 3,
		0, 12, 12, 44, 44, 993, 993, 3, 0, 285, 285, 297, 298, 308, 308, 3, 0,
		286, 288, 304, 307, 309, 311, 2, 0, 294, 294, 296, 296, 2, 0, 292, 292,
		295, 295, 2, 0, 290, 291, 301, 303, 2, 0, 132, 132, 600, 600, 2, 0, 432,
		432, 558, 558, 2, 0, 534, 534, 550, 550, 2, 0, 113, 113, 1126, 1126, 3,
		0, 62, 62, 177, 177, 661, 661, 2, 0, 136, 136, 148, 148, 3, 0, 5, 5, 336,
		336, 617, 617, 3, 0, 113, 113, 1119, 1120, 1126, 1127, 2, 0, 1116, 1118,
		1121, 1122, 1, 0, 1119, 1120, 2, 0, 225, 225, 745, 785, 1, 0, 798, 801,
		5, 0, 707, 708, 724, 726, 732, 732, 738, 739, 741, 741, 1, 0, 688, 695,
		3, 0, 216, 220, 233, 233, 236, 236, 58, 0, 10, 10, 13, 13, 17, 17, 28,
		28, 34, 34, 36, 36, 41, 41, 47, 47, 54, 54, 56, 56, 58, 58, 72, 72, 78,
		78, 93, 93, 116, 116, 120, 120, 123, 123, 129, 129, 157, 157, 167, 167,
		238, 238, 282, 289, 293, 293, 297, 298, 304, 311, 331, 384, 386, 402, 404,
		404, 406, 431, 433, 449, 451, 457, 459, 520, 522, 522, 526, 543, 546, 557,
		559, 588, 590, 605, 607, 635, 637, 671, 673, 674, 676, 681, 683, 687, 696,
		696, 698, 706, 709, 711, 716, 717, 719, 723, 727, 731, 733, 733, 735, 737,
		740, 740, 742, 744, 791, 791, 835, 835, 874, 874, 999, 999, 1004, 1004,
		1087, 1087, 23, 0, 38, 38, 96, 96, 147, 147, 149, 149, 216, 218, 220, 220,
		250, 281, 289, 292, 294, 296, 299, 303, 323, 323, 458, 458, 672, 672, 688,
		695, 735, 735, 802, 802, 805, 834, 836, 873, 875, 998, 1000, 1003, 1005,
		1086, 1088, 1106, 1122, 1122, 8810, 0, 725, 1, 0, 0, 0, 2, 744, 1, 0, 0,
		0, 4, 765, 1, 0, 0, 0, 6, 767, 1, 0, 0, 0, 8, 807, 1, 0, 0, 0, 10, 822,
		1, 0, 0, 0, 12, 833, 1, 0, 0, 0, 14, 850, 1, 0, 0, 0, 16, 855, 1, 0, 0,
		0, 18, 870, 1, 0, 0, 0, 20, 897, 1, 0, 0, 0, 22, 906, 1, 0, 0, 0, 24, 908,
		1, 0, 0, 0, 26, 920, 1, 0, 0, 0, 28, 950, 1, 0, 0, 0, 30, 986, 1, 0, 0,
		0, 32, 1037, 1, 0, 0, 0, 34, 1063, 1, 0, 0, 0, 36, 1099, 1, 0, 0, 0, 38,
		1112, 1, 0, 0, 0, 40, 1209, 1, 0, 0, 0, 42, 1211, 1, 0, 0, 0, 44, 1229,
		1, 0, 0, 0, 46, 1290, 1, 0, 0, 0, 48, 1309, 1, 0, 0, 0, 50, 1315, 1, 0,
		0, 0, 52, 1337, 1, 0, 0, 0, 54, 1339, 1, 0, 0, 0, 56, 1341, 1, 0, 0, 0,
		58, 1421, 1, 0, 0, 0, 60, 1428, 1, 0, 0, 0, 62, 1430, 1, 0, 0, 0, 64, 1435,
		1, 0, 0, 0, 66, 1475, 1, 0, 0, 0, 68, 1481, 1, 0, 0, 0, 70, 1483, 1, 0,
		0, 0, 72, 1504, 1, 0, 0, 0, 74, 1511, 1, 0, 0, 0, 76, 1513, 1, 0, 0, 0,
		78, 1538, 1, 0, 0, 0, 80, 1541, 1, 0, 0, 0, 82, 1546, 1, 0, 0, 0, 84, 1572,
		1, 0, 0, 0, 86, 1588, 1, 0, 0, 0, 88, 1590, 1, 0, 0, 0, 90, 1612, 1, 0,
		0, 0, 92, 1614, 1, 0, 0, 0, 94, 1680, 1, 0, 0, 0, 96, 1751, 1, 0, 0, 0,
		98, 1753, 1, 0, 0, 0, 100, 1781, 1, 0, 0, 0, 102, 1791, 1, 0, 0, 0, 104,
		1821, 1, 0, 0, 0, 106, 2008, 1, 0, 0, 0, 108, 2010, 1, 0, 0, 0, 110, 2012,
		1, 0, 0, 0, 112, 2015, 1, 0, 0, 0, 114, 2090, 1, 0, 0, 0, 116, 2113, 1,
		0, 0, 0, 118, 2261, 1, 0, 0, 0, 120, 2266, 1, 0, 0, 0, 122, 2268, 1, 0,
		0, 0, 124, 2278, 1, 0, 0, 0, 126, 2334, 1, 0, 0, 0, 128, 2354, 1, 0, 0,
		0, 130, 2356, 1, 0, 0, 0, 132, 2391, 1, 0, 0, 0, 134, 2400, 1, 0, 0, 0,
		136, 2407, 1, 0, 0, 0, 138, 2430, 1, 0, 0, 0, 140, 2439, 1, 0, 0, 0, 142,
		2454, 1, 0, 0, 0, 144, 2479, 1, 0, 0, 0, 146, 2499, 1, 0, 0, 0, 148, 2882,
		1, 0, 0, 0, 150, 2982, 1, 0, 0, 0, 152, 2984, 1, 0, 0, 0, 154, 2991, 1,
		0, 0, 0, 156, 2998, 1, 0, 0, 0, 158, 3021, 1, 0, 0, 0, 160, 3029, 1, 0,
		0, 0, 162, 3036, 1, 0, 0, 0, 164, 3043, 1, 0, 0, 0, 166, 3050, 1, 0, 0,
		0, 168, 3062, 1, 0, 0, 0, 170, 3072, 1, 0, 0, 0, 172, 3079, 1, 0, 0, 0,
		174, 3095, 1, 0, 0, 0, 176, 3141, 1, 0, 0, 0, 178, 3143, 1, 0, 0, 0, 180,
		3153, 1, 0, 0, 0, 182, 3157, 1, 0, 0, 0, 184, 3163, 1, 0, 0, 0, 186, 3175,
		1, 0, 0, 0, 188, 3177, 1, 0, 0, 0, 190, 3184, 1, 0, 0, 0, 192, 3186, 1,
		0, 0, 0, 194, 3247, 1, 0, 0, 0, 196, 3321, 1, 0, 0, 0, 198, 3380, 1, 0,
		0, 0, 200, 3478, 1, 0, 0, 0, 202, 3482, 1, 0, 0, 0, 204, 3484, 1, 0, 0,
		0, 206, 3519, 1, 0, 0, 0, 208, 3521, 1, 0, 0, 0, 210, 3529, 1, 0, 0, 0,
		212, 3537, 1, 0, 0, 0, 214, 3539, 1, 0, 0, 0, 216, 3578, 1, 0, 0, 0, 218,
		3636, 1, 0, 0, 0, 220, 3645, 1, 0, 0, 0, 222, 3665, 1, 0, 0, 0, 224, 3677,
		1, 0, 0, 0, 226, 3681, 1, 0, 0, 0, 228, 3717, 1, 0, 0, 0, 230, 3741, 1,
		0, 0, 0, 232, 3751, 1, 0, 0, 0, 234, 3755, 1, 0, 0, 0, 236, 3781, 1, 0,
		0, 0, 238, 3823, 1, 0, 0, 0, 240, 3825, 1, 0, 0, 0, 242, 3840, 1, 0, 0,
		0, 244, 3889, 1, 0, 0, 0, 246, 3898, 1, 0, 0, 0, 248, 3908, 1, 0, 0, 0,
		250, 3918, 1, 0, 0, 0, 252, 3980, 1, 0, 0, 0, 254, 3982, 1, 0, 0, 0, 256,
		3984, 1, 0, 0, 0, 258, 4011, 1, 0, 0, 0, 260, 4017, 1, 0, 0, 0, 262, 4025,
		1, 0, 0, 0, 264, 4042, 1, 0, 0, 0, 266, 4058, 1, 0, 0, 0, 268, 4095, 1,
		0, 0, 0, 270, 4101, 1, 0, 0, 0, 272, 4110, 1, 0, 0, 0, 274, 4123, 1, 0,
		0, 0, 276, 4127, 1, 0, 0, 0, 278, 4165, 1, 0, 0, 0, 280, 4203, 1, 0, 0,
		0, 282, 4217, 1, 0, 0, 0, 284, 4225, 1, 0, 0, 0, 286, 4229, 1, 0, 0, 0,
		288, 4235, 1, 0, 0, 0, 290, 4249, 1, 0, 0, 0, 292, 4252, 1, 0, 0, 0, 294,
		4270, 1, 0, 0, 0, 296, 4274, 1, 0, 0, 0, 298, 4290, 1, 0, 0, 0, 300, 4292,
		1, 0, 0, 0, 302, 4304, 1, 0, 0, 0, 304, 4311, 1, 0, 0, 0, 306, 4331, 1,
		0, 0, 0, 308, 4351, 1, 0, 0, 0, 310, 4354, 1, 0, 0, 0, 312, 4364, 1, 0,
		0, 0, 314, 4368, 1, 0, 0, 0, 316, 4381, 1, 0, 0, 0, 318, 4384, 1, 0, 0,
		0, 320, 4389, 1, 0, 0, 0, 322, 4409, 1, 0, 0, 0, 324, 4411, 1, 0, 0, 0,
		326, 4428, 1, 0, 0, 0, 328, 4437, 1, 0, 0, 0, 330, 4446, 1, 0, 0, 0, 332,
		4448, 1, 0, 0, 0, 334, 4462, 1, 0, 0, 0, 336, 4473, 1, 0, 0, 0, 338, 4482,
		1, 0, 0, 0, 340, 4485, 1, 0, 0, 0, 342, 4493, 1, 0, 0, 0, 344, 4518, 1,
		0, 0, 0, 346, 4530, 1, 0, 0, 0, 348, 4533, 1, 0, 0, 0, 350, 4565, 1, 0,
		0, 0, 352, 4567, 1, 0, 0, 0, 354, 4569, 1, 0, 0, 0, 356, 4571, 1, 0, 0,
		0, 358, 4573, 1, 0, 0, 0, 360, 4626, 1, 0, 0, 0, 362, 4628, 1, 0, 0, 0,
		364, 4634, 1, 0, 0, 0, 366, 4654, 1, 0, 0, 0, 368, 4668, 1, 0, 0, 0, 370,
		4679, 1, 0, 0, 0, 372, 4681, 1, 0, 0, 0, 374, 4687, 1, 0, 0, 0, 376, 4697,
		1, 0, 0, 0, 378, 4701, 1, 0, 0, 0, 380, 4708, 1, 0, 0, 0, 382, 4712, 1,
		0, 0, 0, 384, 4718, 1, 0, 0, 0, 386, 4725, 1, 0, 0, 0, 388, 4731, 1, 0,
		0, 0, 390, 4737, 1, 0, 0, 0, 392, 4742, 1, 0, 0, 0, 394, 4787, 1, 0, 0,
		0, 396, 4808, 1, 0, 0, 0, 398, 4833, 1, 0, 0, 0, 400, 4836, 1, 0, 0, 0,
		402, 4842, 1, 0, 0, 0, 404, 4858, 1, 0, 0, 0, 406, 4873, 1, 0, 0, 0, 408,
		4879, 1, 0, 0, 0, 410, 4909, 1, 0, 0, 0, 412, 4911, 1, 0, 0, 0, 414, 4918,
		1, 0, 0, 0, 416, 4930, 1, 0, 0, 0, 418, 4936, 1, 0, 0, 0, 420, 4961, 1,
		0, 0, 0, 422, 4965, 1, 0, 0, 0, 424, 4969, 1, 0, 0, 0, 426, 4980, 1, 0,
		0, 0, 428, 5061, 1, 0, 0, 0, 430, 5128, 1, 0, 0, 0, 432, 5130, 1, 0, 0,
		0, 434, 5236, 1, 0, 0, 0, 436, 5260, 1, 0, 0, 0, 438, 5262, 1, 0, 0, 0,
		440, 5280, 1, 0, 0, 0, 442, 5360, 1, 0, 0, 0, 444, 5362, 1, 0, 0, 0, 446,
		5375, 1, 0, 0, 0, 448, 5386, 1, 0, 0, 0, 450, 5414, 1, 0, 0, 0, 452, 5418,
		1, 0, 0, 0, 454, 5439, 1, 0, 0, 0, 456, 5449, 1, 0, 0, 0, 458, 5459, 1,
		0, 0, 0, 460, 5499, 1, 0, 0, 0, 462, 5501, 1, 0, 0, 0, 464, 5504, 1, 0,
		0, 0, 466, 5604, 1, 0, 0, 0, 468, 5622, 1, 0, 0, 0, 470, 5624, 1, 0, 0,
		0, 472, 5628, 1, 0, 0, 0, 474, 5666, 1, 0, 0, 0, 476, 5675, 1, 0, 0, 0,
		478, 5681, 1, 0, 0, 0, 480, 5688, 1, 0, 0, 0, 482, 5710, 1, 0, 0, 0, 484,
		5712, 1, 0, 0, 0, 486, 5726, 1, 0, 0, 0, 488, 5732, 1, 0, 0, 0, 490, 5788,
		1, 0, 0, 0, 492, 5943, 1, 0, 0, 0, 494, 5955, 1, 0, 0, 0, 496, 5970, 1,
		0, 0, 0, 498, 5976, 1, 0, 0, 0, 500, 5995, 1, 0, 0, 0, 502, 6005, 1, 0,
		0, 0, 504, 6019, 1, 0, 0, 0, 506, 6021, 1, 0, 0, 0, 508, 6024, 1, 0, 0,
		0, 510, 6046, 1, 0, 0, 0, 512, 6058, 1, 0, 0, 0, 514, 6064, 1, 0, 0, 0,
		516, 6076, 1, 0, 0, 0, 518, 6080, 1, 0, 0, 0, 520, 6082, 1, 0, 0, 0, 522,
		6124, 1, 0, 0, 0, 524, 6131, 1, 0, 0, 0, 526, 6133, 1, 0, 0, 0, 528, 6156,
		1, 0, 0, 0, 530, 6162, 1, 0, 0, 0, 532, 6170, 1, 0, 0, 0, 534, 6173, 1,
		0, 0, 0, 536, 6176, 1, 0, 0, 0, 538, 6197, 1, 0, 0, 0, 540, 6218, 1, 0,
		0, 0, 542, 6226, 1, 0, 0, 0, 544, 6238, 1, 0, 0, 0, 546, 6246, 1, 0, 0,
		0, 548, 6284, 1, 0, 0, 0, 550, 6296, 1, 0, 0, 0, 552, 6298, 1, 0, 0, 0,
		554, 6304, 1, 0, 0, 0, 556, 6308, 1, 0, 0, 0, 558, 6324, 1, 0, 0, 0, 560,
		6337, 1, 0, 0, 0, 562, 6346, 1, 0, 0, 0, 564, 6348, 1, 0, 0, 0, 566, 6355,
		1, 0, 0, 0, 568, 6357, 1, 0, 0, 0, 570, 6363, 1, 0, 0, 0, 572, 6367, 1,
		0, 0, 0, 574, 6372, 1, 0, 0, 0, 576, 6374, 1, 0, 0, 0, 578, 6376, 1, 0,
		0, 0, 580, 6394, 1, 0, 0, 0, 582, 6410, 1, 0, 0, 0, 584, 6414, 1, 0, 0,
		0, 586, 6419, 1, 0, 0, 0, 588, 6430, 1, 0, 0, 0, 590, 6435, 1, 0, 0, 0,
		592, 6437, 1, 0, 0, 0, 594, 6441, 1, 0, 0, 0, 596, 6466, 1, 0, 0, 0, 598,
		6468, 1, 0, 0, 0, 600, 6471, 1, 0, 0, 0, 602, 6476, 1, 0, 0, 0, 604, 6492,
		1, 0, 0, 0, 606, 6620, 1, 0, 0, 0, 608, 6622, 1, 0, 0, 0, 610, 6655, 1,
		0, 0, 0, 612, 6660, 1, 0, 0, 0, 614, 6664, 1, 0, 0, 0, 616, 6670, 1, 0,
		0, 0, 618, 6678, 1, 0, 0, 0, 620, 6686, 1, 0, 0, 0, 622, 6694, 1, 0, 0,
		0, 624, 6702, 1, 0, 0, 0, 626, 6713, 1, 0, 0, 0, 628, 6721, 1, 0, 0, 0,
		630, 6729, 1, 0, 0, 0, 632, 6737, 1, 0, 0, 0, 634, 6745, 1, 0, 0, 0, 636,
		6779, 1, 0, 0, 0, 638, 6795, 1, 0, 0, 0, 640, 6799, 1, 0, 0, 0, 642, 6801,
		1, 0, 0, 0, 644, 6804, 1, 0, 0, 0, 646, 6808, 1, 0, 0, 0, 648, 6814, 1,
		0, 0, 0, 650, 6834, 1, 0, 0, 0, 652, 7015, 1, 0, 0, 0, 654, 7017, 1, 0,
		0, 0, 656, 7036, 1, 0, 0, 0, 658, 7038, 1, 0, 0, 0, 660, 7101, 1, 0, 0,
		0, 662, 7141, 1, 0, 0, 0, 664, 7143, 1, 0, 0, 0, 666, 7152, 1, 0, 0, 0,
		668, 7163, 1, 0, 0, 0, 670, 7165, 1, 0, 0, 0, 672, 7168, 1, 0, 0, 0, 674,
		7172, 1, 0, 0, 0, 676, 7174, 1, 0, 0, 0, 678, 7186, 1, 0, 0, 0, 680, 7188,
		1, 0, 0, 0, 682, 7222, 1, 0, 0, 0, 684, 7224, 1, 0, 0, 0, 686, 7233, 1,
		0, 0, 0, 688, 7251, 1, 0, 0, 0, 690, 7264, 1, 0, 0, 0, 692, 7275, 1, 0,
		0, 0, 694, 7393, 1, 0, 0, 0, 696, 7419, 1, 0, 0, 0, 698, 7435, 1, 0, 0,
		0, 700, 7444, 1, 0, 0, 0, 702, 7453, 1, 0, 0, 0, 704, 7455, 1, 0, 0, 0,
		706, 7457, 1, 0, 0, 0, 708, 7464, 1, 0, 0, 0, 710, 7466, 1, 0, 0, 0, 712,
		7468, 1, 0, 0, 0, 714, 7470, 1, 0, 0, 0, 716, 7472, 1, 0, 0, 0, 718, 7474,
		1, 0, 0, 0, 720, 7476, 1, 0, 0, 0, 722, 7478, 1, 0, 0, 0, 724, 726, 3,
		2, 1, 0, 725, 724, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 729, 1, 0, 0,
		0, 727, 728, 5, 1120, 0, 0, 728, 730, 5, 1120, 0, 0, 729, 727, 1, 0, 0,
		0, 729, 730, 1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731, 732, 5, 0, 0, 1, 732,
		1, 1, 0, 0, 0, 733, 736, 3, 4, 2, 0, 734, 735, 5, 1120, 0, 0, 735, 737,
		5, 1120, 0, 0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 739, 1,
		0, 0, 0, 738, 740, 5, 1135, 0, 0, 739, 738, 1, 0, 0, 0, 739, 740, 1, 0,
		0, 0, 740, 743, 1, 0, 0, 0, 741, 743, 3, 6, 3, 0, 742, 733, 1, 0, 0, 0,
		742, 741, 1, 0, 0, 0, 743, 746, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 744,
		745, 1, 0, 0, 0, 745, 756, 1, 0, 0, 0, 746, 744, 1, 0, 0, 0, 747, 753,
		3, 4, 2, 0, 748, 749, 5, 1120, 0, 0, 749, 751, 5, 1120, 0, 0, 750, 748,
		1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 754, 5, 1135,
		0, 0, 753, 750, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 757, 1, 0, 0, 0,
		755, 757, 3, 6, 3, 0, 756, 747, 1, 0, 0, 0, 756, 755, 1, 0, 0, 0, 757,
		3, 1, 0, 0, 0, 758, 766, 3, 8, 4, 0, 759, 766, 3, 10, 5, 0, 760, 766, 3,
		12, 6, 0, 761, 766, 3, 14, 7, 0, 762, 766, 3, 16, 8, 0, 763, 766, 3, 20,
		10, 0, 764, 766, 3, 22, 11, 0, 765, 758, 1, 0, 0, 0, 765, 759, 1, 0, 0,
		0, 765, 760, 1, 0, 0, 0, 765, 761, 1, 0, 0, 0, 765, 762, 1, 0, 0, 0, 765,
		763, 1, 0, 0, 0, 765, 764, 1, 0, 0, 0, 766, 5, 1, 0, 0, 0, 767, 768, 5,
		1135, 0, 0, 768, 7, 1, 0, 0, 0, 769, 808, 3, 24, 12, 0, 770, 808, 3, 26,
		13, 0, 771, 808, 3, 28, 14, 0, 772, 808, 3, 30, 15, 0, 773, 808, 3, 32,
		16, 0, 774, 808, 3, 34, 17, 0, 775, 808, 3, 38, 19, 0, 776, 808, 3, 40,
		20, 0, 777, 808, 3, 42, 21, 0, 778, 808, 3, 44, 22, 0, 779, 808, 3, 46,
		23, 0, 780, 808, 3, 56, 28, 0, 781, 808, 3, 36, 18, 0, 782, 808, 3, 128,
		64, 0, 783, 808, 3, 130, 65, 0, 784, 808, 3, 132, 66, 0, 785, 808, 3, 134,
		67, 0, 786, 808, 3, 136, 68, 0, 787, 808, 3, 138, 69, 0, 788, 808, 3, 140,
		70, 0, 789, 808, 3, 142, 71, 0, 790, 808, 3, 144, 72, 0, 791, 808, 3, 146,
		73, 0, 792, 808, 3, 152, 76, 0, 793, 808, 3, 154, 77, 0, 794, 808, 3, 156,
		78, 0, 795, 808, 3, 158, 79, 0, 796, 808, 3, 160, 80, 0, 797, 808, 3, 162,
		81, 0, 798, 808, 3, 164, 82, 0, 799, 808, 3, 166, 83, 0, 800, 808, 3, 168,
		84, 0, 801, 808, 3, 170, 85, 0, 802, 808, 3, 172, 86, 0, 803, 808, 3, 174,
		87, 0, 804, 808, 3, 176, 88, 0, 805, 808, 3, 178, 89, 0, 806, 808, 3, 182,
		91, 0, 807, 769, 1, 0, 0, 0, 807, 770, 1, 0, 0, 0, 807, 771, 1, 0, 0, 0,
		807, 772, 1, 0, 0, 0, 807, 773, 1, 0, 0, 0, 807, 774, 1, 0, 0, 0, 807,
		775, 1, 0, 0, 0, 807, 776, 1, 0, 0, 0, 807, 777, 1, 0, 0, 0, 807, 778,
		1, 0, 0, 0, 807, 779, 1, 0, 0, 0, 807, 780, 1, 0, 0, 0, 807, 781, 1, 0,
		0, 0, 807, 782, 1, 0, 0, 0, 807, 783, 1, 0, 0, 0, 807, 784, 1, 0, 0, 0,
		807, 785, 1, 0, 0, 0, 807, 786, 1, 0, 0, 0, 807, 787, 1, 0, 0, 0, 807,
		788, 1, 0, 0, 0, 807, 789, 1, 0, 0, 0, 807, 790, 1, 0, 0, 0, 807, 791,
		1, 0, 0, 0, 807, 792, 1, 0, 0, 0, 807, 793, 1, 0, 0, 0, 807, 794, 1, 0,
		0, 0, 807, 795, 1, 0, 0, 0, 807, 796, 1, 0, 0, 0, 807, 797, 1, 0, 0, 0,
		807, 798, 1, 0, 0, 0, 807, 799, 1, 0, 0, 0, 807, 800, 1, 0, 0, 0, 807,
		801, 1, 0, 0, 0, 807, 802, 1, 0, 0, 0, 807, 803, 1, 0, 0, 0, 807, 804,
		1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 807, 806, 1, 0, 0, 0, 808, 9, 1, 0, 0,
		0, 809, 823, 3, 200, 100, 0, 810, 823, 3, 192, 96, 0, 811, 823, 3, 202,
		101, 0, 812, 823, 3, 186, 93, 0, 813, 823, 3, 198, 99, 0, 814, 823, 3,
		184, 92, 0, 815, 823, 3, 194, 97, 0, 816, 823, 3, 196, 98, 0, 817, 823,
		3, 188, 94, 0, 818, 823, 3, 190, 95, 0, 819, 823, 3, 204, 102, 0, 820,
		823, 3, 542, 271, 0, 821, 823, 3, 544, 272, 0, 822, 809, 1, 0, 0, 0, 822,
		810, 1, 0, 0, 0, 822, 811, 1, 0, 0, 0, 822, 812, 1, 0, 0, 0, 822, 813,
		1, 0, 0, 0, 822, 814, 1, 0, 0, 0, 822, 815, 1, 0, 0, 0, 822, 816, 1, 0,
		0, 0, 822, 817, 1, 0, 0, 0, 822, 818, 1, 0, 0, 0, 822, 819, 1, 0, 0, 0,
		822, 820, 1, 0, 0, 0, 822, 821, 1, 0, 0, 0, 823, 11, 1, 0, 0, 0, 824, 834,
		3, 300, 150, 0, 825, 834, 3, 302, 151, 0, 826, 834, 3, 304, 152, 0, 827,
		834, 3, 306, 153, 0, 828, 834, 3, 308, 154, 0, 829, 834, 3, 310, 155, 0,
		830, 834, 3, 312, 156, 0, 831, 834, 3, 314, 157, 0, 832, 834, 3, 316, 158,
		0, 833, 824, 1, 0, 0, 0, 833, 825, 1, 0, 0, 0, 833, 826, 1, 0, 0, 0, 833,
		827, 1, 0, 0, 0, 833, 828, 1, 0, 0, 0, 833, 829, 1, 0, 0, 0, 833, 830,
		1, 0, 0, 0, 833, 831, 1, 0, 0, 0, 833, 832, 1, 0, 0, 0, 834, 13, 1, 0,
		0, 0, 835, 851, 3, 332, 166, 0, 836, 851, 3, 334, 167, 0, 837, 851, 3,
		336, 168, 0, 838, 851, 3, 338, 169, 0, 839, 851, 3, 340, 170, 0, 840, 851,
		3, 342, 171, 0, 841, 851, 3, 344, 172, 0, 842, 851, 3, 346, 173, 0, 843,
		851, 3, 348, 174, 0, 844, 851, 3, 372, 186, 0, 845, 851, 3, 374, 187, 0,
		846, 851, 3, 376, 188, 0, 847, 851, 3, 378, 189, 0, 848, 851, 3, 380, 190,
		0, 849, 851, 3, 382, 191, 0, 850, 835, 1, 0, 0, 0, 850, 836, 1, 0, 0, 0,
		850, 837, 1, 0, 0, 0, 850, 838, 1, 0, 0, 0, 850, 839, 1, 0, 0, 0, 850,
		840, 1, 0, 0, 0, 850, 841, 1, 0, 0, 0, 850, 842, 1, 0, 0, 0, 850, 843,
		1, 0, 0, 0, 850, 844, 1, 0, 0, 0, 850, 845, 1, 0, 0, 0, 850, 846, 1, 0,
		0, 0, 850, 847, 1, 0, 0, 0, 850, 848, 1, 0, 0, 0, 850, 849, 1, 0, 0, 0,
		851, 15, 1, 0, 0, 0, 852, 856, 3, 384, 192, 0, 853, 856, 3, 386, 193, 0,
		854, 856, 3, 388, 194, 0, 855, 852, 1, 0, 0, 0, 855, 853, 1, 0, 0, 0, 855,
		854, 1, 0, 0, 0, 856, 17, 1, 0, 0, 0, 857, 871, 3, 392, 196, 0, 858, 871,
		3, 394, 197, 0, 859, 871, 3, 396, 198, 0, 860, 871, 3, 400, 200, 0, 861,
		871, 3, 402, 201, 0, 862, 871, 3, 404, 202, 0, 863, 871, 3, 408, 204, 0,
		864, 871, 3, 398, 199, 0, 865, 871, 3, 406, 203, 0, 866, 871, 3, 410, 205,
		0, 867, 868, 3, 542, 271, 0, 868, 869, 3, 10, 5, 0, 869, 871, 1, 0, 0,
		0, 870, 857, 1, 0, 0, 0, 870, 858, 1, 0, 0, 0, 870, 859, 1, 0, 0, 0, 870,
		860, 1, 0, 0, 0, 870, 861, 1, 0, 0, 0, 870, 862, 1, 0, 0, 0, 870, 863,
		1, 0, 0, 0, 870, 864, 1, 0, 0, 0, 870, 865, 1, 0, 0, 0, 870, 866, 1, 0,
		0, 0, 870, 867, 1, 0, 0, 0, 871, 19, 1, 0, 0, 0, 872, 898, 3, 428, 214,
		0, 873, 898, 3, 430, 215, 0, 874, 898, 3, 432, 216, 0, 875, 898, 3, 434,
		217, 0, 876, 898, 3, 438, 219, 0, 877, 898, 3, 440, 220, 0, 878, 898, 3,
		442, 221, 0, 879, 898, 3, 444, 222, 0, 880, 898, 3, 472, 236, 0, 881, 898,
		3, 474, 237, 0, 882, 898, 3, 476, 238, 0, 883, 898, 3, 478, 239, 0, 884,
		898, 3, 480, 240, 0, 885, 898, 3, 484, 242, 0, 886, 898, 3, 486, 243, 0,
		887, 898, 3, 488, 244, 0, 888, 898, 3, 490, 245, 0, 889, 898, 3, 492, 246,
		0, 890, 898, 3, 506, 253, 0, 891, 898, 3, 508, 254, 0, 892, 898, 3, 510,
		255, 0, 893, 898, 3, 512, 256, 0, 894, 898, 3, 514, 257, 0, 895, 898, 3,
		516, 258, 0, 896, 898, 3, 518, 259, 0, 897, 872, 1, 0, 0, 0, 897, 873,
		1, 0, 0, 0, 897, 874, 1, 0, 0, 0, 897, 875, 1, 0, 0, 0, 897, 876, 1, 0,
		0, 0, 897, 877, 1, 0, 0, 0, 897, 878, 1, 0, 0, 0, 897, 879, 1, 0, 0, 0,
		897, 880, 1, 0, 0, 0, 897, 881, 1, 0, 0, 0, 897, 882, 1, 0, 0, 0, 897,
		883, 1, 0, 0, 0, 897, 884, 1, 0, 0, 0, 897, 885, 1, 0, 0, 0, 897, 886,
		1, 0, 0, 0, 897, 887, 1, 0, 0, 0, 897, 888, 1, 0, 0, 0, 897, 889, 1, 0,
		0, 0, 897, 890, 1, 0, 0, 0, 897, 891, 1, 0, 0, 0, 897, 892, 1, 0, 0, 0,
		897, 893, 1, 0, 0, 0, 897, 894, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 897,
		896, 1, 0, 0, 0, 898, 21, 1, 0, 0, 0, 899, 907, 3, 528, 264, 0, 900, 907,
		3, 530, 265, 0, 901, 907, 3, 532, 266, 0, 902, 907, 3, 534, 267, 0, 903,
		907, 3, 536, 268, 0, 904, 907, 3, 538, 269, 0, 905, 907, 3, 546, 273, 0,
		906, 899, 1, 0, 0, 0, 906, 900, 1, 0, 0, 0, 906, 901, 1, 0, 0, 0, 906,
		902, 1, 0, 0, 0, 906, 903, 1, 0, 0, 0, 906, 904, 1, 0, 0, 0, 906, 905,
		1, 0, 0, 0, 907, 23, 1, 0, 0, 0, 908, 909, 5, 32, 0, 0, 909, 911, 7, 0,
		0, 0, 910, 912, 3, 644, 322, 0, 911, 910, 1, 0, 0, 0, 911, 912, 1, 0, 0,
		0, 912, 913, 1, 0, 0, 0, 913, 917, 3, 586, 293, 0, 914, 916, 3, 58, 29,
		0, 915, 914, 1, 0, 0, 0, 916, 919, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 917,
		918, 1, 0, 0, 0, 918, 25, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 920, 922, 5,
		32, 0, 0, 921, 923, 3, 64, 32, 0, 922, 921, 1, 0, 0, 0, 922, 923, 1, 0,
		0, 0, 923, 924, 1, 0, 0, 0, 924, 926, 5, 414, 0, 0, 925, 927, 3, 644, 322,
		0, 926, 925, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 928, 1, 0, 0, 0, 928,
		929, 3, 552, 276, 0, 929, 930, 5, 117, 0, 0, 930, 931, 5, 604, 0, 0, 931,
		938, 3, 66, 33, 0, 932, 933, 5, 117, 0, 0, 933, 935, 5, 370, 0, 0, 934,
		936, 5, 113, 0, 0, 935, 934, 1, 0, 0, 0, 935, 936, 1, 0, 0, 0, 936, 937,
		1, 0, 0, 0, 937, 939, 5, 560, 0, 0, 938, 932, 1, 0, 0, 0, 938, 939, 1,
		0, 0, 0, 939, 941, 1, 0, 0, 0, 940, 942, 3, 74, 37, 0, 941, 940, 1, 0,
		0, 0, 941, 942, 1, 0, 0, 0, 942, 945, 1, 0, 0, 0, 943, 944, 5, 367, 0,
		0, 944, 946, 5, 1147, 0, 0, 945, 943, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0,
		946, 947, 1, 0, 0, 0, 947, 948, 5, 398, 0, 0, 948, 949, 3, 390, 195, 0,
		949, 27, 1, 0, 0, 0, 950, 952, 5, 32, 0, 0, 951, 953, 7, 1, 0, 0, 952,
		951, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953, 955, 1, 0, 0, 0, 954, 956,
		7, 2, 0, 0, 955, 954, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 957, 1, 0,
		0, 0, 957, 958, 5, 80, 0, 0, 958, 960, 3, 586, 293, 0, 959, 961, 3, 76,
		38, 0, 960, 959, 1, 0, 0, 0, 960, 961, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0,
		962, 963, 5, 117, 0, 0, 963, 964, 3, 554, 277, 0, 964, 968, 3, 624, 312,
		0, 965, 967, 3, 78, 39, 0, 966, 965, 1, 0, 0, 0, 967, 970, 1, 0, 0, 0,
		968, 966, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 983, 1, 0, 0, 0, 970,
		968, 1, 0, 0, 0, 971, 973, 5, 335, 0, 0, 972, 974, 5, 1123, 0, 0, 973,
		972, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 982,
		7, 3, 0, 0, 976, 978, 5, 102, 0, 0, 977, 979, 5, 1123, 0, 0, 978, 977,
		1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 982, 7, 4,
		0, 0, 981, 971, 1, 0, 0, 0, 981, 976, 1, 0, 0, 0, 982, 985, 1, 0, 0, 0,
		983, 981, 1, 0, 0, 0, 983, 984, 1, 0, 0, 0, 984, 29, 1, 0, 0, 0, 985, 983,
		1, 0, 0, 0, 986, 987, 5, 32, 0, 0, 987, 988, 5, 474, 0, 0, 988, 989, 5,
		72, 0, 0, 989, 990, 3, 586, 293, 0, 990, 991, 5, 4, 0, 0, 991, 992, 5,
		658, 0, 0, 992, 998, 5, 1147, 0, 0, 993, 995, 5, 452, 0, 0, 994, 996, 5,
		1123, 0, 0, 995, 994, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0, 996, 997, 1, 0,
		0, 0, 997, 999, 3, 594, 297, 0, 998, 993, 1, 0, 0, 0, 998, 999, 1, 0, 0,
		0, 999, 1005, 1, 0, 0, 0, 1000, 1002, 5, 659, 0, 0, 1001, 1003, 5, 1123,
		0, 0, 1002, 1001, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 1, 0,
		0, 0, 1004, 1006, 3, 594, 297, 0, 1005, 1000, 1, 0, 0, 0, 1005, 1006, 1,
		0, 0, 0, 1006, 1012, 1, 0, 0, 0, 1007, 1009, 5, 571, 0, 0, 1008, 1010,
		5, 1123, 0, 0, 1009, 1008, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1011,
		1, 0, 0, 0, 1011, 1013, 3, 594, 297, 0, 1012, 1007, 1, 0, 0, 0, 1012, 1013,
		1, 0, 0, 0, 1013, 1019, 1, 0, 0, 0, 1014, 1016, 5, 527, 0, 0, 1015, 1017,
		5, 1123, 0, 0, 1016, 1015, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018,
		1, 0, 0, 0, 1018, 1020, 3, 586, 293, 0, 1019, 1014, 1, 0, 0, 0, 1019, 1020,
		1, 0, 0, 0, 1020, 1022, 1, 0, 0, 0, 1021, 1023, 5, 673, 0, 0, 1022, 1021,
		1, 0, 0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 1029, 1, 0, 0, 0, 1024, 1026,
		5, 367, 0, 0, 1025, 1027, 5, 1123, 0, 0, 1026, 1025, 1, 0, 0, 0, 1026,
		1027, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1030, 5, 1147, 0, 0, 1029,
		1024, 1, 0, 0, 0, 1029, 1030, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031,
		1033, 5, 408, 0, 0, 1032, 1034, 5, 1123, 0, 0, 1033, 1032, 1, 0, 0, 0,
		1033, 1034, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1036, 3, 574, 287,
		0, 1036, 31, 1, 0, 0, 0, 1037, 1039, 5, 32, 0, 0, 1038, 1040, 3, 64, 32,
		0, 1039, 1038, 1, 0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 1041, 1, 0, 0,
		0, 1041, 1042, 5, 130, 0, 0, 1042, 1043, 3, 552, 276, 0, 1043, 1045, 5,
		1132, 0, 0, 1044, 1046, 3, 80, 40, 0, 1045, 1044, 1, 0, 0, 0, 1045, 1046,
		1, 0, 0, 0, 1046, 1051, 1, 0, 0, 0, 1047, 1048, 5, 1134, 0, 0, 1048, 1050,
		3, 80, 40, 0, 1049, 1047, 1, 0, 0, 0, 1050, 1053, 1, 0, 0, 0, 1051, 1049,
		1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1054, 1, 0, 0, 0, 1053, 1051,
		1, 0, 0, 0, 1054, 1058, 5, 1133, 0, 0, 1055, 1057, 3, 84, 42, 0, 1056,
		1055, 1, 0, 0, 0, 1057, 1060, 1, 0, 0, 0, 1058, 1056, 1, 0, 0, 0, 1058,
		1059, 1, 0, 0, 0, 1059, 1061, 1, 0, 0, 0, 1060, 1058, 1, 0, 0, 0, 1061,
		1062, 3, 390, 195, 0, 1062, 33, 1, 0, 0, 0, 1063, 1065, 5, 32, 0, 0, 1064,
		1066, 3, 64, 32, 0, 1065, 1064, 1, 0, 0, 0, 1065, 1066, 1, 0, 0, 0, 1066,
		1068, 1, 0, 0, 0, 1067, 1069, 5, 334, 0, 0, 1068, 1067, 1, 0, 0, 0, 1068,
		1069, 1, 0, 0, 0, 1069, 1070, 1, 0, 0, 0, 1070, 1072, 5, 436, 0, 0, 1071,
		1073, 3, 644, 322, 0, 1072, 1071, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073,
		1074, 1, 0, 0, 0, 1074, 1075, 3, 552, 276, 0, 1075, 1077, 5, 1132, 0, 0,
		1076, 1078, 3, 82, 41, 0, 1077, 1076, 1, 0, 0, 0, 1077, 1078, 1, 0, 0,
		0, 1078, 1083, 1, 0, 0, 0, 1079, 1080, 5, 1134, 0, 0, 1080, 1082, 3, 82,
		41, 0, 1081, 1079, 1, 0, 0, 0, 1082, 1085, 1, 0, 0, 0, 1083, 1081, 1, 0,
		0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 1086, 1, 0, 0, 0, 1085, 1083, 1, 0,
		0, 0, 1086, 1087, 5, 1133, 0, 0, 1087, 1088, 5, 593, 0, 0, 1088, 1092,
		3, 606, 303, 0, 1089, 1091, 3, 84, 42, 0, 1090, 1089, 1, 0, 0, 0, 1091,
		1094, 1, 0, 0, 0, 1092, 1090, 1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093,
		1097, 1, 0, 0, 0, 1094, 1092, 1, 0, 0, 0, 1095, 1098, 3, 390, 195, 0, 1096,
		1098, 3, 406, 203, 0, 1097, 1095, 1, 0, 0, 0, 1097, 1096, 1, 0, 0, 0, 1098,
		35, 1, 0, 0, 0, 1099, 1100, 5, 32, 0, 0, 1100, 1102, 5, 595, 0, 0, 1101,
		1103, 3, 644, 322, 0, 1102, 1101, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103,
		1104, 1, 0, 0, 0, 1104, 1109, 3, 556, 278, 0, 1105, 1106, 5, 1134, 0, 0,
		1106, 1108, 3, 556, 278, 0, 1107, 1105, 1, 0, 0, 0, 1108, 1111, 1, 0, 0,
		0, 1109, 1107, 1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110, 37, 1, 0, 0, 0,
		1111, 1109, 1, 0, 0, 0, 1112, 1113, 5, 32, 0, 0, 1113, 1114, 5, 607, 0,
		0, 1114, 1115, 3, 586, 293, 0, 1115, 1116, 5, 66, 0, 0, 1116, 1117, 5,
		387, 0, 0, 1117, 1118, 5, 678, 0, 0, 1118, 1119, 7, 5, 0, 0, 1119, 1120,
		5, 540, 0, 0, 1120, 1121, 5, 1132, 0, 0, 1121, 1126, 3, 86, 43, 0, 1122,
		1123, 5, 1134, 0, 0, 1123, 1125, 3, 86, 43, 0, 1124, 1122, 1, 0, 0, 0,
		1125, 1128, 1, 0, 0, 0, 1126, 1124, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0,
		1127, 1129, 1, 0, 0, 0, 1128, 1126, 1, 0, 0, 0, 1129, 1130, 5, 1133, 0,
		0, 1130, 39, 1, 0, 0, 0, 1131, 1133, 5, 32, 0, 0, 1132, 1134, 5, 648, 0,
		0, 1133, 1132, 1, 0, 0, 0, 1133, 1134, 1, 0, 0, 0, 1134, 1135, 1, 0, 0,
		0, 1135, 1137, 5, 171, 0, 0, 1136, 1138, 3, 644, 322, 0, 1137, 1136, 1,
		0, 0, 0, 1137, 1138, 1, 0, 0, 0, 1138, 1139, 1, 0, 0, 0, 1139, 1147, 3,
		554, 277, 0, 1140, 1141, 5, 97, 0, 0, 1141, 1148, 3, 554, 277, 0, 1142,
		1143, 5, 1132, 0, 0, 1143, 1144, 5, 97, 0, 0, 1144, 1145, 3, 554, 277,
		0, 1145, 1146, 5, 1133, 0, 0, 1146, 1148, 1, 0, 0, 0, 1147, 1140, 1, 0,
		0, 0, 1147, 1142, 1, 0, 0, 0, 1148, 1210, 1, 0, 0, 0, 1149, 1151, 5, 32,
		0, 0, 1150, 1152, 5, 648, 0, 0, 1151, 1150, 1, 0, 0, 0, 1151, 1152, 1,
		0, 0, 0, 1152, 1153, 1, 0, 0, 0, 1153, 1155, 5, 171, 0, 0, 1154, 1156,
		3, 644, 322, 0, 1155, 1154, 1, 0, 0, 0, 1155, 1156, 1, 0, 0, 0, 1156, 1157,
		1, 0, 0, 0, 1157, 1159, 3, 554, 277, 0, 1158, 1160, 3, 88, 44, 0, 1159,
		1158, 1, 0, 0, 0, 1159, 1160, 1, 0, 0, 0, 1160, 1171, 1, 0, 0, 0, 1161,
		1168, 3, 106, 53, 0, 1162, 1164, 5, 1134, 0, 0, 1163, 1162, 1, 0, 0, 0,
		1163, 1164, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165, 1167, 3, 106, 53,
		0, 1166, 1163, 1, 0, 0, 0, 1167, 1170, 1, 0, 0, 0, 1168, 1166, 1, 0, 0,
		0, 1168, 1169, 1, 0, 0, 0, 1169, 1172, 1, 0, 0, 0, 1170, 1168, 1, 0, 0,
		0, 1171, 1161, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1174, 1, 0, 0,
		0, 1173, 1175, 3, 112, 56, 0, 1174, 1173, 1, 0, 0, 0, 1174, 1175, 1, 0,
		0, 0, 1175, 1177, 1, 0, 0, 0, 1176, 1178, 7, 6, 0, 0, 1177, 1176, 1, 0,
		0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1180, 1, 0, 0, 0, 1179, 1181, 5, 11,
		0, 0, 1180, 1179, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1182, 1, 0,
		0, 0, 1182, 1183, 3, 200, 100, 0, 1183, 1210, 1, 0, 0, 0, 1184, 1186, 5,
		32, 0, 0, 1185, 1187, 5, 648, 0, 0, 1186, 1185, 1, 0, 0, 0, 1186, 1187,
		1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 1190, 5, 171, 0, 0, 1189, 1191,
		3, 644, 322, 0, 1190, 1189, 1, 0, 0, 0, 1190, 1191, 1, 0, 0, 0, 1191, 1192,
		1, 0, 0, 0, 1192, 1193, 3, 554, 277, 0, 1193, 1204, 3, 88, 44, 0, 1194,
		1201, 3, 106, 53, 0, 1195, 1197, 5, 1134, 0, 0, 1196, 1195, 1, 0, 0, 0,
		1196, 1197, 1, 0, 0, 0, 1197, 1198, 1, 0, 0, 0, 1198, 1200, 3, 106, 53,
		0, 1199, 1196, 1, 0, 0, 0, 1200, 1203, 1, 0, 0, 0, 1201, 1199, 1, 0, 0,
		0, 1201, 1202, 1, 0, 0, 0, 1202, 1205, 1, 0, 0, 0, 1203, 1201, 1, 0, 0,
		0, 1204, 1194, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 1207, 1, 0, 0,
		0, 1206, 1208, 3, 112, 56, 0, 1207, 1206, 1, 0, 0, 0, 1207, 1208, 1, 0,
		0, 0, 1208, 1210, 1, 0, 0, 0, 1209, 1131, 1, 0, 0, 0, 1209, 1149, 1, 0,
		0, 0, 1209, 1184, 1, 0, 0, 0, 1210, 41, 1, 0, 0, 0, 1211, 1212, 5, 32,
		0, 0, 1212, 1213, 5, 646, 0, 0, 1213, 1214, 3, 586, 293, 0, 1214, 1215,
		5, 4, 0, 0, 1215, 1216, 5, 388, 0, 0, 1216, 1220, 5, 1147, 0, 0, 1217,
		1218, 5, 427, 0, 0, 1218, 1219, 5, 1123, 0, 0, 1219, 1221, 3, 594, 297,
		0, 1220, 1217, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221, 1227, 1, 0, 0,
		0, 1222, 1224, 5, 408, 0, 0, 1223, 1225, 5, 1123, 0, 0, 1224, 1223, 1,
		0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 1228, 3,
		574, 287, 0, 1227, 1222, 1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228, 43,
		1, 0, 0, 0, 1229, 1230, 5, 32, 0, 0, 1230, 1231, 5, 646, 0, 0, 1231, 1232,
		3, 586, 293, 0, 1232, 1233, 5, 4, 0, 0, 1233, 1234, 5, 388, 0, 0, 1234,
		1235, 5, 1147, 0, 0, 1235, 1236, 5, 185, 0, 0, 1236, 1237, 5, 474, 0, 0,
		1237, 1238, 5, 72, 0, 0, 1238, 1244, 3, 586, 293, 0, 1239, 1241, 5, 422,
		0, 0, 1240, 1242, 5, 1123, 0, 0, 1241, 1240, 1, 0, 0, 0, 1241, 1242, 1,
		0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1245, 3, 594, 297, 0, 1244, 1239,
		1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 1251, 1, 0, 0, 0, 1246, 1248,
		5, 452, 0, 0, 1247, 1249, 5, 1123, 0, 0, 1248, 1247, 1, 0, 0, 0, 1248,
		1249, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250, 1252, 3, 594, 297, 0, 1251,
		1246, 1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0, 1252, 1258, 1, 0, 0, 0, 1253,
		1255, 5, 340, 0, 0, 1254, 1256, 5, 1123, 0, 0, 1255, 1254, 1, 0, 0, 0,
		1255, 1256, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1259, 3, 594, 297,
		0, 1258, 1253, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1265, 1, 0, 0,
		0, 1260, 1262, 5, 500, 0, 0, 1261, 1263, 5, 1123, 0, 0, 1262, 1261, 1,
		0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263, 1264, 1, 0, 0, 0, 1264, 1266, 3,
		594, 297, 0, 1265, 1260, 1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1272,
		1, 0, 0, 0, 1267, 1269, 5, 527, 0, 0, 1268, 1270, 5, 1123, 0, 0, 1269,
		1268, 1, 0, 0, 0, 1269, 1270, 1, 0, 0, 0, 1270, 1271, 1, 0, 0, 0, 1271,
		1273, 3, 586, 293, 0, 1272, 1267, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273,
		1275, 1, 0, 0, 0, 1274, 1276, 5, 673, 0, 0, 1275, 1274, 1, 0, 0, 0, 1275,
		1276, 1, 0, 0, 0, 1276, 1282, 1, 0, 0, 0, 1277, 1279, 5, 367, 0, 0, 1278,
		1280, 5, 1123, 0, 0, 1279, 1278, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280,
		1281, 1, 0, 0, 0, 1281, 1283, 5, 1147, 0, 0, 1282, 1277, 1, 0, 0, 0, 1282,
		1283, 1, 0, 0, 0, 1283, 1284, 1, 0, 0, 0, 1284, 1286, 5, 408, 0, 0, 1285,
		1287, 5, 1123, 0, 0, 1286, 1285, 1, 0, 0, 0, 1286, 1287, 1, 0, 0, 0, 1287,
		1288, 1, 0, 0, 0, 1288, 1289, 3, 574, 287, 0, 1289, 45, 1, 0, 0, 0, 1290,
		1292, 5, 32, 0, 0, 1291, 1293, 3, 64, 32, 0, 1292, 1291, 1, 0, 0, 0, 1292,
		1293, 1, 0, 0, 0, 1293, 1294, 1, 0, 0, 0, 1294, 1295, 5, 176, 0, 0, 1295,
		1296, 3, 552, 276, 0, 1296, 1297, 7, 7, 0, 0, 1297, 1298, 7, 8, 0, 0, 1298,
		1299, 5, 117, 0, 0, 1299, 1300, 3, 554, 277, 0, 1300, 1301, 5, 64, 0, 0,
		1301, 1302, 5, 51, 0, 0, 1302, 1305, 5, 599, 0, 0, 1303, 1304, 7, 9, 0,
		0, 1304, 1306, 3, 552, 276, 0, 1305, 1303, 1, 0, 0, 0, 1305, 1306, 1, 0,
		0, 0, 1306, 1307, 1, 0, 0, 0, 1307, 1308, 3, 390, 195, 0, 1308, 47, 1,
		0, 0, 0, 1309, 1311, 5, 191, 0, 0, 1310, 1312, 5, 570, 0, 0, 1311, 1310,
		1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1314,
		3, 50, 25, 0, 1314, 49, 1, 0, 0, 0, 1315, 1327, 3, 52, 26, 0, 1316, 1317,
		5, 1132, 0, 0, 1317, 1322, 3, 54, 27, 0, 1318, 1319, 5, 1134, 0, 0, 1319,
		1321, 3, 54, 27, 0, 1320, 1318, 1, 0, 0, 0, 1321, 1324, 1, 0, 0, 0, 1322,
		1320, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1325, 1, 0, 0, 0, 1324,
		1322, 1, 0, 0, 0, 1325, 1326, 5, 1133, 0, 0, 1326, 1328, 1, 0, 0, 0, 1327,
		1316, 1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328, 1329, 1, 0, 0, 0, 1329,
		1330, 5, 11, 0, 0, 1330, 1331, 5, 1132, 0, 0, 1331, 1332, 3, 10, 5, 0,
		1332, 1335, 5, 1133, 0, 0, 1333, 1334, 5, 1134, 0, 0, 1334, 1336, 3, 50,
		25, 0, 1335, 1333, 1, 0, 0, 0, 1335, 1336, 1, 0, 0, 0, 1336, 51, 1, 0,
		0, 0, 1337, 1338, 3, 586, 293, 0, 1338, 53, 1, 0, 0, 0, 1339, 1340, 3,
		586, 293, 0, 1340, 55, 1, 0, 0, 0, 1341, 1343, 5, 32, 0, 0, 1342, 1344,
		3, 646, 323, 0, 1343, 1342, 1, 0, 0, 0, 1343, 1344, 1, 0, 0, 0, 1344, 1348,
		1, 0, 0, 0, 1345, 1346, 5, 335, 0, 0, 1346, 1347, 5, 1123, 0, 0, 1347,
		1349, 7, 10, 0, 0, 1348, 1345, 1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0, 1349,
		1351, 1, 0, 0, 0, 1350, 1352, 3, 64, 32, 0, 1351, 1350, 1, 0, 0, 0, 1351,
		1352, 1, 0, 0, 0, 1352, 1356, 1, 0, 0, 0, 1353, 1354, 5, 159, 0, 0, 1354,
		1355, 5, 605, 0, 0, 1355, 1357, 7, 11, 0, 0, 1356, 1353, 1, 0, 0, 0, 1356,
		1357, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0, 1358, 1359, 5, 670, 0, 0, 1359,
		1364, 3, 552, 276, 0, 1360, 1361, 5, 1132, 0, 0, 1361, 1362, 3, 618, 309,
		0, 1362, 1363, 5, 1133, 0, 0, 1363, 1365, 1, 0, 0, 0, 1364, 1360, 1, 0,
		0, 0, 1364, 1365, 1, 0, 0, 0, 1365, 1366, 1, 0, 0, 0, 1366, 1386, 5, 11,
		0, 0, 1367, 1369, 5, 1132, 0, 0, 1368, 1370, 3, 48, 24, 0, 1369, 1368,
		1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1372,
		3, 200, 100, 0, 1372, 1373, 5, 1133, 0, 0, 1373, 1387, 1, 0, 0, 0, 1374,
		1376, 3, 48, 24, 0, 1375, 1374, 1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376,
		1377, 1, 0, 0, 0, 1377, 1384, 3, 200, 100, 0, 1378, 1380, 5, 191, 0, 0,
		1379, 1381, 7, 12, 0, 0, 1380, 1379, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0,
		1381, 1382, 1, 0, 0, 0, 1382, 1383, 5, 25, 0, 0, 1383, 1385, 5, 119, 0,
		0, 1384, 1378, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1387, 1, 0, 0,
		0, 1386, 1367, 1, 0, 0, 0, 1386, 1375, 1, 0, 0, 0, 1387, 57, 1, 0, 0, 0,
		1388, 1390, 5, 41, 0, 0, 1389, 1388, 1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0,
		1390, 1391, 1, 0, 0, 0, 1391, 1393, 3, 60, 30, 0, 1392, 1394, 5, 1123,
		0, 0, 1393, 1392, 1, 0, 0, 0, 1393, 1394, 1, 0, 0, 0, 1394, 1397, 1, 0,
		0, 0, 1395, 1398, 3, 570, 285, 0, 1396, 1398, 5, 41, 0, 0, 1397, 1395,
		1, 0, 0, 0, 1397, 1396, 1, 0, 0, 0, 1398, 1422, 1, 0, 0, 0, 1399, 1401,
		5, 41, 0, 0, 1400, 1399, 1, 0, 0, 0, 1400, 1401, 1, 0, 0, 0, 1401, 1402,
		1, 0, 0, 0, 1402, 1404, 5, 26, 0, 0, 1403, 1405, 5, 1123, 0, 0, 1404, 1403,
		1, 0, 0, 0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 1, 0, 0, 0, 1406, 1422,
		3, 572, 286, 0, 1407, 1409, 5, 41, 0, 0, 1408, 1407, 1, 0, 0, 0, 1408,
		1409, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1412, 5, 404, 0, 0, 1411,
		1413, 5, 1123, 0, 0, 1412, 1411, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413,
		1414, 1, 0, 0, 0, 1414, 1422, 5, 1147, 0, 0, 1415, 1416, 5, 133, 0, 0,
		1416, 1418, 5, 537, 0, 0, 1417, 1419, 5, 1123, 0, 0, 1418, 1417, 1, 0,
		0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 1422, 7, 13,
		0, 0, 1421, 1389, 1, 0, 0, 0, 1421, 1400, 1, 0, 0, 0, 1421, 1408, 1, 0,
		0, 0, 1421, 1415, 1, 0, 0, 0, 1422, 59, 1, 0, 0, 0, 1423, 1424, 5, 24,
		0, 0, 1424, 1429, 5, 152, 0, 0, 1425, 1429, 5, 840, 0, 0, 1426, 1427, 5,
		221, 0, 0, 1427, 1429, 5, 152, 0, 0, 1428, 1423, 1, 0, 0, 0, 1428, 1425,
		1, 0, 0, 0, 1428, 1426, 1, 0, 0, 0, 1429, 61, 1, 0, 0, 0, 1430, 1433, 5,
		36, 0, 0, 1431, 1432, 5, 1132, 0, 0, 1432, 1434, 5, 1133, 0, 0, 1433, 1431,
		1, 0, 0, 0, 1433, 1434, 1, 0, 0, 0, 1434, 63, 1, 0, 0, 0, 1435, 1436, 5,
		391, 0, 0, 1436, 1439, 5, 1123, 0, 0, 1437, 1440, 3, 566, 283, 0, 1438,
		1440, 3, 62, 31, 0, 1439, 1437, 1, 0, 0, 0, 1439, 1438, 1, 0, 0, 0, 1440,
		65, 1, 0, 0, 0, 1441, 1442, 5, 337, 0, 0, 1442, 1446, 3, 68, 34, 0, 1443,
		1445, 3, 70, 35, 0, 1444, 1443, 1, 0, 0, 0, 1445, 1448, 1, 0, 0, 0, 1446,
		1444, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 1476, 1, 0, 0, 0, 1448,
		1446, 1, 0, 0, 0, 1449, 1452, 5, 416, 0, 0, 1450, 1453, 3, 592, 296, 0,
		1451, 1453, 3, 690, 345, 0, 1452, 1450, 1, 0, 0, 0, 1452, 1451, 1, 0, 0,
		0, 1453, 1454, 1, 0, 0, 0, 1454, 1463, 3, 72, 36, 0, 1455, 1456, 5, 629,
		0, 0, 1456, 1460, 3, 68, 34, 0, 1457, 1459, 3, 70, 35, 0, 1458, 1457, 1,
		0, 0, 0, 1459, 1462, 1, 0, 0, 0, 1460, 1458, 1, 0, 0, 0, 1460, 1461, 1,
		0, 0, 0, 1461, 1464, 1, 0, 0, 0, 1462, 1460, 1, 0, 0, 0, 1463, 1455, 1,
		0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1473, 1, 0, 0, 0, 1465, 1466, 5,
		407, 0, 0, 1466, 1470, 3, 68, 34, 0, 1467, 1469, 3, 70, 35, 0, 1468, 1467,
		1, 0, 0, 0, 1469, 1472, 1, 0, 0, 0, 1470, 1468, 1, 0, 0, 0, 1470, 1471,
		1, 0, 0, 0, 1471, 1474, 1, 0, 0, 0, 1472, 1470, 1, 0, 0, 0, 1473, 1465,
		1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0, 1474, 1476, 1, 0, 0, 0, 1475, 1441,
		1, 0, 0, 0, 1475, 1449, 1, 0, 0, 0, 1476, 67, 1, 0, 0, 0, 1477, 1482, 5,
		314, 0, 0, 1478, 1482, 3, 596, 298, 0, 1479, 1482, 3, 592, 296, 0, 1480,
		1482, 3, 690, 345, 0, 1481, 1477, 1, 0, 0, 0, 1481, 1478, 1, 0, 0, 0, 1481,
		1479, 1, 0, 0, 0, 1481, 1480, 1, 0, 0, 0, 1482, 69, 1, 0, 0, 0, 1483, 1484,
		5, 1119, 0, 0, 1484, 1487, 5, 85, 0, 0, 1485, 1488, 3, 592, 296, 0, 1486,
		1488, 3, 690, 345, 0, 1487, 1485, 1, 0, 0, 0, 1487, 1486, 1, 0, 0, 0, 1488,
		1489, 1, 0, 0, 0, 1489, 1490, 3, 72, 36, 0, 1490, 71, 1, 0, 0, 0, 1491,
		1505, 3, 716, 358, 0, 1492, 1505, 5, 220, 0, 0, 1493, 1505, 5, 239, 0,
		0, 1494, 1505, 5, 240, 0, 0, 1495, 1505, 5, 241, 0, 0, 1496, 1505, 5, 242,
		0, 0, 1497, 1505, 5, 243, 0, 0, 1498, 1505, 5, 244, 0, 0, 1499, 1505, 5,
		245, 0, 0, 1500, 1505, 5, 246, 0, 0, 1501, 1505, 5, 247, 0, 0, 1502, 1505,
		5, 248, 0, 0, 1503, 1505, 5, 249, 0, 0, 1504, 1491, 1, 0, 0, 0, 1504, 1492,
		1, 0, 0, 0, 1504, 1493, 1, 0, 0, 0, 1504, 1494, 1, 0, 0, 0, 1504, 1495,
		1, 0, 0, 0, 1504, 1496, 1, 0, 0, 0, 1504, 1497, 1, 0, 0, 0, 1504, 1498,
		1, 0, 0, 0, 1504, 1499, 1, 0, 0, 0, 1504, 1500, 1, 0, 0, 0, 1504, 1501,
		1, 0, 0, 0, 1504, 1502, 1, 0, 0, 0, 1504, 1503, 1, 0, 0, 0, 1505, 73, 1,
		0, 0, 0, 1506, 1512, 5, 402, 0, 0, 1507, 1512, 5, 395, 0, 0, 1508, 1509,
		5, 395, 0, 0, 1509, 1510, 5, 117, 0, 0, 1510, 1512, 5, 613, 0, 0, 1511,
		1506, 1, 0, 0, 0, 1511, 1507, 1, 0, 0, 0, 1511, 1508, 1, 0, 0, 0, 1512,
		75, 1, 0, 0, 0, 1513, 1514, 5, 186, 0, 0, 1514, 1515, 7, 14, 0, 0, 1515,
		77, 1, 0, 0, 0, 1516, 1518, 5, 466, 0, 0, 1517, 1519, 5, 1123, 0, 0, 1518,
		1517, 1, 0, 0, 0, 1518, 1519, 1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0, 1520,
		1539, 3, 594, 297, 0, 1521, 1539, 3, 76, 38, 0, 1522, 1523, 5, 191, 0,
		0, 1523, 1524, 5, 546, 0, 0, 1524, 1539, 3, 586, 293, 0, 1525, 1526, 5,
		367, 0, 0, 1526, 1539, 5, 1147, 0, 0, 1527, 1539, 7, 15, 0, 0, 1528, 1530,
		5, 874, 0, 0, 1529, 1531, 5, 1123, 0, 0, 1530, 1529, 1, 0, 0, 0, 1530,
		1531, 1, 0, 0, 0, 1531, 1532, 1, 0, 0, 0, 1532, 1539, 5, 1147, 0, 0, 1533,
		1535, 5, 999, 0, 0, 1534, 1536, 5, 1123, 0, 0, 1535, 1534, 1, 0, 0, 0,
		1535, 1536, 1, 0, 0, 0, 1536, 1537, 1, 0, 0, 0, 1537, 1539, 5, 1147, 0,
		0, 1538, 1516, 1, 0, 0, 0, 1538, 1521, 1, 0, 0, 0, 1538, 1522, 1, 0, 0,
		0, 1538, 1525, 1, 0, 0, 0, 1538, 1527, 1, 0, 0, 0, 1538, 1528, 1, 0, 0,
		0, 1538, 1533, 1, 0, 0, 0, 1539, 79, 1, 0, 0, 0, 1540, 1542, 7, 16, 0,
		0, 1541, 1540, 1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1543, 1, 0, 0,
		0, 1543, 1544, 3, 586, 293, 0, 1544, 1545, 3, 606, 303, 0, 1545, 81, 1,
		0, 0, 0, 1546, 1547, 3, 586, 293, 0, 1547, 1548, 3, 606, 303, 0, 1548,
		83, 1, 0, 0, 0, 1549, 1550, 5, 367, 0, 0, 1550, 1573, 5, 1147, 0, 0, 1551,
		1552, 5, 467, 0, 0, 1552, 1573, 5, 159, 0, 0, 1553, 1555, 5, 113, 0, 0,
		1554, 1553, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1556, 1, 0, 0, 0,
		1556, 1573, 5, 46, 0, 0, 1557, 1558, 5, 380, 0, 0, 1558, 1568, 5, 159,
		0, 0, 1559, 1560, 5, 520, 0, 0, 1560, 1568, 5, 159, 0, 0, 1561, 1562, 5,
		134, 0, 0, 1562, 1563, 5, 159, 0, 0, 1563, 1568, 5, 387, 0, 0, 1564, 1565,
		5, 111, 0, 0, 1565, 1566, 5, 159, 0, 0, 1566, 1568, 5, 387, 0, 0, 1567,
		1557, 1, 0, 0, 0, 1567, 1559, 1, 0, 0, 0, 1567, 1561, 1, 0, 0, 0, 1567,
		1564, 1, 0, 0, 0, 1568, 1573, 1, 0, 0, 0, 1569, 1570, 5, 159, 0, 0, 1570,
		1571, 5, 605, 0, 0, 1571, 1573, 7, 11, 0, 0, 1572, 1549, 1, 0, 0, 0, 1572,
		1551, 1, 0, 0, 0, 1572, 1554, 1, 0, 0, 0, 1572, 1567, 1, 0, 0, 0, 1572,
		1569, 1, 0, 0, 0, 1573, 85, 1, 0, 0, 0, 1574, 1575, 5, 445, 0, 0, 1575,
		1589, 5, 1147, 0, 0, 1576, 1577, 5, 38, 0, 0, 1577, 1589, 5, 1147, 0, 0,
		1578, 1579, 5, 664, 0, 0, 1579, 1589, 5, 1147, 0, 0, 1580, 1581, 5, 550,
		0, 0, 1581, 1589, 5, 1147, 0, 0, 1582, 1583, 5, 616, 0, 0, 1583, 1589,
		5, 1147, 0, 0, 1584, 1585, 5, 541, 0, 0, 1585, 1589, 5, 1147, 0, 0, 1586,
		1587, 5, 556, 0, 0, 1587, 1589, 3, 592, 296, 0, 1588, 1574, 1, 0, 0, 0,
		1588, 1576, 1, 0, 0, 0, 1588, 1578, 1, 0, 0, 0, 1588, 1580, 1, 0, 0, 0,
		1588, 1582, 1, 0, 0, 0, 1588, 1584, 1, 0, 0, 0, 1588, 1586, 1, 0, 0, 0,
		1589, 87, 1, 0, 0, 0, 1590, 1591, 5, 1132, 0, 0, 1591, 1596, 3, 90, 45,
		0, 1592, 1593, 5, 1134, 0, 0, 1593, 1595, 3, 90, 45, 0, 1594, 1592, 1,
		0, 0, 0, 1595, 1598, 1, 0, 0, 0, 1596, 1594, 1, 0, 0, 0, 1596, 1597, 1,
		0, 0, 0, 1597, 1599, 1, 0, 0, 0, 1598, 1596, 1, 0, 0, 0, 1599, 1600, 5,
		1133, 0, 0, 1600, 89, 1, 0, 0, 0, 1601, 1602, 3, 558, 279, 0, 1602, 1603,
		3, 92, 46, 0, 1603, 1613, 1, 0, 0, 0, 1604, 1606, 3, 96, 48, 0, 1605, 1607,
		5, 113, 0, 0, 1606, 1605, 1, 0, 0, 0, 1606, 1607, 1, 0, 0, 0, 1607, 1609,
		1, 0, 0, 0, 1608, 1610, 5, 56, 0, 0, 1609, 1608, 1, 0, 0, 0, 1609, 1610,
		1, 0, 0, 0, 1610, 1613, 1, 0, 0, 0, 1611, 1613, 3, 104, 52, 0, 1612, 1601,
		1, 0, 0, 0, 1612, 1604, 1, 0, 0, 0, 1612, 1611, 1, 0, 0, 0, 1613, 91, 1,
		0, 0, 0, 1614, 1618, 3, 606, 303, 0, 1615, 1617, 3, 94, 47, 0, 1616, 1615,
		1, 0, 0, 0, 1617, 1620, 1, 0, 0, 0, 1618, 1616, 1, 0, 0, 0, 1618, 1619,
		1, 0, 0, 0, 1619, 1622, 1, 0, 0, 0, 1620, 1618, 1, 0, 0, 0, 1621, 1623,
		5, 113, 0, 0, 1622, 1621, 1, 0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623, 1625,
		1, 0, 0, 0, 1624, 1626, 5, 56, 0, 0, 1625, 1624, 1, 0, 0, 0, 1625, 1626,
		1, 0, 0, 0, 1626, 93, 1, 0, 0, 0, 1627, 1681, 3, 602, 301, 0, 1628, 1629,
		5, 41, 0, 0, 1629, 1681, 3, 636, 318, 0, 1630, 1681, 5, 672, 0, 0, 1631,
		1681, 5, 458, 0, 0, 1632, 1637, 5, 341, 0, 0, 1633, 1634, 5, 117, 0, 0,
		1634, 1635, 5, 183, 0, 0, 1635, 1637, 3, 638, 319, 0, 1636, 1632, 1, 0,
		0, 0, 1636, 1633, 1, 0, 0, 0, 1637, 1681, 1, 0, 0, 0, 1638, 1640, 5, 129,
		0, 0, 1639, 1638, 1, 0, 0, 0, 1639, 1640, 1, 0, 0, 0, 1640, 1641, 1, 0,
		0, 0, 1641, 1681, 5, 90, 0, 0, 1642, 1644, 5, 180, 0, 0, 1643, 1645, 5,
		90, 0, 0, 1644, 1643, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1681, 1,
		0, 0, 0, 1646, 1647, 5, 367, 0, 0, 1647, 1681, 5, 1147, 0, 0, 1648, 1649,
		5, 365, 0, 0, 1649, 1681, 7, 17, 0, 0, 1650, 1651, 5, 635, 0, 0, 1651,
		1681, 7, 18, 0, 0, 1652, 1681, 3, 98, 49, 0, 1653, 1654, 5, 26, 0, 0, 1654,
		1681, 3, 572, 286, 0, 1655, 1656, 5, 69, 0, 0, 1656, 1658, 5, 7, 0, 0,
		1657, 1655, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0,
		1659, 1660, 5, 11, 0, 0, 1660, 1661, 5, 1132, 0, 0, 1661, 1662, 3, 690,
		345, 0, 1662, 1664, 5, 1133, 0, 0, 1663, 1665, 7, 19, 0, 0, 1664, 1663,
		1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1681, 1, 0, 0, 0, 1666, 1667,
		5, 238, 0, 0, 1667, 1668, 5, 41, 0, 0, 1668, 1681, 5, 668, 0, 0, 1669,
		1671, 5, 29, 0, 0, 1670, 1672, 3, 586, 293, 0, 1671, 1670, 1, 0, 0, 0,
		1671, 1672, 1, 0, 0, 0, 1672, 1674, 1, 0, 0, 0, 1673, 1669, 1, 0, 0, 0,
		1673, 1674, 1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0, 1675, 1676, 5, 25, 0, 0,
		1676, 1677, 5, 1132, 0, 0, 1677, 1678, 3, 690, 345, 0, 1678, 1679, 5, 1133,
		0, 0, 1679, 1681, 1, 0, 0, 0, 1680, 1627, 1, 0, 0, 0, 1680, 1628, 1, 0,
		0, 0, 1680, 1630, 1, 0, 0, 0, 1680, 1631, 1, 0, 0, 0, 1680, 1636, 1, 0,
		0, 0, 1680, 1639, 1, 0, 0, 0, 1680, 1642, 1, 0, 0, 0, 1680, 1646, 1, 0,
		0, 0, 1680, 1648, 1, 0, 0, 0, 1680, 1650, 1, 0, 0, 0, 1680, 1652, 1, 0,
		0, 0, 1680, 1653, 1, 0, 0, 0, 1680, 1657, 1, 0, 0, 0, 1680, 1666, 1, 0,
		0, 0, 1680, 1673, 1, 0, 0, 0, 1681, 95, 1, 0, 0, 0, 1682, 1684, 5, 29,
		0, 0, 1683, 1685, 3, 586, 293, 0, 1684, 1683, 1, 0, 0, 0, 1684, 1685, 1,
		0, 0, 0, 1685, 1687, 1, 0, 0, 0, 1686, 1682, 1, 0, 0, 0, 1686, 1687, 1,
		0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688, 1689, 5, 129, 0, 0, 1689, 1691,
		5, 90, 0, 0, 1690, 1692, 3, 586, 293, 0, 1691, 1690, 1, 0, 0, 0, 1691,
		1692, 1, 0, 0, 0, 1692, 1694, 1, 0, 0, 0, 1693, 1695, 3, 76, 38, 0, 1694,
		1693, 1, 0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695, 1696, 1, 0, 0, 0, 1696,
		1700, 3, 624, 312, 0, 1697, 1699, 3, 78, 39, 0, 1698, 1697, 1, 0, 0, 0,
		1699, 1702, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0, 1700, 1701, 1, 0, 0, 0,
		1701, 1752, 1, 0, 0, 0, 1702, 1700, 1, 0, 0, 0, 1703, 1705, 5, 29, 0, 0,
		1704, 1706, 3, 586, 293, 0, 1705, 1704, 1, 0, 0, 0, 1705, 1706, 1, 0, 0,
		0, 1706, 1708, 1, 0, 0, 0, 1707, 1703, 1, 0, 0, 0, 1707, 1708, 1, 0, 0,
		0, 1708, 1709, 1, 0, 0, 0, 1709, 1711, 5, 180, 0, 0, 1710, 1712, 7, 20,
		0, 0, 1711, 1710, 1, 0, 0, 0, 1711, 1712, 1, 0, 0, 0, 1712, 1714, 1, 0,
		0, 0, 1713, 1715, 3, 586, 293, 0, 1714, 1713, 1, 0, 0, 0, 1714, 1715, 1,
		0, 0, 0, 1715, 1717, 1, 0, 0, 0, 1716, 1718, 3, 76, 38, 0, 1717, 1716,
		1, 0, 0, 0, 1717, 1718, 1, 0, 0, 0, 1718, 1719, 1, 0, 0, 0, 1719, 1723,
		3, 624, 312, 0, 1720, 1722, 3, 78, 39, 0, 1721, 1720, 1, 0, 0, 0, 1722,
		1725, 1, 0, 0, 0, 1723, 1721, 1, 0, 0, 0, 1723, 1724, 1, 0, 0, 0, 1724,
		1752, 1, 0, 0, 0, 1725, 1723, 1, 0, 0, 0, 1726, 1728, 5, 29, 0, 0, 1727,
		1729, 3, 586, 293, 0, 1728, 1727, 1, 0, 0, 0, 1728, 1729, 1, 0, 0, 0, 1729,
		1731, 1, 0, 0, 0, 1730, 1726, 1, 0, 0, 0, 1730, 1731, 1, 0, 0, 0, 1731,
		1732, 1, 0, 0, 0, 1732, 1733, 5, 66, 0, 0, 1733, 1735, 5, 90, 0, 0, 1734,
		1736, 3, 586, 293, 0, 1735, 1734, 1, 0, 0, 0, 1735, 1736, 1, 0, 0, 0, 1736,
		1737, 1, 0, 0, 0, 1737, 1738, 3, 624, 312, 0, 1738, 1739, 3, 98, 49, 0,
		1739, 1752, 1, 0, 0, 0, 1740, 1742, 5, 29, 0, 0, 1741, 1743, 3, 586, 293,
		0, 1742, 1741, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1745, 1, 0, 0,
		0, 1744, 1740, 1, 0, 0, 0, 1744, 1745, 1, 0, 0, 0, 1745, 1746, 1, 0, 0,
		0, 1746, 1747, 5, 25, 0, 0, 1747, 1748, 5, 1132, 0, 0, 1748, 1749, 3, 690,
		345, 0, 1749, 1750, 5, 1133, 0, 0, 1750, 1752, 1, 0, 0, 0, 1751, 1686,
		1, 0, 0, 0, 1751, 1707, 1, 0, 0, 0, 1751, 1730, 1, 0, 0, 0, 1751, 1744,
		1, 0, 0, 0, 1752, 97, 1, 0, 0, 0, 1753, 1754, 5, 135, 0, 0, 1754, 1756,
		3, 554, 277, 0, 1755, 1757, 3, 624, 312, 0, 1756, 1755, 1, 0, 0, 0, 1756,
		1757, 1, 0, 0, 0, 1757, 1760, 1, 0, 0, 0, 1758, 1759, 5, 108, 0, 0, 1759,
		1761, 7, 21, 0, 0, 1760, 1758, 1, 0, 0, 0, 1760, 1761, 1, 0, 0, 0, 1761,
		1763, 1, 0, 0, 0, 1762, 1764, 3, 100, 50, 0, 1763, 1762, 1, 0, 0, 0, 1763,
		1764, 1, 0, 0, 0, 1764, 99, 1, 0, 0, 0, 1765, 1766, 5, 117, 0, 0, 1766,
		1767, 5, 43, 0, 0, 1767, 1771, 3, 102, 51, 0, 1768, 1769, 5, 117, 0, 0,
		1769, 1770, 5, 183, 0, 0, 1770, 1772, 3, 102, 51, 0, 1771, 1768, 1, 0,
		0, 0, 1771, 1772, 1, 0, 0, 0, 1772, 1782, 1, 0, 0, 0, 1773, 1774, 5, 117,
		0, 0, 1774, 1775, 5, 183, 0, 0, 1775, 1779, 3, 102, 51, 0, 1776, 1777,
		5, 117, 0, 0, 1777, 1778, 5, 43, 0, 0, 1778, 1780, 3, 102, 51, 0, 1779,
		1776, 1, 0, 0, 0, 1779, 1780, 1, 0, 0, 0, 1780, 1782, 1, 0, 0, 0, 1781,
		1765, 1, 0, 0, 0, 1781, 1773, 1, 0, 0, 0, 1782, 101, 1, 0, 0, 0, 1783,
		1792, 5, 143, 0, 0, 1784, 1792, 5, 20, 0, 0, 1785, 1786, 5, 152, 0, 0,
		1786, 1792, 5, 115, 0, 0, 1787, 1788, 5, 520, 0, 0, 1788, 1792, 5, 332,
		0, 0, 1789, 1790, 5, 152, 0, 0, 1790, 1792, 5, 41, 0, 0, 1791, 1783, 1,
		0, 0, 0, 1791, 1784, 1, 0, 0, 0, 1791, 1785, 1, 0, 0, 0, 1791, 1787, 1,
		0, 0, 0, 1791, 1789, 1, 0, 0, 0, 1792, 103, 1, 0, 0, 0, 1793, 1795, 7,
		20, 0, 0, 1794, 1796, 3, 586, 293, 0, 1795, 1794, 1, 0, 0, 0, 1795, 1796,
		1, 0, 0, 0, 1796, 1798, 1, 0, 0, 0, 1797, 1799, 3, 76, 38, 0, 1798, 1797,
		1, 0, 0, 0, 1798, 1799, 1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 1804,
		3, 624, 312, 0, 1801, 1803, 3, 78, 39, 0, 1802, 1801, 1, 0, 0, 0, 1803,
		1806, 1, 0, 0, 0, 1804, 1802, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805,
		1822, 1, 0, 0, 0, 1806, 1804, 1, 0, 0, 0, 1807, 1809, 7, 22, 0, 0, 1808,
		1810, 7, 20, 0, 0, 1809, 1808, 1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0, 1810,
		1812, 1, 0, 0, 0, 1811, 1813, 3, 586, 293, 0, 1812, 1811, 1, 0, 0, 0, 1812,
		1813, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1818, 3, 624, 312, 0, 1815,
		1817, 3, 78, 39, 0, 1816, 1815, 1, 0, 0, 0, 1817, 1820, 1, 0, 0, 0, 1818,
		1816, 1, 0, 0, 0, 1818, 1819, 1, 0, 0, 0, 1819, 1822, 1, 0, 0, 0, 1820,
		1818, 1, 0, 0, 0, 1821, 1793, 1, 0, 0, 0, 1821, 1807, 1, 0, 0, 0, 1822,
		105, 1, 0, 0, 0, 1823, 1825, 5, 408, 0, 0, 1824, 1826, 5, 1123, 0, 0, 1825,
		1824, 1, 0, 0, 0, 1825, 1826, 1, 0, 0, 0, 1826, 1828, 1, 0, 0, 0, 1827,
		1829, 3, 574, 287, 0, 1828, 1827, 1, 0, 0, 0, 1828, 1829, 1, 0, 0, 0, 1829,
		2009, 1, 0, 0, 0, 1830, 1832, 5, 874, 0, 0, 1831, 1833, 5, 1123, 0, 0,
		1832, 1831, 1, 0, 0, 0, 1832, 1833, 1, 0, 0, 0, 1833, 1834, 1, 0, 0, 0,
		1834, 2009, 5, 1147, 0, 0, 1835, 1837, 5, 340, 0, 0, 1836, 1838, 5, 1123,
		0, 0, 1837, 1836, 1, 0, 0, 0, 1837, 1838, 1, 0, 0, 0, 1838, 1839, 1, 0,
		0, 0, 1839, 2009, 3, 592, 296, 0, 1840, 1842, 5, 341, 0, 0, 1841, 1843,
		5, 1123, 0, 0, 1842, 1841, 1, 0, 0, 0, 1842, 1843, 1, 0, 0, 0, 1843, 1844,
		1, 0, 0, 0, 1844, 2009, 3, 592, 296, 0, 1845, 1847, 5, 342, 0, 0, 1846,
		1848, 5, 1123, 0, 0, 1847, 1846, 1, 0, 0, 0, 1847, 1848, 1, 0, 0, 0, 1848,
		1849, 1, 0, 0, 0, 1849, 2009, 3, 592, 296, 0, 1850, 1852, 5, 41, 0, 0,
		1851, 1850, 1, 0, 0, 0, 1851, 1852, 1, 0, 0, 0, 1852, 1853, 1, 0, 0, 0,
		1853, 1855, 3, 60, 30, 0, 1854, 1856, 5, 1123, 0, 0, 1855, 1854, 1, 0,
		0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 1859, 1, 0, 0, 0, 1857, 1860, 3, 570,
		285, 0, 1858, 1860, 5, 41, 0, 0, 1859, 1857, 1, 0, 0, 0, 1859, 1858, 1,
		0, 0, 0, 1860, 2009, 1, 0, 0, 0, 1861, 1863, 7, 23, 0, 0, 1862, 1864, 5,
		1123, 0, 0, 1863, 1862, 1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 1865,
		1, 0, 0, 0, 1865, 2009, 7, 24, 0, 0, 1866, 1868, 5, 41, 0, 0, 1867, 1866,
		1, 0, 0, 0, 1867, 1868, 1, 0, 0, 0, 1868, 1869, 1, 0, 0, 0, 1869, 1871,
		5, 26, 0, 0, 1870, 1872, 5, 1123, 0, 0, 1871, 1870, 1, 0, 0, 0, 1871, 1872,
		1, 0, 0, 0, 1872, 1873, 1, 0, 0, 0, 1873, 2009, 3, 572, 286, 0, 1874, 1876,
		5, 367, 0, 0, 1875, 1877, 5, 1123, 0, 0, 1876, 1875, 1, 0, 0, 0, 1876,
		1877, 1, 0, 0, 0, 1877, 1878, 1, 0, 0, 0, 1878, 2009, 5, 1147, 0, 0, 1879,
		1881, 5, 372, 0, 0, 1880, 1882, 5, 1123, 0, 0, 1881, 1880, 1, 0, 0, 0,
		1881, 1882, 1, 0, 0, 0, 1882, 1883, 1, 0, 0, 0, 1883, 2009, 7, 25, 0, 0,
		1884, 1886, 5, 375, 0, 0, 1885, 1887, 5, 1123, 0, 0, 1886, 1885, 1, 0,
		0, 0, 1886, 1887, 1, 0, 0, 0, 1887, 1888, 1, 0, 0, 0, 1888, 2009, 5, 1147,
		0, 0, 1889, 1890, 7, 26, 0, 0, 1890, 1892, 5, 394, 0, 0, 1891, 1893, 5,
		1123, 0, 0, 1892, 1891, 1, 0, 0, 0, 1892, 1893, 1, 0, 0, 0, 1893, 1894,
		1, 0, 0, 0, 1894, 2009, 5, 1147, 0, 0, 1895, 1897, 5, 392, 0, 0, 1896,
		1898, 5, 1123, 0, 0, 1897, 1896, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898,
		1899, 1, 0, 0, 0, 1899, 2009, 7, 24, 0, 0, 1900, 1902, 5, 404, 0, 0, 1901,
		1903, 5, 1123, 0, 0, 1902, 1901, 1, 0, 0, 0, 1902, 1903, 1, 0, 0, 0, 1903,
		1904, 1, 0, 0, 0, 1904, 2009, 5, 1147, 0, 0, 1905, 1907, 7, 27, 0, 0, 1906,
		1908, 5, 1123, 0, 0, 1907, 1906, 1, 0, 0, 0, 1907, 1908, 1, 0, 0, 0, 1908,
		1909, 1, 0, 0, 0, 1909, 2009, 7, 24, 0, 0, 1910, 1912, 7, 28, 0, 0, 1911,
		1913, 5, 1123, 0, 0, 1912, 1911, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913,
		1914, 1, 0, 0, 0, 1914, 2009, 3, 592, 296, 0, 1915, 1917, 5, 405, 0, 0,
		1916, 1918, 5, 1123, 0, 0, 1917, 1916, 1, 0, 0, 0, 1917, 1918, 1, 0, 0,
		0, 1918, 1919, 1, 0, 0, 0, 1919, 2009, 3, 592, 296, 0, 1920, 1921, 5, 80,
		0, 0, 1921, 1923, 5, 394, 0, 0, 1922, 1924, 5, 1123, 0, 0, 1923, 1922,
		1, 0, 0, 0, 1923, 1924, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 2009,
		5, 1147, 0, 0, 1926, 1928, 5, 454, 0, 0, 1927, 1929, 5, 1123, 0, 0, 1928,
		1927, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1930, 1, 0, 0, 0, 1930,
		2009, 7, 29, 0, 0, 1931, 1933, 5, 466, 0, 0, 1932, 1934, 5, 1123, 0, 0,
		1933, 1932, 1, 0, 0, 0, 1933, 1934, 1, 0, 0, 0, 1934, 1935, 1, 0, 0, 0,
		1935, 2009, 3, 594, 297, 0, 1936, 1938, 5, 499, 0, 0, 1937, 1939, 5, 1123,
		0, 0, 1938, 1937, 1, 0, 0, 0, 1938, 1939, 1, 0, 0, 0, 1939, 1940, 1, 0,
		0, 0, 1940, 2009, 3, 592, 296, 0, 1941, 1943, 5, 509, 0, 0, 1942, 1944,
		5, 1123, 0, 0, 1943, 1942, 1, 0, 0, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1945,
		1, 0, 0, 0, 1945, 2009, 3, 592, 296, 0, 1946, 1948, 5, 542, 0, 0, 1947,
		1949, 5, 1123, 0, 0, 1948, 1947, 1, 0, 0, 0, 1948, 1949, 1, 0, 0, 0, 1949,
		1950, 1, 0, 0, 0, 1950, 2009, 7, 13, 0, 0, 1951, 1953, 5, 550, 0, 0, 1952,
		1954, 5, 1123, 0, 0, 1953, 1952, 1, 0, 0, 0, 1953, 1954, 1, 0, 0, 0, 1954,
		1955, 1, 0, 0, 0, 1955, 2009, 5, 1147, 0, 0, 1956, 1958, 5, 601, 0, 0,
		1957, 1959, 5, 1123, 0, 0, 1958, 1957, 1, 0, 0, 0, 1958, 1959, 1, 0, 0,
		0, 1959, 1960, 1, 0, 0, 0, 1960, 2009, 7, 30, 0, 0, 1961, 1962, 5, 628,
		0, 0, 1962, 2009, 5, 652, 0, 0, 1963, 1965, 5, 999, 0, 0, 1964, 1966, 5,
		1123, 0, 0, 1965, 1964, 1, 0, 0, 0, 1965, 1966, 1, 0, 0, 0, 1966, 1967,
		1, 0, 0, 0, 1967, 2009, 5, 1147, 0, 0, 1968, 1970, 5, 630, 0, 0, 1969,
		1971, 5, 1123, 0, 0, 1970, 1969, 1, 0, 0, 0, 1970, 1971, 1, 0, 0, 0, 1971,
		1972, 1, 0, 0, 0, 1972, 2009, 7, 13, 0, 0, 1973, 1975, 5, 631, 0, 0, 1974,
		1976, 5, 1123, 0, 0, 1975, 1974, 1, 0, 0, 0, 1975, 1976, 1, 0, 0, 0, 1976,
		1977, 1, 0, 0, 0, 1977, 2009, 7, 13, 0, 0, 1978, 1980, 5, 632, 0, 0, 1979,
		1981, 5, 1123, 0, 0, 1980, 1979, 1, 0, 0, 0, 1980, 1981, 1, 0, 0, 0, 1981,
		1984, 1, 0, 0, 0, 1982, 1985, 5, 41, 0, 0, 1983, 1985, 3, 592, 296, 0,
		1984, 1982, 1, 0, 0, 0, 1984, 1983, 1, 0, 0, 0, 1985, 2009, 1, 0, 0, 0,
		1986, 1987, 5, 646, 0, 0, 1987, 1989, 3, 586, 293, 0, 1988, 1990, 3, 110,
		55, 0, 1989, 1988, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0, 1990, 2009, 1, 0,
		0, 0, 1991, 1992, 5, 647, 0, 0, 1992, 1993, 5, 1123, 0, 0, 1993, 2009,
		3, 108, 54, 0, 1994, 2009, 3, 110, 55, 0, 1995, 1997, 5, 653, 0, 0, 1996,
		1998, 5, 1123, 0, 0, 1997, 1996, 1, 0, 0, 0, 1997, 1998, 1, 0, 0, 0, 1998,
		1999, 1, 0, 0, 0, 1999, 2009, 7, 24, 0, 0, 2000, 2002, 5, 179, 0, 0, 2001,
		2003, 5, 1123, 0, 0, 2002, 2001, 1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003,
		2004, 1, 0, 0, 0, 2004, 2005, 5, 1132, 0, 0, 2005, 2006, 3, 622, 311, 0,
		2006, 2007, 5, 1133, 0, 0, 2007, 2009, 1, 0, 0, 0, 2008, 1823, 1, 0, 0,
		0, 2008, 1830, 1, 0, 0, 0, 2008, 1835, 1, 0, 0, 0, 2008, 1840, 1, 0, 0,
		0, 2008, 1845, 1, 0, 0, 0, 2008, 1851, 1, 0, 0, 0, 2008, 1861, 1, 0, 0,
		0, 2008, 1867, 1, 0, 0, 0, 2008, 1874, 1, 0, 0, 0, 2008, 1879, 1, 0, 0,
		0, 2008, 1884, 1, 0, 0, 0, 2008, 1889, 1, 0, 0, 0, 2008, 1895, 1, 0, 0,
		0, 2008, 1900, 1, 0, 0, 0, 2008, 1905, 1, 0, 0, 0, 2008, 1910, 1, 0, 0,
		0, 2008, 1915, 1, 0, 0, 0, 2008, 1920, 1, 0, 0, 0, 2008, 1926, 1, 0, 0,
		0, 2008, 1931, 1, 0, 0, 0, 2008, 1936, 1, 0, 0, 0, 2008, 1941, 1, 0, 0,
		0, 2008, 1946, 1, 0, 0, 0, 2008, 1951, 1, 0, 0, 0, 2008, 1956, 1, 0, 0,
		0, 2008, 1961, 1, 0, 0, 0, 2008, 1963, 1, 0, 0, 0, 2008, 1968, 1, 0, 0,
		0, 2008, 1973, 1, 0, 0, 0, 2008, 1978, 1, 0, 0, 0, 2008, 1986, 1, 0, 0,
		0, 2008, 1991, 1, 0, 0, 0, 2008, 1994, 1, 0, 0, 0, 2008, 1995, 1, 0, 0,
		0, 2008, 2000, 1, 0, 0, 0, 2009, 107, 1, 0, 0, 0, 2010, 2011, 7, 31, 0,
		0, 2011, 109, 1, 0, 0, 0, 2012, 2013, 5, 635, 0, 0, 2013, 2014, 7, 18,
		0, 0, 2014, 111, 1, 0, 0, 0, 2015, 2016, 5, 128, 0, 0, 2016, 2017, 5, 18,
		0, 0, 2017, 2020, 3, 114, 57, 0, 2018, 2019, 5, 549, 0, 0, 2019, 2021,
		3, 592, 296, 0, 2020, 2018, 1, 0, 0, 0, 2020, 2021, 1, 0, 0, 0, 2021, 2029,
		1, 0, 0, 0, 2022, 2023, 5, 640, 0, 0, 2023, 2024, 5, 18, 0, 0, 2024, 2027,
		3, 116, 58, 0, 2025, 2026, 5, 641, 0, 0, 2026, 2028, 3, 592, 296, 0, 2027,
		2025, 1, 0, 0, 0, 2027, 2028, 1, 0, 0, 0, 2028, 2030, 1, 0, 0, 0, 2029,
		2022, 1, 0, 0, 0, 2029, 2030, 1, 0, 0, 0, 2030, 2042, 1, 0, 0, 0, 2031,
		2032, 5, 1132, 0, 0, 2032, 2037, 3, 118, 59, 0, 2033, 2034, 5, 1134, 0,
		0, 2034, 2036, 3, 118, 59, 0, 2035, 2033, 1, 0, 0, 0, 2036, 2039, 1, 0,
		0, 0, 2037, 2035, 1, 0, 0, 0, 2037, 2038, 1, 0, 0, 0, 2038, 2040, 1, 0,
		0, 0, 2039, 2037, 1, 0, 0, 0, 2040, 2041, 5, 1133, 0, 0, 2041, 2043, 1,
		0, 0, 0, 2042, 2031, 1, 0, 0, 0, 2042, 2043, 1, 0, 0, 0, 2043, 113, 1,
		0, 0, 0, 2044, 2046, 5, 99, 0, 0, 2045, 2044, 1, 0, 0, 0, 2045, 2046, 1,
		0, 0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 2048, 5, 442, 0, 0, 2048, 2049,
		5, 1132, 0, 0, 2049, 2050, 3, 690, 345, 0, 2050, 2051, 5, 1133, 0, 0, 2051,
		2091, 1, 0, 0, 0, 2052, 2054, 5, 99, 0, 0, 2053, 2052, 1, 0, 0, 0, 2053,
		2054, 1, 0, 0, 0, 2054, 2055, 1, 0, 0, 0, 2055, 2059, 5, 90, 0, 0, 2056,
		2057, 5, 335, 0, 0, 2057, 2058, 5, 1123, 0, 0, 2058, 2060, 7, 32, 0, 0,
		2059, 2056, 1, 0, 0, 0, 2059, 2060, 1, 0, 0, 0, 2060, 2061, 1, 0, 0, 0,
		2061, 2063, 5, 1132, 0, 0, 2062, 2064, 3, 618, 309, 0, 2063, 2062, 1, 0,
		0, 0, 2063, 2064, 1, 0, 0, 0, 2064, 2065, 1, 0, 0, 0, 2065, 2091, 5, 1133,
		0, 0, 2066, 2076, 5, 132, 0, 0, 2067, 2068, 5, 1132, 0, 0, 2068, 2069,
		3, 690, 345, 0, 2069, 2070, 5, 1133, 0, 0, 2070, 2077, 1, 0, 0, 0, 2071,
		2072, 5, 364, 0, 0, 2072, 2073, 5, 1132, 0, 0, 2073, 2074, 3, 618, 309,
		0, 2074, 2075, 5, 1133, 0, 0, 2075, 2077, 1, 0, 0, 0, 2076, 2067, 1, 0,
		0, 0, 2076, 2071, 1, 0, 0, 0, 2077, 2091, 1, 0, 0, 0, 2078, 2088, 5, 472,
		0, 0, 2079, 2080, 5, 1132, 0, 0, 2080, 2081, 3, 690, 345, 0, 2081, 2082,
		5, 1133, 0, 0, 2082, 2089, 1, 0, 0, 0, 2083, 2084, 5, 364, 0, 0, 2084,
		2085, 5, 1132, 0, 0, 2085, 2086, 3, 618, 309, 0, 2086, 2087, 5, 1133, 0,
		0, 2087, 2089, 1, 0, 0, 0, 2088, 2079, 1, 0, 0, 0, 2088, 2083, 1, 0, 0,
		0, 2089, 2091, 1, 0, 0, 0, 2090, 2045, 1, 0, 0, 0, 2090, 2053, 1, 0, 0,
		0, 2090, 2066, 1, 0, 0, 0, 2090, 2078, 1, 0, 0, 0, 2091, 115, 1, 0, 0,
		0, 2092, 2094, 5, 99, 0, 0, 2093, 2092, 1, 0, 0, 0, 2093, 2094, 1, 0, 0,
		0, 2094, 2095, 1, 0, 0, 0, 2095, 2096, 5, 442, 0, 0, 2096, 2097, 5, 1132,
		0, 0, 2097, 2098, 3, 690, 345, 0, 2098, 2099, 5, 1133, 0, 0, 2099, 2114,
		1, 0, 0, 0, 2100, 2102, 5, 99, 0, 0, 2101, 2100, 1, 0, 0, 0, 2101, 2102,
		1, 0, 0, 0, 2102, 2103, 1, 0, 0, 0, 2103, 2107, 5, 90, 0, 0, 2104, 2105,
		5, 335, 0, 0, 2105, 2106, 5, 1123, 0, 0, 2106, 2108, 7, 32, 0, 0, 2107,
		2104, 1, 0, 0, 0, 2107, 2108, 1, 0, 0, 0, 2108, 2109, 1, 0, 0, 0, 2109,
		2110, 5, 1132, 0, 0, 2110, 2111, 3, 618, 309, 0, 2111, 2112, 5, 1133, 0,
		0, 2112, 2114, 1, 0, 0, 0, 2113, 2093, 1, 0, 0, 0, 2113, 2101, 1, 0, 0,
		0, 2114, 117, 1, 0, 0, 0, 2115, 2116, 5, 128, 0, 0, 2116, 2117, 3, 586,
		293, 0, 2117, 2118, 5, 187, 0, 0, 2118, 2119, 5, 470, 0, 0, 2119, 2120,
		5, 650, 0, 0, 2120, 2121, 5, 1132, 0, 0, 2121, 2126, 3, 120, 60, 0, 2122,
		2123, 5, 1134, 0, 0, 2123, 2125, 3, 120, 60, 0, 2124, 2122, 1, 0, 0, 0,
		2125, 2128, 1, 0, 0, 0, 2126, 2124, 1, 0, 0, 0, 2126, 2127, 1, 0, 0, 0,
		2127, 2129, 1, 0, 0, 0, 2128, 2126, 1, 0, 0, 0, 2129, 2133, 5, 1133, 0,
		0, 2130, 2132, 3, 126, 63, 0, 2131, 2130, 1, 0, 0, 0, 2132, 2135, 1, 0,
		0, 0, 2133, 2131, 1, 0, 0, 0, 2133, 2134, 1, 0, 0, 0, 2134, 2147, 1, 0,
		0, 0, 2135, 2133, 1, 0, 0, 0, 2136, 2137, 5, 1132, 0, 0, 2137, 2142, 3,
		124, 62, 0, 2138, 2139, 5, 1134, 0, 0, 2139, 2141, 3, 124, 62, 0, 2140,
		2138, 1, 0, 0, 0, 2141, 2144, 1, 0, 0, 0, 2142, 2140, 1, 0, 0, 0, 2142,
		2143, 1, 0, 0, 0, 2143, 2145, 1, 0, 0, 0, 2144, 2142, 1, 0, 0, 0, 2145,
		2146, 5, 1133, 0, 0, 2146, 2148, 1, 0, 0, 0, 2147, 2136, 1, 0, 0, 0, 2147,
		2148, 1, 0, 0, 0, 2148, 2262, 1, 0, 0, 0, 2149, 2150, 5, 128, 0, 0, 2150,
		2151, 3, 586, 293, 0, 2151, 2152, 5, 187, 0, 0, 2152, 2153, 5, 470, 0,
		0, 2153, 2154, 5, 650, 0, 0, 2154, 2158, 3, 120, 60, 0, 2155, 2157, 3,
		126, 63, 0, 2156, 2155, 1, 0, 0, 0, 2157, 2160, 1, 0, 0, 0, 2158, 2156,
		1, 0, 0, 0, 2158, 2159, 1, 0, 0, 0, 2159, 2172, 1, 0, 0, 0, 2160, 2158,
		1, 0, 0, 0, 2161, 2162, 5, 1132, 0, 0, 2162, 2167, 3, 124, 62, 0, 2163,
		2164, 5, 1134, 0, 0, 2164, 2166, 3, 124, 62, 0, 2165, 2163, 1, 0, 0, 0,
		2166, 2169, 1, 0, 0, 0, 2167, 2165, 1, 0, 0, 0, 2167, 2168, 1, 0, 0, 0,
		2168, 2170, 1, 0, 0, 0, 2169, 2167, 1, 0, 0, 0, 2170, 2171, 5, 1133, 0,
		0, 2171, 2173, 1, 0, 0, 0, 2172, 2161, 1, 0, 0, 0, 2172, 2173, 1, 0, 0,
		0, 2173, 2262, 1, 0, 0, 0, 2174, 2175, 5, 128, 0, 0, 2175, 2176, 3, 586,
		293, 0, 2176, 2177, 5, 187, 0, 0, 2177, 2178, 5, 79, 0, 0, 2178, 2179,
		5, 1132, 0, 0, 2179, 2184, 3, 120, 60, 0, 2180, 2181, 5, 1134, 0, 0, 2181,
		2183, 3, 120, 60, 0, 2182, 2180, 1, 0, 0, 0, 2183, 2186, 1, 0, 0, 0, 2184,
		2182, 1, 0, 0, 0, 2184, 2185, 1, 0, 0, 0, 2185, 2187, 1, 0, 0, 0, 2186,
		2184, 1, 0, 0, 0, 2187, 2191, 5, 1133, 0, 0, 2188, 2190, 3, 126, 63, 0,
		2189, 2188, 1, 0, 0, 0, 2190, 2193, 1, 0, 0, 0, 2191, 2189, 1, 0, 0, 0,
		2191, 2192, 1, 0, 0, 0, 2192, 2205, 1, 0, 0, 0, 2193, 2191, 1, 0, 0, 0,
		2194, 2195, 5, 1132, 0, 0, 2195, 2200, 3, 124, 62, 0, 2196, 2197, 5, 1134,
		0, 0, 2197, 2199, 3, 124, 62, 0, 2198, 2196, 1, 0, 0, 0, 2199, 2202, 1,
		0, 0, 0, 2200, 2198, 1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2203, 1,
		0, 0, 0, 2202, 2200, 1, 0, 0, 0, 2203, 2204, 5, 1133, 0, 0, 2204, 2206,
		1, 0, 0, 0, 2205, 2194, 1, 0, 0, 0, 2205, 2206, 1, 0, 0, 0, 2206, 2262,
		1, 0, 0, 0, 2207, 2208, 5, 128, 0, 0, 2208, 2209, 3, 586, 293, 0, 2209,
		2210, 5, 187, 0, 0, 2210, 2211, 5, 79, 0, 0, 2211, 2212, 5, 1132, 0, 0,
		2212, 2217, 3, 122, 61, 0, 2213, 2214, 5, 1134, 0, 0, 2214, 2216, 3, 122,
		61, 0, 2215, 2213, 1, 0, 0, 0, 2216, 2219, 1, 0, 0, 0, 2217, 2215, 1, 0,
		0, 0, 2217, 2218, 1, 0, 0, 0, 2218, 2220, 1, 0, 0, 0, 2219, 2217, 1, 0,
		0, 0, 2220, 2224, 5, 1133, 0, 0, 2221, 2223, 3, 126, 63, 0, 2222, 2221,
		1, 0, 0, 0, 2223, 2226, 1, 0, 0, 0, 2224, 2222, 1, 0, 0, 0, 2224, 2225,
		1, 0, 0, 0, 2225, 2238, 1, 0, 0, 0, 2226, 2224, 1, 0, 0, 0, 2227, 2228,
		5, 1132, 0, 0, 2228, 2233, 3, 124, 62, 0, 2229, 2230, 5, 1134, 0, 0, 2230,
		2232, 3, 124, 62, 0, 2231, 2229, 1, 0, 0, 0, 2232, 2235, 1, 0, 0, 0, 2233,
		2231, 1, 0, 0, 0, 2233, 2234, 1, 0, 0, 0, 2234, 2236, 1, 0, 0, 0, 2235,
		2233, 1, 0, 0, 0, 2236, 2237, 5, 1133, 0, 0, 2237, 2239, 1, 0, 0, 0, 2238,
		2227, 1, 0, 0, 0, 2238, 2239, 1, 0, 0, 0, 2239, 2262, 1, 0, 0, 0, 2240,
		2241, 5, 128, 0, 0, 2241, 2245, 3, 586, 293, 0, 2242, 2244, 3, 126, 63,
		0, 2243, 2242, 1, 0, 0, 0, 2244, 2247, 1, 0, 0, 0, 2245, 2243, 1, 0, 0,
		0, 2245, 2246, 1, 0, 0, 0, 2246, 2259, 1, 0, 0, 0, 2247, 2245, 1, 0, 0,
		0, 2248, 2249, 5, 1132, 0, 0, 2249, 2254, 3, 124, 62, 0, 2250, 2251, 5,
		1134, 0, 0, 2251, 2253, 3, 124, 62, 0, 2252, 2250, 1, 0, 0, 0, 2253, 2256,
		1, 0, 0, 0, 2254, 2252, 1, 0, 0, 0, 2254, 2255, 1, 0, 0, 0, 2255, 2257,
		1, 0, 0, 0, 2256, 2254, 1, 0, 0, 0, 2257, 2258, 5, 1133, 0, 0, 2258, 2260,
		1, 0, 0, 0, 2259, 2248, 1, 0, 0, 0, 2259, 2260, 1, 0, 0, 0, 2260, 2262,
		1, 0, 0, 0, 2261, 2115, 1, 0, 0, 0, 2261, 2149, 1, 0, 0, 0, 2261, 2174,
		1, 0, 0, 0, 2261, 2207, 1, 0, 0, 0, 2261, 2240, 1, 0, 0, 0, 2262, 119,
		1, 0, 0, 0, 2263, 2267, 3, 604, 302, 0, 2264, 2267, 3, 690, 345, 0, 2265,
		2267, 5, 109, 0, 0, 2266, 2263, 1, 0, 0, 0, 2266, 2264, 1, 0, 0, 0, 2266,
		2265, 1, 0, 0, 0, 2267, 121, 1, 0, 0, 0, 2268, 2269, 5, 1132, 0, 0, 2269,
		2272, 3, 120, 60, 0, 2270, 2271, 5, 1134, 0, 0, 2271, 2273, 3, 120, 60,
		0, 2272, 2270, 1, 0, 0, 0, 2273, 2274, 1, 0, 0, 0, 2274, 2272, 1, 0, 0,
		0, 2274, 2275, 1, 0, 0, 0, 2275, 2276, 1, 0, 0, 0, 2276, 2277, 5, 1133,
		0, 0, 2277, 123, 1, 0, 0, 0, 2278, 2279, 5, 640, 0, 0, 2279, 2283, 3, 586,
		293, 0, 2280, 2282, 3, 126, 63, 0, 2281, 2280, 1, 0, 0, 0, 2282, 2285,
		1, 0, 0, 0, 2283, 2281, 1, 0, 0, 0, 2283, 2284, 1, 0, 0, 0, 2284, 125,
		1, 0, 0, 0, 2285, 2283, 1, 0, 0, 0, 2286, 2288, 5, 41, 0, 0, 2287, 2286,
		1, 0, 0, 0, 2287, 2288, 1, 0, 0, 0, 2288, 2290, 1, 0, 0, 0, 2289, 2291,
		5, 635, 0, 0, 2290, 2289, 1, 0, 0, 0, 2290, 2291, 1, 0, 0, 0, 2291, 2292,
		1, 0, 0, 0, 2292, 2294, 5, 408, 0, 0, 2293, 2295, 5, 1123, 0, 0, 2294,
		2293, 1, 0, 0, 0, 2294, 2295, 1, 0, 0, 0, 2295, 2296, 1, 0, 0, 0, 2296,
		2335, 3, 574, 287, 0, 2297, 2299, 5, 367, 0, 0, 2298, 2300, 5, 1123, 0,
		0, 2299, 2298, 1, 0, 0, 0, 2299, 2300, 1, 0, 0, 0, 2300, 2301, 1, 0, 0,
		0, 2301, 2335, 5, 1147, 0, 0, 2302, 2303, 5, 387, 0, 0, 2303, 2305, 5,
		394, 0, 0, 2304, 2306, 5, 1123, 0, 0, 2305, 2304, 1, 0, 0, 0, 2305, 2306,
		1, 0, 0, 0, 2306, 2307, 1, 0, 0, 0, 2307, 2335, 5, 1147, 0, 0, 2308, 2309,
		5, 80, 0, 0, 2309, 2311, 5, 394, 0, 0, 2310, 2312, 5, 1123, 0, 0, 2311,
		2310, 1, 0, 0, 0, 2311, 2312, 1, 0, 0, 0, 2312, 2313, 1, 0, 0, 0, 2313,
		2335, 5, 1147, 0, 0, 2314, 2316, 5, 499, 0, 0, 2315, 2317, 5, 1123, 0,
		0, 2316, 2315, 1, 0, 0, 0, 2316, 2317, 1, 0, 0, 0, 2317, 2318, 1, 0, 0,
		0, 2318, 2335, 3, 592, 296, 0, 2319, 2321, 5, 509, 0, 0, 2320, 2322, 5,
		1123, 0, 0, 2321, 2320, 1, 0, 0, 0, 2321, 2322, 1, 0, 0, 0, 2322, 2323,
		1, 0, 0, 0, 2323, 2335, 3, 592, 296, 0, 2324, 2326, 5, 646, 0, 0, 2325,
		2327, 5, 1123, 0, 0, 2326, 2325, 1, 0, 0, 0, 2326, 2327, 1, 0, 0, 0, 2327,
		2328, 1, 0, 0, 0, 2328, 2335, 3, 586, 293, 0, 2329, 2331, 5, 527, 0, 0,
		2330, 2332, 5, 1123, 0, 0, 2331, 2330, 1, 0, 0, 0, 2331, 2332, 1, 0, 0,
		0, 2332, 2333, 1, 0, 0, 0, 2333, 2335, 3, 586, 293, 0, 2334, 2287, 1, 0,
		0, 0, 2334, 2297, 1, 0, 0, 0, 2334, 2302, 1, 0, 0, 0, 2334, 2308, 1, 0,
		0, 0, 2334, 2314, 1, 0, 0, 0, 2334, 2319, 1, 0, 0, 0, 2334, 2324, 1, 0,
		0, 0, 2334, 2329, 1, 0, 0, 0, 2335, 127, 1, 0, 0, 0, 2336, 2337, 5, 6,
		0, 0, 2337, 2339, 7, 0, 0, 0, 2338, 2340, 3, 586, 293, 0, 2339, 2338, 1,
		0, 0, 0, 2339, 2340, 1, 0, 0, 0, 2340, 2342, 1, 0, 0, 0, 2341, 2343, 3,
		58, 29, 0, 2342, 2341, 1, 0, 0, 0, 2343, 2344, 1, 0, 0, 0, 2344, 2342,
		1, 0, 0, 0, 2344, 2345, 1, 0, 0, 0, 2345, 2355, 1, 0, 0, 0, 2346, 2347,
		5, 6, 0, 0, 2347, 2348, 7, 0, 0, 0, 2348, 2349, 3, 586, 293, 0, 2349, 2350,
		5, 663, 0, 0, 2350, 2351, 5, 387, 0, 0, 2351, 2352, 5, 394, 0, 0, 2352,
		2353, 5, 515, 0, 0, 2353, 2355, 1, 0, 0, 0, 2354, 2336, 1, 0, 0, 0, 2354,
		2346, 1, 0, 0, 0, 2355, 129, 1, 0, 0, 0, 2356, 2358, 5, 6, 0, 0, 2357,
		2359, 3, 64, 32, 0, 2358, 2357, 1, 0, 0, 0, 2358, 2359, 1, 0, 0, 0, 2359,
		2360, 1, 0, 0, 0, 2360, 2361, 5, 414, 0, 0, 2361, 2365, 3, 552, 276, 0,
		2362, 2363, 5, 117, 0, 0, 2363, 2364, 5, 604, 0, 0, 2364, 2366, 3, 66,
		33, 0, 2365, 2362, 1, 0, 0, 0, 2365, 2366, 1, 0, 0, 0, 2366, 2373, 1, 0,
		0, 0, 2367, 2368, 5, 117, 0, 0, 2368, 2370, 5, 370, 0, 0, 2369, 2371, 5,
		113, 0, 0, 2370, 2369, 1, 0, 0, 0, 2370, 2371, 1, 0, 0, 0, 2371, 2372,
		1, 0, 0, 0, 2372, 2374, 5, 560, 0, 0, 2373, 2367, 1, 0, 0, 0, 2373, 2374,
		1, 0, 0, 0, 2374, 2378, 1, 0, 0, 0, 2375, 2376, 5, 138, 0, 0, 2376, 2377,
		5, 174, 0, 0, 2377, 2379, 3, 552, 276, 0, 2378, 2375, 1, 0, 0, 0, 2378,
		2379, 1, 0, 0, 0, 2379, 2381, 1, 0, 0, 0, 2380, 2382, 3, 74, 37, 0, 2381,
		2380, 1, 0, 0, 0, 2381, 2382, 1, 0, 0, 0, 2382, 2385, 1, 0, 0, 0, 2383,
		2384, 5, 367, 0, 0, 2384, 2386, 5, 1147, 0, 0, 2385, 2383, 1, 0, 0, 0,
		2385, 2386, 1, 0, 0, 0, 2386, 2389, 1, 0, 0, 0, 2387, 2388, 5, 398, 0,
		0, 2388, 2390, 3, 390, 195, 0, 2389, 2387, 1, 0, 0, 0, 2389, 2390, 1, 0,
		0, 0, 2390, 131, 1, 0, 0, 0, 2391, 2392, 5, 6, 0, 0, 2392, 2393, 5, 436,
		0, 0, 2393, 2397, 3, 552, 276, 0, 2394, 2396, 3, 84, 42, 0, 2395, 2394,
		1, 0, 0, 0, 2396, 2399, 1, 0, 0, 0, 2397, 2395, 1, 0, 0, 0, 2397, 2398,
		1, 0, 0, 0, 2398, 133, 1, 0, 0, 0, 2399, 2397, 1, 0, 0, 0, 2400, 2401,
		5, 6, 0, 0, 2401, 2402, 5, 456, 0, 0, 2402, 2403, 5, 598, 0, 0, 2403, 2404,
		5, 790, 0, 0, 2404, 2405, 5, 476, 0, 0, 2405, 2406, 5, 90, 0, 0, 2406,
		135, 1, 0, 0, 0, 2407, 2408, 5, 6, 0, 0, 2408, 2409, 5, 474, 0, 0, 2409,
		2410, 5, 72, 0, 0, 2410, 2411, 3, 586, 293, 0, 2411, 2412, 5, 4, 0, 0,
		2412, 2413, 5, 658, 0, 0, 2413, 2419, 5, 1147, 0, 0, 2414, 2416, 5, 452,
		0, 0, 2415, 2417, 5, 1123, 0, 0, 2416, 2415, 1, 0, 0, 0, 2416, 2417, 1,
		0, 0, 0, 2417, 2418, 1, 0, 0, 0, 2418, 2420, 3, 594, 297, 0, 2419, 2414,
		1, 0, 0, 0, 2419, 2420, 1, 0, 0, 0, 2420, 2422, 1, 0, 0, 0, 2421, 2423,
		5, 673, 0, 0, 2422, 2421, 1, 0, 0, 0, 2422, 2423, 1, 0, 0, 0, 2423, 2424,
		1, 0, 0, 0, 2424, 2426, 5, 408, 0, 0, 2425, 2427, 5, 1123, 0, 0, 2426,
		2425, 1, 0, 0, 0, 2426, 2427, 1, 0, 0, 0, 2427, 2428, 1, 0, 0, 0, 2428,
		2429, 3, 574, 287, 0, 2429, 137, 1, 0, 0, 0, 2430, 2431, 5, 6, 0, 0, 2431,
		2432, 5, 130, 0, 0, 2432, 2436, 3, 552, 276, 0, 2433, 2435, 3, 84, 42,
		0, 2434, 2433, 1, 0, 0, 0, 2435, 2438, 1, 0, 0, 0, 2436, 2434, 1, 0, 0,
		0, 2436, 2437, 1, 0, 0, 0, 2437, 139, 1, 0, 0, 0, 2438, 2436, 1, 0, 0,
		0, 2439, 2440, 5, 6, 0, 0, 2440, 2441, 5, 607, 0, 0, 2441, 2442, 3, 586,
		293, 0, 2442, 2443, 5, 540, 0, 0, 2443, 2444, 5, 1132, 0, 0, 2444, 2449,
		3, 86, 43, 0, 2445, 2446, 5, 1134, 0, 0, 2446, 2448, 3, 86, 43, 0, 2447,
		2445, 1, 0, 0, 0, 2448, 2451, 1, 0, 0, 0, 2449, 2447, 1, 0, 0, 0, 2449,
		2450, 1, 0, 0, 0, 2450, 2452, 1, 0, 0, 0, 2451, 2449, 1, 0, 0, 0, 2452,
		2453, 5, 1133, 0, 0, 2453, 141, 1, 0, 0, 0, 2454, 2456, 5, 6, 0, 0, 2455,
		2457, 7, 1, 0, 0, 2456, 2455, 1, 0, 0, 0, 2456, 2457, 1, 0, 0, 0, 2457,
		2459, 1, 0, 0, 0, 2458, 2460, 5, 77, 0, 0, 2459, 2458, 1, 0, 0, 0, 2459,
		2460, 1, 0, 0, 0, 2460, 2461, 1, 0, 0, 0, 2461, 2462, 5, 171, 0, 0, 2462,
		2464, 3, 554, 277, 0, 2463, 2465, 3, 648, 324, 0, 2464, 2463, 1, 0, 0,
		0, 2464, 2465, 1, 0, 0, 0, 2465, 2474, 1, 0, 0, 0, 2466, 2471, 3, 148,
		74, 0, 2467, 2468, 5, 1134, 0, 0, 2468, 2470, 3, 148, 74, 0, 2469, 2467,
		1, 0, 0, 0, 2470, 2473, 1, 0, 0, 0, 2471, 2469, 1, 0, 0, 0, 2471, 2472,
		1, 0, 0, 0, 2472, 2475, 1, 0, 0, 0, 2473, 2471, 1, 0, 0, 0, 2474, 2466,
		1, 0, 0, 0, 2474, 2475, 1, 0, 0, 0, 2475, 2477, 1, 0, 0, 0, 2476, 2478,
		3, 112, 56, 0, 2477, 2476, 1, 0, 0, 0, 2477, 2478, 1, 0, 0, 0, 2478, 143,
		1, 0, 0, 0, 2479, 2480, 5, 6, 0, 0, 2480, 2481, 5, 646, 0, 0, 2481, 2482,
		3, 586, 293, 0, 2482, 2483, 7, 33, 0, 0, 2483, 2484, 5, 388, 0, 0, 2484,
		2488, 5, 1147, 0, 0, 2485, 2486, 5, 452, 0, 0, 2486, 2487, 5, 1123, 0,
		0, 2487, 2489, 3, 594, 297, 0, 2488, 2485, 1, 0, 0, 0, 2488, 2489, 1, 0,
		0, 0, 2489, 2491, 1, 0, 0, 0, 2490, 2492, 5, 673, 0, 0, 2491, 2490, 1,
		0, 0, 0, 2491, 2492, 1, 0, 0, 0, 2492, 2493, 1, 0, 0, 0, 2493, 2495, 5,
		408, 0, 0, 2494, 2496, 5, 1123, 0, 0, 2495, 2494, 1, 0, 0, 0, 2495, 2496,
		1, 0, 0, 0, 2496, 2497, 1, 0, 0, 0, 2497, 2498, 3, 574, 287, 0, 2498, 145,
		1, 0, 0, 0, 2499, 2503, 5, 6, 0, 0, 2500, 2501, 5, 335, 0, 0, 2501, 2502,
		5, 1123, 0, 0, 2502, 2504, 7, 10, 0, 0, 2503, 2500, 1, 0, 0, 0, 2503, 2504,
		1, 0, 0, 0, 2504, 2506, 1, 0, 0, 0, 2505, 2507, 3, 64, 32, 0, 2506, 2505,
		1, 0, 0, 0, 2506, 2507, 1, 0, 0, 0, 2507, 2511, 1, 0, 0, 0, 2508, 2509,
		5, 159, 0, 0, 2509, 2510, 5, 605, 0, 0, 2510, 2512, 7, 11, 0, 0, 2511,
		2508, 1, 0, 0, 0, 2511, 2512, 1, 0, 0, 0, 2512, 2513, 1, 0, 0, 0, 2513,
		2514, 5, 670, 0, 0, 2514, 2519, 3, 552, 276, 0, 2515, 2516, 5, 1132, 0,
		0, 2516, 2517, 3, 618, 309, 0, 2517, 2518, 5, 1133, 0, 0, 2518, 2520, 1,
		0, 0, 0, 2519, 2515, 1, 0, 0, 0, 2519, 2520, 1, 0, 0, 0, 2520, 2521, 1,
		0, 0, 0, 2521, 2522, 5, 11, 0, 0, 2522, 2529, 3, 200, 100, 0, 2523, 2525,
		5, 191, 0, 0, 2524, 2526, 7, 12, 0, 0, 2525, 2524, 1, 0, 0, 0, 2525, 2526,
		1, 0, 0, 0, 2526, 2527, 1, 0, 0, 0, 2527, 2528, 5, 25, 0, 0, 2528, 2530,
		5, 119, 0, 0, 2529, 2523, 1, 0, 0, 0, 2529, 2530, 1, 0, 0, 0, 2530, 147,
		1, 0, 0, 0, 2531, 2538, 3, 106, 53, 0, 2532, 2534, 5, 1134, 0, 0, 2533,
		2532, 1, 0, 0, 0, 2533, 2534, 1, 0, 0, 0, 2534, 2535, 1, 0, 0, 0, 2535,
		2537, 3, 106, 53, 0, 2536, 2533, 1, 0, 0, 0, 2537, 2540, 1, 0, 0, 0, 2538,
		2536, 1, 0, 0, 0, 2538, 2539, 1, 0, 0, 0, 2539, 2883, 1, 0, 0, 0, 2540,
		2538, 1, 0, 0, 0, 2541, 2543, 5, 4, 0, 0, 2542, 2544, 5, 27, 0, 0, 2543,
		2542, 1, 0, 0, 0, 2543, 2544, 1, 0, 0, 0, 2544, 2545, 1, 0, 0, 0, 2545,
		2546, 3, 586, 293, 0, 2546, 2550, 3, 92, 46, 0, 2547, 2551, 5, 429, 0,
		0, 2548, 2549, 5, 333, 0, 0, 2549, 2551, 3, 586, 293, 0, 2550, 2547, 1,
		0, 0, 0, 2550, 2548, 1, 0, 0, 0, 2550, 2551, 1, 0, 0, 0, 2551, 2883, 1,
		0, 0, 0, 2552, 2554, 5, 4, 0, 0, 2553, 2555, 5, 27, 0, 0, 2554, 2553, 1,
		0, 0, 0, 2554, 2555, 1, 0, 0, 0, 2555, 2556, 1, 0, 0, 0, 2556, 2557, 5,
		1132, 0, 0, 2557, 2558, 3, 586, 293, 0, 2558, 2565, 3, 92, 46, 0, 2559,
		2560, 5, 1134, 0, 0, 2560, 2561, 3, 586, 293, 0, 2561, 2562, 3, 92, 46,
		0, 2562, 2564, 1, 0, 0, 0, 2563, 2559, 1, 0, 0, 0, 2564, 2567, 1, 0, 0,
		0, 2565, 2563, 1, 0, 0, 0, 2565, 2566, 1, 0, 0, 0, 2566, 2568, 1, 0, 0,
		0, 2567, 2565, 1, 0, 0, 0, 2568, 2569, 5, 1133, 0, 0, 2569, 2883, 1, 0,
		0, 0, 2570, 2571, 5, 4, 0, 0, 2571, 2573, 7, 20, 0, 0, 2572, 2574, 3, 586,
		293, 0, 2573, 2572, 1, 0, 0, 0, 2573, 2574, 1, 0, 0, 0, 2574, 2576, 1,
		0, 0, 0, 2575, 2577, 3, 76, 38, 0, 2576, 2575, 1, 0, 0, 0, 2576, 2577,
		1, 0, 0, 0, 2577, 2578, 1, 0, 0, 0, 2578, 2582, 3, 624, 312, 0, 2579, 2581,
		3, 78, 39, 0, 2580, 2579, 1, 0, 0, 0, 2581, 2584, 1, 0, 0, 0, 2582, 2580,
		1, 0, 0, 0, 2582, 2583, 1, 0, 0, 0, 2583, 2883, 1, 0, 0, 0, 2584, 2582,
		1, 0, 0, 0, 2585, 2590, 5, 4, 0, 0, 2586, 2588, 5, 29, 0, 0, 2587, 2589,
		3, 586, 293, 0, 2588, 2587, 1, 0, 0, 0, 2588, 2589, 1, 0, 0, 0, 2589, 2591,
		1, 0, 0, 0, 2590, 2586, 1, 0, 0, 0, 2590, 2591, 1, 0, 0, 0, 2591, 2592,
		1, 0, 0, 0, 2592, 2593, 5, 129, 0, 0, 2593, 2595, 5, 90, 0, 0, 2594, 2596,
		3, 586, 293, 0, 2595, 2594, 1, 0, 0, 0, 2595, 2596, 1, 0, 0, 0, 2596, 2598,
		1, 0, 0, 0, 2597, 2599, 3, 76, 38, 0, 2598, 2597, 1, 0, 0, 0, 2598, 2599,
		1, 0, 0, 0, 2599, 2600, 1, 0, 0, 0, 2600, 2604, 3, 624, 312, 0, 2601, 2603,
		3, 78, 39, 0, 2602, 2601, 1, 0, 0, 0, 2603, 2606, 1, 0, 0, 0, 2604, 2602,
		1, 0, 0, 0, 2604, 2605, 1, 0, 0, 0, 2605, 2883, 1, 0, 0, 0, 2606, 2604,
		1, 0, 0, 0, 2607, 2612, 5, 4, 0, 0, 2608, 2610, 5, 29, 0, 0, 2609, 2611,
		3, 586, 293, 0, 2610, 2609, 1, 0, 0, 0, 2610, 2611, 1, 0, 0, 0, 2611, 2613,
		1, 0, 0, 0, 2612, 2608, 1, 0, 0, 0, 2612, 2613, 1, 0, 0, 0, 2613, 2614,
		1, 0, 0, 0, 2614, 2616, 5, 180, 0, 0, 2615, 2617, 7, 20, 0, 0, 2616, 2615,
		1, 0, 0, 0, 2616, 2617, 1, 0, 0, 0, 2617, 2619, 1, 0, 0, 0, 2618, 2620,
		3, 586, 293, 0, 2619, 2618, 1, 0, 0, 0, 2619, 2620, 1, 0, 0, 0, 2620, 2622,
		1, 0, 0, 0, 2621, 2623, 3, 76, 38, 0, 2622, 2621, 1, 0, 0, 0, 2622, 2623,
		1, 0, 0, 0, 2623, 2624, 1, 0, 0, 0, 2624, 2628, 3, 624, 312, 0, 2625, 2627,
		3, 78, 39, 0, 2626, 2625, 1, 0, 0, 0, 2627, 2630, 1, 0, 0, 0, 2628, 2626,
		1, 0, 0, 0, 2628, 2629, 1, 0, 0, 0, 2629, 2883, 1, 0, 0, 0, 2630, 2628,
		1, 0, 0, 0, 2631, 2632, 5, 4, 0, 0, 2632, 2634, 7, 22, 0, 0, 2633, 2635,
		7, 20, 0, 0, 2634, 2633, 1, 0, 0, 0, 2634, 2635, 1, 0, 0, 0, 2635, 2637,
		1, 0, 0, 0, 2636, 2638, 3, 586, 293, 0, 2637, 2636, 1, 0, 0, 0, 2637, 2638,
		1, 0, 0, 0, 2638, 2639, 1, 0, 0, 0, 2639, 2643, 3, 624, 312, 0, 2640, 2642,
		3, 78, 39, 0, 2641, 2640, 1, 0, 0, 0, 2642, 2645, 1, 0, 0, 0, 2643, 2641,
		1, 0, 0, 0, 2643, 2644, 1, 0, 0, 0, 2644, 2883, 1, 0, 0, 0, 2645, 2643,
		1, 0, 0, 0, 2646, 2651, 5, 4, 0, 0, 2647, 2649, 5, 29, 0, 0, 2648, 2650,
		3, 586, 293, 0, 2649, 2648, 1, 0, 0, 0, 2649, 2650, 1, 0, 0, 0, 2650, 2652,
		1, 0, 0, 0, 2651, 2647, 1, 0, 0, 0, 2651, 2652, 1, 0, 0, 0, 2652, 2653,
		1, 0, 0, 0, 2653, 2654, 5, 66, 0, 0, 2654, 2656, 5, 90, 0, 0, 2655, 2657,
		3, 586, 293, 0, 2656, 2655, 1, 0, 0, 0, 2656, 2657, 1, 0, 0, 0, 2657, 2658,
		1, 0, 0, 0, 2658, 2659, 3, 624, 312, 0, 2659, 2660, 3, 98, 49, 0, 2660,
		2883, 1, 0, 0, 0, 2661, 2666, 5, 4, 0, 0, 2662, 2664, 5, 29, 0, 0, 2663,
		2665, 3, 586, 293, 0, 2664, 2663, 1, 0, 0, 0, 2664, 2665, 1, 0, 0, 0, 2665,
		2667, 1, 0, 0, 0, 2666, 2662, 1, 0, 0, 0, 2666, 2667, 1, 0, 0, 0, 2667,
		2668, 1, 0, 0, 0, 2668, 2675, 5, 25, 0, 0, 2669, 2676, 3, 586, 293, 0,
		2670, 2676, 3, 596, 298, 0, 2671, 2672, 5, 1132, 0, 0, 2672, 2673, 3, 690,
		345, 0, 2673, 2674, 5, 1133, 0, 0, 2674, 2676, 1, 0, 0, 0, 2675, 2669,
		1, 0, 0, 0, 2675, 2670, 1, 0, 0, 0, 2675, 2671, 1, 0, 0, 0, 2676, 2678,
		1, 0, 0, 0, 2677, 2679, 5, 113, 0, 0, 2678, 2677, 1, 0, 0, 0, 2678, 2679,
		1, 0, 0, 0, 2679, 2681, 1, 0, 0, 0, 2680, 2682, 5, 56, 0, 0, 2681, 2680,
		1, 0, 0, 0, 2681, 2682, 1, 0, 0, 0, 2682, 2883, 1, 0, 0, 0, 2683, 2688,
		5, 6, 0, 0, 2684, 2686, 5, 29, 0, 0, 2685, 2687, 3, 586, 293, 0, 2686,
		2685, 1, 0, 0, 0, 2686, 2687, 1, 0, 0, 0, 2687, 2689, 1, 0, 0, 0, 2688,
		2684, 1, 0, 0, 0, 2688, 2689, 1, 0, 0, 0, 2689, 2690, 1, 0, 0, 0, 2690,
		2697, 5, 25, 0, 0, 2691, 2698, 3, 586, 293, 0, 2692, 2698, 3, 596, 298,
		0, 2693, 2694, 5, 1132, 0, 0, 2694, 2695, 3, 690, 345, 0, 2695, 2696, 5,
		1133, 0, 0, 2696, 2698, 1, 0, 0, 0, 2697, 2691, 1, 0, 0, 0, 2697, 2692,
		1, 0, 0, 0, 2697, 2693, 1, 0, 0, 0, 2698, 2700, 1, 0, 0, 0, 2699, 2701,
		5, 113, 0, 0, 2700, 2699, 1, 0, 0, 0, 2700, 2701, 1, 0, 0, 0, 2701, 2703,
		1, 0, 0, 0, 2702, 2704, 5, 56, 0, 0, 2703, 2702, 1, 0, 0, 0, 2703, 2704,
		1, 0, 0, 0, 2704, 2883, 1, 0, 0, 0, 2705, 2710, 5, 4, 0, 0, 2706, 2708,
		5, 29, 0, 0, 2707, 2709, 3, 586, 293, 0, 2708, 2707, 1, 0, 0, 0, 2708,
		2709, 1, 0, 0, 0, 2709, 2711, 1, 0, 0, 0, 2710, 2706, 1, 0, 0, 0, 2710,
		2711, 1, 0, 0, 0, 2711, 2712, 1, 0, 0, 0, 2712, 2713, 5, 25, 0, 0, 2713,
		2714, 5, 1132, 0, 0, 2714, 2715, 3, 690, 345, 0, 2715, 2716, 5, 1133, 0,
		0, 2716, 2883, 1, 0, 0, 0, 2717, 2719, 5, 335, 0, 0, 2718, 2720, 5, 1123,
		0, 0, 2719, 2718, 1, 0, 0, 0, 2719, 2720, 1, 0, 0, 0, 2720, 2721, 1, 0,
		0, 0, 2721, 2883, 7, 34, 0, 0, 2722, 2724, 5, 6, 0, 0, 2723, 2725, 5, 27,
		0, 0, 2724, 2723, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725, 2726, 1, 0,
		0, 0, 2726, 2732, 3, 586, 293, 0, 2727, 2728, 5, 152, 0, 0, 2728, 2729,
		5, 41, 0, 0, 2729, 2733, 3, 636, 318, 0, 2730, 2731, 5, 50, 0, 0, 2731,
		2733, 5, 41, 0, 0, 2732, 2727, 1, 0, 0, 0, 2732, 2730, 1, 0, 0, 0, 2733,
		2883, 1, 0, 0, 0, 2734, 2736, 5, 23, 0, 0, 2735, 2737, 5, 27, 0, 0, 2736,
		2735, 1, 0, 0, 0, 2736, 2737, 1, 0, 0, 0, 2737, 2738, 1, 0, 0, 0, 2738,
		2739, 3, 586, 293, 0, 2739, 2740, 3, 586, 293, 0, 2740, 2744, 3, 92, 46,
		0, 2741, 2745, 5, 429, 0, 0, 2742, 2743, 5, 333, 0, 0, 2743, 2745, 3, 586,
		293, 0, 2744, 2741, 1, 0, 0, 0, 2744, 2742, 1, 0, 0, 0, 2744, 2745, 1,
		0, 0, 0, 2745, 2883, 1, 0, 0, 0, 2746, 2747, 5, 138, 0, 0, 2747, 2748,
		5, 27, 0, 0, 2748, 2749, 3, 586, 293, 0, 2749, 2750, 5, 174, 0, 0, 2750,
		2751, 3, 586, 293, 0, 2751, 2883, 1, 0, 0, 0, 2752, 2754, 5, 102, 0, 0,
		2753, 2755, 5, 1123, 0, 0, 2754, 2753, 1, 0, 0, 0, 2754, 2755, 1, 0, 0,
		0, 2755, 2756, 1, 0, 0, 0, 2756, 2883, 7, 4, 0, 0, 2757, 2759, 5, 511,
		0, 0, 2758, 2760, 5, 27, 0, 0, 2759, 2758, 1, 0, 0, 0, 2759, 2760, 1, 0,
		0, 0, 2760, 2761, 1, 0, 0, 0, 2761, 2762, 3, 586, 293, 0, 2762, 2766, 3,
		92, 46, 0, 2763, 2767, 5, 429, 0, 0, 2764, 2765, 5, 333, 0, 0, 2765, 2767,
		3, 586, 293, 0, 2766, 2763, 1, 0, 0, 0, 2766, 2764, 1, 0, 0, 0, 2766, 2767,
		1, 0, 0, 0, 2767, 2883, 1, 0, 0, 0, 2768, 2770, 5, 50, 0, 0, 2769, 2771,
		5, 27, 0, 0, 2770, 2769, 1, 0, 0, 0, 2770, 2771, 1, 0, 0, 0, 2771, 2772,
		1, 0, 0, 0, 2772, 2774, 3, 586, 293, 0, 2773, 2775, 5, 143, 0, 0, 2774,
		2773, 1, 0, 0, 0, 2774, 2775, 1, 0, 0, 0, 2775, 2883, 1, 0, 0, 0, 2776,
		2777, 5, 50, 0, 0, 2777, 2778, 7, 35, 0, 0, 2778, 2883, 3, 586, 293, 0,
		2779, 2780, 5, 50, 0, 0, 2780, 2781, 5, 129, 0, 0, 2781, 2883, 5, 90, 0,
		0, 2782, 2783, 5, 50, 0, 0, 2783, 2784, 7, 20, 0, 0, 2784, 2883, 3, 586,
		293, 0, 2785, 2786, 5, 138, 0, 0, 2786, 2787, 7, 20, 0, 0, 2787, 2788,
		3, 586, 293, 0, 2788, 2789, 5, 174, 0, 0, 2789, 2790, 3, 586, 293, 0, 2790,
		2883, 1, 0, 0, 0, 2791, 2793, 5, 6, 0, 0, 2792, 2794, 5, 27, 0, 0, 2793,
		2792, 1, 0, 0, 0, 2793, 2794, 1, 0, 0, 0, 2794, 2795, 1, 0, 0, 0, 2795,
		2809, 3, 586, 293, 0, 2796, 2797, 5, 152, 0, 0, 2797, 2803, 5, 41, 0, 0,
		2798, 2804, 3, 596, 298, 0, 2799, 2800, 5, 1132, 0, 0, 2800, 2801, 3, 690,
		345, 0, 2801, 2802, 5, 1133, 0, 0, 2802, 2804, 1, 0, 0, 0, 2803, 2798,
		1, 0, 0, 0, 2803, 2799, 1, 0, 0, 0, 2804, 2810, 1, 0, 0, 0, 2805, 2806,
		5, 152, 0, 0, 2806, 2810, 7, 15, 0, 0, 2807, 2808, 5, 50, 0, 0, 2808, 2810,
		5, 41, 0, 0, 2809, 2796, 1, 0, 0, 0, 2809, 2805, 1, 0, 0, 0, 2809, 2807,
		1, 0, 0, 0, 2810, 2883, 1, 0, 0, 0, 2811, 2812, 5, 6, 0, 0, 2812, 2813,
		5, 80, 0, 0, 2813, 2814, 3, 586, 293, 0, 2814, 2815, 7, 15, 0, 0, 2815,
		2883, 1, 0, 0, 0, 2816, 2817, 5, 50, 0, 0, 2817, 2818, 5, 66, 0, 0, 2818,
		2819, 5, 90, 0, 0, 2819, 2883, 3, 586, 293, 0, 2820, 2821, 5, 395, 0, 0,
		2821, 2883, 5, 91, 0, 0, 2822, 2823, 5, 402, 0, 0, 2823, 2883, 5, 91, 0,
		0, 2824, 2826, 5, 138, 0, 0, 2825, 2827, 7, 36, 0, 0, 2826, 2825, 1, 0,
		0, 0, 2826, 2827, 1, 0, 0, 0, 2827, 2830, 1, 0, 0, 0, 2828, 2831, 3, 586,
		293, 0, 2829, 2831, 3, 552, 276, 0, 2830, 2828, 1, 0, 0, 0, 2830, 2829,
		1, 0, 0, 0, 2831, 2883, 1, 0, 0, 0, 2832, 2833, 5, 123, 0, 0, 2833, 2834,
		5, 18, 0, 0, 2834, 2883, 3, 618, 309, 0, 2835, 2836, 5, 31, 0, 0, 2836,
		2840, 5, 174, 0, 0, 2837, 2841, 5, 840, 0, 0, 2838, 2839, 5, 24, 0, 0,
		2839, 2841, 5, 152, 0, 0, 2840, 2837, 1, 0, 0, 0, 2840, 2838, 1, 0, 0,
		0, 2841, 2842, 1, 0, 0, 0, 2842, 2845, 3, 570, 285, 0, 2843, 2844, 5, 26,
		0, 0, 2844, 2846, 3, 572, 286, 0, 2845, 2843, 1, 0, 0, 0, 2845, 2846, 1,
		0, 0, 0, 2846, 2883, 1, 0, 0, 0, 2847, 2849, 5, 41, 0, 0, 2848, 2847, 1,
		0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 2850, 1, 0, 0, 0, 2850, 2851, 5,
		24, 0, 0, 2851, 2852, 5, 152, 0, 0, 2852, 2853, 5, 1123, 0, 0, 2853, 2857,
		3, 570, 285, 0, 2854, 2855, 5, 26, 0, 0, 2855, 2856, 5, 1123, 0, 0, 2856,
		2858, 3, 572, 286, 0, 2857, 2854, 1, 0, 0, 0, 2857, 2858, 1, 0, 0, 0, 2858,
		2883, 1, 0, 0, 0, 2859, 2860, 5, 396, 0, 0, 2860, 2883, 5, 646, 0, 0, 2861,
		2862, 5, 449, 0, 0, 2862, 2883, 5, 646, 0, 0, 2863, 2883, 5, 65, 0, 0,
		2864, 2865, 7, 37, 0, 0, 2865, 2883, 5, 667, 0, 0, 2866, 2868, 5, 4, 0,
		0, 2867, 2869, 5, 27, 0, 0, 2868, 2867, 1, 0, 0, 0, 2868, 2869, 1, 0, 0,
		0, 2869, 2870, 1, 0, 0, 0, 2870, 2871, 5, 1132, 0, 0, 2871, 2876, 3, 90,
		45, 0, 2872, 2873, 5, 1134, 0, 0, 2873, 2875, 3, 90, 45, 0, 2874, 2872,
		1, 0, 0, 0, 2875, 2878, 1, 0, 0, 0, 2876, 2874, 1, 0, 0, 0, 2876, 2877,
		1, 0, 0, 0, 2877, 2879, 1, 0, 0, 0, 2878, 2876, 1, 0, 0, 0, 2879, 2880,
		5, 1133, 0, 0, 2880, 2883, 1, 0, 0, 0, 2881, 2883, 3, 150, 75, 0, 2882,
		2531, 1, 0, 0, 0, 2882, 2541, 1, 0, 0, 0, 2882, 2552, 1, 0, 0, 0, 2882,
		2570, 1, 0, 0, 0, 2882, 2585, 1, 0, 0, 0, 2882, 2607, 1, 0, 0, 0, 2882,
		2631, 1, 0, 0, 0, 2882, 2646, 1, 0, 0, 0, 2882, 2661, 1, 0, 0, 0, 2882,
		2683, 1, 0, 0, 0, 2882, 2705, 1, 0, 0, 0, 2882, 2717, 1, 0, 0, 0, 2882,
		2722, 1, 0, 0, 0, 2882, 2734, 1, 0, 0, 0, 2882, 2746, 1, 0, 0, 0, 2882,
		2752, 1, 0, 0, 0, 2882, 2757, 1, 0, 0, 0, 2882, 2768, 1, 0, 0, 0, 2882,
		2776, 1, 0, 0, 0, 2882, 2779, 1, 0, 0, 0, 2882, 2782, 1, 0, 0, 0, 2882,
		2785, 1, 0, 0, 0, 2882, 2791, 1, 0, 0, 0, 2882, 2811, 1, 0, 0, 0, 2882,
		2816, 1, 0, 0, 0, 2882, 2820, 1, 0, 0, 0, 2882, 2822, 1, 0, 0, 0, 2882,
		2824, 1, 0, 0, 0, 2882, 2832, 1, 0, 0, 0, 2882, 2835, 1, 0, 0, 0, 2882,
		2848, 1, 0, 0, 0, 2882, 2859, 1, 0, 0, 0, 2882, 2861, 1, 0, 0, 0, 2882,
		2863, 1, 0, 0, 0, 2882, 2864, 1, 0, 0, 0, 2882, 2866, 1, 0, 0, 0, 2882,
		2881, 1, 0, 0, 0, 2883, 149, 1, 0, 0, 0, 2884, 2885, 5, 4, 0, 0, 2885,
		2886, 5, 128, 0, 0, 2886, 2887, 5, 1132, 0, 0, 2887, 2892, 3, 118, 59,
		0, 2888, 2889, 5, 1134, 0, 0, 2889, 2891, 3, 118, 59, 0, 2890, 2888, 1,
		0, 0, 0, 2891, 2894, 1, 0, 0, 0, 2892, 2890, 1, 0, 0, 0, 2892, 2893, 1,
		0, 0, 0, 2893, 2895, 1, 0, 0, 0, 2894, 2892, 1, 0, 0, 0, 2895, 2896, 5,
		1133, 0, 0, 2896, 2983, 1, 0, 0, 0, 2897, 2898, 5, 50, 0, 0, 2898, 2899,
		5, 128, 0, 0, 2899, 2983, 3, 618, 309, 0, 2900, 2901, 5, 396, 0, 0, 2901,
		2904, 5, 128, 0, 0, 2902, 2905, 3, 618, 309, 0, 2903, 2905, 5, 5, 0, 0,
		2904, 2902, 1, 0, 0, 0, 2904, 2903, 1, 0, 0, 0, 2905, 2906, 1, 0, 0, 0,
		2906, 2983, 5, 646, 0, 0, 2907, 2908, 5, 449, 0, 0, 2908, 2911, 5, 128,
		0, 0, 2909, 2912, 3, 618, 309, 0, 2910, 2912, 5, 5, 0, 0, 2911, 2909, 1,
		0, 0, 0, 2911, 2910, 1, 0, 0, 0, 2912, 2913, 1, 0, 0, 0, 2913, 2983, 5,
		646, 0, 0, 2914, 2915, 5, 655, 0, 0, 2915, 2918, 5, 128, 0, 0, 2916, 2919,
		3, 618, 309, 0, 2917, 2919, 5, 5, 0, 0, 2918, 2916, 1, 0, 0, 0, 2918, 2917,
		1, 0, 0, 0, 2919, 2983, 1, 0, 0, 0, 2920, 2921, 5, 362, 0, 0, 2921, 2922,
		5, 128, 0, 0, 2922, 2983, 3, 592, 296, 0, 2923, 2924, 5, 578, 0, 0, 2924,
		2925, 5, 128, 0, 0, 2925, 2926, 3, 618, 309, 0, 2926, 2927, 5, 86, 0, 0,
		2927, 2928, 5, 1132, 0, 0, 2928, 2933, 3, 118, 59, 0, 2929, 2930, 5, 1134,
		0, 0, 2930, 2932, 3, 118, 59, 0, 2931, 2929, 1, 0, 0, 0, 2932, 2935, 1,
		0, 0, 0, 2933, 2931, 1, 0, 0, 0, 2933, 2934, 1, 0, 0, 0, 2934, 2936, 1,
		0, 0, 0, 2935, 2933, 1, 0, 0, 0, 2936, 2937, 5, 1133, 0, 0, 2937, 2983,
		1, 0, 0, 0, 2938, 2939, 5, 417, 0, 0, 2939, 2940, 5, 128, 0, 0, 2940, 2941,
		3, 586, 293, 0, 2941, 2942, 5, 191, 0, 0, 2942, 2943, 5, 171, 0, 0, 2943,
		2946, 3, 554, 277, 0, 2944, 2945, 7, 37, 0, 0, 2945, 2947, 5, 667, 0, 0,
		2946, 2944, 1, 0, 0, 0, 2946, 2947, 1, 0, 0, 0, 2947, 2983, 1, 0, 0, 0,
		2948, 2949, 5, 8, 0, 0, 2949, 2952, 5, 128, 0, 0, 2950, 2953, 3, 618, 309,
		0, 2951, 2953, 5, 5, 0, 0, 2952, 2950, 1, 0, 0, 0, 2952, 2951, 1, 0, 0,
		0, 2953, 2983, 1, 0, 0, 0, 2954, 2955, 5, 25, 0, 0, 2955, 2958, 5, 128,
		0, 0, 2956, 2959, 3, 618, 309, 0, 2957, 2959, 5, 5, 0, 0, 2958, 2956, 1,
		0, 0, 0, 2958, 2957, 1, 0, 0, 0, 2959, 2983, 1, 0, 0, 0, 2960, 2961, 5,
		118, 0, 0, 2961, 2964, 5, 128, 0, 0, 2962, 2965, 3, 618, 309, 0, 2963,
		2965, 5, 5, 0, 0, 2964, 2962, 1, 0, 0, 0, 2964, 2963, 1, 0, 0, 0, 2965,
		2983, 1, 0, 0, 0, 2966, 2967, 5, 568, 0, 0, 2967, 2970, 5, 128, 0, 0, 2968,
		2971, 3, 618, 309, 0, 2969, 2971, 5, 5, 0, 0, 2970, 2968, 1, 0, 0, 0, 2970,
		2969, 1, 0, 0, 0, 2971, 2983, 1, 0, 0, 0, 2972, 2973, 5, 579, 0, 0, 2973,
		2976, 5, 128, 0, 0, 2974, 2977, 3, 618, 309, 0, 2975, 2977, 5, 5, 0, 0,
		2976, 2974, 1, 0, 0, 0, 2976, 2975, 1, 0, 0, 0, 2977, 2983, 1, 0, 0, 0,
		2978, 2979, 5, 577, 0, 0, 2979, 2983, 5, 548, 0, 0, 2980, 2981, 5, 663,
		0, 0, 2981, 2983, 5, 548, 0, 0, 2982, 2884, 1, 0, 0, 0, 2982, 2897, 1,
		0, 0, 0, 2982, 2900, 1, 0, 0, 0, 2982, 2907, 1, 0, 0, 0, 2982, 2914, 1,
		0, 0, 0, 2982, 2920, 1, 0, 0, 0, 2982, 2923, 1, 0, 0, 0, 2982, 2938, 1,
		0, 0, 0, 2982, 2948, 1, 0, 0, 0, 2982, 2954, 1, 0, 0, 0, 2982, 2960, 1,
		0, 0, 0, 2982, 2966, 1, 0, 0, 0, 2982, 2972, 1, 0, 0, 0, 2982, 2978, 1,
		0, 0, 0, 2982, 2980, 1, 0, 0, 0, 2983, 151, 1, 0, 0, 0, 2984, 2985, 5,
		50, 0, 0, 2985, 2987, 7, 0, 0, 0, 2986, 2988, 3, 642, 321, 0, 2987, 2986,
		1, 0, 0, 0, 2987, 2988, 1, 0, 0, 0, 2988, 2989, 1, 0, 0, 0, 2989, 2990,
		3, 586, 293, 0, 2990, 153, 1, 0, 0, 0, 2991, 2992, 5, 50, 0, 0, 2992, 2994,
		5, 414, 0, 0, 2993, 2995, 3, 642, 321, 0, 2994, 2993, 1, 0, 0, 0, 2994,
		2995, 1, 0, 0, 0, 2995, 2996, 1, 0, 0, 0, 2996, 2997, 3, 552, 276, 0, 2997,
		155, 1, 0, 0, 0, 2998, 2999, 5, 50, 0, 0, 2999, 3001, 5, 80, 0, 0, 3000,
		3002, 7, 1, 0, 0, 3001, 3000, 1, 0, 0, 0, 3001, 3002, 1, 0, 0, 0, 3002,
		3003, 1, 0, 0, 0, 3003, 3004, 3, 586, 293, 0, 3004, 3005, 5, 117, 0, 0,
		3005, 3018, 3, 554, 277, 0, 3006, 3008, 5, 335, 0, 0, 3007, 3009, 5, 1123,
		0, 0, 3008, 3007, 1, 0, 0, 0, 3008, 3009, 1, 0, 0, 0, 3009, 3010, 1, 0,
		0, 0, 3010, 3017, 7, 3, 0, 0, 3011, 3013, 5, 102, 0, 0, 3012, 3014, 5,
		1123, 0, 0, 3013, 3012, 1, 0, 0, 0, 3013, 3014, 1, 0, 0, 0, 3014, 3015,
		1, 0, 0, 0, 3015, 3017, 7, 4, 0, 0, 3016, 3006, 1, 0, 0, 0, 3016, 3011,
		1, 0, 0, 0, 3017, 3020, 1, 0, 0, 0, 3018, 3016, 1, 0, 0, 0, 3018, 3019,
		1, 0, 0, 0, 3019, 157, 1, 0, 0, 0, 3020, 3018, 1, 0, 0, 0, 3021, 3022,
		5, 50, 0, 0, 3022, 3023, 5, 474, 0, 0, 3023, 3024, 5, 72, 0, 0, 3024, 3025,
		3, 586, 293, 0, 3025, 3026, 5, 408, 0, 0, 3026, 3027, 5, 1123, 0, 0, 3027,
		3028, 3, 574, 287, 0, 3028, 159, 1, 0, 0, 0, 3029, 3030, 5, 50, 0, 0, 3030,
		3032, 5, 130, 0, 0, 3031, 3033, 3, 642, 321, 0, 3032, 3031, 1, 0, 0, 0,
		3032, 3033, 1, 0, 0, 0, 3033, 3034, 1, 0, 0, 0, 3034, 3035, 3, 552, 276,
		0, 3035, 161, 1, 0, 0, 0, 3036, 3037, 5, 50, 0, 0, 3037, 3039, 5, 436,
		0, 0, 3038, 3040, 3, 642, 321, 0, 3039, 3038, 1, 0, 0, 0, 3039, 3040, 1,
		0, 0, 0, 3040, 3041, 1, 0, 0, 0, 3041, 3042, 3, 552, 276, 0, 3042, 163,
		1, 0, 0, 0, 3043, 3044, 5, 50, 0, 0, 3044, 3046, 5, 607, 0, 0, 3045, 3047,
		3, 642, 321, 0, 3046, 3045, 1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 3048,
		1, 0, 0, 0, 3048, 3049, 3, 586, 293, 0, 3049, 165, 1, 0, 0, 0, 3050, 3052,
		5, 50, 0, 0, 3051, 3053, 5, 648, 0, 0, 3052, 3051, 1, 0, 0, 0, 3052, 3053,
		1, 0, 0, 0, 3053, 3054, 1, 0, 0, 0, 3054, 3056, 5, 171, 0, 0, 3055, 3057,
		3, 642, 321, 0, 3056, 3055, 1, 0, 0, 0, 3056, 3057, 1, 0, 0, 0, 3057, 3058,
		1, 0, 0, 0, 3058, 3060, 3, 622, 311, 0, 3059, 3061, 7, 38, 0, 0, 3060,
		3059, 1, 0, 0, 0, 3060, 3061, 1, 0, 0, 0, 3061, 167, 1, 0, 0, 0, 3062,
		3063, 5, 50, 0, 0, 3063, 3064, 5, 646, 0, 0, 3064, 3070, 3, 586, 293, 0,
		3065, 3067, 5, 408, 0, 0, 3066, 3068, 5, 1123, 0, 0, 3067, 3066, 1, 0,
		0, 0, 3067, 3068, 1, 0, 0, 0, 3068, 3069, 1, 0, 0, 0, 3069, 3071, 3, 574,
		287, 0, 3070, 3065, 1, 0, 0, 0, 3070, 3071, 1, 0, 0, 0, 3071, 169, 1, 0,
		0, 0, 3072, 3073, 5, 50, 0, 0, 3073, 3075, 5, 176, 0, 0, 3074, 3076, 3,
		642, 321, 0, 3075, 3074, 1, 0, 0, 0, 3075, 3076, 1, 0, 0, 0, 3076, 3077,
		1, 0, 0, 0, 3077, 3078, 3, 552, 276, 0, 3078, 171, 1, 0, 0, 0, 3079, 3080,
		5, 50, 0, 0, 3080, 3082, 5, 670, 0, 0, 3081, 3083, 3, 642, 321, 0, 3082,
		3081, 1, 0, 0, 0, 3082, 3083, 1, 0, 0, 0, 3083, 3084, 1, 0, 0, 0, 3084,
		3089, 3, 552, 276, 0, 3085, 3086, 5, 1134, 0, 0, 3086, 3088, 3, 552, 276,
		0, 3087, 3085, 1, 0, 0, 0, 3088, 3091, 1, 0, 0, 0, 3089, 3087, 1, 0, 0,
		0, 3089, 3090, 1, 0, 0, 0, 3090, 3093, 1, 0, 0, 0, 3091, 3089, 1, 0, 0,
		0, 3092, 3094, 7, 38, 0, 0, 3093, 3092, 1, 0, 0, 0, 3093, 3094, 1, 0, 0,
		0, 3094, 173, 1, 0, 0, 0, 3095, 3096, 5, 50, 0, 0, 3096, 3098, 5, 595,
		0, 0, 3097, 3099, 3, 642, 321, 0, 3098, 3097, 1, 0, 0, 0, 3098, 3099, 1,
		0, 0, 0, 3099, 3100, 1, 0, 0, 0, 3100, 3105, 3, 556, 278, 0, 3101, 3102,
		5, 1134, 0, 0, 3102, 3104, 3, 556, 278, 0, 3103, 3101, 1, 0, 0, 0, 3104,
		3107, 1, 0, 0, 0, 3105, 3103, 1, 0, 0, 0, 3105, 3106, 1, 0, 0, 0, 3106,
		175, 1, 0, 0, 0, 3107, 3105, 1, 0, 0, 0, 3108, 3109, 5, 152, 0, 0, 3109,
		3110, 5, 41, 0, 0, 3110, 3121, 5, 595, 0, 0, 3111, 3122, 5, 528, 0, 0,
		3112, 3122, 5, 5, 0, 0, 3113, 3118, 3, 556, 278, 0, 3114, 3115, 5, 1134,
		0, 0, 3115, 3117, 3, 556, 278, 0, 3116, 3114, 1, 0, 0, 0, 3117, 3120, 1,
		0, 0, 0, 3118, 3116, 1, 0, 0, 0, 3118, 3119, 1, 0, 0, 0, 3119, 3122, 1,
		0, 0, 0, 3120, 3118, 1, 0, 0, 0, 3121, 3111, 1, 0, 0, 0, 3121, 3112, 1,
		0, 0, 0, 3121, 3113, 1, 0, 0, 0, 3122, 3123, 1, 0, 0, 0, 3123, 3126, 5,
		174, 0, 0, 3124, 3127, 3, 566, 283, 0, 3125, 3127, 3, 586, 293, 0, 3126,
		3124, 1, 0, 0, 0, 3126, 3125, 1, 0, 0, 0, 3127, 3135, 1, 0, 0, 0, 3128,
		3131, 5, 1134, 0, 0, 3129, 3132, 3, 566, 283, 0, 3130, 3132, 3, 586, 293,
		0, 3131, 3129, 1, 0, 0, 0, 3131, 3130, 1, 0, 0, 0, 3132, 3134, 1, 0, 0,
		0, 3133, 3128, 1, 0, 0, 0, 3134, 3137, 1, 0, 0, 0, 3135, 3133, 1, 0, 0,
		0, 3135, 3136, 1, 0, 0, 0, 3136, 3142, 1, 0, 0, 0, 3137, 3135, 1, 0, 0,
		0, 3138, 3139, 5, 152, 0, 0, 3139, 3140, 5, 595, 0, 0, 3140, 3142, 3, 436,
		218, 0, 3141, 3108, 1, 0, 0, 0, 3141, 3138, 1, 0, 0, 0, 3142, 177, 1, 0,
		0, 0, 3143, 3144, 5, 138, 0, 0, 3144, 3145, 5, 171, 0, 0, 3145, 3150, 3,
		180, 90, 0, 3146, 3147, 5, 1134, 0, 0, 3147, 3149, 3, 180, 90, 0, 3148,
		3146, 1, 0, 0, 0, 3149, 3152, 1, 0, 0, 0, 3150, 3148, 1, 0, 0, 0, 3150,
		3151, 1, 0, 0, 0, 3151, 179, 1, 0, 0, 0, 3152, 3150, 1, 0, 0, 0, 3153,
		3154, 3, 554, 277, 0, 3154, 3155, 5, 174, 0, 0, 3155, 3156, 3, 554, 277,
		0, 3156, 181, 1, 0, 0, 0, 3157, 3159, 5, 655, 0, 0, 3158, 3160, 5, 171,
		0, 0, 3159, 3158, 1, 0, 0, 0, 3159, 3160, 1, 0, 0, 0, 3160, 3161, 1, 0,
		0, 0, 3161, 3162, 3, 554, 277, 0, 3162, 183, 1, 0, 0, 0, 3163, 3164, 5,
		19, 0, 0, 3164, 3171, 3, 552, 276, 0, 3165, 3168, 5, 1132, 0, 0, 3166,
		3169, 3, 630, 315, 0, 3167, 3169, 3, 626, 313, 0, 3168, 3166, 1, 0, 0,
		0, 3168, 3167, 1, 0, 0, 0, 3168, 3169, 1, 0, 0, 0, 3169, 3170, 1, 0, 0,
		0, 3170, 3172, 5, 1133, 0, 0, 3171, 3165, 1, 0, 0, 0, 3171, 3172, 1, 0,
		0, 0, 3172, 185, 1, 0, 0, 0, 3173, 3176, 3, 214, 107, 0, 3174, 3176, 3,
		216, 108, 0, 3175, 3173, 1, 0, 0, 0, 3175, 3174, 1, 0, 0, 0, 3176, 187,
		1, 0, 0, 0, 3177, 3178, 5, 398, 0, 0, 3178, 3179, 3, 626, 313, 0, 3179,
		189, 1, 0, 0, 0, 3180, 3185, 3, 218, 109, 0, 3181, 3185, 3, 220, 110, 0,
		3182, 3185, 3, 222, 111, 0, 3183, 3185, 3, 224, 112, 0, 3184, 3180, 1,
		0, 0, 0, 3184, 3181, 1, 0, 0, 0, 3184, 3182, 1, 0, 0, 0, 3184, 3183, 1,
		0, 0, 0, 3185, 191, 1, 0, 0, 0, 3186, 3188, 5, 84, 0, 0, 3187, 3189, 3,
		254, 127, 0, 3188, 3187, 1, 0, 0, 0, 3188, 3189, 1, 0, 0, 0, 3189, 3191,
		1, 0, 0, 0, 3190, 3192, 7, 39, 0, 0, 3191, 3190, 1, 0, 0, 0, 3191, 3192,
		1, 0, 0, 0, 3192, 3194, 1, 0, 0, 0, 3193, 3195, 5, 77, 0, 0, 3194, 3193,
		1, 0, 0, 0, 3194, 3195, 1, 0, 0, 0, 3195, 3197, 1, 0, 0, 0, 3196, 3198,
		5, 86, 0, 0, 3197, 3196, 1, 0, 0, 0, 3197, 3198, 1, 0, 0, 0, 3198, 3199,
		1, 0, 0, 0, 3199, 3206, 3, 554, 277, 0, 3200, 3201, 5, 128, 0, 0, 3201,
		3203, 5, 1132, 0, 0, 3202, 3204, 3, 618, 309, 0, 3203, 3202, 1, 0, 0, 0,
		3203, 3204, 1, 0, 0, 0, 3204, 3205, 1, 0, 0, 0, 3205, 3207, 5, 1133, 0,
		0, 3206, 3200, 1, 0, 0, 0, 3206, 3207, 1, 0, 0, 0, 3207, 3231, 1, 0, 0,
		0, 3208, 3210, 5, 1132, 0, 0, 3209, 3211, 3, 620, 310, 0, 3210, 3209, 1,
		0, 0, 0, 3210, 3211, 1, 0, 0, 0, 3211, 3212, 1, 0, 0, 0, 3212, 3214, 5,
		1133, 0, 0, 3213, 3208, 1, 0, 0, 0, 3213, 3214, 1, 0, 0, 0, 3214, 3215,
		1, 0, 0, 0, 3215, 3220, 3, 206, 103, 0, 3216, 3218, 5, 11, 0, 0, 3217,
		3216, 1, 0, 0, 0, 3217, 3218, 1, 0, 0, 0, 3218, 3219, 1, 0, 0, 0, 3219,
		3221, 3, 586, 293, 0, 3220, 3217, 1, 0, 0, 0, 3220, 3221, 1, 0, 0, 0, 3221,
		3232, 1, 0, 0, 0, 3222, 3223, 5, 152, 0, 0, 3223, 3228, 3, 208, 104, 0,
		3224, 3225, 5, 1134, 0, 0, 3225, 3227, 3, 208, 104, 0, 3226, 3224, 1, 0,
		0, 0, 3227, 3230, 1, 0, 0, 0, 3228, 3226, 1, 0, 0, 0, 3228, 3229, 1, 0,
		0, 0, 3229, 3232, 1, 0, 0, 0, 3230, 3228, 1, 0, 0, 0, 3231, 3213, 1, 0,
		0, 0, 3231, 3222, 1, 0, 0, 0, 3232, 3245, 1, 0, 0, 0, 3233, 3234, 5, 117,
		0, 0, 3234, 3235, 5, 400, 0, 0, 3235, 3236, 5, 90, 0, 0, 3236, 3237, 5,
		183, 0, 0, 3237, 3242, 3, 208, 104, 0, 3238, 3239, 5, 1134, 0, 0, 3239,
		3241, 3, 208, 104, 0, 3240, 3238, 1, 0, 0, 0, 3241, 3244, 1, 0, 0, 0, 3242,
		3240, 1, 0, 0, 0, 3242, 3243, 1, 0, 0, 0, 3243, 3246, 1, 0, 0, 0, 3244,
		3242, 1, 0, 0, 0, 3245, 3233, 1, 0, 0, 0, 3245, 3246, 1, 0, 0, 0, 3246,
		193, 1, 0, 0, 0, 3247, 3248, 5, 101, 0, 0, 3248, 3250, 5, 387, 0, 0, 3249,
		3251, 7, 40, 0, 0, 3250, 3249, 1, 0, 0, 0, 3250, 3251, 1, 0, 0, 0, 3251,
		3253, 1, 0, 0, 0, 3252, 3254, 5, 473, 0, 0, 3253, 3252, 1, 0, 0, 0, 3253,
		3254, 1, 0, 0, 0, 3254, 3255, 1, 0, 0, 0, 3255, 3256, 5, 81, 0, 0, 3256,
		3258, 5, 1147, 0, 0, 3257, 3259, 7, 6, 0, 0, 3258, 3257, 1, 0, 0, 0, 3258,
		3259, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3261, 5, 86, 0, 0, 3261,
		3262, 5, 171, 0, 0, 3262, 3268, 3, 554, 277, 0, 3263, 3264, 5, 128, 0,
		0, 3264, 3265, 5, 1132, 0, 0, 3265, 3266, 3, 618, 309, 0, 3266, 3267, 5,
		1133, 0, 0, 3267, 3269, 1, 0, 0, 0, 3268, 3263, 1, 0, 0, 0, 3268, 3269,
		1, 0, 0, 0, 3269, 3273, 1, 0, 0, 0, 3270, 3271, 5, 24, 0, 0, 3271, 3272,
		5, 152, 0, 0, 3272, 3274, 3, 570, 285, 0, 3273, 3270, 1, 0, 0, 0, 3273,
		3274, 1, 0, 0, 0, 3274, 3281, 1, 0, 0, 0, 3275, 3277, 7, 41, 0, 0, 3276,
		3278, 3, 282, 141, 0, 3277, 3276, 1, 0, 0, 0, 3278, 3279, 1, 0, 0, 0, 3279,
		3277, 1, 0, 0, 0, 3279, 3280, 1, 0, 0, 0, 3280, 3282, 1, 0, 0, 0, 3281,
		3275, 1, 0, 0, 0, 3281, 3282, 1, 0, 0, 0, 3282, 3289, 1, 0, 0, 0, 3283,
		3285, 5, 100, 0, 0, 3284, 3286, 3, 284, 142, 0, 3285, 3284, 1, 0, 0, 0,
		3286, 3287, 1, 0, 0, 0, 3287, 3285, 1, 0, 0, 0, 3287, 3288, 1, 0, 0, 0,
		3288, 3290, 1, 0, 0, 0, 3289, 3283, 1, 0, 0, 0, 3289, 3290, 1, 0, 0, 0,
		3290, 3295, 1, 0, 0, 0, 3291, 3292, 5, 77, 0, 0, 3292, 3293, 3, 592, 296,
		0, 3293, 3294, 7, 42, 0, 0, 3294, 3296, 1, 0, 0, 0, 3295, 3291, 1, 0, 0,
		0, 3295, 3296, 1, 0, 0, 0, 3296, 3308, 1, 0, 0, 0, 3297, 3298, 5, 1132,
		0, 0, 3298, 3303, 3, 210, 105, 0, 3299, 3300, 5, 1134, 0, 0, 3300, 3302,
		3, 210, 105, 0, 3301, 3299, 1, 0, 0, 0, 3302, 3305, 1, 0, 0, 0, 3303, 3301,
		1, 0, 0, 0, 3303, 3304, 1, 0, 0, 0, 3304, 3306, 1, 0, 0, 0, 3305, 3303,
		1, 0, 0, 0, 3306, 3307, 5, 1133, 0, 0, 3307, 3309, 1, 0, 0, 0, 3308, 3297,
		1, 0, 0, 0, 3308, 3309, 1, 0, 0, 0, 3309, 3319, 1, 0, 0, 0, 3310, 3311,
		5, 152, 0, 0, 3311, 3316, 3, 208, 104, 0, 3312, 3313, 5, 1134, 0, 0, 3313,
		3315, 3, 208, 104, 0, 3314, 3312, 1, 0, 0, 0, 3315, 3318, 1, 0, 0, 0, 3316,
		3314, 1, 0, 0, 0, 3316, 3317, 1, 0, 0, 0, 3317, 3320, 1, 0, 0, 0, 3318,
		3316, 1, 0, 0, 0, 3319, 3310, 1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320,
		195, 1, 0, 0, 0, 3321, 3322, 5, 101, 0, 0, 3322, 3324, 5, 681, 0, 0, 3323,
		3325, 7, 40, 0, 0, 3324, 3323, 1, 0, 0, 0, 3324, 3325, 1, 0, 0, 0, 3325,
		3327, 1, 0, 0, 0, 3326, 3328, 5, 473, 0, 0, 3327, 3326, 1, 0, 0, 0, 3327,
		3328, 1, 0, 0, 0, 3328, 3329, 1, 0, 0, 0, 3329, 3330, 5, 81, 0, 0, 3330,
		3332, 5, 1147, 0, 0, 3331, 3333, 7, 6, 0, 0, 3332, 3331, 1, 0, 0, 0, 3332,
		3333, 1, 0, 0, 0, 3333, 3334, 1, 0, 0, 0, 3334, 3335, 5, 86, 0, 0, 3335,
		3336, 5, 171, 0, 0, 3336, 3340, 3, 554, 277, 0, 3337, 3338, 5, 24, 0, 0,
		3338, 3339, 5, 152, 0, 0, 3339, 3341, 3, 570, 285, 0, 3340, 3337, 1, 0,
		0, 0, 3340, 3341, 1, 0, 0, 0, 3341, 3348, 1, 0, 0, 0, 3342, 3343, 5, 600,
		0, 0, 3343, 3344, 5, 447, 0, 0, 3344, 3345, 5, 18, 0, 0, 3345, 3346, 5,
		1125, 0, 0, 3346, 3347, 5, 1147, 0, 0, 3347, 3349, 5, 1124, 0, 0, 3348,
		3342, 1, 0, 0, 0, 3348, 3349, 1, 0, 0, 0, 3349, 3354, 1, 0, 0, 0, 3350,
		3351, 5, 77, 0, 0, 3351, 3352, 3, 592, 296, 0, 3352, 3353, 7, 42, 0, 0,
		3353, 3355, 1, 0, 0, 0, 3354, 3350, 1, 0, 0, 0, 3354, 3355, 1, 0, 0, 0,
		3355, 3367, 1, 0, 0, 0, 3356, 3357, 5, 1132, 0, 0, 3357, 3362, 3, 210,
		105, 0, 3358, 3359, 5, 1134, 0, 0, 3359, 3361, 3, 210, 105, 0, 3360, 3358,
		1, 0, 0, 0, 3361, 3364, 1, 0, 0, 0, 3362, 3360, 1, 0, 0, 0, 3362, 3363,
		1, 0, 0, 0, 3363, 3365, 1, 0, 0, 0, 3364, 3362, 1, 0, 0, 0, 3365, 3366,
		5, 1133, 0, 0, 3366, 3368, 1, 0, 0, 0, 3367, 3356, 1, 0, 0, 0, 3367, 3368,
		1, 0, 0, 0, 3368, 3378, 1, 0, 0, 0, 3369, 3370, 5, 152, 0, 0, 3370, 3375,
		3, 208, 104, 0, 3371, 3372, 5, 1134, 0, 0, 3372, 3374, 3, 208, 104, 0,
		3373, 3371, 1, 0, 0, 0, 3374, 3377, 1, 0, 0, 0, 3375, 3373, 1, 0, 0, 0,
		3375, 3376, 1, 0, 0, 0, 3376, 3379, 1, 0, 0, 0, 3377, 3375, 1, 0, 0, 0,
		3378, 3369, 1, 0, 0, 0, 3378, 3379, 1, 0, 0, 0, 3379, 197, 1, 0, 0, 0,
		3380, 3382, 5, 140, 0, 0, 3381, 3383, 7, 43, 0, 0, 3382, 3381, 1, 0, 0,
		0, 3382, 3383, 1, 0, 0, 0, 3383, 3385, 1, 0, 0, 0, 3384, 3386, 5, 86, 0,
		0, 3385, 3384, 1, 0, 0, 0, 3385, 3386, 1, 0, 0, 0, 3386, 3387, 1, 0, 0,
		0, 3387, 3393, 3, 554, 277, 0, 3388, 3389, 5, 128, 0, 0, 3389, 3390, 5,
		1132, 0, 0, 3390, 3391, 3, 618, 309, 0, 3391, 3392, 5, 1133, 0, 0, 3392,
		3394, 1, 0, 0, 0, 3393, 3388, 1, 0, 0, 0, 3393, 3394, 1, 0, 0, 0, 3394,
		3411, 1, 0, 0, 0, 3395, 3396, 5, 1132, 0, 0, 3396, 3397, 3, 618, 309, 0,
		3397, 3398, 5, 1133, 0, 0, 3398, 3400, 1, 0, 0, 0, 3399, 3395, 1, 0, 0,
		0, 3399, 3400, 1, 0, 0, 0, 3400, 3401, 1, 0, 0, 0, 3401, 3412, 3, 206,
		103, 0, 3402, 3403, 5, 152, 0, 0, 3403, 3408, 3, 208, 104, 0, 3404, 3405,
		5, 1134, 0, 0, 3405, 3407, 3, 208, 104, 0, 3406, 3404, 1, 0, 0, 0, 3407,
		3410, 1, 0, 0, 0, 3408, 3406, 1, 0, 0, 0, 3408, 3409, 1, 0, 0, 0, 3409,
		3412, 1, 0, 0, 0, 3410, 3408, 1, 0, 0, 0, 3411, 3399, 1, 0, 0, 0, 3411,
		3402, 1, 0, 0, 0, 3412, 199, 1, 0, 0, 0, 3413, 3415, 3, 252, 126, 0, 3414,
		3416, 3, 212, 106, 0, 3415, 3414, 1, 0, 0, 0, 3415, 3416, 1, 0, 0, 0, 3416,
		3479, 1, 0, 0, 0, 3417, 3419, 3, 248, 124, 0, 3418, 3420, 3, 212, 106,
		0, 3419, 3418, 1, 0, 0, 0, 3419, 3420, 1, 0, 0, 0, 3420, 3479, 1, 0, 0,
		0, 3421, 3424, 3, 256, 128, 0, 3422, 3424, 3, 250, 125, 0, 3423, 3421,
		1, 0, 0, 0, 3423, 3422, 1, 0, 0, 0, 3424, 3426, 1, 0, 0, 0, 3425, 3427,
		3, 260, 130, 0, 3426, 3425, 1, 0, 0, 0, 3427, 3428, 1, 0, 0, 0, 3428, 3426,
		1, 0, 0, 0, 3428, 3429, 1, 0, 0, 0, 3429, 3438, 1, 0, 0, 0, 3430, 3432,
		5, 179, 0, 0, 3431, 3433, 7, 44, 0, 0, 3432, 3431, 1, 0, 0, 0, 3432, 3433,
		1, 0, 0, 0, 3433, 3436, 1, 0, 0, 0, 3434, 3437, 3, 252, 126, 0, 3435, 3437,
		3, 248, 124, 0, 3436, 3434, 1, 0, 0, 0, 3436, 3435, 1, 0, 0, 0, 3437, 3439,
		1, 0, 0, 0, 3438, 3430, 1, 0, 0, 0, 3438, 3439, 1, 0, 0, 0, 3439, 3441,
		1, 0, 0, 0, 3440, 3442, 3, 230, 115, 0, 3441, 3440, 1, 0, 0, 0, 3441, 3442,
		1, 0, 0, 0, 3442, 3444, 1, 0, 0, 0, 3443, 3445, 3, 296, 148, 0, 3444, 3443,
		1, 0, 0, 0, 3444, 3445, 1, 0, 0, 0, 3445, 3447, 1, 0, 0, 0, 3446, 3448,
		3, 212, 106, 0, 3447, 3446, 1, 0, 0, 0, 3447, 3448, 1, 0, 0, 0, 3448, 3479,
		1, 0, 0, 0, 3449, 3451, 3, 250, 125, 0, 3450, 3452, 3, 258, 129, 0, 3451,
		3450, 1, 0, 0, 0, 3452, 3453, 1, 0, 0, 0, 3453, 3451, 1, 0, 0, 0, 3453,
		3454, 1, 0, 0, 0, 3454, 3460, 1, 0, 0, 0, 3455, 3457, 5, 179, 0, 0, 3456,
		3458, 7, 44, 0, 0, 3457, 3456, 1, 0, 0, 0, 3457, 3458, 1, 0, 0, 0, 3458,
		3459, 1, 0, 0, 0, 3459, 3461, 3, 248, 124, 0, 3460, 3455, 1, 0, 0, 0, 3460,
		3461, 1, 0, 0, 0, 3461, 3463, 1, 0, 0, 0, 3462, 3464, 3, 230, 115, 0, 3463,
		3462, 1, 0, 0, 0, 3463, 3464, 1, 0, 0, 0, 3464, 3466, 1, 0, 0, 0, 3465,
		3467, 3, 296, 148, 0, 3466, 3465, 1, 0, 0, 0, 3466, 3467, 1, 0, 0, 0, 3467,
		3469, 1, 0, 0, 0, 3468, 3470, 3, 212, 106, 0, 3469, 3468, 1, 0, 0, 0, 3469,
		3470, 1, 0, 0, 0, 3470, 3479, 1, 0, 0, 0, 3471, 3474, 3, 256, 128, 0, 3472,
		3473, 5, 1134, 0, 0, 3473, 3475, 3, 262, 131, 0, 3474, 3472, 1, 0, 0, 0,
		3475, 3476, 1, 0, 0, 0, 3476, 3474, 1, 0, 0, 0, 3476, 3477, 1, 0, 0, 0,
		3477, 3479, 1, 0, 0, 0, 3478, 3413, 1, 0, 0, 0, 3478, 3417, 1, 0, 0, 0,
		3478, 3423, 1, 0, 0, 0, 3478, 3449, 1, 0, 0, 0, 3478, 3471, 1, 0, 0, 0,
		3479, 201, 1, 0, 0, 0, 3480, 3483, 3, 226, 113, 0, 3481, 3483, 3, 228,
		114, 0, 3482, 3480, 1, 0, 0, 0, 3482, 3481, 1, 0, 0, 0, 3483, 203, 1, 0,
		0, 0, 3484, 3485, 5, 187, 0, 0, 3485, 3487, 5, 1132, 0, 0, 3486, 3488,
		3, 628, 314, 0, 3487, 3486, 1, 0, 0, 0, 3487, 3488, 1, 0, 0, 0, 3488, 3489,
		1, 0, 0, 0, 3489, 3498, 5, 1133, 0, 0, 3490, 3491, 5, 1134, 0, 0, 3491,
		3493, 5, 1132, 0, 0, 3492, 3494, 3, 628, 314, 0, 3493, 3492, 1, 0, 0, 0,
		3493, 3494, 1, 0, 0, 0, 3494, 3495, 1, 0, 0, 0, 3495, 3497, 5, 1133, 0,
		0, 3496, 3490, 1, 0, 0, 0, 3497, 3500, 1, 0, 0, 0, 3498, 3496, 1, 0, 0,
		0, 3498, 3499, 1, 0, 0, 0, 3499, 205, 1, 0, 0, 0, 3500, 3498, 1, 0, 0,
		0, 3501, 3520, 3, 200, 100, 0, 3502, 3503, 7, 45, 0, 0, 3503, 3505, 5,
		1132, 0, 0, 3504, 3506, 3, 628, 314, 0, 3505, 3504, 1, 0, 0, 0, 3505, 3506,
		1, 0, 0, 0, 3506, 3507, 1, 0, 0, 0, 3507, 3516, 5, 1133, 0, 0, 3508, 3509,
		5, 1134, 0, 0, 3509, 3511, 5, 1132, 0, 0, 3510, 3512, 3, 628, 314, 0, 3511,
		3510, 1, 0, 0, 0, 3511, 3512, 1, 0, 0, 0, 3512, 3513, 1, 0, 0, 0, 3513,
		3515, 5, 1133, 0, 0, 3514, 3508, 1, 0, 0, 0, 3515, 3518, 1, 0, 0, 0, 3516,
		3514, 1, 0, 0, 0, 3516, 3517, 1, 0, 0, 0, 3517, 3520, 1, 0, 0, 0, 3518,
		3516, 1, 0, 0, 0, 3519, 3501, 1, 0, 0, 0, 3519, 3502, 1, 0, 0, 0, 3520,
		207, 1, 0, 0, 0, 3521, 3522, 3, 558, 279, 0, 3522, 3525, 5, 1123, 0, 0,
		3523, 3526, 3, 690, 345, 0, 3524, 3526, 5, 41, 0, 0, 3525, 3523, 1, 0,
		0, 0, 3525, 3524, 1, 0, 0, 0, 3526, 209, 1, 0, 0, 0, 3527, 3530, 3, 586,
		293, 0, 3528, 3530, 5, 1158, 0, 0, 3529, 3527, 1, 0, 0, 0, 3529, 3528,
		1, 0, 0, 0, 3530, 211, 1, 0, 0, 0, 3531, 3532, 5, 64, 0, 0, 3532, 3538,
		5, 183, 0, 0, 3533, 3534, 5, 102, 0, 0, 3534, 3535, 5, 79, 0, 0, 3535,
		3536, 5, 609, 0, 0, 3536, 3538, 5, 510, 0, 0, 3537, 3531, 1, 0, 0, 0, 3537,
		3533, 1, 0, 0, 0, 3538, 213, 1, 0, 0, 0, 3539, 3541, 5, 43, 0, 0, 3540,
		3542, 3, 254, 127, 0, 3541, 3540, 1, 0, 0, 0, 3541, 3542, 1, 0, 0, 0, 3542,
		3544, 1, 0, 0, 0, 3543, 3545, 5, 105, 0, 0, 3544, 3543, 1, 0, 0, 0, 3544,
		3545, 1, 0, 0, 0, 3545, 3547, 1, 0, 0, 0, 3546, 3548, 5, 567, 0, 0, 3547,
		3546, 1, 0, 0, 0, 3547, 3548, 1, 0, 0, 0, 3548, 3550, 1, 0, 0, 0, 3549,
		3551, 5, 77, 0, 0, 3550, 3549, 1, 0, 0, 0, 3550, 3551, 1, 0, 0, 0, 3551,
		3552, 1, 0, 0, 0, 3552, 3553, 5, 67, 0, 0, 3553, 3558, 3, 554, 277, 0,
		3554, 3556, 5, 11, 0, 0, 3555, 3554, 1, 0, 0, 0, 3555, 3556, 1, 0, 0, 0,
		3556, 3557, 1, 0, 0, 0, 3557, 3559, 3, 586, 293, 0, 3558, 3555, 1, 0, 0,
		0, 3558, 3559, 1, 0, 0, 0, 3559, 3565, 1, 0, 0, 0, 3560, 3561, 5, 128,
		0, 0, 3561, 3562, 5, 1132, 0, 0, 3562, 3563, 3, 618, 309, 0, 3563, 3564,
		5, 1133, 0, 0, 3564, 3566, 1, 0, 0, 0, 3565, 3560, 1, 0, 0, 0, 3565, 3566,
		1, 0, 0, 0, 3566, 3569, 1, 0, 0, 0, 3567, 3568, 5, 189, 0, 0, 3568, 3570,
		3, 690, 345, 0, 3569, 3567, 1, 0, 0, 0, 3569, 3570, 1, 0, 0, 0, 3570, 3572,
		1, 0, 0, 0, 3571, 3573, 3, 230, 115, 0, 3572, 3571, 1, 0, 0, 0, 3572, 3573,
		1, 0, 0, 0, 3573, 3576, 1, 0, 0, 0, 3574, 3575, 5, 98, 0, 0, 3575, 3577,
		3, 298, 149, 0, 3576, 3574, 1, 0, 0, 0, 3576, 3577, 1, 0, 0, 0, 3577, 215,
		1, 0, 0, 0, 3578, 3580, 5, 43, 0, 0, 3579, 3581, 3, 254, 127, 0, 3580,
		3579, 1, 0, 0, 0, 3580, 3581, 1, 0, 0, 0, 3581, 3583, 1, 0, 0, 0, 3582,
		3584, 5, 105, 0, 0, 3583, 3582, 1, 0, 0, 0, 3583, 3584, 1, 0, 0, 0, 3584,
		3586, 1, 0, 0, 0, 3585, 3587, 5, 567, 0, 0, 3586, 3585, 1, 0, 0, 0, 3586,
		3587, 1, 0, 0, 0, 3587, 3589, 1, 0, 0, 0, 3588, 3590, 5, 77, 0, 0, 3589,
		3588, 1, 0, 0, 0, 3589, 3590, 1, 0, 0, 0, 3590, 3630, 1, 0, 0, 0, 3591,
		3594, 3, 554, 277, 0, 3592, 3593, 5, 1131, 0, 0, 3593, 3595, 5, 1116, 0,
		0, 3594, 3592, 1, 0, 0, 0, 3594, 3595, 1, 0, 0, 0, 3595, 3604, 1, 0, 0,
		0, 3596, 3597, 5, 1134, 0, 0, 3597, 3600, 3, 554, 277, 0, 3598, 3599, 5,
		1131, 0, 0, 3599, 3601, 5, 1116, 0, 0, 3600, 3598, 1, 0, 0, 0, 3600, 3601,
		1, 0, 0, 0, 3601, 3603, 1, 0, 0, 0, 3602, 3596, 1, 0, 0, 0, 3603, 3606,
		1, 0, 0, 0, 3604, 3602, 1, 0, 0, 0, 3604, 3605, 1, 0, 0, 0, 3605, 3607,
		1, 0, 0, 0, 3606, 3604, 1, 0, 0, 0, 3607, 3608, 5, 67, 0, 0, 3608, 3609,
		3, 234, 117, 0, 3609, 3631, 1, 0, 0, 0, 3610, 3611, 5, 67, 0, 0, 3611,
		3614, 3, 554, 277, 0, 3612, 3613, 5, 1131, 0, 0, 3613, 3615, 5, 1116, 0,
		0, 3614, 3612, 1, 0, 0, 0, 3614, 3615, 1, 0, 0, 0, 3615, 3624, 1, 0, 0,
		0, 3616, 3617, 5, 1134, 0, 0, 3617, 3620, 3, 554, 277, 0, 3618, 3619, 5,
		1131, 0, 0, 3619, 3621, 5, 1116, 0, 0, 3620, 3618, 1, 0, 0, 0, 3620, 3621,
		1, 0, 0, 0, 3621, 3623, 1, 0, 0, 0, 3622, 3616, 1, 0, 0, 0, 3623, 3626,
		1, 0, 0, 0, 3624, 3622, 1, 0, 0, 0, 3624, 3625, 1, 0, 0, 0, 3625, 3627,
		1, 0, 0, 0, 3626, 3624, 1, 0, 0, 0, 3627, 3628, 5, 186, 0, 0, 3628, 3629,
		3, 234, 117, 0, 3629, 3631, 1, 0, 0, 0, 3630, 3591, 1, 0, 0, 0, 3630, 3610,
		1, 0, 0, 0, 3631, 3634, 1, 0, 0, 0, 3632, 3633, 5, 189, 0, 0, 3633, 3635,
		3, 690, 345, 0, 3634, 3632, 1, 0, 0, 0, 3634, 3635, 1, 0, 0, 0, 3635, 217,
		1, 0, 0, 0, 3636, 3637, 5, 441, 0, 0, 3637, 3638, 3, 554, 277, 0, 3638,
		3643, 5, 538, 0, 0, 3639, 3641, 5, 11, 0, 0, 3640, 3639, 1, 0, 0, 0, 3640,
		3641, 1, 0, 0, 0, 3641, 3642, 1, 0, 0, 0, 3642, 3644, 3, 586, 293, 0, 3643,
		3640, 1, 0, 0, 0, 3643, 3644, 1, 0, 0, 0, 3644, 219, 1, 0, 0, 0, 3645,
		3646, 5, 441, 0, 0, 3646, 3647, 3, 554, 277, 0, 3647, 3648, 5, 133, 0,
		0, 3648, 3655, 3, 586, 293, 0, 3649, 3650, 3, 698, 349, 0, 3650, 3651,
		5, 1132, 0, 0, 3651, 3652, 3, 630, 315, 0, 3652, 3653, 5, 1133, 0, 0, 3653,
		3656, 1, 0, 0, 0, 3654, 3656, 7, 46, 0, 0, 3655, 3649, 1, 0, 0, 0, 3655,
		3654, 1, 0, 0, 0, 3656, 3659, 1, 0, 0, 0, 3657, 3658, 5, 189, 0, 0, 3658,
		3660, 3, 690, 345, 0, 3659, 3657, 1, 0, 0, 0, 3659, 3660, 1, 0, 0, 0, 3660,
		3663, 1, 0, 0, 0, 3661, 3662, 5, 98, 0, 0, 3662, 3664, 3, 298, 149, 0,
		3663, 3661, 1, 0, 0, 0, 3663, 3664, 1, 0, 0, 0, 3664, 221, 1, 0, 0, 0,
		3665, 3666, 5, 441, 0, 0, 3666, 3667, 3, 554, 277, 0, 3667, 3668, 5, 133,
		0, 0, 3668, 3671, 7, 47, 0, 0, 3669, 3670, 5, 189, 0, 0, 3670, 3672, 3,
		690, 345, 0, 3671, 3669, 1, 0, 0, 0, 3671, 3672, 1, 0, 0, 0, 3672, 3675,
		1, 0, 0, 0, 3673, 3674, 5, 98, 0, 0, 3674, 3676, 3, 298, 149, 0, 3675,
		3673, 1, 0, 0, 0, 3675, 3676, 1, 0, 0, 0, 3676, 223, 1, 0, 0, 0, 3677,
		3678, 5, 441, 0, 0, 3678, 3679, 3, 554, 277, 0, 3679, 3680, 5, 360, 0,
		0, 3680, 225, 1, 0, 0, 0, 3681, 3683, 5, 183, 0, 0, 3682, 3684, 3, 254,
		127, 0, 3683, 3682, 1, 0, 0, 0, 3683, 3684, 1, 0, 0, 0, 3684, 3686, 1,
		0, 0, 0, 3685, 3687, 5, 105, 0, 0, 3686, 3685, 1, 0, 0, 0, 3686, 3687,
		1, 0, 0, 0, 3687, 3689, 1, 0, 0, 0, 3688, 3690, 5, 77, 0, 0, 3689, 3688,
		1, 0, 0, 0, 3689, 3690, 1, 0, 0, 0, 3690, 3691, 1, 0, 0, 0, 3691, 3696,
		3, 554, 277, 0, 3692, 3694, 5, 11, 0, 0, 3693, 3692, 1, 0, 0, 0, 3693,
		3694, 1, 0, 0, 0, 3694, 3695, 1, 0, 0, 0, 3695, 3697, 3, 586, 293, 0, 3696,
		3693, 1, 0, 0, 0, 3696, 3697, 1, 0, 0, 0, 3697, 3698, 1, 0, 0, 0, 3698,
		3699, 5, 152, 0, 0, 3699, 3704, 3, 208, 104, 0, 3700, 3701, 5, 1134, 0,
		0, 3701, 3703, 3, 208, 104, 0, 3702, 3700, 1, 0, 0, 0, 3703, 3706, 1, 0,
		0, 0, 3704, 3702, 1, 0, 0, 0, 3704, 3705, 1, 0, 0, 0, 3705, 3709, 1, 0,
		0, 0, 3706, 3704, 1, 0, 0, 0, 3707, 3708, 5, 189, 0, 0, 3708, 3710, 3,
		690, 345, 0, 3709, 3707, 1, 0, 0, 0, 3709, 3710, 1, 0, 0, 0, 3710, 3712,
		1, 0, 0, 0, 3711, 3713, 3, 230, 115, 0, 3712, 3711, 1, 0, 0, 0, 3712, 3713,
		1, 0, 0, 0, 3713, 3715, 1, 0, 0, 0, 3714, 3716, 3, 296, 148, 0, 3715, 3714,
		1, 0, 0, 0, 3715, 3716, 1, 0, 0, 0, 3716, 227, 1, 0, 0, 0, 3717, 3719,
		5, 183, 0, 0, 3718, 3720, 3, 254, 127, 0, 3719, 3718, 1, 0, 0, 0, 3719,
		3720, 1, 0, 0, 0, 3720, 3722, 1, 0, 0, 0, 3721, 3723, 5, 105, 0, 0, 3722,
		3721, 1, 0, 0, 0, 3722, 3723, 1, 0, 0, 0, 3723, 3725, 1, 0, 0, 0, 3724,
		3726, 5, 77, 0, 0, 3725, 3724, 1, 0, 0, 0, 3725, 3726, 1, 0, 0, 0, 3726,
		3727, 1, 0, 0, 0, 3727, 3728, 3, 234, 117, 0, 3728, 3729, 5, 152, 0, 0,
		3729, 3734, 3, 208, 104, 0, 3730, 3731, 5, 1134, 0, 0, 3731, 3733, 3, 208,
		104, 0, 3732, 3730, 1, 0, 0, 0, 3733, 3736, 1, 0, 0, 0, 3734, 3732, 1,
		0, 0, 0, 3734, 3735, 1, 0, 0, 0, 3735, 3739, 1, 0, 0, 0, 3736, 3734, 1,
		0, 0, 0, 3737, 3738, 5, 189, 0, 0, 3738, 3740, 3, 690, 345, 0, 3739, 3737,
		1, 0, 0, 0, 3739, 3740, 1, 0, 0, 0, 3740, 229, 1, 0, 0, 0, 3741, 3742,
		5, 123, 0, 0, 3742, 3743, 5, 18, 0, 0, 3743, 3748, 3, 232, 116, 0, 3744,
		3745, 5, 1134, 0, 0, 3745, 3747, 3, 232, 116, 0, 3746, 3744, 1, 0, 0, 0,
		3747, 3750, 1, 0, 0, 0, 3748, 3746, 1, 0, 0, 0, 3748, 3749, 1, 0, 0, 0,
		3749, 231, 1, 0, 0, 0, 3750, 3748, 1, 0, 0, 0, 3751, 3753, 3, 690, 345,
		0, 3752, 3754, 7, 48, 0, 0, 3753, 3752, 1, 0, 0, 0, 3753, 3754, 1, 0, 0,
		0, 3754, 233, 1, 0, 0, 0, 3755, 3760, 3, 236, 118, 0, 3756, 3757, 5, 1134,
		0, 0, 3757, 3759, 3, 236, 118, 0, 3758, 3756, 1, 0, 0, 0, 3759, 3762, 1,
		0, 0, 0, 3760, 3758, 1, 0, 0, 0, 3760, 3761, 1, 0, 0, 0, 3761, 235, 1,
		0, 0, 0, 3762, 3760, 1, 0, 0, 0, 3763, 3767, 3, 238, 119, 0, 3764, 3766,
		3, 244, 122, 0, 3765, 3764, 1, 0, 0, 0, 3766, 3769, 1, 0, 0, 0, 3767, 3765,
		1, 0, 0, 0, 3767, 3768, 1, 0, 0, 0, 3768, 3782, 1, 0, 0, 0, 3769, 3767,
		1, 0, 0, 0, 3770, 3771, 5, 1132, 0, 0, 3771, 3775, 3, 238, 119, 0, 3772,
		3774, 3, 244, 122, 0, 3773, 3772, 1, 0, 0, 0, 3774, 3777, 1, 0, 0, 0, 3775,
		3773, 1, 0, 0, 0, 3775, 3776, 1, 0, 0, 0, 3776, 3778, 1, 0, 0, 0, 3777,
		3775, 1, 0, 0, 0, 3778, 3779, 5, 1133, 0, 0, 3779, 3782, 1, 0, 0, 0, 3780,
		3782, 3, 264, 132, 0, 3781, 3763, 1, 0, 0, 0, 3781, 3770, 1, 0, 0, 0, 3781,
		3780, 1, 0, 0, 0, 3782, 237, 1, 0, 0, 0, 3783, 3789, 3, 554, 277, 0, 3784,
		3785, 5, 128, 0, 0, 3785, 3786, 5, 1132, 0, 0, 3786, 3787, 3, 618, 309,
		0, 3787, 3788, 5, 1133, 0, 0, 3788, 3790, 1, 0, 0, 0, 3789, 3784, 1, 0,
		0, 0, 3789, 3790, 1, 0, 0, 0, 3790, 3795, 1, 0, 0, 0, 3791, 3793, 5, 11,
		0, 0, 3792, 3791, 1, 0, 0, 0, 3792, 3793, 1, 0, 0, 0, 3793, 3794, 1, 0,
		0, 0, 3794, 3796, 3, 586, 293, 0, 3795, 3792, 1, 0, 0, 0, 3795, 3796, 1,
		0, 0, 0, 3796, 3805, 1, 0, 0, 0, 3797, 3802, 3, 240, 120, 0, 3798, 3799,
		5, 1134, 0, 0, 3799, 3801, 3, 240, 120, 0, 3800, 3798, 1, 0, 0, 0, 3801,
		3804, 1, 0, 0, 0, 3802, 3800, 1, 0, 0, 0, 3802, 3803, 1, 0, 0, 0, 3803,
		3806, 1, 0, 0, 0, 3804, 3802, 1, 0, 0, 0, 3805, 3797, 1, 0, 0, 0, 3805,
		3806, 1, 0, 0, 0, 3806, 3824, 1, 0, 0, 0, 3807, 3813, 3, 200, 100, 0, 3808,
		3809, 5, 1132, 0, 0, 3809, 3810, 3, 200, 100, 0, 3810, 3811, 5, 1133, 0,
		0, 3811, 3813, 1, 0, 0, 0, 3812, 3807, 1, 0, 0, 0, 3812, 3808, 1, 0, 0,
		0, 3813, 3815, 1, 0, 0, 0, 3814, 3816, 5, 11, 0, 0, 3815, 3814, 1, 0, 0,
		0, 3815, 3816, 1, 0, 0, 0, 3816, 3817, 1, 0, 0, 0, 3817, 3818, 3, 586,
		293, 0, 3818, 3824, 1, 0, 0, 0, 3819, 3820, 5, 1132, 0, 0, 3820, 3821,
		3, 234, 117, 0, 3821, 3822, 5, 1133, 0, 0, 3822, 3824, 1, 0, 0, 0, 3823,
		3783, 1, 0, 0, 0, 3823, 3812, 1, 0, 0, 0, 3823, 3819, 1, 0, 0, 0, 3824,
		239, 1, 0, 0, 0, 3825, 3826, 7, 49, 0, 0, 3826, 3829, 7, 20, 0, 0, 3827,
		3828, 5, 64, 0, 0, 3828, 3830, 3, 242, 121, 0, 3829, 3827, 1, 0, 0, 0,
		3829, 3830, 1, 0, 0, 0, 3830, 3831, 1, 0, 0, 0, 3831, 3832, 5, 1132, 0,
		0, 3832, 3833, 3, 618, 309, 0, 3833, 3834, 5, 1133, 0, 0, 3834, 241, 1,
		0, 0, 0, 3835, 3841, 5, 89, 0, 0, 3836, 3837, 5, 123, 0, 0, 3837, 3841,
		5, 18, 0, 0, 3838, 3839, 5, 72, 0, 0, 3839, 3841, 5, 18, 0, 0, 3840, 3835,
		1, 0, 0, 0, 3840, 3836, 1, 0, 0, 0, 3840, 3838, 1, 0, 0, 0, 3841, 243,
		1, 0, 0, 0, 3842, 3844, 7, 50, 0, 0, 3843, 3842, 1, 0, 0, 0, 3843, 3844,
		1, 0, 0, 0, 3844, 3845, 1, 0, 0, 0, 3845, 3847, 5, 89, 0, 0, 3846, 3848,
		5, 93, 0, 0, 3847, 3846, 1, 0, 0, 0, 3847, 3848, 1, 0, 0, 0, 3848, 3849,
		1, 0, 0, 0, 3849, 3853, 3, 238, 119, 0, 3850, 3852, 3, 246, 123, 0, 3851,
		3850, 1, 0, 0, 0, 3852, 3855, 1, 0, 0, 0, 3853, 3851, 1, 0, 0, 0, 3853,
		3854, 1, 0, 0, 0, 3854, 3890, 1, 0, 0, 0, 3855, 3853, 1, 0, 0, 0, 3856,
		3857, 5, 170, 0, 0, 3857, 3862, 3, 238, 119, 0, 3858, 3859, 5, 117, 0,
		0, 3859, 3861, 3, 690, 345, 0, 3860, 3858, 1, 0, 0, 0, 3861, 3864, 1, 0,
		0, 0, 3862, 3860, 1, 0, 0, 0, 3862, 3863, 1, 0, 0, 0, 3863, 3890, 1, 0,
		0, 0, 3864, 3862, 1, 0, 0, 0, 3865, 3867, 7, 51, 0, 0, 3866, 3868, 5, 125,
		0, 0, 3867, 3866, 1, 0, 0, 0, 3867, 3868, 1, 0, 0, 0, 3868, 3869, 1, 0,
		0, 0, 3869, 3871, 5, 89, 0, 0, 3870, 3872, 5, 93, 0, 0, 3871, 3870, 1,
		0, 0, 0, 3871, 3872, 1, 0, 0, 0, 3872, 3873, 1, 0, 0, 0, 3873, 3877, 3,
		238, 119, 0, 3874, 3876, 3, 246, 123, 0, 3875, 3874, 1, 0, 0, 0, 3876,
		3879, 1, 0, 0, 0, 3877, 3875, 1, 0, 0, 0, 3877, 3878, 1, 0, 0, 0, 3878,
		3890, 1, 0, 0, 0, 3879, 3877, 1, 0, 0, 0, 3880, 3885, 5, 112, 0, 0, 3881,
		3883, 7, 51, 0, 0, 3882, 3884, 5, 125, 0, 0, 3883, 3882, 1, 0, 0, 0, 3883,
		3884, 1, 0, 0, 0, 3884, 3886, 1, 0, 0, 0, 3885, 3881, 1, 0, 0, 0, 3885,
		3886, 1, 0, 0, 0, 3886, 3887, 1, 0, 0, 0, 3887, 3888, 5, 89, 0, 0, 3888,
		3890, 3, 238, 119, 0, 3889, 3843, 1, 0, 0, 0, 3889, 3856, 1, 0, 0, 0, 3889,
		3865, 1, 0, 0, 0, 3889, 3880, 1, 0, 0, 0, 3890, 245, 1, 0, 0, 0, 3891,
		3892, 5, 117, 0, 0, 3892, 3899, 3, 690, 345, 0, 3893, 3894, 5, 186, 0,
		0, 3894, 3895, 5, 1132, 0, 0, 3895, 3896, 3, 618, 309, 0, 3896, 3897, 5,
		1133, 0, 0, 3897, 3899, 1, 0, 0, 0, 3898, 3891, 1, 0, 0, 0, 3898, 3893,
		1, 0, 0, 0, 3899, 247, 1, 0, 0, 0, 3900, 3901, 5, 1132, 0, 0, 3901, 3902,
		3, 252, 126, 0, 3902, 3903, 5, 1133, 0, 0, 3903, 3909, 1, 0, 0, 0, 3904,
		3905, 5, 1132, 0, 0, 3905, 3906, 3, 248, 124, 0, 3906, 3907, 5, 1133, 0,
		0, 3907, 3909, 1, 0, 0, 0, 3908, 3900, 1, 0, 0, 0, 3908, 3904, 1, 0, 0,
		0, 3909, 249, 1, 0, 0, 0, 3910, 3911, 5, 1132, 0, 0, 3911, 3912, 3, 256,
		128, 0, 3912, 3913, 5, 1133, 0, 0, 3913, 3919, 1, 0, 0, 0, 3914, 3915,
		5, 1132, 0, 0, 3915, 3916, 3, 250, 125, 0, 3916, 3917, 5, 1133, 0, 0, 3917,
		3919, 1, 0, 0, 0, 3918, 3910, 1, 0, 0, 0, 3918, 3914, 1, 0, 0, 0, 3919,
		251, 1, 0, 0, 0, 3920, 3922, 5, 151, 0, 0, 3921, 3923, 3, 254, 127, 0,
		3922, 3921, 1, 0, 0, 0, 3922, 3923, 1, 0, 0, 0, 3923, 3927, 1, 0, 0, 0,
		3924, 3926, 3, 274, 137, 0, 3925, 3924, 1, 0, 0, 0, 3926, 3929, 1, 0, 0,
		0, 3927, 3925, 1, 0, 0, 0, 3927, 3928, 1, 0, 0, 0, 3928, 3930, 1, 0, 0,
		0, 3929, 3927, 1, 0, 0, 0, 3930, 3932, 3, 276, 138, 0, 3931, 3933, 3, 280,
		140, 0, 3932, 3931, 1, 0, 0, 0, 3932, 3933, 1, 0, 0, 0, 3933, 3934, 1,
		0, 0, 0, 3934, 3936, 3, 286, 143, 0, 3935, 3937, 3, 288, 144, 0, 3936,
		3935, 1, 0, 0, 0, 3936, 3937, 1, 0, 0, 0, 3937, 3939, 1, 0, 0, 0, 3938,
		3940, 3, 290, 145, 0, 3939, 3938, 1, 0, 0, 0, 3939, 3940, 1, 0, 0, 0, 3940,
		3942, 1, 0, 0, 0, 3941, 3943, 3, 292, 146, 0, 3942, 3941, 1, 0, 0, 0, 3942,
		3943, 1, 0, 0, 0, 3943, 3945, 1, 0, 0, 0, 3944, 3946, 3, 230, 115, 0, 3945,
		3944, 1, 0, 0, 0, 3945, 3946, 1, 0, 0, 0, 3946, 3948, 1, 0, 0, 0, 3947,
		3949, 3, 296, 148, 0, 3948, 3947, 1, 0, 0, 0, 3948, 3949, 1, 0, 0, 0, 3949,
		3981, 1, 0, 0, 0, 3950, 3952, 5, 151, 0, 0, 3951, 3953, 3, 254, 127, 0,
		3952, 3951, 1, 0, 0, 0, 3952, 3953, 1, 0, 0, 0, 3953, 3957, 1, 0, 0, 0,
		3954, 3956, 3, 274, 137, 0, 3955, 3954, 1, 0, 0, 0, 3956, 3959, 1, 0, 0,
		0, 3957, 3955, 1, 0, 0, 0, 3957, 3958, 1, 0, 0, 0, 3958, 3960, 1, 0, 0,
		0, 3959, 3957, 1, 0, 0, 0, 3960, 3961, 3, 276, 138, 0, 3961, 3963, 3, 286,
		143, 0, 3962, 3964, 3, 288, 144, 0, 3963, 3962, 1, 0, 0, 0, 3963, 3964,
		1, 0, 0, 0, 3964, 3966, 1, 0, 0, 0, 3965, 3967, 3, 290, 145, 0, 3966, 3965,
		1, 0, 0, 0, 3966, 3967, 1, 0, 0, 0, 3967, 3969, 1, 0, 0, 0, 3968, 3970,
		3, 292, 146, 0, 3969, 3968, 1, 0, 0, 0, 3969, 3970, 1, 0, 0, 0, 3970, 3972,
		1, 0, 0, 0, 3971, 3973, 3, 230, 115, 0, 3972, 3971, 1, 0, 0, 0, 3972, 3973,
		1, 0, 0, 0, 3973, 3975, 1, 0, 0, 0, 3974, 3976, 3, 296, 148, 0, 3975, 3974,
		1, 0, 0, 0, 3975, 3976, 1, 0, 0, 0, 3976, 3978, 1, 0, 0, 0, 3977, 3979,
		3, 280, 140, 0, 3978, 3977, 1, 0, 0, 0, 3978, 3979, 1, 0, 0, 0, 3979, 3981,
		1, 0, 0, 0, 3980, 3920, 1, 0, 0, 0, 3980, 3950, 1, 0, 0, 0, 3981, 253,
		1, 0, 0, 0, 3982, 3983, 5, 1, 0, 0, 3983, 255, 1, 0, 0, 0, 3984, 3988,
		5, 151, 0, 0, 3985, 3987, 3, 274, 137, 0, 3986, 3985, 1, 0, 0, 0, 3987,
		3990, 1, 0, 0, 0, 3988, 3986, 1, 0, 0, 0, 3988, 3989, 1, 0, 0, 0, 3989,
		3991, 1, 0, 0, 0, 3990, 3988, 1, 0, 0, 0, 3991, 3992, 3, 276, 138, 0, 3992,
		3994, 3, 286, 143, 0, 3993, 3995, 3, 288, 144, 0, 3994, 3993, 1, 0, 0,
		0, 3994, 3995, 1, 0, 0, 0, 3995, 3997, 1, 0, 0, 0, 3996, 3998, 3, 290,
		145, 0, 3997, 3996, 1, 0, 0, 0, 3997, 3998, 1, 0, 0, 0, 3998, 4000, 1,
		0, 0, 0, 3999, 4001, 3, 292, 146, 0, 4000, 3999, 1, 0, 0, 0, 4000, 4001,
		1, 0, 0, 0, 4001, 4003, 1, 0, 0, 0, 4002, 4004, 3, 230, 115, 0, 4003, 4002,
		1, 0, 0, 0, 4003, 4004, 1, 0, 0, 0, 4004, 4006, 1, 0, 0, 0, 4005, 4007,
		3, 296, 148, 0, 4006, 4005, 1, 0, 0, 0, 4006, 4007, 1, 0, 0, 0, 4007, 4009,
		1, 0, 0, 0, 4008, 4010, 3, 260, 130, 0, 4009, 4008, 1, 0, 0, 0, 4009, 4010,
		1, 0, 0, 0, 4010, 257, 1, 0, 0, 0, 4011, 4013, 5, 179, 0, 0, 4012, 4014,
		7, 44, 0, 0, 4013, 4012, 1, 0, 0, 0, 4013, 4014, 1, 0, 0, 0, 4014, 4015,
		1, 0, 0, 0, 4015, 4016, 3, 250, 125, 0, 4016, 259, 1, 0, 0, 0, 4017, 4019,
		5, 179, 0, 0, 4018, 4020, 7, 44, 0, 0, 4019, 4018, 1, 0, 0, 0, 4019, 4020,
		1, 0, 0, 0, 4020, 4023, 1, 0, 0, 0, 4021, 4024, 3, 256, 128, 0, 4022, 4024,
		3, 250, 125, 0, 4023, 4021, 1, 0, 0, 0, 4023, 4022, 1, 0, 0, 0, 4024, 261,
		1, 0, 0, 0, 4025, 4040, 5, 93, 0, 0, 4026, 4041, 3, 256, 128, 0, 4027,
		4041, 3, 250, 125, 0, 4028, 4031, 5, 1132, 0, 0, 4029, 4032, 3, 256, 128,
		0, 4030, 4032, 3, 250, 125, 0, 4031, 4029, 1, 0, 0, 0, 4031, 4030, 1, 0,
		0, 0, 4032, 4033, 1, 0, 0, 0, 4033, 4038, 5, 1133, 0, 0, 4034, 4036, 5,
		11, 0, 0, 4035, 4034, 1, 0, 0, 0, 4035, 4036, 1, 0, 0, 0, 4036, 4037, 1,
		0, 0, 0, 4037, 4039, 3, 586, 293, 0, 4038, 4035, 1, 0, 0, 0, 4038, 4039,
		1, 0, 0, 0, 4039, 4041, 1, 0, 0, 0, 4040, 4026, 1, 0, 0, 0, 4040, 4027,
		1, 0, 0, 0, 4040, 4028, 1, 0, 0, 0, 4041, 263, 1, 0, 0, 0, 4042, 4043,
		5, 277, 0, 0, 4043, 4044, 5, 1132, 0, 0, 4044, 4045, 5, 1147, 0, 0, 4045,
		4046, 5, 1134, 0, 0, 4046, 4047, 5, 1147, 0, 0, 4047, 4048, 5, 364, 0,
		0, 4048, 4049, 5, 1132, 0, 0, 4049, 4050, 3, 266, 133, 0, 4050, 4051, 5,
		1133, 0, 0, 4051, 4056, 5, 1133, 0, 0, 4052, 4054, 5, 11, 0, 0, 4053, 4052,
		1, 0, 0, 0, 4053, 4054, 1, 0, 0, 0, 4054, 4055, 1, 0, 0, 0, 4055, 4057,
		3, 586, 293, 0, 4056, 4053, 1, 0, 0, 0, 4056, 4057, 1, 0, 0, 0, 4057, 265,
		1, 0, 0, 0, 4058, 4063, 3, 268, 134, 0, 4059, 4060, 5, 1134, 0, 0, 4060,
		4062, 3, 268, 134, 0, 4061, 4059, 1, 0, 0, 0, 4062, 4065, 1, 0, 0, 0, 4063,
		4061, 1, 0, 0, 0, 4063, 4064, 1, 0, 0, 0, 4064, 267, 1, 0, 0, 0, 4065,
		4063, 1, 0, 0, 0, 4066, 4083, 3, 558, 279, 0, 4067, 4068, 5, 64, 0, 0,
		4068, 4084, 5, 283, 0, 0, 4069, 4081, 3, 606, 303, 0, 4070, 4071, 5, 284,
		0, 0, 4071, 4073, 5, 1147, 0, 0, 4072, 4074, 3, 270, 135, 0, 4073, 4072,
		1, 0, 0, 0, 4073, 4074, 1, 0, 0, 0, 4074, 4076, 1, 0, 0, 0, 4075, 4077,
		3, 272, 136, 0, 4076, 4075, 1, 0, 0, 0, 4076, 4077, 1, 0, 0, 0, 4077, 4082,
		1, 0, 0, 0, 4078, 4079, 5, 59, 0, 0, 4079, 4080, 5, 284, 0, 0, 4080, 4082,
		5, 1147, 0, 0, 4081, 4070, 1, 0, 0, 0, 4081, 4078, 1, 0, 0, 0, 4082, 4084,
		1, 0, 0, 0, 4083, 4067, 1, 0, 0, 0, 4083, 4069, 1, 0, 0, 0, 4084, 4096,
		1, 0, 0, 0, 4085, 4087, 5, 282, 0, 0, 4086, 4088, 5, 284, 0, 0, 4087, 4086,
		1, 0, 0, 0, 4087, 4088, 1, 0, 0, 0, 4088, 4089, 1, 0, 0, 0, 4089, 4090,
		5, 1147, 0, 0, 4090, 4091, 5, 364, 0, 0, 4091, 4092, 5, 1132, 0, 0, 4092,
		4093, 3, 266, 133, 0, 4093, 4094, 5, 1133, 0, 0, 4094, 4096, 1, 0, 0, 0,
		4095, 4066, 1, 0, 0, 0, 4095, 4085, 1, 0, 0, 0, 4096, 269, 1, 0, 0, 0,
		4097, 4102, 5, 115, 0, 0, 4098, 4102, 5, 410, 0, 0, 4099, 4100, 5, 41,
		0, 0, 4100, 4102, 3, 636, 318, 0, 4101, 4097, 1, 0, 0, 0, 4101, 4098, 1,
		0, 0, 0, 4101, 4099, 1, 0, 0, 0, 4102, 4103, 1, 0, 0, 0, 4103, 4104, 5,
		117, 0, 0, 4104, 4105, 5, 54, 0, 0, 4105, 271, 1, 0, 0, 0, 4106, 4111,
		5, 115, 0, 0, 4107, 4111, 5, 410, 0, 0, 4108, 4109, 5, 41, 0, 0, 4109,
		4111, 3, 636, 318, 0, 4110, 4106, 1, 0, 0, 0, 4110, 4107, 1, 0, 0, 0, 4110,
		4108, 1, 0, 0, 0, 4111, 4112, 1, 0, 0, 0, 4112, 4113, 5, 117, 0, 0, 4113,
		4114, 5, 410, 0, 0, 4114, 273, 1, 0, 0, 0, 4115, 4124, 7, 52, 0, 0, 4116,
		4124, 5, 74, 0, 0, 4117, 4124, 5, 170, 0, 0, 4118, 4124, 5, 165, 0, 0,
		4119, 4124, 5, 163, 0, 0, 4120, 4124, 5, 624, 0, 0, 4121, 4124, 7, 53,
		0, 0, 4122, 4124, 5, 164, 0, 0, 4123, 4115, 1, 0, 0, 0, 4123, 4116, 1,
		0, 0, 0, 4123, 4117, 1, 0, 0, 0, 4123, 4118, 1, 0, 0, 0, 4123, 4119, 1,
		0, 0, 0, 4123, 4120, 1, 0, 0, 0, 4123, 4121, 1, 0, 0, 0, 4123, 4122, 1,
		0, 0, 0, 4124, 275, 1, 0, 0, 0, 4125, 4128, 5, 1116, 0, 0, 4126, 4128,
		3, 278, 139, 0, 4127, 4125, 1, 0, 0, 0, 4127, 4126, 1, 0, 0, 0, 4128, 4133,
		1, 0, 0, 0, 4129, 4130, 5, 1134, 0, 0, 4130, 4132, 3, 278, 139, 0, 4131,
		4129, 1, 0, 0, 0, 4132, 4135, 1, 0, 0, 0, 4133, 4131, 1, 0, 0, 0, 4133,
		4134, 1, 0, 0, 0, 4134, 277, 1, 0, 0, 0, 4135, 4133, 1, 0, 0, 0, 4136,
		4137, 3, 552, 276, 0, 4137, 4138, 5, 1131, 0, 0, 4138, 4139, 5, 1116, 0,
		0, 4139, 4166, 1, 0, 0, 0, 4140, 4145, 3, 558, 279, 0, 4141, 4143, 5, 11,
		0, 0, 4142, 4141, 1, 0, 0, 0, 4142, 4143, 1, 0, 0, 0, 4143, 4144, 1, 0,
		0, 0, 4144, 4146, 3, 586, 293, 0, 4145, 4142, 1, 0, 0, 0, 4145, 4146, 1,
		0, 0, 0, 4146, 4166, 1, 0, 0, 0, 4147, 4152, 3, 650, 325, 0, 4148, 4150,
		5, 11, 0, 0, 4149, 4148, 1, 0, 0, 0, 4149, 4150, 1, 0, 0, 0, 4150, 4151,
		1, 0, 0, 0, 4151, 4153, 3, 586, 293, 0, 4152, 4149, 1, 0, 0, 0, 4152, 4153,
		1, 0, 0, 0, 4153, 4166, 1, 0, 0, 0, 4154, 4155, 5, 1158, 0, 0, 4155, 4157,
		5, 1107, 0, 0, 4156, 4154, 1, 0, 0, 0, 4156, 4157, 1, 0, 0, 0, 4157, 4158,
		1, 0, 0, 0, 4158, 4163, 3, 690, 345, 0, 4159, 4161, 5, 11, 0, 0, 4160,
		4159, 1, 0, 0, 0, 4160, 4161, 1, 0, 0, 0, 4161, 4162, 1, 0, 0, 0, 4162,
		4164, 3, 586, 293, 0, 4163, 4160, 1, 0, 0, 0, 4163, 4164, 1, 0, 0, 0, 4164,
		4166, 1, 0, 0, 0, 4165, 4136, 1, 0, 0, 0, 4165, 4140, 1, 0, 0, 0, 4165,
		4147, 1, 0, 0, 0, 4165, 4156, 1, 0, 0, 0, 4166, 279, 1, 0, 0, 0, 4167,
		4168, 5, 86, 0, 0, 4168, 4173, 3, 210, 105, 0, 4169, 4170, 5, 1134, 0,
		0, 4170, 4172, 3, 210, 105, 0, 4171, 4169, 1, 0, 0, 0, 4172, 4175, 1, 0,
		0, 0, 4173, 4171, 1, 0, 0, 0, 4173, 4174, 1, 0, 0, 0, 4174, 4204, 1, 0,
		0, 0, 4175, 4173, 1, 0, 0, 0, 4176, 4177, 5, 86, 0, 0, 4177, 4178, 5, 399,
		0, 0, 4178, 4204, 5, 1147, 0, 0, 4179, 4180, 5, 86, 0, 0, 4180, 4181, 5,
		126, 0, 0, 4181, 4185, 5, 1147, 0, 0, 4182, 4183, 5, 24, 0, 0, 4183, 4184,
		5, 152, 0, 0, 4184, 4186, 3, 570, 285, 0, 4185, 4182, 1, 0, 0, 0, 4185,
		4186, 1, 0, 0, 0, 4186, 4193, 1, 0, 0, 0, 4187, 4189, 7, 41, 0, 0, 4188,
		4190, 3, 282, 141, 0, 4189, 4188, 1, 0, 0, 0, 4190, 4191, 1, 0, 0, 0, 4191,
		4189, 1, 0, 0, 0, 4191, 4192, 1, 0, 0, 0, 4192, 4194, 1, 0, 0, 0, 4193,
		4187, 1, 0, 0, 0, 4193, 4194, 1, 0, 0, 0, 4194, 4201, 1, 0, 0, 0, 4195,
		4197, 5, 100, 0, 0, 4196, 4198, 3, 284, 142, 0, 4197, 4196, 1, 0, 0, 0,
		4198, 4199, 1, 0, 0, 0, 4199, 4197, 1, 0, 0, 0, 4199, 4200, 1, 0, 0, 0,
		4200, 4202, 1, 0, 0, 0, 4201, 4195, 1, 0, 0, 0, 4201, 4202, 1, 0, 0, 0,
		4202, 4204, 1, 0, 0, 0, 4203, 4167, 1, 0, 0, 0, 4203, 4176, 1, 0, 0, 0,
		4203, 4179, 1, 0, 0, 0, 4204, 281, 1, 0, 0, 0, 4205, 4206, 5, 172, 0, 0,
		4206, 4207, 5, 18, 0, 0, 4207, 4218, 5, 1147, 0, 0, 4208, 4210, 5, 121,
		0, 0, 4209, 4208, 1, 0, 0, 0, 4209, 4210, 1, 0, 0, 0, 4210, 4211, 1, 0,
		0, 0, 4211, 4212, 5, 55, 0, 0, 4212, 4213, 5, 18, 0, 0, 4213, 4218, 5,
		1147, 0, 0, 4214, 4215, 5, 57, 0, 0, 4215, 4216, 5, 18, 0, 0, 4216, 4218,
		5, 1147, 0, 0, 4217, 4205, 1, 0, 0, 0, 4217, 4209, 1, 0, 0, 0, 4217, 4214,
		1, 0, 0, 0, 4218, 283, 1, 0, 0, 0, 4219, 4220, 5, 168, 0, 0, 4220, 4221,
		5, 18, 0, 0, 4221, 4226, 5, 1147, 0, 0, 4222, 4223, 5, 172, 0, 0, 4223,
		4224, 5, 18, 0, 0, 4224, 4226, 5, 1147, 0, 0, 4225, 4219, 1, 0, 0, 0, 4225,
		4222, 1, 0, 0, 0, 4226, 285, 1, 0, 0, 0, 4227, 4228, 5, 67, 0, 0, 4228,
		4230, 3, 234, 117, 0, 4229, 4227, 1, 0, 0, 0, 4229, 4230, 1, 0, 0, 0, 4230,
		4233, 1, 0, 0, 0, 4231, 4232, 5, 189, 0, 0, 4232, 4234, 3, 690, 345, 0,
		4233, 4231, 1, 0, 0, 0, 4233, 4234, 1, 0, 0, 0, 4234, 287, 1, 0, 0, 0,
		4235, 4236, 5, 72, 0, 0, 4236, 4237, 5, 18, 0, 0, 4237, 4242, 3, 294, 147,
		0, 4238, 4239, 5, 1134, 0, 0, 4239, 4241, 3, 294, 147, 0, 4240, 4238, 1,
		0, 0, 0, 4241, 4244, 1, 0, 0, 0, 4242, 4240, 1, 0, 0, 0, 4242, 4243, 1,
		0, 0, 0, 4243, 4247, 1, 0, 0, 0, 4244, 4242, 1, 0, 0, 0, 4245, 4246, 5,
		191, 0, 0, 4246, 4248, 5, 597, 0, 0, 4247, 4245, 1, 0, 0, 0, 4247, 4248,
		1, 0, 0, 0, 4248, 289, 1, 0, 0, 0, 4249, 4250, 5, 73, 0, 0, 4250, 4251,
		3, 690, 345, 0, 4251, 291, 1, 0, 0, 0, 4252, 4253, 5, 675, 0, 0, 4253,
		4254, 3, 668, 334, 0, 4254, 4255, 5, 11, 0, 0, 4255, 4256, 5, 1132, 0,
		0, 4256, 4257, 3, 666, 333, 0, 4257, 4267, 5, 1133, 0, 0, 4258, 4259, 5,
		1134, 0, 0, 4259, 4260, 3, 668, 334, 0, 4260, 4261, 5, 11, 0, 0, 4261,
		4262, 5, 1132, 0, 0, 4262, 4263, 3, 666, 333, 0, 4263, 4264, 5, 1133, 0,
		0, 4264, 4266, 1, 0, 0, 0, 4265, 4258, 1, 0, 0, 0, 4266, 4269, 1, 0, 0,
		0, 4267, 4265, 1, 0, 0, 0, 4267, 4268, 1, 0, 0, 0, 4268, 293, 1, 0, 0,
		0, 4269, 4267, 1, 0, 0, 0, 4270, 4272, 3, 690, 345, 0, 4271, 4273, 7, 48,
		0, 0, 4272, 4271, 1, 0, 0, 0, 4272, 4273, 1, 0, 0, 0, 4273, 295, 1, 0,
		0, 0, 4274, 4285, 5, 98, 0, 0, 4275, 4276, 3, 298, 149, 0, 4276, 4277,
		5, 1134, 0, 0, 4277, 4279, 1, 0, 0, 0, 4278, 4275, 1, 0, 0, 0, 4278, 4279,
		1, 0, 0, 0, 4279, 4280, 1, 0, 0, 0, 4280, 4286, 3, 298, 149, 0, 4281, 4282,
		3, 298, 149, 0, 4282, 4283, 5, 531, 0, 0, 4283, 4284, 3, 298, 149, 0, 4284,
		4286, 1, 0, 0, 0, 4285, 4278, 1, 0, 0, 0, 4285, 4281, 1, 0, 0, 0, 4286,
		297, 1, 0, 0, 0, 4287, 4291, 3, 592, 296, 0, 4288, 4291, 3, 568, 284, 0,
		4289, 4291, 3, 588, 294, 0, 4290, 4287, 1, 0, 0, 0, 4290, 4288, 1, 0, 0,
		0, 4290, 4289, 1, 0, 0, 0, 4291, 299, 1, 0, 0, 0, 4292, 4293, 5, 628, 0,
		0, 4293, 4302, 5, 652, 0, 0, 4294, 4299, 3, 322, 161, 0, 4295, 4296, 5,
		1134, 0, 0, 4296, 4298, 3, 322, 161, 0, 4297, 4295, 1, 0, 0, 0, 4298, 4301,
		1, 0, 0, 0, 4299, 4297, 1, 0, 0, 0, 4299, 4300, 1, 0, 0, 0, 4300, 4303,
		1, 0, 0, 0, 4301, 4299, 1, 0, 0, 0, 4302, 4294, 1, 0, 0, 0, 4302, 4303,
		1, 0, 0, 0, 4303, 301, 1, 0, 0, 0, 4304, 4306, 5, 343, 0, 0, 4305, 4307,
		5, 677, 0, 0, 4306, 4305, 1, 0, 0, 0, 4306, 4307, 1, 0, 0, 0, 4307, 4309,
		1, 0, 0, 0, 4308, 4310, 3, 254, 127, 0, 4309, 4308, 1, 0, 0, 0, 4309, 4310,
		1, 0, 0, 0, 4310, 303, 1, 0, 0, 0, 4311, 4313, 5, 368, 0, 0, 4312, 4314,
		5, 677, 0, 0, 4313, 4312, 1, 0, 0, 0, 4313, 4314, 1, 0, 0, 0, 4314, 4320,
		1, 0, 0, 0, 4315, 4317, 5, 9, 0, 0, 4316, 4318, 5, 520, 0, 0, 4317, 4316,
		1, 0, 0, 0, 4317, 4318, 1, 0, 0, 0, 4318, 4319, 1, 0, 0, 0, 4319, 4321,
		5, 352, 0, 0, 4320, 4315, 1, 0, 0, 0, 4320, 4321, 1, 0, 0, 0, 4321, 4326,
		1, 0, 0, 0, 4322, 4324, 5, 520, 0, 0, 4323, 4322, 1, 0, 0, 0, 4323, 4324,
		1, 0, 0, 0, 4324, 4325, 1, 0, 0, 0, 4325, 4327, 5, 137, 0, 0, 4326, 4323,
		1, 0, 0, 0, 4326, 4327, 1, 0, 0, 0, 4327, 4329, 1, 0, 0, 0, 4328, 4330,
		3, 254, 127, 0, 4329, 4328, 1, 0, 0, 0, 4329, 4330, 1, 0, 0, 0, 4330, 305,
		1, 0, 0, 0, 4331, 4333, 5, 596, 0, 0, 4332, 4334, 5, 677, 0, 0, 4333, 4332,
		1, 0, 0, 0, 4333, 4334, 1, 0, 0, 0, 4334, 4340, 1, 0, 0, 0, 4335, 4337,
		5, 9, 0, 0, 4336, 4338, 5, 520, 0, 0, 4337, 4336, 1, 0, 0, 0, 4337, 4338,
		1, 0, 0, 0, 4338, 4339, 1, 0, 0, 0, 4339, 4341, 5, 352, 0, 0, 4340, 4335,
		1, 0, 0, 0, 4340, 4341, 1, 0, 0, 0, 4341, 4346, 1, 0, 0, 0, 4342, 4344,
		5, 520, 0, 0, 4343, 4342, 1, 0, 0, 0, 4343, 4344, 1, 0, 0, 0, 4344, 4345,
		1, 0, 0, 0, 4345, 4347, 5, 137, 0, 0, 4346, 4343, 1, 0, 0, 0, 4346, 4347,
		1, 0, 0, 0, 4347, 4349, 1, 0, 0, 0, 4348, 4350, 3, 254, 127, 0, 4349, 4348,
		1, 0, 0, 0, 4349, 4350, 1, 0, 0, 0, 4350, 307, 1, 0, 0, 0, 4351, 4352,
		5, 603, 0, 0, 4352, 4353, 3, 586, 293, 0, 4353, 309, 1, 0, 0, 0, 4354,
		4356, 5, 596, 0, 0, 4355, 4357, 5, 677, 0, 0, 4356, 4355, 1, 0, 0, 0, 4356,
		4357, 1, 0, 0, 0, 4357, 4358, 1, 0, 0, 0, 4358, 4360, 5, 174, 0, 0, 4359,
		4361, 5, 603, 0, 0, 4360, 4359, 1, 0, 0, 0, 4360, 4361, 1, 0, 0, 0, 4361,
		4362, 1, 0, 0, 0, 4362, 4363, 3, 586, 293, 0, 4363, 311, 1, 0, 0, 0, 4364,
		4365, 5, 137, 0, 0, 4365, 4366, 5, 603, 0, 0, 4366, 4367, 3, 586, 293,
		0, 4367, 313, 1, 0, 0, 0, 4368, 4369, 5, 102, 0, 0, 4369, 4370, 7, 54,
		0, 0, 4370, 4375, 3, 324, 162, 0, 4371, 4372, 5, 1134, 0, 0, 4372, 4374,
		3, 324, 162, 0, 4373, 4371, 1, 0, 0, 0, 4374, 4377, 1, 0, 0, 0, 4375, 4373,
		1, 0, 0, 0, 4375, 4376, 1, 0, 0, 0, 4376, 4379, 1, 0, 0, 0, 4377, 4375,
		1, 0, 0, 0, 4378, 4380, 3, 648, 324, 0, 4379, 4378, 1, 0, 0, 0, 4379, 4380,
		1, 0, 0, 0, 4380, 315, 1, 0, 0, 0, 4381, 4382, 5, 181, 0, 0, 4382, 4383,
		5, 741, 0, 0, 4383, 317, 1, 0, 0, 0, 4384, 4385, 5, 152, 0, 0, 4385, 4386,
		5, 339, 0, 0, 4386, 4387, 5, 1123, 0, 0, 4387, 4388, 7, 24, 0, 0, 4388,
		319, 1, 0, 0, 0, 4389, 4391, 5, 152, 0, 0, 4390, 4392, 7, 55, 0, 0, 4391,
		4390, 1, 0, 0, 0, 4391, 4392, 1, 0, 0, 0, 4392, 4393, 1, 0, 0, 0, 4393,
		4394, 5, 652, 0, 0, 4394, 4399, 3, 328, 164, 0, 4395, 4396, 5, 1134, 0,
		0, 4396, 4398, 3, 328, 164, 0, 4397, 4395, 1, 0, 0, 0, 4398, 4401, 1, 0,
		0, 0, 4399, 4397, 1, 0, 0, 0, 4399, 4400, 1, 0, 0, 0, 4400, 321, 1, 0,
		0, 0, 4401, 4399, 1, 0, 0, 0, 4402, 4403, 5, 191, 0, 0, 4403, 4404, 5,
		376, 0, 0, 4404, 4410, 5, 615, 0, 0, 4405, 4406, 5, 133, 0, 0, 4406, 4410,
		5, 192, 0, 0, 4407, 4408, 5, 133, 0, 0, 4408, 4410, 5, 537, 0, 0, 4409,
		4402, 1, 0, 0, 0, 4409, 4405, 1, 0, 0, 0, 4409, 4407, 1, 0, 0, 0, 4410,
		323, 1, 0, 0, 0, 4411, 4416, 3, 554, 277, 0, 4412, 4414, 5, 11, 0, 0, 4413,
		4412, 1, 0, 0, 0, 4413, 4414, 1, 0, 0, 0, 4414, 4415, 1, 0, 0, 0, 4415,
		4417, 3, 586, 293, 0, 4416, 4413, 1, 0, 0, 0, 4416, 4417, 1, 0, 0, 0, 4417,
		4418, 1, 0, 0, 0, 4418, 4419, 3, 326, 163, 0, 4419, 325, 1, 0, 0, 0, 4420,
		4422, 5, 133, 0, 0, 4421, 4423, 5, 473, 0, 0, 4422, 4421, 1, 0, 0, 0, 4422,
		4423, 1, 0, 0, 0, 4423, 4429, 1, 0, 0, 0, 4424, 4426, 5, 105, 0, 0, 4425,
		4424, 1, 0, 0, 0, 4425, 4426, 1, 0, 0, 0, 4426, 4427, 1, 0, 0, 0, 4427,
		4429, 5, 192, 0, 0, 4428, 4420, 1, 0, 0, 0, 4428, 4425, 1, 0, 0, 0, 4429,
		327, 1, 0, 0, 0, 4430, 4431, 5, 463, 0, 0, 4431, 4432, 5, 471, 0, 0, 4432,
		4438, 3, 330, 165, 0, 4433, 4434, 5, 133, 0, 0, 4434, 4438, 5, 192, 0,
		0, 4435, 4436, 5, 133, 0, 0, 4436, 4438, 5, 537, 0, 0, 4437, 4430, 1, 0,
		0, 0, 4437, 4433, 1, 0, 0, 0, 4437, 4435, 1, 0, 0, 0, 4438, 329, 1, 0,
		0, 0, 4439, 4440, 5, 798, 0, 0, 4440, 4447, 5, 133, 0, 0, 4441, 4442, 5,
		133, 0, 0, 4442, 4447, 5, 799, 0, 0, 4443, 4444, 5, 133, 0, 0, 4444, 4447,
		5, 800, 0, 0, 4445, 4447, 5, 801, 0, 0, 4446, 4439, 1, 0, 0, 0, 4446, 4441,
		1, 0, 0, 0, 4446, 4443, 1, 0, 0, 0, 4446, 4445, 1, 0, 0, 0, 4447, 331,
		1, 0, 0, 0, 4448, 4449, 5, 23, 0, 0, 4449, 4450, 5, 476, 0, 0, 4450, 4451,
		5, 174, 0, 0, 4451, 4456, 3, 350, 175, 0, 4452, 4453, 5, 1134, 0, 0, 4453,
		4455, 3, 350, 175, 0, 4454, 4452, 1, 0, 0, 0, 4455, 4458, 1, 0, 0, 0, 4456,
		4454, 1, 0, 0, 0, 4456, 4457, 1, 0, 0, 0, 4457, 4460, 1, 0, 0, 0, 4458,
		4456, 1, 0, 0, 0, 4459, 4461, 3, 358, 179, 0, 4460, 4459, 1, 0, 0, 0, 4460,
		4461, 1, 0, 0, 0, 4461, 333, 1, 0, 0, 0, 4462, 4463, 5, 23, 0, 0, 4463,
		4464, 5, 587, 0, 0, 4464, 4465, 5, 428, 0, 0, 4465, 4470, 3, 360, 180,
		0, 4466, 4467, 5, 1134, 0, 0, 4467, 4469, 3, 360, 180, 0, 4468, 4466, 1,
		0, 0, 0, 4469, 4472, 1, 0, 0, 0, 4470, 4468, 1, 0, 0, 0, 4470, 4471, 1,
		0, 0, 0, 4471, 335, 1, 0, 0, 0, 4472, 4470, 1, 0, 0, 0, 4473, 4474, 5,
		131, 0, 0, 4474, 4475, 7, 56, 0, 0, 4475, 4480, 5, 475, 0, 0, 4476, 4477,
		5, 174, 0, 0, 4477, 4481, 5, 1147, 0, 0, 4478, 4479, 5, 14, 0, 0, 4479,
		4481, 5, 1147, 0, 0, 4480, 4476, 1, 0, 0, 0, 4480, 4478, 1, 0, 0, 0, 4481,
		337, 1, 0, 0, 0, 4482, 4483, 5, 588, 0, 0, 4483, 4484, 5, 476, 0, 0, 4484,
		339, 1, 0, 0, 0, 4485, 4486, 5, 588, 0, 0, 4486, 4488, 5, 613, 0, 0, 4487,
		4489, 5, 5, 0, 0, 4488, 4487, 1, 0, 0, 0, 4488, 4489, 1, 0, 0, 0, 4489,
		4491, 1, 0, 0, 0, 4490, 4492, 3, 358, 179, 0, 4491, 4490, 1, 0, 0, 0, 4491,
		4492, 1, 0, 0, 0, 4492, 341, 1, 0, 0, 0, 4493, 4494, 5, 628, 0, 0, 4494,
		4503, 5, 613, 0, 0, 4495, 4500, 3, 364, 182, 0, 4496, 4497, 5, 1134, 0,
		0, 4497, 4499, 3, 364, 182, 0, 4498, 4496, 1, 0, 0, 0, 4499, 4502, 1, 0,
		0, 0, 4500, 4498, 1, 0, 0, 0, 4500, 4501, 1, 0, 0, 0, 4501, 4504, 1, 0,
		0, 0, 4502, 4500, 1, 0, 0, 0, 4503, 4495, 1, 0, 0, 0, 4503, 4504, 1, 0,
		0, 0, 4504, 4507, 1, 0, 0, 0, 4505, 4506, 5, 662, 0, 0, 4506, 4508, 3,
		366, 183, 0, 4507, 4505, 1, 0, 0, 0, 4507, 4508, 1, 0, 0, 0, 4508, 4512,
		1, 0, 0, 0, 4509, 4511, 3, 368, 184, 0, 4510, 4509, 1, 0, 0, 0, 4511, 4514,
		1, 0, 0, 0, 4512, 4510, 1, 0, 0, 0, 4512, 4513, 1, 0, 0, 0, 4513, 4516,
		1, 0, 0, 0, 4514, 4512, 1, 0, 0, 0, 4515, 4517, 3, 358, 179, 0, 4516, 4515,
		1, 0, 0, 0, 4516, 4517, 1, 0, 0, 0, 4517, 343, 1, 0, 0, 0, 4518, 4519,
		5, 634, 0, 0, 4519, 4528, 5, 613, 0, 0, 4520, 4525, 3, 364, 182, 0, 4521,
		4522, 5, 1134, 0, 0, 4522, 4524, 3, 364, 182, 0, 4523, 4521, 1, 0, 0, 0,
		4524, 4527, 1, 0, 0, 0, 4525, 4523, 1, 0, 0, 0, 4525, 4526, 1, 0, 0, 0,
		4526, 4529, 1, 0, 0, 0, 4527, 4525, 1, 0, 0, 0, 4528, 4520, 1, 0, 0, 0,
		4528, 4529, 1, 0, 0, 0, 4529, 345, 1, 0, 0, 0, 4530, 4531, 5, 628, 0, 0,
		4531, 4532, 5, 440, 0, 0, 4532, 347, 1, 0, 0, 0, 4533, 4534, 5, 634, 0,
		0, 4534, 4535, 5, 440, 0, 0, 4535, 349, 1, 0, 0, 0, 4536, 4537, 3, 352,
		176, 0, 4537, 4538, 5, 1123, 0, 0, 4538, 4539, 5, 1147, 0, 0, 4539, 4566,
		1, 0, 0, 0, 4540, 4541, 3, 354, 177, 0, 4541, 4542, 5, 1123, 0, 0, 4542,
		4543, 3, 592, 296, 0, 4543, 4566, 1, 0, 0, 0, 4544, 4545, 3, 356, 178,
		0, 4545, 4546, 5, 1123, 0, 0, 4546, 4547, 7, 24, 0, 0, 4547, 4566, 1, 0,
		0, 0, 4548, 4549, 5, 480, 0, 0, 4549, 4550, 5, 1123, 0, 0, 4550, 4566,
		5, 1150, 0, 0, 4551, 4552, 5, 448, 0, 0, 4552, 4553, 5, 1123, 0, 0, 4553,
		4562, 5, 1132, 0, 0, 4554, 4559, 3, 586, 293, 0, 4555, 4556, 5, 1134, 0,
		0, 4556, 4558, 3, 586, 293, 0, 4557, 4555, 1, 0, 0, 0, 4558, 4561, 1, 0,
		0, 0, 4559, 4557, 1, 0, 0, 0, 4559, 4560, 1, 0, 0, 0, 4560, 4563, 1, 0,
		0, 0, 4561, 4559, 1, 0, 0, 0, 4562, 4554, 1, 0, 0, 0, 4562, 4563, 1, 0,
		0, 0, 4563, 4564, 1, 0, 0, 0, 4564, 4566, 5, 1133, 0, 0, 4565, 4536, 1,
		0, 0, 0, 4565, 4540, 1, 0, 0, 0, 4565, 4544, 1, 0, 0, 0, 4565, 4548, 1,
		0, 0, 0, 4565, 4551, 1, 0, 0, 0, 4566, 351, 1, 0, 0, 0, 4567, 4568, 7,
		57, 0, 0, 4568, 353, 1, 0, 0, 0, 4569, 4570, 7, 58, 0, 0, 4570, 355, 1,
		0, 0, 0, 4571, 4572, 7, 59, 0, 0, 4572, 357, 1, 0, 0, 0, 4573, 4574, 5,
		64, 0, 0, 4574, 4575, 5, 354, 0, 0, 4575, 4576, 5, 1147, 0, 0, 4576, 359,
		1, 0, 0, 0, 4577, 4578, 5, 580, 0, 0, 4578, 4579, 5, 1123, 0, 0, 4579,
		4580, 5, 1132, 0, 0, 4580, 4581, 3, 618, 309, 0, 4581, 4582, 5, 1133, 0,
		0, 4582, 4627, 1, 0, 0, 0, 4583, 4584, 5, 582, 0, 0, 4584, 4585, 5, 1123,
		0, 0, 4585, 4586, 5, 1132, 0, 0, 4586, 4587, 3, 618, 309, 0, 4587, 4588,
		5, 1133, 0, 0, 4588, 4627, 1, 0, 0, 0, 4589, 4590, 5, 581, 0, 0, 4590,
		4591, 5, 1123, 0, 0, 4591, 4592, 5, 1132, 0, 0, 4592, 4593, 3, 622, 311,
		0, 4593, 4594, 5, 1133, 0, 0, 4594, 4627, 1, 0, 0, 0, 4595, 4596, 5, 583,
		0, 0, 4596, 4597, 5, 1123, 0, 0, 4597, 4598, 5, 1132, 0, 0, 4598, 4599,
		3, 622, 311, 0, 4599, 4600, 5, 1133, 0, 0, 4600, 4627, 1, 0, 0, 0, 4601,
		4602, 5, 585, 0, 0, 4602, 4603, 5, 1123, 0, 0, 4603, 4604, 5, 1132, 0,
		0, 4604, 4605, 3, 632, 316, 0, 4605, 4606, 5, 1133, 0, 0, 4606, 4627, 1,
		0, 0, 0, 4607, 4608, 5, 586, 0, 0, 4608, 4609, 5, 1123, 0, 0, 4609, 4610,
		5, 1132, 0, 0, 4610, 4611, 3, 632, 316, 0, 4611, 4612, 5, 1133, 0, 0, 4612,
		4627, 1, 0, 0, 0, 4613, 4614, 5, 584, 0, 0, 4614, 4615, 5, 1123, 0, 0,
		4615, 4616, 5, 1132, 0, 0, 4616, 4621, 3, 362, 181, 0, 4617, 4618, 5, 1134,
		0, 0, 4618, 4620, 3, 362, 181, 0, 4619, 4617, 1, 0, 0, 0, 4620, 4623, 1,
		0, 0, 0, 4621, 4619, 1, 0, 0, 0, 4621, 4622, 1, 0, 0, 0, 4622, 4624, 1,
		0, 0, 0, 4623, 4621, 1, 0, 0, 0, 4624, 4625, 5, 1133, 0, 0, 4625, 4627,
		1, 0, 0, 0, 4626, 4577, 1, 0, 0, 0, 4626, 4583, 1, 0, 0, 0, 4626, 4589,
		1, 0, 0, 0, 4626, 4595, 1, 0, 0, 0, 4626, 4601, 1, 0, 0, 0, 4626, 4607,
		1, 0, 0, 0, 4626, 4613, 1, 0, 0, 0, 4627, 361, 1, 0, 0, 0, 4628, 4629,
		5, 1132, 0, 0, 4629, 4630, 3, 554, 277, 0, 4630, 4631, 5, 1134, 0, 0, 4631,
		4632, 3, 554, 277, 0, 4632, 4633, 5, 1133, 0, 0, 4633, 363, 1, 0, 0, 0,
		4634, 4635, 7, 60, 0, 0, 4635, 365, 1, 0, 0, 0, 4636, 4637, 7, 61, 0, 0,
		4637, 4638, 5, 1123, 0, 0, 4638, 4655, 3, 370, 185, 0, 4639, 4640, 5, 482,
		0, 0, 4640, 4641, 5, 1123, 0, 0, 4641, 4642, 5, 1147, 0, 0, 4642, 4643,
		5, 1134, 0, 0, 4643, 4644, 5, 483, 0, 0, 4644, 4645, 5, 1123, 0, 0, 4645,
		4655, 3, 592, 296, 0, 4646, 4647, 5, 574, 0, 0, 4647, 4648, 5, 1123, 0,
		0, 4648, 4649, 5, 1147, 0, 0, 4649, 4650, 5, 1134, 0, 0, 4650, 4651, 5,
		575, 0, 0, 4651, 4652, 5, 1123, 0, 0, 4652, 4655, 3, 592, 296, 0, 4653,
		4655, 5, 622, 0, 0, 4654, 4636, 1, 0, 0, 0, 4654, 4639, 1, 0, 0, 0, 4654,
		4646, 1, 0, 0, 0, 4654, 4653, 1, 0, 0, 0, 4655, 367, 1, 0, 0, 0, 4656,
		4657, 5, 664, 0, 0, 4657, 4658, 5, 1123, 0, 0, 4658, 4669, 5, 1147, 0,
		0, 4659, 4660, 5, 550, 0, 0, 4660, 4661, 5, 1123, 0, 0, 4661, 4669, 5,
		1147, 0, 0, 4662, 4663, 5, 390, 0, 0, 4663, 4664, 5, 1123, 0, 0, 4664,
		4669, 5, 1147, 0, 0, 4665, 4666, 5, 554, 0, 0, 4666, 4667, 5, 1123, 0,
		0, 4667, 4669, 5, 1147, 0, 0, 4668, 4656, 1, 0, 0, 0, 4668, 4659, 1, 0,
		0, 0, 4668, 4662, 1, 0, 0, 0, 4668, 4665, 1, 0, 0, 0, 4669, 369, 1, 0,
		0, 0, 4670, 4675, 3, 578, 289, 0, 4671, 4672, 5, 1134, 0, 0, 4672, 4674,
		3, 578, 289, 0, 4673, 4671, 1, 0, 0, 0, 4674, 4677, 1, 0, 0, 0, 4675, 4673,
		1, 0, 0, 0, 4675, 4676, 1, 0, 0, 0, 4676, 4680, 1, 0, 0, 0, 4677, 4675,
		1, 0, 0, 0, 4678, 4680, 5, 1147, 0, 0, 4679, 4670, 1, 0, 0, 0, 4679, 4678,
		1, 0, 0, 0, 4680, 371, 1, 0, 0, 0, 4681, 4682, 5, 680, 0, 0, 4682, 4683,
		7, 62, 0, 0, 4683, 4685, 3, 580, 290, 0, 4684, 4686, 7, 63, 0, 0, 4685,
		4684, 1, 0, 0, 0, 4685, 4686, 1, 0, 0, 0, 4686, 373, 1, 0, 0, 0, 4687,
		4688, 5, 680, 0, 0, 4688, 4689, 5, 406, 0, 0, 4689, 4695, 3, 580, 290,
		0, 4690, 4693, 5, 642, 0, 0, 4691, 4692, 5, 64, 0, 0, 4692, 4694, 5, 508,
		0, 0, 4693, 4691, 1, 0, 0, 0, 4693, 4694, 1, 0, 0, 0, 4694, 4696, 1, 0,
		0, 0, 4695, 4690, 1, 0, 0, 0, 4695, 4696, 1, 0, 0, 0, 4696, 375, 1, 0,
		0, 0, 4697, 4698, 5, 680, 0, 0, 4698, 4699, 5, 559, 0, 0, 4699, 4700, 3,
		580, 290, 0, 4700, 377, 1, 0, 0, 0, 4701, 4702, 5, 680, 0, 0, 4702, 4703,
		5, 368, 0, 0, 4703, 4706, 3, 580, 290, 0, 4704, 4705, 5, 535, 0, 0, 4705,
		4707, 5, 552, 0, 0, 4706, 4704, 1, 0, 0, 0, 4706, 4707, 1, 0, 0, 0, 4707,
		379, 1, 0, 0, 0, 4708, 4709, 5, 680, 0, 0, 4709, 4710, 5, 596, 0, 0, 4710,
		4711, 3, 580, 290, 0, 4711, 381, 1, 0, 0, 0, 4712, 4713, 5, 680, 0, 0,
		4713, 4716, 5, 569, 0, 0, 4714, 4715, 5, 31, 0, 0, 4715, 4717, 3, 580,
		290, 0, 4716, 4714, 1, 0, 0, 0, 4716, 4717, 1, 0, 0, 0, 4717, 383, 1, 0,
		0, 0, 4718, 4719, 5, 559, 0, 0, 4719, 4720, 3, 586, 293, 0, 4720, 4723,
		5, 67, 0, 0, 4721, 4724, 5, 1147, 0, 0, 4722, 4724, 5, 1158, 0, 0, 4723,
		4721, 1, 0, 0, 0, 4723, 4722, 1, 0, 0, 0, 4724, 385, 1, 0, 0, 0, 4725,
		4726, 5, 707, 0, 0, 4726, 4729, 3, 586, 293, 0, 4727, 4728, 5, 186, 0,
		0, 4728, 4730, 3, 634, 317, 0, 4729, 4727, 1, 0, 0, 0, 4729, 4730, 1, 0,
		0, 0, 4730, 387, 1, 0, 0, 0, 4731, 4732, 7, 64, 0, 0, 4732, 4733, 5, 559,
		0, 0, 4733, 4734, 3, 586, 293, 0, 4734, 389, 1, 0, 0, 0, 4735, 4738, 3,
		392, 196, 0, 4736, 4738, 3, 4, 2, 0, 4737, 4735, 1, 0, 0, 0, 4737, 4736,
		1, 0, 0, 0, 4738, 391, 1, 0, 0, 0, 4739, 4740, 3, 586, 293, 0, 4740, 4741,
		5, 1143, 0, 0, 4741, 4743, 1, 0, 0, 0, 4742, 4739, 1, 0, 0, 0, 4742, 4743,
		1, 0, 0, 0, 4743, 4744, 1, 0, 0, 0, 4744, 4750, 5, 343, 0, 0, 4745, 4746,
		3, 412, 206, 0, 4746, 4747, 5, 1135, 0, 0, 4747, 4749, 1, 0, 0, 0, 4748,
		4745, 1, 0, 0, 0, 4749, 4752, 1, 0, 0, 0, 4750, 4748, 1, 0, 0, 0, 4750,
		4751, 1, 0, 0, 0, 4751, 4758, 1, 0, 0, 0, 4752, 4750, 1, 0, 0, 0, 4753,
		4754, 3, 414, 207, 0, 4754, 4755, 5, 1135, 0, 0, 4755, 4757, 1, 0, 0, 0,
		4756, 4753, 1, 0, 0, 0, 4757, 4760, 1, 0, 0, 0, 4758, 4756, 1, 0, 0, 0,
		4758, 4759, 1, 0, 0, 0, 4759, 4766, 1, 0, 0, 0, 4760, 4758, 1, 0, 0, 0,
		4761, 4762, 3, 416, 208, 0, 4762, 4763, 5, 1135, 0, 0, 4763, 4765, 1, 0,
		0, 0, 4764, 4761, 1, 0, 0, 0, 4765, 4768, 1, 0, 0, 0, 4766, 4764, 1, 0,
		0, 0, 4766, 4767, 1, 0, 0, 0, 4767, 4774, 1, 0, 0, 0, 4768, 4766, 1, 0,
		0, 0, 4769, 4770, 3, 418, 209, 0, 4770, 4771, 5, 1135, 0, 0, 4771, 4773,
		1, 0, 0, 0, 4772, 4769, 1, 0, 0, 0, 4773, 4776, 1, 0, 0, 0, 4774, 4772,
		1, 0, 0, 0, 4774, 4775, 1, 0, 0, 0, 4775, 4780, 1, 0, 0, 0, 4776, 4774,
		1, 0, 0, 0, 4777, 4779, 3, 422, 211, 0, 4778, 4777, 1, 0, 0, 0, 4779, 4782,
		1, 0, 0, 0, 4780, 4778, 1, 0, 0, 0, 4780, 4781, 1, 0, 0, 0, 4781, 4783,
		1, 0, 0, 0, 4782, 4780, 1, 0, 0, 0, 4783, 4785, 5, 406, 0, 0, 4784, 4786,
		3, 586, 293, 0, 4785, 4784, 1, 0, 0, 0, 4785, 4786, 1, 0, 0, 0, 4786, 393,
		1, 0, 0, 0, 4787, 4790, 5, 21, 0, 0, 4788, 4791, 3, 586, 293, 0, 4789,
		4791, 3, 690, 345, 0, 4790, 4788, 1, 0, 0, 0, 4790, 4789, 1, 0, 0, 0, 4790,
		4791, 1, 0, 0, 0, 4791, 4793, 1, 0, 0, 0, 4792, 4794, 3, 424, 212, 0, 4793,
		4792, 1, 0, 0, 0, 4794, 4795, 1, 0, 0, 0, 4795, 4793, 1, 0, 0, 0, 4795,
		4796, 1, 0, 0, 0, 4796, 4803, 1, 0, 0, 0, 4797, 4799, 5, 52, 0, 0, 4798,
		4800, 3, 422, 211, 0, 4799, 4798, 1, 0, 0, 0, 4800, 4801, 1, 0, 0, 0, 4801,
		4799, 1, 0, 0, 0, 4801, 4802, 1, 0, 0, 0, 4802, 4804, 1, 0, 0, 0, 4803,
		4797, 1, 0, 0, 0, 4803, 4804, 1, 0, 0, 0, 4804, 4805, 1, 0, 0, 0, 4805,
		4806, 5, 406, 0, 0, 4806, 4807, 5, 21, 0, 0, 4807, 395, 1, 0, 0, 0, 4808,
		4809, 5, 76, 0, 0, 4809, 4810, 3, 690, 345, 0, 4810, 4812, 5, 173, 0, 0,
		4811, 4813, 3, 422, 211, 0, 4812, 4811, 1, 0, 0, 0, 4813, 4814, 1, 0, 0,
		0, 4814, 4812, 1, 0, 0, 0, 4814, 4815, 1, 0, 0, 0, 4815, 4819, 1, 0, 0,
		0, 4816, 4818, 3, 426, 213, 0, 4817, 4816, 1, 0, 0, 0, 4818, 4821, 1, 0,
		0, 0, 4819, 4817, 1, 0, 0, 0, 4819, 4820, 1, 0, 0, 0, 4820, 4828, 1, 0,
		0, 0, 4821, 4819, 1, 0, 0, 0, 4822, 4824, 5, 52, 0, 0, 4823, 4825, 3, 422,
		211, 0, 4824, 4823, 1, 0, 0, 0, 4825, 4826, 1, 0, 0, 0, 4826, 4824, 1,
		0, 0, 0, 4826, 4827, 1, 0, 0, 0, 4827, 4829, 1, 0, 0, 0, 4828, 4822, 1,
		0, 0, 0, 4828, 4829, 1, 0, 0, 0, 4829, 4830, 1, 0, 0, 0, 4830, 4831, 5,
		406, 0, 0, 4831, 4832, 5, 76, 0, 0, 4832, 397, 1, 0, 0, 0, 4833, 4834,
		5, 88, 0, 0, 4834, 4835, 3, 586, 293, 0, 4835, 399, 1, 0, 0, 0, 4836, 4837,
		5, 95, 0, 0, 4837, 4838, 3, 586, 293, 0, 4838, 401, 1, 0, 0, 0, 4839, 4840,
		3, 586, 293, 0, 4840, 4841, 5, 1143, 0, 0, 4841, 4843, 1, 0, 0, 0, 4842,
		4839, 1, 0, 0, 0, 4842, 4843, 1, 0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844,
		4846, 5, 104, 0, 0, 4845, 4847, 3, 422, 211, 0, 4846, 4845, 1, 0, 0, 0,
		4847, 4848, 1, 0, 0, 0, 4848, 4846, 1, 0, 0, 0, 4848, 4849, 1, 0, 0, 0,
		4849, 4850, 1, 0, 0, 0, 4850, 4851, 5, 406, 0, 0, 4851, 4853, 5, 104, 0,
		0, 4852, 4854, 3, 586, 293, 0, 4853, 4852, 1, 0, 0, 0, 4853, 4854, 1, 0,
		0, 0, 4854, 403, 1, 0, 0, 0, 4855, 4856, 3, 586, 293, 0, 4856, 4857, 5,
		1143, 0, 0, 4857, 4859, 1, 0, 0, 0, 4858, 4855, 1, 0, 0, 0, 4858, 4859,
		1, 0, 0, 0, 4859, 4860, 1, 0, 0, 0, 4860, 4862, 5, 139, 0, 0, 4861, 4863,
		3, 422, 211, 0, 4862, 4861, 1, 0, 0, 0, 4863, 4864, 1, 0, 0, 0, 4864, 4862,
		1, 0, 0, 0, 4864, 4865, 1, 0, 0, 0, 4865, 4866, 1, 0, 0, 0, 4866, 4867,
		5, 662, 0, 0, 4867, 4868, 3, 690, 345, 0, 4868, 4869, 5, 406, 0, 0, 4869,
		4871, 5, 139, 0, 0, 4870, 4872, 3, 586, 293, 0, 4871, 4870, 1, 0, 0, 0,
		4871, 4872, 1, 0, 0, 0, 4872, 405, 1, 0, 0, 0, 4873, 4874, 5, 145, 0, 0,
		4874, 4875, 3, 690, 345, 0, 4875, 407, 1, 0, 0, 0, 4876, 4877, 3, 586,
		293, 0, 4877, 4878, 5, 1143, 0, 0, 4878, 4880, 1, 0, 0, 0, 4879, 4876,
		1, 0, 0, 0, 4879, 4880, 1, 0, 0, 0, 4880, 4881, 1, 0, 0, 0, 4881, 4882,
		5, 190, 0, 0, 4882, 4883, 3, 690, 345, 0, 4883, 4885, 5, 398, 0, 0, 4884,
		4886, 3, 422, 211, 0, 4885, 4884, 1, 0, 0, 0, 4886, 4887, 1, 0, 0, 0, 4887,
		4885, 1, 0, 0, 0, 4887, 4888, 1, 0, 0, 0, 4888, 4889, 1, 0, 0, 0, 4889,
		4890, 5, 406, 0, 0, 4890, 4892, 5, 190, 0, 0, 4891, 4893, 3, 586, 293,
		0, 4892, 4891, 1, 0, 0, 0, 4892, 4893, 1, 0, 0, 0, 4893, 409, 1, 0, 0,
		0, 4894, 4895, 5, 360, 0, 0, 4895, 4910, 3, 586, 293, 0, 4896, 4901, 5,
		63, 0, 0, 4897, 4899, 5, 519, 0, 0, 4898, 4897, 1, 0, 0, 0, 4898, 4899,
		1, 0, 0, 0, 4899, 4900, 1, 0, 0, 0, 4900, 4902, 5, 67, 0, 0, 4901, 4898,
		1, 0, 0, 0, 4901, 4902, 1, 0, 0, 0, 4902, 4903, 1, 0, 0, 0, 4903, 4904,
		3, 586, 293, 0, 4904, 4905, 5, 86, 0, 0, 4905, 4906, 3, 618, 309, 0, 4906,
		4910, 1, 0, 0, 0, 4907, 4908, 5, 538, 0, 0, 4908, 4910, 3, 586, 293, 0,
		4909, 4894, 1, 0, 0, 0, 4909, 4896, 1, 0, 0, 0, 4909, 4907, 1, 0, 0, 0,
		4910, 411, 1, 0, 0, 0, 4911, 4912, 5, 40, 0, 0, 4912, 4913, 3, 618, 309,
		0, 4913, 4916, 3, 606, 303, 0, 4914, 4915, 5, 41, 0, 0, 4915, 4917, 3,
		690, 345, 0, 4916, 4914, 1, 0, 0, 0, 4916, 4917, 1, 0, 0, 0, 4917, 413,
		1, 0, 0, 0, 4918, 4919, 5, 40, 0, 0, 4919, 4920, 3, 586, 293, 0, 4920,
		4921, 5, 28, 0, 0, 4921, 4928, 5, 64, 0, 0, 4922, 4929, 3, 592, 296, 0,
		4923, 4925, 5, 161, 0, 0, 4924, 4926, 5, 668, 0, 0, 4925, 4924, 1, 0, 0,
		0, 4925, 4926, 1, 0, 0, 0, 4926, 4927, 1, 0, 0, 0, 4927, 4929, 5, 1147,
		0, 0, 4928, 4922, 1, 0, 0, 0, 4928, 4923, 1, 0, 0, 0, 4929, 415, 1, 0,
		0, 0, 4930, 4931, 5, 40, 0, 0, 4931, 4932, 3, 586, 293, 0, 4932, 4933,
		5, 37, 0, 0, 4933, 4934, 5, 64, 0, 0, 4934, 4935, 3, 200, 100, 0, 4935,
		417, 1, 0, 0, 0, 4936, 4937, 5, 40, 0, 0, 4937, 4938, 7, 65, 0, 0, 4938,
		4939, 5, 441, 0, 0, 4939, 4940, 5, 64, 0, 0, 4940, 4945, 3, 420, 210, 0,
		4941, 4942, 5, 1134, 0, 0, 4942, 4944, 3, 420, 210, 0, 4943, 4941, 1, 0,
		0, 0, 4944, 4947, 1, 0, 0, 0, 4945, 4943, 1, 0, 0, 0, 4945, 4946, 1, 0,
		0, 0, 4946, 4948, 1, 0, 0, 0, 4947, 4945, 1, 0, 0, 0, 4948, 4949, 3, 390,
		195, 0, 4949, 419, 1, 0, 0, 0, 4950, 4962, 3, 592, 296, 0, 4951, 4953,
		5, 161, 0, 0, 4952, 4954, 5, 668, 0, 0, 4953, 4952, 1, 0, 0, 0, 4953, 4954,
		1, 0, 0, 0, 4954, 4955, 1, 0, 0, 0, 4955, 4962, 5, 1147, 0, 0, 4956, 4962,
		3, 586, 293, 0, 4957, 4962, 5, 162, 0, 0, 4958, 4959, 5, 113, 0, 0, 4959,
		4962, 5, 434, 0, 0, 4960, 4962, 5, 160, 0, 0, 4961, 4950, 1, 0, 0, 0, 4961,
		4951, 1, 0, 0, 0, 4961, 4956, 1, 0, 0, 0, 4961, 4957, 1, 0, 0, 0, 4961,
		4958, 1, 0, 0, 0, 4961, 4960, 1, 0, 0, 0, 4962, 421, 1, 0, 0, 0, 4963,
		4966, 3, 18, 9, 0, 4964, 4966, 3, 4, 2, 0, 4965, 4963, 1, 0, 0, 0, 4965,
		4964, 1, 0, 0, 0, 4966, 4967, 1, 0, 0, 0, 4967, 4968, 5, 1135, 0, 0, 4968,
		423, 1, 0, 0, 0, 4969, 4972, 5, 188, 0, 0, 4970, 4973, 3, 604, 302, 0,
		4971, 4973, 3, 690, 345, 0, 4972, 4970, 1, 0, 0, 0, 4972, 4971, 1, 0, 0,
		0, 4973, 4974, 1, 0, 0, 0, 4974, 4976, 5, 173, 0, 0, 4975, 4977, 3, 422,
		211, 0, 4976, 4975, 1, 0, 0, 0, 4977, 4978, 1, 0, 0, 0, 4978, 4976, 1,
		0, 0, 0, 4978, 4979, 1, 0, 0, 0, 4979, 425, 1, 0, 0, 0, 4980, 4981, 5,
		53, 0, 0, 4981, 4982, 3, 690, 345, 0, 4982, 4984, 5, 173, 0, 0, 4983, 4985,
		3, 422, 211, 0, 4984, 4983, 1, 0, 0, 0, 4985, 4986, 1, 0, 0, 0, 4986, 4984,
		1, 0, 0, 0, 4986, 4987, 1, 0, 0, 0, 4987, 427, 1, 0, 0, 0, 4988, 4989,
		5, 6, 0, 0, 4989, 4990, 5, 664, 0, 0, 4990, 4995, 3, 448, 224, 0, 4991,
		4992, 5, 1134, 0, 0, 4992, 4994, 3, 448, 224, 0, 4993, 4991, 1, 0, 0, 0,
		4994, 4997, 1, 0, 0, 0, 4995, 4993, 1, 0, 0, 0, 4995, 4996, 1, 0, 0, 0,
		4996, 5062, 1, 0, 0, 0, 4997, 4995, 1, 0, 0, 0, 4998, 4999, 5, 6, 0, 0,
		4999, 5001, 5, 664, 0, 0, 5000, 5002, 3, 642, 321, 0, 5001, 5000, 1, 0,
		0, 0, 5001, 5002, 1, 0, 0, 0, 5002, 5003, 1, 0, 0, 0, 5003, 5008, 3, 450,
		225, 0, 5004, 5005, 5, 1134, 0, 0, 5005, 5007, 3, 450, 225, 0, 5006, 5004,
		1, 0, 0, 0, 5007, 5010, 1, 0, 0, 0, 5008, 5006, 1, 0, 0, 0, 5008, 5009,
		1, 0, 0, 0, 5009, 5025, 1, 0, 0, 0, 5010, 5008, 1, 0, 0, 0, 5011, 5023,
		5, 141, 0, 0, 5012, 5024, 5, 528, 0, 0, 5013, 5020, 3, 456, 228, 0, 5014,
		5016, 5, 9, 0, 0, 5015, 5014, 1, 0, 0, 0, 5015, 5016, 1, 0, 0, 0, 5016,
		5017, 1, 0, 0, 0, 5017, 5019, 3, 456, 228, 0, 5018, 5015, 1, 0, 0, 0, 5019,
		5022, 1, 0, 0, 0, 5020, 5018, 1, 0, 0, 0, 5020, 5021, 1, 0, 0, 0, 5021,
		5024, 1, 0, 0, 0, 5022, 5020, 1, 0, 0, 0, 5023, 5012, 1, 0, 0, 0, 5023,
		5013, 1, 0, 0, 0, 5024, 5026, 1, 0, 0, 0, 5025, 5011, 1, 0, 0, 0, 5025,
		5026, 1, 0, 0, 0, 5026, 5033, 1, 0, 0, 0, 5027, 5029, 5, 191, 0, 0, 5028,
		5030, 3, 458, 229, 0, 5029, 5028, 1, 0, 0, 0, 5030, 5031, 1, 0, 0, 0, 5031,
		5029, 1, 0, 0, 0, 5031, 5032, 1, 0, 0, 0, 5032, 5034, 1, 0, 0, 0, 5033,
		5027, 1, 0, 0, 0, 5033, 5034, 1, 0, 0, 0, 5034, 5039, 1, 0, 0, 0, 5035,
		5038, 3, 460, 230, 0, 5036, 5038, 3, 462, 231, 0, 5037, 5035, 1, 0, 0,
		0, 5037, 5036, 1, 0, 0, 0, 5038, 5041, 1, 0, 0, 0, 5039, 5037, 1, 0, 0,
		0, 5039, 5040, 1, 0, 0, 0, 5040, 5046, 1, 0, 0, 0, 5041, 5039, 1, 0, 0,
		0, 5042, 5043, 5, 367, 0, 0, 5043, 5047, 5, 1147, 0, 0, 5044, 5045, 5,
		13, 0, 0, 5045, 5047, 5, 1147, 0, 0, 5046, 5042, 1, 0, 0, 0, 5046, 5044,
		1, 0, 0, 0, 5046, 5047, 1, 0, 0, 0, 5047, 5062, 1, 0, 0, 0, 5048, 5049,
		5, 6, 0, 0, 5049, 5051, 5, 664, 0, 0, 5050, 5052, 3, 642, 321, 0, 5051,
		5050, 1, 0, 0, 0, 5051, 5052, 1, 0, 0, 0, 5052, 5055, 1, 0, 0, 0, 5053,
		5056, 3, 566, 283, 0, 5054, 5056, 3, 586, 293, 0, 5055, 5053, 1, 0, 0,
		0, 5055, 5054, 1, 0, 0, 0, 5056, 5057, 1, 0, 0, 0, 5057, 5058, 5, 41, 0,
		0, 5058, 5059, 5, 595, 0, 0, 5059, 5060, 3, 436, 218, 0, 5060, 5062, 1,
		0, 0, 0, 5061, 4988, 1, 0, 0, 0, 5061, 4998, 1, 0, 0, 0, 5061, 5048, 1,
		0, 0, 0, 5062, 429, 1, 0, 0, 0, 5063, 5064, 5, 32, 0, 0, 5064, 5065, 5,
		664, 0, 0, 5065, 5070, 3, 450, 225, 0, 5066, 5067, 5, 1134, 0, 0, 5067,
		5069, 3, 450, 225, 0, 5068, 5066, 1, 0, 0, 0, 5069, 5072, 1, 0, 0, 0, 5070,
		5068, 1, 0, 0, 0, 5070, 5071, 1, 0, 0, 0, 5071, 5129, 1, 0, 0, 0, 5072,
		5070, 1, 0, 0, 0, 5073, 5074, 5, 32, 0, 0, 5074, 5076, 5, 664, 0, 0, 5075,
		5077, 3, 644, 322, 0, 5076, 5075, 1, 0, 0, 0, 5076, 5077, 1, 0, 0, 0, 5077,
		5078, 1, 0, 0, 0, 5078, 5083, 3, 450, 225, 0, 5079, 5080, 5, 1134, 0, 0,
		5080, 5082, 3, 450, 225, 0, 5081, 5079, 1, 0, 0, 0, 5082, 5085, 1, 0, 0,
		0, 5083, 5081, 1, 0, 0, 0, 5083, 5084, 1, 0, 0, 0, 5084, 5089, 1, 0, 0,
		0, 5085, 5083, 1, 0, 0, 0, 5086, 5087, 5, 41, 0, 0, 5087, 5088, 5, 595,
		0, 0, 5088, 5090, 3, 436, 218, 0, 5089, 5086, 1, 0, 0, 0, 5089, 5090, 1,
		0, 0, 0, 5090, 5105, 1, 0, 0, 0, 5091, 5103, 5, 141, 0, 0, 5092, 5104,
		5, 528, 0, 0, 5093, 5100, 3, 456, 228, 0, 5094, 5096, 5, 9, 0, 0, 5095,
		5094, 1, 0, 0, 0, 5095, 5096, 1, 0, 0, 0, 5096, 5097, 1, 0, 0, 0, 5097,
		5099, 3, 456, 228, 0, 5098, 5095, 1, 0, 0, 0, 5099, 5102, 1, 0, 0, 0, 5100,
		5098, 1, 0, 0, 0, 5100, 5101, 1, 0, 0, 0, 5101, 5104, 1, 0, 0, 0, 5102,
		5100, 1, 0, 0, 0, 5103, 5092, 1, 0, 0, 0, 5103, 5093, 1, 0, 0, 0, 5104,
		5106, 1, 0, 0, 0, 5105, 5091, 1, 0, 0, 0, 5105, 5106, 1, 0, 0, 0, 5106,
		5113, 1, 0, 0, 0, 5107, 5109, 5, 191, 0, 0, 5108, 5110, 3, 458, 229, 0,
		5109, 5108, 1, 0, 0, 0, 5110, 5111, 1, 0, 0, 0, 5111, 5109, 1, 0, 0, 0,
		5111, 5112, 1, 0, 0, 0, 5112, 5114, 1, 0, 0, 0, 5113, 5107, 1, 0, 0, 0,
		5113, 5114, 1, 0, 0, 0, 5114, 5119, 1, 0, 0, 0, 5115, 5118, 3, 460, 230,
		0, 5116, 5118, 3, 462, 231, 0, 5117, 5115, 1, 0, 0, 0, 5117, 5116, 1, 0,
		0, 0, 5118, 5121, 1, 0, 0, 0, 5119, 5117, 1, 0, 0, 0, 5119, 5120, 1, 0,
		0, 0, 5120, 5126, 1, 0, 0, 0, 5121, 5119, 1, 0, 0, 0, 5122, 5123, 5, 367,
		0, 0, 5123, 5127, 5, 1147, 0, 0, 5124, 5125, 5, 13, 0, 0, 5125, 5127, 5,
		1147, 0, 0, 5126, 5122, 1, 0, 0, 0, 5126, 5124, 1, 0, 0, 0, 5126, 5127,
		1, 0, 0, 0, 5127, 5129, 1, 0, 0, 0, 5128, 5063, 1, 0, 0, 0, 5128, 5073,
		1, 0, 0, 0, 5129, 431, 1, 0, 0, 0, 5130, 5131, 5, 50, 0, 0, 5131, 5133,
		5, 664, 0, 0, 5132, 5134, 3, 642, 321, 0, 5133, 5132, 1, 0, 0, 0, 5133,
		5134, 1, 0, 0, 0, 5134, 5135, 1, 0, 0, 0, 5135, 5140, 3, 566, 283, 0, 5136,
		5137, 5, 1134, 0, 0, 5137, 5139, 3, 566, 283, 0, 5138, 5136, 1, 0, 0, 0,
		5139, 5142, 1, 0, 0, 0, 5140, 5138, 1, 0, 0, 0, 5140, 5141, 1, 0, 0, 0,
		5141, 433, 1, 0, 0, 0, 5142, 5140, 1, 0, 0, 0, 5143, 5144, 5, 71, 0, 0,
		5144, 5149, 3, 464, 232, 0, 5145, 5146, 5, 1134, 0, 0, 5146, 5148, 3, 464,
		232, 0, 5147, 5145, 1, 0, 0, 0, 5148, 5151, 1, 0, 0, 0, 5149, 5147, 1,
		0, 0, 0, 5149, 5150, 1, 0, 0, 0, 5150, 5152, 1, 0, 0, 0, 5151, 5149, 1,
		0, 0, 0, 5152, 5154, 5, 117, 0, 0, 5153, 5155, 7, 66, 0, 0, 5154, 5153,
		1, 0, 0, 0, 5154, 5155, 1, 0, 0, 0, 5155, 5156, 1, 0, 0, 0, 5156, 5157,
		3, 468, 234, 0, 5157, 5158, 5, 174, 0, 0, 5158, 5163, 3, 450, 225, 0, 5159,
		5160, 5, 1134, 0, 0, 5160, 5162, 3, 450, 225, 0, 5161, 5159, 1, 0, 0, 0,
		5162, 5165, 1, 0, 0, 0, 5163, 5161, 1, 0, 0, 0, 5163, 5164, 1, 0, 0, 0,
		5164, 5180, 1, 0, 0, 0, 5165, 5163, 1, 0, 0, 0, 5166, 5178, 5, 141, 0,
		0, 5167, 5179, 5, 528, 0, 0, 5168, 5175, 3, 456, 228, 0, 5169, 5171, 5,
		9, 0, 0, 5170, 5169, 1, 0, 0, 0, 5170, 5171, 1, 0, 0, 0, 5171, 5172, 1,
		0, 0, 0, 5172, 5174, 3, 456, 228, 0, 5173, 5170, 1, 0, 0, 0, 5174, 5177,
		1, 0, 0, 0, 5175, 5173, 1, 0, 0, 0, 5175, 5176, 1, 0, 0, 0, 5176, 5179,
		1, 0, 0, 0, 5177, 5175, 1, 0, 0, 0, 5178, 5167, 1, 0, 0, 0, 5178, 5168,
		1, 0, 0, 0, 5179, 5181, 1, 0, 0, 0, 5180, 5166, 1, 0, 0, 0, 5180, 5181,
		1, 0, 0, 0, 5181, 5191, 1, 0, 0, 0, 5182, 5188, 5, 191, 0, 0, 5183, 5184,
		5, 71, 0, 0, 5184, 5187, 5, 119, 0, 0, 5185, 5187, 3, 458, 229, 0, 5186,
		5183, 1, 0, 0, 0, 5186, 5185, 1, 0, 0, 0, 5187, 5190, 1, 0, 0, 0, 5188,
		5186, 1, 0, 0, 0, 5188, 5189, 1, 0, 0, 0, 5189, 5192, 1, 0, 0, 0, 5190,
		5188, 1, 0, 0, 0, 5191, 5182, 1, 0, 0, 0, 5191, 5192, 1, 0, 0, 0, 5192,
		5199, 1, 0, 0, 0, 5193, 5194, 5, 11, 0, 0, 5194, 5195, 3, 566, 283, 0,
		5195, 5196, 5, 191, 0, 0, 5196, 5197, 5, 595, 0, 0, 5197, 5198, 3, 436,
		218, 0, 5198, 5200, 1, 0, 0, 0, 5199, 5193, 1, 0, 0, 0, 5199, 5200, 1,
		0, 0, 0, 5200, 5237, 1, 0, 0, 0, 5201, 5204, 5, 71, 0, 0, 5202, 5205, 3,
		566, 283, 0, 5203, 5205, 3, 586, 293, 0, 5204, 5202, 1, 0, 0, 0, 5204,
		5203, 1, 0, 0, 0, 5205, 5213, 1, 0, 0, 0, 5206, 5209, 5, 1134, 0, 0, 5207,
		5210, 3, 566, 283, 0, 5208, 5210, 3, 586, 293, 0, 5209, 5207, 1, 0, 0,
		0, 5209, 5208, 1, 0, 0, 0, 5210, 5212, 1, 0, 0, 0, 5211, 5206, 1, 0, 0,
		0, 5212, 5215, 1, 0, 0, 0, 5213, 5211, 1, 0, 0, 0, 5213, 5214, 1, 0, 0,
		0, 5214, 5216, 1, 0, 0, 0, 5215, 5213, 1, 0, 0, 0, 5216, 5219, 5, 174,
		0, 0, 5217, 5220, 3, 566, 283, 0, 5218, 5220, 3, 586, 293, 0, 5219, 5217,
		1, 0, 0, 0, 5219, 5218, 1, 0, 0, 0, 5220, 5228, 1, 0, 0, 0, 5221, 5224,
		5, 1134, 0, 0, 5222, 5225, 3, 566, 283, 0, 5223, 5225, 3, 586, 293, 0,
		5224, 5222, 1, 0, 0, 0, 5224, 5223, 1, 0, 0, 0, 5225, 5227, 1, 0, 0, 0,
		5226, 5221, 1, 0, 0, 0, 5227, 5230, 1, 0, 0, 0, 5228, 5226, 1, 0, 0, 0,
		5228, 5229, 1, 0, 0, 0, 5229, 5234, 1, 0, 0, 0, 5230, 5228, 1, 0, 0, 0,
		5231, 5232, 5, 191, 0, 0, 5232, 5233, 5, 696, 0, 0, 5233, 5235, 5, 119,
		0, 0, 5234, 5231, 1, 0, 0, 0, 5234, 5235, 1, 0, 0, 0, 5235, 5237, 1, 0,
		0, 0, 5236, 5143, 1, 0, 0, 0, 5236, 5201, 1, 0, 0, 0, 5237, 435, 1, 0,
		0, 0, 5238, 5261, 5, 41, 0, 0, 5239, 5261, 5, 528, 0, 0, 5240, 5250, 5,
		5, 0, 0, 5241, 5242, 5, 58, 0, 0, 5242, 5247, 3, 566, 283, 0, 5243, 5244,
		5, 1134, 0, 0, 5244, 5246, 3, 566, 283, 0, 5245, 5243, 1, 0, 0, 0, 5246,
		5249, 1, 0, 0, 0, 5247, 5245, 1, 0, 0, 0, 5247, 5248, 1, 0, 0, 0, 5248,
		5251, 1, 0, 0, 0, 5249, 5247, 1, 0, 0, 0, 5250, 5241, 1, 0, 0, 0, 5250,
		5251, 1, 0, 0, 0, 5251, 5261, 1, 0, 0, 0, 5252, 5257, 3, 566, 283, 0, 5253,
		5254, 5, 1134, 0, 0, 5254, 5256, 3, 566, 283, 0, 5255, 5253, 1, 0, 0, 0,
		5256, 5259, 1, 0, 0, 0, 5257, 5255, 1, 0, 0, 0, 5257, 5258, 1, 0, 0, 0,
		5258, 5261, 1, 0, 0, 0, 5259, 5257, 1, 0, 0, 0, 5260, 5238, 1, 0, 0, 0,
		5260, 5239, 1, 0, 0, 0, 5260, 5240, 1, 0, 0, 0, 5260, 5252, 1, 0, 0, 0,
		5261, 437, 1, 0, 0, 0, 5262, 5263, 5, 71, 0, 0, 5263, 5264, 5, 565, 0,
		0, 5264, 5265, 5, 117, 0, 0, 5265, 5266, 3, 566, 283, 0, 5266, 5267, 5,
		174, 0, 0, 5267, 5272, 3, 566, 283, 0, 5268, 5269, 5, 1134, 0, 0, 5269,
		5271, 3, 566, 283, 0, 5270, 5268, 1, 0, 0, 0, 5271, 5274, 1, 0, 0, 0, 5272,
		5270, 1, 0, 0, 0, 5272, 5273, 1, 0, 0, 0, 5273, 5278, 1, 0, 0, 0, 5274,
		5272, 1, 0, 0, 0, 5275, 5276, 5, 191, 0, 0, 5276, 5277, 5, 71, 0, 0, 5277,
		5279, 5, 119, 0, 0, 5278, 5275, 1, 0, 0, 0, 5278, 5279, 1, 0, 0, 0, 5279,
		439, 1, 0, 0, 0, 5280, 5281, 5, 138, 0, 0, 5281, 5282, 5, 664, 0, 0, 5282,
		5287, 3, 470, 235, 0, 5283, 5284, 5, 1134, 0, 0, 5284, 5286, 3, 470, 235,
		0, 5285, 5283, 1, 0, 0, 0, 5286, 5289, 1, 0, 0, 0, 5287, 5285, 1, 0, 0,
		0, 5287, 5288, 1, 0, 0, 0, 5288, 441, 1, 0, 0, 0, 5289, 5287, 1, 0, 0,
		0, 5290, 5291, 5, 146, 0, 0, 5291, 5296, 3, 464, 232, 0, 5292, 5293, 5,
		1134, 0, 0, 5293, 5295, 3, 464, 232, 0, 5294, 5292, 1, 0, 0, 0, 5295, 5298,
		1, 0, 0, 0, 5296, 5294, 1, 0, 0, 0, 5296, 5297, 1, 0, 0, 0, 5297, 5299,
		1, 0, 0, 0, 5298, 5296, 1, 0, 0, 0, 5299, 5301, 5, 117, 0, 0, 5300, 5302,
		7, 66, 0, 0, 5301, 5300, 1, 0, 0, 0, 5301, 5302, 1, 0, 0, 0, 5302, 5303,
		1, 0, 0, 0, 5303, 5304, 3, 468, 234, 0, 5304, 5305, 5, 67, 0, 0, 5305,
		5310, 3, 566, 283, 0, 5306, 5307, 5, 1134, 0, 0, 5307, 5309, 3, 566, 283,
		0, 5308, 5306, 1, 0, 0, 0, 5309, 5312, 1, 0, 0, 0, 5310, 5308, 1, 0, 0,
		0, 5310, 5311, 1, 0, 0, 0, 5311, 5361, 1, 0, 0, 0, 5312, 5310, 1, 0, 0,
		0, 5313, 5314, 5, 146, 0, 0, 5314, 5316, 5, 5, 0, 0, 5315, 5317, 5, 724,
		0, 0, 5316, 5315, 1, 0, 0, 0, 5316, 5317, 1, 0, 0, 0, 5317, 5318, 1, 0,
		0, 0, 5318, 5319, 5, 1134, 0, 0, 5319, 5320, 5, 71, 0, 0, 5320, 5321, 5,
		119, 0, 0, 5321, 5322, 5, 67, 0, 0, 5322, 5327, 3, 566, 283, 0, 5323, 5324,
		5, 1134, 0, 0, 5324, 5326, 3, 566, 283, 0, 5325, 5323, 1, 0, 0, 0, 5326,
		5329, 1, 0, 0, 0, 5327, 5325, 1, 0, 0, 0, 5327, 5328, 1, 0, 0, 0, 5328,
		5361, 1, 0, 0, 0, 5329, 5327, 1, 0, 0, 0, 5330, 5333, 5, 146, 0, 0, 5331,
		5334, 3, 566, 283, 0, 5332, 5334, 3, 586, 293, 0, 5333, 5331, 1, 0, 0,
		0, 5333, 5332, 1, 0, 0, 0, 5334, 5342, 1, 0, 0, 0, 5335, 5338, 5, 1134,
		0, 0, 5336, 5339, 3, 566, 283, 0, 5337, 5339, 3, 586, 293, 0, 5338, 5336,
		1, 0, 0, 0, 5338, 5337, 1, 0, 0, 0, 5339, 5341, 1, 0, 0, 0, 5340, 5335,
		1, 0, 0, 0, 5341, 5344, 1, 0, 0, 0, 5342, 5340, 1, 0, 0, 0, 5342, 5343,
		1, 0, 0, 0, 5343, 5345, 1, 0, 0, 0, 5344, 5342, 1, 0, 0, 0, 5345, 5348,
		5, 67, 0, 0, 5346, 5349, 3, 566, 283, 0, 5347, 5349, 3, 586, 293, 0, 5348,
		5346, 1, 0, 0, 0, 5348, 5347, 1, 0, 0, 0, 5349, 5357, 1, 0, 0, 0, 5350,
		5353, 5, 1134, 0, 0, 5351, 5354, 3, 566, 283, 0, 5352, 5354, 3, 586, 293,
		0, 5353, 5351, 1, 0, 0, 0, 5353, 5352, 1, 0, 0, 0, 5354, 5356, 1, 0, 0,
		0, 5355, 5350, 1, 0, 0, 0, 5356, 5359, 1, 0, 0, 0, 5357, 5355, 1, 0, 0,
		0, 5357, 5358, 1, 0, 0, 0, 5358, 5361, 1, 0, 0, 0, 5359, 5357, 1, 0, 0,
		0, 5360, 5290, 1, 0, 0, 0, 5360, 5313, 1, 0, 0, 0, 5360, 5330, 1, 0, 0,
		0, 5361, 443, 1, 0, 0, 0, 5362, 5363, 5, 146, 0, 0, 5363, 5364, 5, 565,
		0, 0, 5364, 5365, 5, 117, 0, 0, 5365, 5366, 3, 566, 283, 0, 5366, 5367,
		5, 67, 0, 0, 5367, 5372, 3, 566, 283, 0, 5368, 5369, 5, 1134, 0, 0, 5369,
		5371, 3, 566, 283, 0, 5370, 5368, 1, 0, 0, 0, 5371, 5374, 1, 0, 0, 0, 5372,
		5370, 1, 0, 0, 0, 5372, 5373, 1, 0, 0, 0, 5373, 445, 1, 0, 0, 0, 5374,
		5372, 1, 0, 0, 0, 5375, 5376, 5, 152, 0, 0, 5376, 5379, 5, 550, 0, 0, 5377,
		5378, 5, 64, 0, 0, 5378, 5380, 3, 566, 283, 0, 5379, 5377, 1, 0, 0, 0,
		5379, 5380, 1, 0, 0, 0, 5380, 5381, 1, 0, 0, 0, 5381, 5384, 5, 1123, 0,
		0, 5382, 5385, 3, 684, 342, 0, 5383, 5385, 5, 1147, 0, 0, 5384, 5382, 1,
		0, 0, 0, 5384, 5383, 1, 0, 0, 0, 5385, 447, 1, 0, 0, 0, 5386, 5387, 3,
		566, 283, 0, 5387, 5388, 3, 460, 230, 0, 5388, 449, 1, 0, 0, 0, 5389, 5390,
		3, 566, 283, 0, 5390, 5391, 5, 447, 0, 0, 5391, 5392, 5, 18, 0, 0, 5392,
		5393, 5, 550, 0, 0, 5393, 5394, 5, 1147, 0, 0, 5394, 5415, 1, 0, 0, 0,
		5395, 5396, 3, 566, 283, 0, 5396, 5397, 5, 447, 0, 0, 5397, 5398, 5, 18,
		0, 0, 5398, 5399, 5, 990, 0, 0, 5399, 5400, 5, 550, 0, 0, 5400, 5401, 3,
		452, 226, 0, 5401, 5415, 1, 0, 0, 0, 5402, 5403, 3, 566, 283, 0, 5403,
		5404, 5, 447, 0, 0, 5404, 5405, 5, 18, 0, 0, 5405, 5406, 5, 1147, 0, 0,
		5406, 5407, 3, 452, 226, 0, 5407, 5415, 1, 0, 0, 0, 5408, 5409, 3, 566,
		283, 0, 5409, 5410, 5, 447, 0, 0, 5410, 5411, 5, 191, 0, 0, 5411, 5412,
		3, 454, 227, 0, 5412, 5415, 1, 0, 0, 0, 5413, 5415, 3, 566, 283, 0, 5414,
		5389, 1, 0, 0, 0, 5414, 5395, 1, 0, 0, 0, 5414, 5402, 1, 0, 0, 0, 5414,
		5408, 1, 0, 0, 0, 5414, 5413, 1, 0, 0, 0, 5415, 451, 1, 0, 0, 0, 5416,
		5417, 5, 140, 0, 0, 5417, 5419, 5, 1147, 0, 0, 5418, 5416, 1, 0, 0, 0,
		5418, 5419, 1, 0, 0, 0, 5419, 5423, 1, 0, 0, 0, 5420, 5421, 5, 144, 0,
		0, 5421, 5422, 5, 34, 0, 0, 5422, 5424, 5, 550, 0, 0, 5423, 5420, 1, 0,
		0, 0, 5423, 5424, 1, 0, 0, 0, 5424, 453, 1, 0, 0, 0, 5425, 5433, 3, 584,
		292, 0, 5426, 5430, 7, 67, 0, 0, 5427, 5431, 5, 1147, 0, 0, 5428, 5429,
		5, 990, 0, 0, 5429, 5431, 5, 550, 0, 0, 5430, 5427, 1, 0, 0, 0, 5430, 5428,
		1, 0, 0, 0, 5431, 5432, 1, 0, 0, 0, 5432, 5434, 3, 452, 226, 0, 5433, 5426,
		1, 0, 0, 0, 5433, 5434, 1, 0, 0, 0, 5434, 5440, 1, 0, 0, 0, 5435, 5436,
		3, 584, 292, 0, 5436, 5437, 5, 186, 0, 0, 5437, 5438, 3, 684, 342, 0, 5438,
		5440, 1, 0, 0, 0, 5439, 5425, 1, 0, 0, 0, 5439, 5435, 1, 0, 0, 0, 5440,
		455, 1, 0, 0, 0, 5441, 5450, 5, 166, 0, 0, 5442, 5450, 5, 679, 0, 0, 5443,
		5444, 5, 357, 0, 0, 5444, 5450, 5, 1147, 0, 0, 5445, 5446, 5, 464, 0, 0,
		5446, 5450, 5, 1147, 0, 0, 5447, 5448, 5, 639, 0, 0, 5448, 5450, 5, 1147,
		0, 0, 5449, 5441, 1, 0, 0, 0, 5449, 5442, 1, 0, 0, 0, 5449, 5443, 1, 0,
		0, 0, 5449, 5445, 1, 0, 0, 0, 5449, 5447, 1, 0, 0, 0, 5450, 457, 1, 0,
		0, 0, 5451, 5452, 5, 498, 0, 0, 5452, 5460, 3, 592, 296, 0, 5453, 5454,
		5, 501, 0, 0, 5454, 5460, 3, 592, 296, 0, 5455, 5456, 5, 497, 0, 0, 5456,
		5460, 3, 592, 296, 0, 5457, 5458, 5, 502, 0, 0, 5458, 5460, 3, 592, 296,
		0, 5459, 5451, 1, 0, 0, 0, 5459, 5453, 1, 0, 0, 0, 5459, 5455, 1, 0, 0,
		0, 5459, 5457, 1, 0, 0, 0, 5460, 459, 1, 0, 0, 0, 5461, 5462, 5, 550, 0,
		0, 5462, 5469, 5, 419, 0, 0, 5463, 5470, 5, 41, 0, 0, 5464, 5470, 5, 518,
		0, 0, 5465, 5466, 5, 85, 0, 0, 5466, 5467, 3, 592, 296, 0, 5467, 5468,
		5, 690, 0, 0, 5468, 5470, 1, 0, 0, 0, 5469, 5463, 1, 0, 0, 0, 5469, 5464,
		1, 0, 0, 0, 5469, 5465, 1, 0, 0, 0, 5469, 5470, 1, 0, 0, 0, 5470, 5500,
		1, 0, 0, 0, 5471, 5472, 5, 550, 0, 0, 5472, 5475, 5, 444, 0, 0, 5473, 5476,
		5, 41, 0, 0, 5474, 5476, 3, 592, 296, 0, 5475, 5473, 1, 0, 0, 0, 5475,
		5474, 1, 0, 0, 0, 5476, 5500, 1, 0, 0, 0, 5477, 5478, 5, 550, 0, 0, 5478,
		5479, 5, 594, 0, 0, 5479, 5484, 5, 85, 0, 0, 5480, 5485, 5, 41, 0, 0, 5481,
		5482, 3, 592, 296, 0, 5482, 5483, 5, 690, 0, 0, 5483, 5485, 1, 0, 0, 0,
		5484, 5480, 1, 0, 0, 0, 5484, 5481, 1, 0, 0, 0, 5485, 5500, 1, 0, 0, 0,
		5486, 5487, 5, 550, 0, 0, 5487, 5488, 5, 141, 0, 0, 5488, 5490, 5, 34,
		0, 0, 5489, 5491, 7, 68, 0, 0, 5490, 5489, 1, 0, 0, 0, 5490, 5491, 1, 0,
		0, 0, 5491, 5500, 1, 0, 0, 0, 5492, 5493, 5, 423, 0, 0, 5493, 5500, 3,
		592, 296, 0, 5494, 5497, 5, 551, 0, 0, 5495, 5498, 3, 592, 296, 0, 5496,
		5498, 5, 656, 0, 0, 5497, 5495, 1, 0, 0, 0, 5497, 5496, 1, 0, 0, 0, 5498,
		5500, 1, 0, 0, 0, 5499, 5461, 1, 0, 0, 0, 5499, 5471, 1, 0, 0, 0, 5499,
		5477, 1, 0, 0, 0, 5499, 5486, 1, 0, 0, 0, 5499, 5492, 1, 0, 0, 0, 5499,
		5494, 1, 0, 0, 0, 5500, 461, 1, 0, 0, 0, 5501, 5502, 5, 331, 0, 0, 5502,
		5503, 7, 69, 0, 0, 5503, 463, 1, 0, 0, 0, 5504, 5509, 3, 466, 233, 0, 5505,
		5506, 5, 1132, 0, 0, 5506, 5507, 3, 618, 309, 0, 5507, 5508, 5, 1133, 0,
		0, 5508, 5510, 1, 0, 0, 0, 5509, 5505, 1, 0, 0, 0, 5509, 5510, 1, 0, 0,
		0, 5510, 465, 1, 0, 0, 0, 5511, 5513, 5, 5, 0, 0, 5512, 5514, 5, 724, 0,
		0, 5513, 5512, 1, 0, 0, 0, 5513, 5514, 1, 0, 0, 0, 5514, 5605, 1, 0, 0,
		0, 5515, 5517, 5, 6, 0, 0, 5516, 5518, 5, 732, 0, 0, 5517, 5516, 1, 0,
		0, 0, 5517, 5518, 1, 0, 0, 0, 5518, 5605, 1, 0, 0, 0, 5519, 5527, 5, 32,
		0, 0, 5520, 5521, 5, 648, 0, 0, 5521, 5528, 5, 741, 0, 0, 5522, 5528, 5,
		732, 0, 0, 5523, 5528, 5, 670, 0, 0, 5524, 5528, 5, 664, 0, 0, 5525, 5528,
		5, 646, 0, 0, 5526, 5528, 5, 595, 0, 0, 5527, 5520, 1, 0, 0, 0, 5527, 5522,
		1, 0, 0, 0, 5527, 5523, 1, 0, 0, 0, 5527, 5524, 1, 0, 0, 0, 5527, 5525,
		1, 0, 0, 0, 5527, 5526, 1, 0, 0, 0, 5527, 5528, 1, 0, 0, 0, 5528, 5605,
		1, 0, 0, 0, 5529, 5605, 5, 43, 0, 0, 5530, 5532, 5, 50, 0, 0, 5531, 5533,
		5, 595, 0, 0, 5532, 5531, 1, 0, 0, 0, 5532, 5533, 1, 0, 0, 0, 5533, 5605,
		1, 0, 0, 0, 5534, 5605, 5, 414, 0, 0, 5535, 5605, 5, 707, 0, 0, 5536, 5605,
		5, 708, 0, 0, 5537, 5538, 5, 71, 0, 0, 5538, 5605, 5, 119, 0, 0, 5539,
		5605, 5, 80, 0, 0, 5540, 5605, 5, 84, 0, 0, 5541, 5542, 5, 102, 0, 0, 5542,
		5605, 5, 741, 0, 0, 5543, 5605, 5, 725, 0, 0, 5544, 5605, 5, 565, 0, 0,
		5545, 5605, 5, 135, 0, 0, 5546, 5605, 5, 726, 0, 0, 5547, 5548, 5, 587,
		0, 0, 5548, 5605, 7, 70, 0, 0, 5549, 5605, 5, 151, 0, 0, 5550, 5551, 5,
		154, 0, 0, 5551, 5605, 7, 71, 0, 0, 5552, 5605, 5, 738, 0, 0, 5553, 5605,
		5, 739, 0, 0, 5554, 5605, 5, 176, 0, 0, 5555, 5605, 5, 183, 0, 0, 5556,
		5605, 5, 184, 0, 0, 5557, 5605, 5, 697, 0, 0, 5558, 5605, 5, 698, 0, 0,
		5559, 5605, 5, 699, 0, 0, 5560, 5605, 5, 700, 0, 0, 5561, 5605, 5, 701,
		0, 0, 5562, 5605, 5, 702, 0, 0, 5563, 5605, 5, 703, 0, 0, 5564, 5605, 5,
		704, 0, 0, 5565, 5605, 5, 705, 0, 0, 5566, 5605, 5, 706, 0, 0, 5567, 5605,
		5, 709, 0, 0, 5568, 5605, 5, 710, 0, 0, 5569, 5605, 5, 711, 0, 0, 5570,
		5605, 5, 712, 0, 0, 5571, 5605, 5, 713, 0, 0, 5572, 5605, 5, 714, 0, 0,
		5573, 5605, 5, 715, 0, 0, 5574, 5605, 5, 716, 0, 0, 5575, 5605, 5, 717,
		0, 0, 5576, 5605, 5, 718, 0, 0, 5577, 5605, 5, 721, 0, 0, 5578, 5605, 5,
		722, 0, 0, 5579, 5605, 5, 723, 0, 0, 5580, 5605, 5, 727, 0, 0, 5581, 5605,
		5, 728, 0, 0, 5582, 5605, 5, 729, 0, 0, 5583, 5605, 5, 730, 0, 0, 5584,
		5605, 5, 731, 0, 0, 5585, 5605, 5, 734, 0, 0, 5586, 5605, 5, 735, 0, 0,
		5587, 5605, 5, 736, 0, 0, 5588, 5605, 5, 157, 0, 0, 5589, 5605, 5, 737,
		0, 0, 5590, 5605, 5, 1076, 0, 0, 5591, 5605, 5, 740, 0, 0, 5592, 5605,
		5, 742, 0, 0, 5593, 5605, 5, 1087, 0, 0, 5594, 5605, 5, 743, 0, 0, 5595,
		5605, 5, 744, 0, 0, 5596, 5597, 5, 101, 0, 0, 5597, 5598, 5, 67, 0, 0,
		5598, 5605, 5, 733, 0, 0, 5599, 5600, 5, 151, 0, 0, 5600, 5601, 5, 86,
		0, 0, 5601, 5605, 5, 733, 0, 0, 5602, 5603, 5, 719, 0, 0, 5603, 5605, 5,
		720, 0, 0, 5604, 5511, 1, 0, 0, 0, 5604, 5515, 1, 0, 0, 0, 5604, 5519,
		1, 0, 0, 0, 5604, 5529, 1, 0, 0, 0, 5604, 5530, 1, 0, 0, 0, 5604, 5534,
		1, 0, 0, 0, 5604, 5535, 1, 0, 0, 0, 5604, 5536, 1, 0, 0, 0, 5604, 5537,
		1, 0, 0, 0, 5604, 5539, 1, 0, 0, 0, 5604, 5540, 1, 0, 0, 0, 5604, 5541,
		1, 0, 0, 0, 5604, 5543, 1, 0, 0, 0, 5604, 5544, 1, 0, 0, 0, 5604, 5545,
		1, 0, 0, 0, 5604, 5546, 1, 0, 0, 0, 5604, 5547, 1, 0, 0, 0, 5604, 5549,
		1, 0, 0, 0, 5604, 5550, 1, 0, 0, 0, 5604, 5552, 1, 0, 0, 0, 5604, 5553,
		1, 0, 0, 0, 5604, 5554, 1, 0, 0, 0, 5604, 5555, 1, 0, 0, 0, 5604, 5556,
		1, 0, 0, 0, 5604, 5557, 1, 0, 0, 0, 5604, 5558, 1, 0, 0, 0, 5604, 5559,
		1, 0, 0, 0, 5604, 5560, 1, 0, 0, 0, 5604, 5561, 1, 0, 0, 0, 5604, 5562,
		1, 0, 0, 0, 5604, 5563, 1, 0, 0, 0, 5604, 5564, 1, 0, 0, 0, 5604, 5565,
		1, 0, 0, 0, 5604, 5566, 1, 0, 0, 0, 5604, 5567, 1, 0, 0, 0, 5604, 5568,
		1, 0, 0, 0, 5604, 5569, 1, 0, 0, 0, 5604, 5570, 1, 0, 0, 0, 5604, 5571,
		1, 0, 0, 0, 5604, 5572, 1, 0, 0, 0, 5604, 5573, 1, 0, 0, 0, 5604, 5574,
		1, 0, 0, 0, 5604, 5575, 1, 0, 0, 0, 5604, 5576, 1, 0, 0, 0, 5604, 5577,
		1, 0, 0, 0, 5604, 5578, 1, 0, 0, 0, 5604, 5579, 1, 0, 0, 0, 5604, 5580,
		1, 0, 0, 0, 5604, 5581, 1, 0, 0, 0, 5604, 5582, 1, 0, 0, 0, 5604, 5583,
		1, 0, 0, 0, 5604, 5584, 1, 0, 0, 0, 5604, 5585, 1, 0, 0, 0, 5604, 5586,
		1, 0, 0, 0, 5604, 5587, 1, 0, 0, 0, 5604, 5588, 1, 0, 0, 0, 5604, 5589,
		1, 0, 0, 0, 5604, 5590, 1, 0, 0, 0, 5604, 5591, 1, 0, 0, 0, 5604, 5592,
		1, 0, 0, 0, 5604, 5593, 1, 0, 0, 0, 5604, 5594, 1, 0, 0, 0, 5604, 5595,
		1, 0, 0, 0, 5604, 5596, 1, 0, 0, 0, 5604, 5599, 1, 0, 0, 0, 5604, 5602,
		1, 0, 0, 0, 5605, 467, 1, 0, 0, 0, 5606, 5623, 5, 1116, 0, 0, 5607, 5608,
		5, 1116, 0, 0, 5608, 5609, 5, 1131, 0, 0, 5609, 5623, 5, 1116, 0, 0, 5610,
		5611, 3, 586, 293, 0, 5611, 5612, 5, 1131, 0, 0, 5612, 5613, 5, 1116, 0,
		0, 5613, 5623, 1, 0, 0, 0, 5614, 5615, 3, 586, 293, 0, 5615, 5616, 5, 1131,
		0, 0, 5616, 5617, 3, 586, 293, 0, 5617, 5623, 1, 0, 0, 0, 5618, 5619, 3,
		586, 293, 0, 5619, 5620, 3, 590, 295, 0, 5620, 5623, 1, 0, 0, 0, 5621,
		5623, 3, 586, 293, 0, 5622, 5606, 1, 0, 0, 0, 5622, 5607, 1, 0, 0, 0, 5622,
		5610, 1, 0, 0, 0, 5622, 5614, 1, 0, 0, 0, 5622, 5618, 1, 0, 0, 0, 5622,
		5621, 1, 0, 0, 0, 5623, 469, 1, 0, 0, 0, 5624, 5625, 3, 566, 283, 0, 5625,
		5626, 5, 174, 0, 0, 5626, 5627, 3, 566, 283, 0, 5627, 471, 1, 0, 0, 0,
		5628, 5630, 5, 8, 0, 0, 5629, 5631, 7, 72, 0, 0, 5630, 5629, 1, 0, 0, 0,
		5630, 5631, 1, 0, 0, 0, 5631, 5632, 1, 0, 0, 0, 5632, 5633, 7, 54, 0, 0,
		5633, 5651, 3, 622, 311, 0, 5634, 5635, 5, 183, 0, 0, 5635, 5636, 5, 75,
		0, 0, 5636, 5637, 5, 117, 0, 0, 5637, 5642, 3, 558, 279, 0, 5638, 5639,
		5, 1134, 0, 0, 5639, 5641, 3, 558, 279, 0, 5640, 5638, 1, 0, 0, 0, 5641,
		5644, 1, 0, 0, 0, 5642, 5640, 1, 0, 0, 0, 5642, 5643, 1, 0, 0, 0, 5643,
		5649, 1, 0, 0, 0, 5644, 5642, 1, 0, 0, 0, 5645, 5646, 5, 191, 0, 0, 5646,
		5647, 3, 592, 296, 0, 5647, 5648, 5, 17, 0, 0, 5648, 5650, 1, 0, 0, 0,
		5649, 5645, 1, 0, 0, 0, 5649, 5650, 1, 0, 0, 0, 5650, 5652, 1, 0, 0, 0,
		5651, 5634, 1, 0, 0, 0, 5651, 5652, 1, 0, 0, 0, 5652, 5664, 1, 0, 0, 0,
		5653, 5654, 5, 50, 0, 0, 5654, 5655, 5, 75, 0, 0, 5655, 5656, 5, 117, 0,
		0, 5656, 5661, 3, 558, 279, 0, 5657, 5658, 5, 1134, 0, 0, 5658, 5660, 3,
		558, 279, 0, 5659, 5657, 1, 0, 0, 0, 5660, 5663, 1, 0, 0, 0, 5661, 5659,
		1, 0, 0, 0, 5661, 5662, 1, 0, 0, 0, 5662, 5665, 1, 0, 0, 0, 5663, 5661,
		1, 0, 0, 0, 5664, 5653, 1, 0, 0, 0, 5664, 5665, 1, 0, 0, 0, 5665, 473,
		1, 0, 0, 0, 5666, 5667, 5, 25, 0, 0, 5667, 5668, 5, 171, 0, 0, 5668, 5672,
		3, 622, 311, 0, 5669, 5671, 3, 482, 241, 0, 5670, 5669, 1, 0, 0, 0, 5671,
		5674, 1, 0, 0, 0, 5672, 5670, 1, 0, 0, 0, 5672, 5673, 1, 0, 0, 0, 5673,
		475, 1, 0, 0, 0, 5674, 5672, 1, 0, 0, 0, 5675, 5676, 5, 355, 0, 0, 5676,
		5677, 5, 171, 0, 0, 5677, 5679, 3, 622, 311, 0, 5678, 5680, 7, 73, 0, 0,
		5679, 5678, 1, 0, 0, 0, 5679, 5680, 1, 0, 0, 0, 5680, 477, 1, 0, 0, 0,
		5681, 5683, 5, 118, 0, 0, 5682, 5684, 7, 72, 0, 0, 5683, 5682, 1, 0, 0,
		0, 5683, 5684, 1, 0, 0, 0, 5684, 5685, 1, 0, 0, 0, 5685, 5686, 7, 54, 0,
		0, 5686, 5687, 3, 622, 311, 0, 5687, 479, 1, 0, 0, 0, 5688, 5690, 5, 579,
		0, 0, 5689, 5691, 7, 72, 0, 0, 5690, 5689, 1, 0, 0, 0, 5690, 5691, 1, 0,
		0, 0, 5691, 5692, 1, 0, 0, 0, 5692, 5693, 5, 171, 0, 0, 5693, 5695, 3,
		622, 311, 0, 5694, 5696, 5, 567, 0, 0, 5695, 5694, 1, 0, 0, 0, 5695, 5696,
		1, 0, 0, 0, 5696, 5698, 1, 0, 0, 0, 5697, 5699, 5, 421, 0, 0, 5698, 5697,
		1, 0, 0, 0, 5698, 5699, 1, 0, 0, 0, 5699, 5701, 1, 0, 0, 0, 5700, 5702,
		5, 665, 0, 0, 5701, 5700, 1, 0, 0, 0, 5701, 5702, 1, 0, 0, 0, 5702, 481,
		1, 0, 0, 0, 5703, 5704, 5, 64, 0, 0, 5704, 5711, 5, 663, 0, 0, 5705, 5711,
		5, 567, 0, 0, 5706, 5711, 5, 424, 0, 0, 5707, 5711, 5, 503, 0, 0, 5708,
		5711, 5, 421, 0, 0, 5709, 5711, 5, 353, 0, 0, 5710, 5703, 1, 0, 0, 0, 5710,
		5705, 1, 0, 0, 0, 5710, 5706, 1, 0, 0, 0, 5710, 5707, 1, 0, 0, 0, 5710,
		5708, 1, 0, 0, 0, 5710, 5709, 1, 0, 0, 0, 5711, 483, 1, 0, 0, 0, 5712,
		5714, 5, 32, 0, 0, 5713, 5715, 5, 334, 0, 0, 5714, 5713, 1, 0, 0, 0, 5714,
		5715, 1, 0, 0, 0, 5715, 5716, 1, 0, 0, 0, 5716, 5718, 5, 436, 0, 0, 5717,
		5719, 3, 644, 322, 0, 5718, 5717, 1, 0, 0, 0, 5718, 5719, 1, 0, 0, 0, 5719,
		5720, 1, 0, 0, 0, 5720, 5721, 3, 586, 293, 0, 5721, 5722, 5, 593, 0, 0,
		5722, 5723, 7, 74, 0, 0, 5723, 5724, 5, 618, 0, 0, 5724, 5725, 5, 1147,
		0, 0, 5725, 485, 1, 0, 0, 0, 5726, 5727, 5, 455, 0, 0, 5727, 5728, 5, 553,
		0, 0, 5728, 5729, 3, 586, 293, 0, 5729, 5730, 5, 618, 0, 0, 5730, 5731,
		5, 1147, 0, 0, 5731, 487, 1, 0, 0, 0, 5732, 5733, 5, 660, 0, 0, 5733, 5734,
		5, 553, 0, 0, 5734, 5735, 3, 586, 293, 0, 5735, 489, 1, 0, 0, 0, 5736,
		5737, 5, 152, 0, 0, 5737, 5738, 3, 494, 247, 0, 5738, 5741, 7, 75, 0, 0,
		5739, 5742, 3, 690, 345, 0, 5740, 5742, 5, 117, 0, 0, 5741, 5739, 1, 0,
		0, 0, 5741, 5740, 1, 0, 0, 0, 5742, 5752, 1, 0, 0, 0, 5743, 5744, 5, 1134,
		0, 0, 5744, 5745, 3, 494, 247, 0, 5745, 5748, 7, 75, 0, 0, 5746, 5749,
		3, 690, 345, 0, 5747, 5749, 5, 117, 0, 0, 5748, 5746, 1, 0, 0, 0, 5748,
		5747, 1, 0, 0, 0, 5749, 5751, 1, 0, 0, 0, 5750, 5743, 1, 0, 0, 0, 5751,
		5754, 1, 0, 0, 0, 5752, 5750, 1, 0, 0, 0, 5752, 5753, 1, 0, 0, 0, 5753,
		5789, 1, 0, 0, 0, 5754, 5752, 1, 0, 0, 0, 5755, 5756, 5, 152, 0, 0, 5756,
		5759, 3, 60, 30, 0, 5757, 5760, 3, 570, 285, 0, 5758, 5760, 5, 41, 0, 0,
		5759, 5757, 1, 0, 0, 0, 5759, 5758, 1, 0, 0, 0, 5760, 5789, 1, 0, 0, 0,
		5761, 5762, 5, 152, 0, 0, 5762, 5769, 5, 516, 0, 0, 5763, 5766, 3, 570,
		285, 0, 5764, 5765, 5, 26, 0, 0, 5765, 5767, 3, 572, 286, 0, 5766, 5764,
		1, 0, 0, 0, 5766, 5767, 1, 0, 0, 0, 5767, 5770, 1, 0, 0, 0, 5768, 5770,
		5, 41, 0, 0, 5769, 5763, 1, 0, 0, 0, 5769, 5768, 1, 0, 0, 0, 5770, 5789,
		1, 0, 0, 0, 5771, 5789, 3, 446, 223, 0, 5772, 5789, 3, 320, 160, 0, 5773,
		5789, 3, 318, 159, 0, 5774, 5775, 5, 152, 0, 0, 5775, 5776, 3, 552, 276,
		0, 5776, 5777, 7, 75, 0, 0, 5777, 5785, 3, 690, 345, 0, 5778, 5779, 5,
		1134, 0, 0, 5779, 5780, 3, 552, 276, 0, 5780, 5781, 7, 75, 0, 0, 5781,
		5782, 3, 690, 345, 0, 5782, 5784, 1, 0, 0, 0, 5783, 5778, 1, 0, 0, 0, 5784,
		5787, 1, 0, 0, 0, 5785, 5783, 1, 0, 0, 0, 5785, 5786, 1, 0, 0, 0, 5786,
		5789, 1, 0, 0, 0, 5787, 5785, 1, 0, 0, 0, 5788, 5736, 1, 0, 0, 0, 5788,
		5755, 1, 0, 0, 0, 5788, 5761, 1, 0, 0, 0, 5788, 5771, 1, 0, 0, 0, 5788,
		5772, 1, 0, 0, 0, 5788, 5773, 1, 0, 0, 0, 5788, 5774, 1, 0, 0, 0, 5789,
		491, 1, 0, 0, 0, 5790, 5791, 5, 154, 0, 0, 5791, 5792, 7, 56, 0, 0, 5792,
		5944, 5, 475, 0, 0, 5793, 5794, 5, 154, 0, 0, 5794, 5795, 7, 76, 0, 0,
		5795, 5798, 5, 415, 0, 0, 5796, 5797, 5, 79, 0, 0, 5797, 5799, 5, 1147,
		0, 0, 5798, 5796, 1, 0, 0, 0, 5798, 5799, 1, 0, 0, 0, 5799, 5802, 1, 0,
		0, 0, 5800, 5801, 5, 67, 0, 0, 5801, 5803, 3, 592, 296, 0, 5802, 5800,
		1, 0, 0, 0, 5802, 5803, 1, 0, 0, 0, 5803, 5811, 1, 0, 0, 0, 5804, 5808,
		5, 98, 0, 0, 5805, 5806, 3, 592, 296, 0, 5806, 5807, 5, 1134, 0, 0, 5807,
		5809, 1, 0, 0, 0, 5808, 5805, 1, 0, 0, 0, 5808, 5809, 1, 0, 0, 0, 5809,
		5810, 1, 0, 0, 0, 5810, 5812, 3, 592, 296, 0, 5811, 5804, 1, 0, 0, 0, 5811,
		5812, 1, 0, 0, 0, 5812, 5944, 1, 0, 0, 0, 5813, 5814, 5, 154, 0, 0, 5814,
		5816, 3, 496, 248, 0, 5815, 5817, 3, 498, 249, 0, 5816, 5815, 1, 0, 0,
		0, 5816, 5817, 1, 0, 0, 0, 5817, 5944, 1, 0, 0, 0, 5818, 5820, 5, 154,
		0, 0, 5819, 5821, 5, 435, 0, 0, 5820, 5819, 1, 0, 0, 0, 5820, 5821, 1,
		0, 0, 0, 5821, 5822, 1, 0, 0, 0, 5822, 5823, 7, 41, 0, 0, 5823, 5824, 7,
		77, 0, 0, 5824, 5827, 3, 554, 277, 0, 5825, 5826, 7, 77, 0, 0, 5826, 5828,
		3, 586, 293, 0, 5827, 5825, 1, 0, 0, 0, 5827, 5828, 1, 0, 0, 0, 5828, 5830,
		1, 0, 0, 0, 5829, 5831, 3, 498, 249, 0, 5830, 5829, 1, 0, 0, 0, 5830, 5831,
		1, 0, 0, 0, 5831, 5944, 1, 0, 0, 0, 5832, 5833, 5, 154, 0, 0, 5833, 5834,
		5, 32, 0, 0, 5834, 5836, 7, 0, 0, 0, 5835, 5837, 3, 644, 322, 0, 5836,
		5835, 1, 0, 0, 0, 5836, 5837, 1, 0, 0, 0, 5837, 5838, 1, 0, 0, 0, 5838,
		5944, 3, 586, 293, 0, 5839, 5840, 5, 154, 0, 0, 5840, 5841, 5, 32, 0, 0,
		5841, 5842, 7, 78, 0, 0, 5842, 5944, 3, 552, 276, 0, 5843, 5844, 5, 154,
		0, 0, 5844, 5845, 5, 32, 0, 0, 5845, 5846, 5, 664, 0, 0, 5846, 5944, 3,
		566, 283, 0, 5847, 5848, 5, 154, 0, 0, 5848, 5849, 5, 408, 0, 0, 5849,
		5850, 3, 574, 287, 0, 5850, 5851, 7, 79, 0, 0, 5851, 5944, 1, 0, 0, 0,
		5852, 5853, 5, 154, 0, 0, 5853, 5944, 3, 500, 250, 0, 5854, 5855, 5, 154,
		0, 0, 5855, 5863, 7, 80, 0, 0, 5856, 5860, 5, 98, 0, 0, 5857, 5858, 3,
		592, 296, 0, 5858, 5859, 5, 1134, 0, 0, 5859, 5861, 1, 0, 0, 0, 5860, 5857,
		1, 0, 0, 0, 5860, 5861, 1, 0, 0, 0, 5861, 5862, 1, 0, 0, 0, 5862, 5864,
		3, 592, 296, 0, 5863, 5856, 1, 0, 0, 0, 5863, 5864, 1, 0, 0, 0, 5864, 5944,
		1, 0, 0, 0, 5865, 5866, 5, 154, 0, 0, 5866, 5867, 5, 289, 0, 0, 5867, 5868,
		5, 1132, 0, 0, 5868, 5869, 5, 1116, 0, 0, 5869, 5870, 5, 1133, 0, 0, 5870,
		5944, 7, 80, 0, 0, 5871, 5872, 5, 154, 0, 0, 5872, 5875, 3, 502, 251, 0,
		5873, 5874, 7, 77, 0, 0, 5874, 5876, 3, 586, 293, 0, 5875, 5873, 1, 0,
		0, 0, 5875, 5876, 1, 0, 0, 0, 5876, 5878, 1, 0, 0, 0, 5877, 5879, 3, 498,
		249, 0, 5878, 5877, 1, 0, 0, 0, 5878, 5879, 1, 0, 0, 0, 5879, 5944, 1,
		0, 0, 0, 5880, 5881, 5, 154, 0, 0, 5881, 5882, 7, 81, 0, 0, 5882, 5883,
		5, 363, 0, 0, 5883, 5944, 3, 552, 276, 0, 5884, 5885, 5, 154, 0, 0, 5885,
		5888, 5, 439, 0, 0, 5886, 5887, 5, 64, 0, 0, 5887, 5889, 3, 566, 283, 0,
		5888, 5886, 1, 0, 0, 0, 5888, 5889, 1, 0, 0, 0, 5889, 5944, 1, 0, 0, 0,
		5890, 5891, 5, 154, 0, 0, 5891, 5892, 7, 82, 0, 0, 5892, 5893, 7, 77, 0,
		0, 5893, 5896, 3, 554, 277, 0, 5894, 5895, 7, 77, 0, 0, 5895, 5897, 3,
		586, 293, 0, 5896, 5894, 1, 0, 0, 0, 5896, 5897, 1, 0, 0, 0, 5897, 5900,
		1, 0, 0, 0, 5898, 5899, 5, 189, 0, 0, 5899, 5901, 3, 690, 345, 0, 5900,
		5898, 1, 0, 0, 0, 5900, 5901, 1, 0, 0, 0, 5901, 5944, 1, 0, 0, 0, 5902,
		5903, 5, 154, 0, 0, 5903, 5904, 5, 538, 0, 0, 5904, 5907, 5, 741, 0, 0,
		5905, 5906, 7, 77, 0, 0, 5906, 5908, 3, 586, 293, 0, 5907, 5905, 1, 0,
		0, 0, 5907, 5908, 1, 0, 0, 0, 5908, 5910, 1, 0, 0, 0, 5909, 5911, 3, 498,
		249, 0, 5910, 5909, 1, 0, 0, 0, 5910, 5911, 1, 0, 0, 0, 5911, 5944, 1,
		0, 0, 0, 5912, 5913, 5, 154, 0, 0, 5913, 5914, 5, 563, 0, 0, 5914, 5919,
		3, 504, 252, 0, 5915, 5916, 5, 1134, 0, 0, 5916, 5918, 3, 504, 252, 0,
		5917, 5915, 1, 0, 0, 0, 5918, 5921, 1, 0, 0, 0, 5919, 5917, 1, 0, 0, 0,
		5919, 5920, 1, 0, 0, 0, 5920, 5925, 1, 0, 0, 0, 5921, 5919, 1, 0, 0, 0,
		5922, 5923, 5, 64, 0, 0, 5923, 5924, 5, 566, 0, 0, 5924, 5926, 3, 592,
		296, 0, 5925, 5922, 1, 0, 0, 0, 5925, 5926, 1, 0, 0, 0, 5926, 5927, 1,
		0, 0, 0, 5927, 5931, 5, 98, 0, 0, 5928, 5929, 3, 592, 296, 0, 5929, 5930,
		5, 1134, 0, 0, 5930, 5932, 1, 0, 0, 0, 5931, 5928, 1, 0, 0, 0, 5931, 5932,
		1, 0, 0, 0, 5932, 5933, 1, 0, 0, 0, 5933, 5934, 3, 592, 296, 0, 5934, 5944,
		1, 0, 0, 0, 5935, 5936, 5, 154, 0, 0, 5936, 5937, 5, 613, 0, 0, 5937, 5941,
		5, 633, 0, 0, 5938, 5939, 5, 64, 0, 0, 5939, 5940, 5, 354, 0, 0, 5940,
		5942, 5, 1147, 0, 0, 5941, 5938, 1, 0, 0, 0, 5941, 5942, 1, 0, 0, 0, 5942,
		5944, 1, 0, 0, 0, 5943, 5790, 1, 0, 0, 0, 5943, 5793, 1, 0, 0, 0, 5943,
		5813, 1, 0, 0, 0, 5943, 5818, 1, 0, 0, 0, 5943, 5832, 1, 0, 0, 0, 5943,
		5839, 1, 0, 0, 0, 5943, 5843, 1, 0, 0, 0, 5943, 5847, 1, 0, 0, 0, 5943,
		5852, 1, 0, 0, 0, 5943, 5854, 1, 0, 0, 0, 5943, 5865, 1, 0, 0, 0, 5943,
		5871, 1, 0, 0, 0, 5943, 5880, 1, 0, 0, 0, 5943, 5884, 1, 0, 0, 0, 5943,
		5890, 1, 0, 0, 0, 5943, 5902, 1, 0, 0, 0, 5943, 5912, 1, 0, 0, 0, 5943,
		5935, 1, 0, 0, 0, 5944, 493, 1, 0, 0, 0, 5945, 5956, 5, 1158, 0, 0, 5946,
		5956, 5, 1159, 0, 0, 5947, 5948, 5, 1136, 0, 0, 5948, 5950, 5, 1136, 0,
		0, 5949, 5947, 1, 0, 0, 0, 5949, 5950, 1, 0, 0, 0, 5950, 5951, 1, 0, 0,
		0, 5951, 5953, 7, 83, 0, 0, 5952, 5949, 1, 0, 0, 0, 5952, 5953, 1, 0, 0,
		0, 5953, 5954, 1, 0, 0, 0, 5954, 5956, 3, 586, 293, 0, 5955, 5945, 1, 0,
		0, 0, 5955, 5946, 1, 0, 0, 0, 5955, 5952, 1, 0, 0, 0, 5956, 495, 1, 0,
		0, 0, 5957, 5958, 5, 24, 0, 0, 5958, 5971, 5, 152, 0, 0, 5959, 5971, 5,
		843, 0, 0, 5960, 5971, 5, 39, 0, 0, 5961, 5971, 5, 150, 0, 0, 5962, 5963,
		5, 436, 0, 0, 5963, 5971, 5, 633, 0, 0, 5964, 5965, 5, 130, 0, 0, 5965,
		5971, 5, 633, 0, 0, 5966, 5968, 7, 55, 0, 0, 5967, 5966, 1, 0, 0, 0, 5967,
		5968, 1, 0, 0, 0, 5968, 5969, 1, 0, 0, 0, 5969, 5971, 7, 84, 0, 0, 5970,
		5957, 1, 0, 0, 0, 5970, 5959, 1, 0, 0, 0, 5970, 5960, 1, 0, 0, 0, 5970,
		5961, 1, 0, 0, 0, 5970, 5962, 1, 0, 0, 0, 5970, 5964, 1, 0, 0, 0, 5970,
		5967, 1, 0, 0, 0, 5971, 497, 1, 0, 0, 0, 5972, 5973, 5, 97, 0, 0, 5973,
		5977, 5, 1147, 0, 0, 5974, 5975, 5, 189, 0, 0, 5975, 5977, 3, 690, 345,
		0, 5976, 5972, 1, 0, 0, 0, 5976, 5974, 1, 0, 0, 0, 5977, 499, 1, 0, 0,
		0, 5978, 5980, 5, 635, 0, 0, 5979, 5978, 1, 0, 0, 0, 5979, 5980, 1, 0,
		0, 0, 5980, 5981, 1, 0, 0, 0, 5981, 5996, 5, 409, 0, 0, 5982, 5983, 5,
		476, 0, 0, 5983, 5996, 5, 633, 0, 0, 5984, 5996, 5, 555, 0, 0, 5985, 5996,
		5, 724, 0, 0, 5986, 5988, 5, 435, 0, 0, 5987, 5986, 1, 0, 0, 0, 5987, 5988,
		1, 0, 0, 0, 5988, 5989, 1, 0, 0, 0, 5989, 5996, 5, 562, 0, 0, 5990, 5996,
		5, 564, 0, 0, 5991, 5992, 5, 613, 0, 0, 5992, 5996, 5, 446, 0, 0, 5993,
		5996, 5, 338, 0, 0, 5994, 5996, 5, 382, 0, 0, 5995, 5979, 1, 0, 0, 0, 5995,
		5982, 1, 0, 0, 0, 5995, 5984, 1, 0, 0, 0, 5995, 5985, 1, 0, 0, 0, 5995,
		5987, 1, 0, 0, 0, 5995, 5990, 1, 0, 0, 0, 5995, 5991, 1, 0, 0, 0, 5995,
		5993, 1, 0, 0, 0, 5995, 5994, 1, 0, 0, 0, 5996, 501, 1, 0, 0, 0, 5997,
		6006, 5, 415, 0, 0, 5998, 5999, 5, 171, 0, 0, 5999, 6006, 5, 633, 0, 0,
		6000, 6002, 5, 435, 0, 0, 6001, 6000, 1, 0, 0, 0, 6001, 6002, 1, 0, 0,
		0, 6002, 6003, 1, 0, 0, 0, 6003, 6006, 5, 741, 0, 0, 6004, 6006, 5, 654,
		0, 0, 6005, 5997, 1, 0, 0, 0, 6005, 5998, 1, 0, 0, 0, 6005, 6001, 1, 0,
		0, 0, 6005, 6004, 1, 0, 0, 0, 6006, 503, 1, 0, 0, 0, 6007, 6020, 5, 5,
		0, 0, 6008, 6009, 5, 346, 0, 0, 6009, 6020, 5, 460, 0, 0, 6010, 6011, 5,
		381, 0, 0, 6011, 6020, 5, 644, 0, 0, 6012, 6020, 5, 384, 0, 0, 6013, 6020,
		5, 462, 0, 0, 6014, 6020, 5, 791, 0, 0, 6015, 6016, 5, 543, 0, 0, 6016,
		6020, 5, 425, 0, 0, 6017, 6020, 5, 620, 0, 0, 6018, 6020, 5, 643, 0, 0,
		6019, 6007, 1, 0, 0, 0, 6019, 6008, 1, 0, 0, 0, 6019, 6010, 1, 0, 0, 0,
		6019, 6012, 1, 0, 0, 0, 6019, 6013, 1, 0, 0, 0, 6019, 6014, 1, 0, 0, 0,
		6019, 6015, 1, 0, 0, 0, 6019, 6017, 1, 0, 0, 0, 6019, 6018, 1, 0, 0, 0,
		6020, 505, 1, 0, 0, 0, 6021, 6022, 5, 344, 0, 0, 6022, 6023, 5, 1147, 0,
		0, 6023, 507, 1, 0, 0, 0, 6024, 6025, 5, 350, 0, 0, 6025, 6026, 5, 80,
		0, 0, 6026, 6031, 3, 520, 260, 0, 6027, 6028, 5, 1134, 0, 0, 6028, 6030,
		3, 520, 260, 0, 6029, 6027, 1, 0, 0, 0, 6030, 6033, 1, 0, 0, 0, 6031, 6029,
		1, 0, 0, 0, 6031, 6032, 1, 0, 0, 0, 6032, 6041, 1, 0, 0, 0, 6033, 6031,
		1, 0, 0, 0, 6034, 6035, 5, 128, 0, 0, 6035, 6038, 5, 1132, 0, 0, 6036,
		6039, 3, 618, 309, 0, 6037, 6039, 5, 5, 0, 0, 6038, 6036, 1, 0, 0, 0, 6038,
		6037, 1, 0, 0, 0, 6039, 6040, 1, 0, 0, 0, 6040, 6042, 5, 1133, 0, 0, 6041,
		6034, 1, 0, 0, 0, 6041, 6042, 1, 0, 0, 0, 6042, 6043, 1, 0, 0, 0, 6043,
		6044, 5, 79, 0, 0, 6044, 6045, 3, 586, 293, 0, 6045, 509, 1, 0, 0, 0, 6046,
		6048, 5, 431, 0, 0, 6047, 6049, 7, 72, 0, 0, 6048, 6047, 1, 0, 0, 0, 6048,
		6049, 1, 0, 0, 0, 6049, 6050, 1, 0, 0, 0, 6050, 6055, 3, 522, 261, 0, 6051,
		6052, 5, 1134, 0, 0, 6052, 6054, 3, 522, 261, 0, 6053, 6051, 1, 0, 0, 0,
		6054, 6057, 1, 0, 0, 0, 6055, 6053, 1, 0, 0, 0, 6055, 6056, 1, 0, 0, 0,
		6056, 511, 1, 0, 0, 0, 6057, 6055, 1, 0, 0, 0, 6058, 6060, 5, 92, 0, 0,
		6059, 6061, 7, 85, 0, 0, 6060, 6059, 1, 0, 0, 0, 6060, 6061, 1, 0, 0, 0,
		6061, 6062, 1, 0, 0, 0, 6062, 6063, 3, 690, 345, 0, 6063, 513, 1, 0, 0,
		0, 6064, 6065, 5, 101, 0, 0, 6065, 6066, 5, 80, 0, 0, 6066, 6067, 5, 86,
		0, 0, 6067, 6068, 5, 350, 0, 0, 6068, 6073, 3, 526, 263, 0, 6069, 6070,
		5, 1134, 0, 0, 6070, 6072, 3, 526, 263, 0, 6071, 6069, 1, 0, 0, 0, 6072,
		6075, 1, 0, 0, 0, 6073, 6071, 1, 0, 0, 0, 6073, 6074, 1, 0, 0, 0, 6074,
		515, 1, 0, 0, 0, 6075, 6073, 1, 0, 0, 0, 6076, 6077, 5, 588, 0, 0, 6077,
		6078, 5, 566, 0, 0, 6078, 6079, 5, 350, 0, 0, 6079, 517, 1, 0, 0, 0, 6080,
		6081, 5, 738, 0, 0, 6081, 519, 1, 0, 0, 0, 6082, 6090, 3, 554, 277, 0,
		6083, 6085, 7, 20, 0, 0, 6084, 6083, 1, 0, 0, 0, 6084, 6085, 1, 0, 0, 0,
		6085, 6086, 1, 0, 0, 0, 6086, 6087, 5, 1132, 0, 0, 6087, 6088, 3, 618,
		309, 0, 6088, 6089, 5, 1133, 0, 0, 6089, 6091, 1, 0, 0, 0, 6090, 6084,
		1, 0, 0, 0, 6090, 6091, 1, 0, 0, 0, 6091, 521, 1, 0, 0, 0, 6092, 6111,
		5, 393, 0, 0, 6093, 6111, 5, 446, 0, 0, 6094, 6096, 7, 86, 0, 0, 6095,
		6094, 1, 0, 0, 0, 6095, 6096, 1, 0, 0, 0, 6096, 6097, 1, 0, 0, 0, 6097,
		6111, 5, 475, 0, 0, 6098, 6111, 5, 539, 0, 0, 6099, 6111, 5, 724, 0, 0,
		6100, 6101, 5, 566, 0, 0, 6101, 6111, 5, 350, 0, 0, 6102, 6111, 5, 633,
		0, 0, 6103, 6111, 5, 666, 0, 0, 6104, 6108, 5, 741, 0, 0, 6105, 6106, 5,
		191, 0, 0, 6106, 6107, 5, 133, 0, 0, 6107, 6109, 5, 102, 0, 0, 6108, 6105,
		1, 0, 0, 0, 6108, 6109, 1, 0, 0, 0, 6109, 6111, 1, 0, 0, 0, 6110, 6092,
		1, 0, 0, 0, 6110, 6093, 1, 0, 0, 0, 6110, 6095, 1, 0, 0, 0, 6110, 6098,
		1, 0, 0, 0, 6110, 6099, 1, 0, 0, 0, 6110, 6100, 1, 0, 0, 0, 6110, 6102,
		1, 0, 0, 0, 6110, 6103, 1, 0, 0, 0, 6110, 6104, 1, 0, 0, 0, 6111, 6125,
		1, 0, 0, 0, 6112, 6113, 5, 573, 0, 0, 6113, 6115, 5, 475, 0, 0, 6114, 6116,
		3, 358, 179, 0, 6115, 6114, 1, 0, 0, 0, 6115, 6116, 1, 0, 0, 0, 6116, 6125,
		1, 0, 0, 0, 6117, 6119, 7, 54, 0, 0, 6118, 6120, 3, 622, 311, 0, 6119,
		6118, 1, 0, 0, 0, 6119, 6120, 1, 0, 0, 0, 6120, 6122, 1, 0, 0, 0, 6121,
		6123, 3, 524, 262, 0, 6122, 6121, 1, 0, 0, 0, 6122, 6123, 1, 0, 0, 0, 6123,
		6125, 1, 0, 0, 0, 6124, 6110, 1, 0, 0, 0, 6124, 6112, 1, 0, 0, 0, 6124,
		6117, 1, 0, 0, 0, 6125, 523, 1, 0, 0, 0, 6126, 6127, 5, 191, 0, 0, 6127,
		6128, 5, 133, 0, 0, 6128, 6132, 5, 102, 0, 0, 6129, 6130, 5, 64, 0, 0,
		6130, 6132, 5, 420, 0, 0, 6131, 6126, 1, 0, 0, 0, 6131, 6129, 1, 0, 0,
		0, 6132, 525, 1, 0, 0, 0, 6133, 6141, 3, 554, 277, 0, 6134, 6135, 5, 128,
		0, 0, 6135, 6138, 5, 1132, 0, 0, 6136, 6139, 3, 618, 309, 0, 6137, 6139,
		5, 5, 0, 0, 6138, 6136, 1, 0, 0, 0, 6138, 6137, 1, 0, 0, 0, 6139, 6140,
		1, 0, 0, 0, 6140, 6142, 5, 1133, 0, 0, 6141, 6134, 1, 0, 0, 0, 6141, 6142,
		1, 0, 0, 0, 6142, 6150, 1, 0, 0, 0, 6143, 6145, 7, 20, 0, 0, 6144, 6143,
		1, 0, 0, 0, 6144, 6145, 1, 0, 0, 0, 6145, 6146, 1, 0, 0, 0, 6146, 6147,
		5, 1132, 0, 0, 6147, 6148, 3, 618, 309, 0, 6148, 6149, 5, 1133, 0, 0, 6149,
		6151, 1, 0, 0, 0, 6150, 6144, 1, 0, 0, 0, 6150, 6151, 1, 0, 0, 0, 6151,
		6154, 1, 0, 0, 0, 6152, 6153, 5, 77, 0, 0, 6153, 6155, 5, 469, 0, 0, 6154,
		6152, 1, 0, 0, 0, 6154, 6155, 1, 0, 0, 0, 6155, 527, 1, 0, 0, 0, 6156,
		6157, 7, 87, 0, 0, 6157, 6160, 3, 554, 277, 0, 6158, 6161, 3, 586, 293,
		0, 6159, 6161, 5, 1147, 0, 0, 6160, 6158, 1, 0, 0, 0, 6160, 6159, 1, 0,
		0, 0, 6160, 6161, 1, 0, 0, 0, 6161, 529, 1, 0, 0, 0, 6162, 6166, 7, 87,
		0, 0, 6163, 6164, 7, 88, 0, 0, 6164, 6165, 5, 1123, 0, 0, 6165, 6167, 7,
		89, 0, 0, 6166, 6163, 1, 0, 0, 0, 6166, 6167, 1, 0, 0, 0, 6167, 6168, 1,
		0, 0, 0, 6168, 6169, 3, 550, 275, 0, 6169, 531, 1, 0, 0, 0, 6170, 6171,
		5, 443, 0, 0, 6171, 6172, 5, 1147, 0, 0, 6172, 533, 1, 0, 0, 0, 6173, 6174,
		5, 185, 0, 0, 6174, 6175, 3, 586, 293, 0, 6175, 535, 1, 0, 0, 0, 6176,
		6184, 5, 155, 0, 0, 6177, 6179, 5, 161, 0, 0, 6178, 6180, 5, 668, 0, 0,
		6179, 6178, 1, 0, 0, 0, 6179, 6180, 1, 0, 0, 0, 6180, 6181, 1, 0, 0, 0,
		6181, 6185, 3, 596, 298, 0, 6182, 6185, 5, 1155, 0, 0, 6183, 6185, 5, 1156,
		0, 0, 6184, 6177, 1, 0, 0, 0, 6184, 6182, 1, 0, 0, 0, 6184, 6183, 1, 0,
		0, 0, 6185, 6195, 1, 0, 0, 0, 6186, 6187, 5, 152, 0, 0, 6187, 6192, 3,
		540, 270, 0, 6188, 6189, 5, 1134, 0, 0, 6189, 6191, 3, 540, 270, 0, 6190,
		6188, 1, 0, 0, 0, 6191, 6194, 1, 0, 0, 0, 6192, 6190, 1, 0, 0, 0, 6192,
		6193, 1, 0, 0, 0, 6193, 6196, 1, 0, 0, 0, 6194, 6192, 1, 0, 0, 0, 6195,
		6186, 1, 0, 0, 0, 6195, 6196, 1, 0, 0, 0, 6196, 537, 1, 0, 0, 0, 6197,
		6205, 5, 142, 0, 0, 6198, 6200, 5, 161, 0, 0, 6199, 6201, 5, 668, 0, 0,
		6200, 6199, 1, 0, 0, 0, 6200, 6201, 1, 0, 0, 0, 6201, 6202, 1, 0, 0, 0,
		6202, 6206, 3, 596, 298, 0, 6203, 6206, 5, 1155, 0, 0, 6204, 6206, 5, 1156,
		0, 0, 6205, 6198, 1, 0, 0, 0, 6205, 6203, 1, 0, 0, 0, 6205, 6204, 1, 0,
		0, 0, 6205, 6206, 1, 0, 0, 0, 6206, 6216, 1, 0, 0, 0, 6207, 6208, 5, 152,
		0, 0, 6208, 6213, 3, 540, 270, 0, 6209, 6210, 5, 1134, 0, 0, 6210, 6212,
		3, 540, 270, 0, 6211, 6209, 1, 0, 0, 0, 6212, 6215, 1, 0, 0, 0, 6213, 6211,
		1, 0, 0, 0, 6213, 6214, 1, 0, 0, 0, 6214, 6217, 1, 0, 0, 0, 6215, 6213,
		1, 0, 0, 0, 6216, 6207, 1, 0, 0, 0, 6216, 6217, 1, 0, 0, 0, 6217, 539,
		1, 0, 0, 0, 6218, 6219, 7, 90, 0, 0, 6219, 6224, 5, 1123, 0, 0, 6220, 6225,
		3, 596, 298, 0, 6221, 6225, 5, 1148, 0, 0, 6222, 6225, 3, 568, 284, 0,
		6223, 6225, 3, 588, 294, 0, 6224, 6220, 1, 0, 0, 0, 6224, 6221, 1, 0, 0,
		0, 6224, 6222, 1, 0, 0, 0, 6224, 6223, 1, 0, 0, 0, 6225, 541, 1, 0, 0,
		0, 6226, 6228, 5, 191, 0, 0, 6227, 6229, 5, 570, 0, 0, 6228, 6227, 1, 0,
		0, 0, 6228, 6229, 1, 0, 0, 0, 6229, 6230, 1, 0, 0, 0, 6230, 6235, 3, 50,
		25, 0, 6231, 6232, 5, 1134, 0, 0, 6232, 6234, 3, 50, 25, 0, 6233, 6231,
		1, 0, 0, 0, 6234, 6237, 1, 0, 0, 0, 6235, 6233, 1, 0, 0, 0, 6235, 6236,
		1, 0, 0, 0, 6236, 543, 1, 0, 0, 0, 6237, 6235, 1, 0, 0, 0, 6238, 6239,
		5, 171, 0, 0, 6239, 6241, 3, 554, 277, 0, 6240, 6242, 3, 230, 115, 0, 6241,
		6240, 1, 0, 0, 0, 6241, 6242, 1, 0, 0, 0, 6242, 6244, 1, 0, 0, 0, 6243,
		6245, 3, 296, 148, 0, 6244, 6243, 1, 0, 0, 0, 6244, 6245, 1, 0, 0, 0, 6245,
		545, 1, 0, 0, 0, 6246, 6248, 5, 70, 0, 0, 6247, 6249, 7, 91, 0, 0, 6248,
		6247, 1, 0, 0, 0, 6248, 6249, 1, 0, 0, 0, 6249, 6250, 1, 0, 0, 0, 6250,
		6282, 5, 47, 0, 0, 6251, 6252, 3, 494, 247, 0, 6252, 6253, 5, 1123, 0,
		0, 6253, 6261, 7, 92, 0, 0, 6254, 6255, 5, 1134, 0, 0, 6255, 6256, 3, 494,
		247, 0, 6256, 6257, 5, 1123, 0, 0, 6257, 6258, 7, 92, 0, 0, 6258, 6260,
		1, 0, 0, 0, 6259, 6254, 1, 0, 0, 0, 6260, 6263, 1, 0, 0, 0, 6261, 6259,
		1, 0, 0, 0, 6261, 6262, 1, 0, 0, 0, 6262, 6283, 1, 0, 0, 0, 6263, 6261,
		1, 0, 0, 0, 6264, 6267, 5, 28, 0, 0, 6265, 6268, 3, 592, 296, 0, 6266,
		6268, 3, 494, 247, 0, 6267, 6265, 1, 0, 0, 0, 6267, 6266, 1, 0, 0, 0, 6268,
		6269, 1, 0, 0, 0, 6269, 6270, 3, 494, 247, 0, 6270, 6271, 5, 1123, 0, 0,
		6271, 6279, 3, 548, 274, 0, 6272, 6273, 5, 1134, 0, 0, 6273, 6274, 3, 494,
		247, 0, 6274, 6275, 5, 1123, 0, 0, 6275, 6276, 3, 548, 274, 0, 6276, 6278,
		1, 0, 0, 0, 6277, 6272, 1, 0, 0, 0, 6278, 6281, 1, 0, 0, 0, 6279, 6277,
		1, 0, 0, 0, 6279, 6280, 1, 0, 0, 0, 6280, 6283, 1, 0, 0, 0, 6281, 6279,
		1, 0, 0, 0, 6282, 6251, 1, 0, 0, 0, 6282, 6264, 1, 0, 0, 0, 6283, 547,
		1, 0, 0, 0, 6284, 6285, 7, 93, 0, 0, 6285, 549, 1, 0, 0, 0, 6286, 6292,
		3, 200, 100, 0, 6287, 6292, 3, 186, 93, 0, 6288, 6292, 3, 192, 96, 0, 6289,
		6292, 3, 198, 99, 0, 6290, 6292, 3, 202, 101, 0, 6291, 6286, 1, 0, 0, 0,
		6291, 6287, 1, 0, 0, 0, 6291, 6288, 1, 0, 0, 0, 6291, 6289, 1, 0, 0, 0,
		6291, 6290, 1, 0, 0, 0, 6292, 6297, 1, 0, 0, 0, 6293, 6294, 5, 64, 0, 0,
		6294, 6295, 5, 375, 0, 0, 6295, 6297, 3, 586, 293, 0, 6296, 6291, 1, 0,
		0, 0, 6296, 6293, 1, 0, 0, 0, 6297, 551, 1, 0, 0, 0, 6298, 6302, 3, 586,
		293, 0, 6299, 6303, 5, 1154, 0, 0, 6300, 6301, 5, 1131, 0, 0, 6301, 6303,
		3, 586, 293, 0, 6302, 6299, 1, 0, 0, 0, 6302, 6300, 1, 0, 0, 0, 6302, 6303,
		1, 0, 0, 0, 6303, 553, 1, 0, 0, 0, 6304, 6305, 3, 552, 276, 0, 6305, 555,
		1, 0, 0, 0, 6306, 6309, 3, 566, 283, 0, 6307, 6309, 3, 586, 293, 0, 6308,
		6306, 1, 0, 0, 0, 6308, 6307, 1, 0, 0, 0, 6309, 557, 1, 0, 0, 0, 6310,
		6315, 3, 586, 293, 0, 6311, 6313, 3, 590, 295, 0, 6312, 6314, 3, 590, 295,
		0, 6313, 6312, 1, 0, 0, 0, 6313, 6314, 1, 0, 0, 0, 6314, 6316, 1, 0, 0,
		0, 6315, 6311, 1, 0, 0, 0, 6315, 6316, 1, 0, 0, 0, 6316, 6325, 1, 0, 0,
		0, 6317, 6319, 9, 0, 0, 0, 6318, 6317, 1, 0, 0, 0, 6318, 6319, 1, 0, 0,
		0, 6319, 6320, 1, 0, 0, 0, 6320, 6322, 3, 590, 295, 0, 6321, 6323, 3, 590,
		295, 0, 6322, 6321, 1, 0, 0, 0, 6322, 6323, 1, 0, 0, 0, 6323, 6325, 1,
		0, 0, 0, 6324, 6310, 1, 0, 0, 0, 6324, 6318, 1, 0, 0, 0, 6325, 559, 1,
		0, 0, 0, 6326, 6329, 3, 586, 293, 0, 6327, 6329, 5, 1147, 0, 0, 6328, 6326,
		1, 0, 0, 0, 6328, 6327, 1, 0, 0, 0, 6329, 6334, 1, 0, 0, 0, 6330, 6331,
		5, 1132, 0, 0, 6331, 6332, 3, 592, 296, 0, 6332, 6333, 5, 1133, 0, 0, 6333,
		6335, 1, 0, 0, 0, 6334, 6330, 1, 0, 0, 0, 6334, 6335, 1, 0, 0, 0, 6335,
		6338, 1, 0, 0, 0, 6336, 6338, 3, 690, 345, 0, 6337, 6328, 1, 0, 0, 0, 6337,
		6336, 1, 0, 0, 0, 6338, 6340, 1, 0, 0, 0, 6339, 6341, 7, 48, 0, 0, 6340,
		6339, 1, 0, 0, 0, 6340, 6341, 1, 0, 0, 0, 6341, 561, 1, 0, 0, 0, 6342,
		6347, 5, 1147, 0, 0, 6343, 6347, 5, 1155, 0, 0, 6344, 6347, 5, 696, 0,
		0, 6345, 6347, 3, 720, 360, 0, 6346, 6342, 1, 0, 0, 0, 6346, 6343, 1, 0,
		0, 0, 6346, 6344, 1, 0, 0, 0, 6346, 6345, 1, 0, 0, 0, 6347, 563, 1, 0,
		0, 0, 6348, 6349, 7, 94, 0, 0, 6349, 565, 1, 0, 0, 0, 6350, 6356, 3, 562,
		281, 0, 6351, 6352, 3, 562, 281, 0, 6352, 6353, 3, 564, 282, 0, 6353, 6356,
		1, 0, 0, 0, 6354, 6356, 3, 62, 31, 0, 6355, 6350, 1, 0, 0, 0, 6355, 6351,
		1, 0, 0, 0, 6355, 6354, 1, 0, 0, 0, 6356, 567, 1, 0, 0, 0, 6357, 6358,
		7, 95, 0, 0, 6358, 569, 1, 0, 0, 0, 6359, 6364, 5, 225, 0, 0, 6360, 6364,
		3, 710, 355, 0, 6361, 6364, 5, 1147, 0, 0, 6362, 6364, 5, 1144, 0, 0, 6363,
		6359, 1, 0, 0, 0, 6363, 6360, 1, 0, 0, 0, 6363, 6361, 1, 0, 0, 0, 6363,
		6362, 1, 0, 0, 0, 6364, 571, 1, 0, 0, 0, 6365, 6368, 3, 586, 293, 0, 6366,
		6368, 5, 1147, 0, 0, 6367, 6365, 1, 0, 0, 0, 6367, 6366, 1, 0, 0, 0, 6368,
		573, 1, 0, 0, 0, 6369, 6373, 3, 576, 288, 0, 6370, 6373, 5, 1155, 0, 0,
		6371, 6373, 5, 1147, 0, 0, 6372, 6369, 1, 0, 0, 0, 6372, 6370, 1, 0, 0,
		0, 6372, 6371, 1, 0, 0, 0, 6373, 575, 1, 0, 0, 0, 6374, 6375, 7, 96, 0,
		0, 6375, 577, 1, 0, 0, 0, 6376, 6377, 3, 592, 296, 0, 6377, 6378, 5, 1120,
		0, 0, 6378, 6379, 3, 592, 296, 0, 6379, 6380, 5, 1120, 0, 0, 6380, 6381,
		3, 592, 296, 0, 6381, 6382, 5, 1120, 0, 0, 6382, 6383, 3, 592, 296, 0,
		6383, 6384, 5, 1120, 0, 0, 6384, 6390, 3, 592, 296, 0, 6385, 6386, 5, 1143,
		0, 0, 6386, 6387, 3, 592, 296, 0, 6387, 6388, 5, 1120, 0, 0, 6388, 6389,
		3, 592, 296, 0, 6389, 6391, 1, 0, 0, 0, 6390, 6385, 1, 0, 0, 0, 6391, 6392,
		1, 0, 0, 0, 6392, 6390, 1, 0, 0, 0, 6392, 6393, 1, 0, 0, 0, 6393, 579,
		1, 0, 0, 0, 6394, 6401, 3, 582, 291, 0, 6395, 6396, 5, 1134, 0, 0, 6396,
		6399, 3, 582, 291, 0, 6397, 6398, 5, 1134, 0, 0, 6398, 6400, 3, 592, 296,
		0, 6399, 6397, 1, 0, 0, 0, 6399, 6400, 1, 0, 0, 0, 6400, 6402, 1, 0, 0,
		0, 6401, 6395, 1, 0, 0, 0, 6401, 6402, 1, 0, 0, 0, 6402, 581, 1, 0, 0,
		0, 6403, 6411, 5, 1147, 0, 0, 6404, 6411, 5, 1152, 0, 0, 6405, 6407, 5,
		1149, 0, 0, 6406, 6405, 1, 0, 0, 0, 6407, 6408, 1, 0, 0, 0, 6408, 6406,
		1, 0, 0, 0, 6408, 6409, 1, 0, 0, 0, 6409, 6411, 1, 0, 0, 0, 6410, 6403,
		1, 0, 0, 0, 6410, 6404, 1, 0, 0, 0, 6410, 6406, 1, 0, 0, 0, 6411, 583,
		1, 0, 0, 0, 6412, 6415, 3, 586, 293, 0, 6413, 6415, 5, 1147, 0, 0, 6414,
		6412, 1, 0, 0, 0, 6414, 6413, 1, 0, 0, 0, 6415, 585, 1, 0, 0, 0, 6416,
		6420, 3, 588, 294, 0, 6417, 6420, 5, 1144, 0, 0, 6418, 6420, 5, 1147, 0,
		0, 6419, 6416, 1, 0, 0, 0, 6419, 6417, 1, 0, 0, 0, 6419, 6418, 1, 0, 0,
		0, 6420, 587, 1, 0, 0, 0, 6421, 6431, 5, 1155, 0, 0, 6422, 6431, 3, 710,
		355, 0, 6423, 6431, 3, 712, 356, 0, 6424, 6431, 3, 576, 288, 0, 6425, 6431,
		3, 714, 357, 0, 6426, 6431, 3, 716, 358, 0, 6427, 6431, 3, 718, 359, 0,
		6428, 6431, 3, 720, 360, 0, 6429, 6431, 3, 682, 341, 0, 6430, 6421, 1,
		0, 0, 0, 6430, 6422, 1, 0, 0, 0, 6430, 6423, 1, 0, 0, 0, 6430, 6424, 1,
		0, 0, 0, 6430, 6425, 1, 0, 0, 0, 6430, 6426, 1, 0, 0, 0, 6430, 6427, 1,
		0, 0, 0, 6430, 6428, 1, 0, 0, 0, 6430, 6429, 1, 0, 0, 0, 6431, 589, 1,
		0, 0, 0, 6432, 6436, 5, 1154, 0, 0, 6433, 6434, 5, 1131, 0, 0, 6434, 6436,
		3, 586, 293, 0, 6435, 6432, 1, 0, 0, 0, 6435, 6433, 1, 0, 0, 0, 6436, 591,
		1, 0, 0, 0, 6437, 6438, 7, 97, 0, 0, 6438, 593, 1, 0, 0, 0, 6439, 6442,
		5, 1145, 0, 0, 6440, 6442, 3, 592, 296, 0, 6441, 6439, 1, 0, 0, 0, 6441,
		6440, 1, 0, 0, 0, 6442, 595, 1, 0, 0, 0, 6443, 6445, 5, 1153, 0, 0, 6444,
		6443, 1, 0, 0, 0, 6444, 6445, 1, 0, 0, 0, 6445, 6446, 1, 0, 0, 0, 6446,
		6449, 5, 1147, 0, 0, 6447, 6449, 5, 1146, 0, 0, 6448, 6444, 1, 0, 0, 0,
		6448, 6447, 1, 0, 0, 0, 6449, 6451, 1, 0, 0, 0, 6450, 6452, 5, 1147, 0,
		0, 6451, 6450, 1, 0, 0, 0, 6452, 6453, 1, 0, 0, 0, 6453, 6451, 1, 0, 0,
		0, 6453, 6454, 1, 0, 0, 0, 6454, 6467, 1, 0, 0, 0, 6455, 6457, 5, 1153,
		0, 0, 6456, 6455, 1, 0, 0, 0, 6456, 6457, 1, 0, 0, 0, 6457, 6458, 1, 0,
		0, 0, 6458, 6461, 5, 1147, 0, 0, 6459, 6461, 5, 1146, 0, 0, 6460, 6456,
		1, 0, 0, 0, 6460, 6459, 1, 0, 0, 0, 6461, 6464, 1, 0, 0, 0, 6462, 6463,
		5, 26, 0, 0, 6463, 6465, 3, 572, 286, 0, 6464, 6462, 1, 0, 0, 0, 6464,
		6465, 1, 0, 0, 0, 6465, 6467, 1, 0, 0, 0, 6466, 6448, 1, 0, 0, 0, 6466,
		6460, 1, 0, 0, 0, 6467, 597, 1, 0, 0, 0, 6468, 6469, 7, 98, 0, 0, 6469,
		599, 1, 0, 0, 0, 6470, 6472, 5, 1153, 0, 0, 6471, 6470, 1, 0, 0, 0, 6471,
		6472, 1, 0, 0, 0, 6472, 6473, 1, 0, 0, 0, 6473, 6474, 5, 1149, 0, 0, 6474,
		601, 1, 0, 0, 0, 6475, 6477, 5, 113, 0, 0, 6476, 6475, 1, 0, 0, 0, 6476,
		6477, 1, 0, 0, 0, 6477, 6478, 1, 0, 0, 0, 6478, 6479, 7, 99, 0, 0, 6479,
		603, 1, 0, 0, 0, 6480, 6493, 3, 596, 298, 0, 6481, 6493, 3, 592, 296, 0,
		6482, 6483, 5, 1120, 0, 0, 6483, 6493, 3, 592, 296, 0, 6484, 6493, 3, 600,
		300, 0, 6485, 6493, 3, 598, 299, 0, 6486, 6493, 5, 1150, 0, 0, 6487, 6493,
		5, 1152, 0, 0, 6488, 6490, 5, 113, 0, 0, 6489, 6488, 1, 0, 0, 0, 6489,
		6490, 1, 0, 0, 0, 6490, 6491, 1, 0, 0, 0, 6491, 6493, 7, 99, 0, 0, 6492,
		6480, 1, 0, 0, 0, 6492, 6481, 1, 0, 0, 0, 6492, 6482, 1, 0, 0, 0, 6492,
		6484, 1, 0, 0, 0, 6492, 6485, 1, 0, 0, 0, 6492, 6486, 1, 0, 0, 0, 6492,
		6487, 1, 0, 0, 0, 6492, 6489, 1, 0, 0, 0, 6493, 605, 1, 0, 0, 0, 6494,
		6496, 7, 100, 0, 0, 6495, 6497, 5, 237, 0, 0, 6496, 6495, 1, 0, 0, 0, 6496,
		6497, 1, 0, 0, 0, 6497, 6499, 1, 0, 0, 0, 6498, 6500, 3, 612, 306, 0, 6499,
		6498, 1, 0, 0, 0, 6499, 6500, 1, 0, 0, 0, 6500, 6502, 1, 0, 0, 0, 6501,
		6503, 5, 225, 0, 0, 6502, 6501, 1, 0, 0, 0, 6502, 6503, 1, 0, 0, 0, 6503,
		6507, 1, 0, 0, 0, 6504, 6505, 3, 60, 30, 0, 6505, 6506, 3, 570, 285, 0,
		6506, 6508, 1, 0, 0, 0, 6507, 6504, 1, 0, 0, 0, 6507, 6508, 1, 0, 0, 0,
		6508, 6512, 1, 0, 0, 0, 6509, 6510, 5, 26, 0, 0, 6510, 6513, 3, 572, 286,
		0, 6511, 6513, 5, 225, 0, 0, 6512, 6509, 1, 0, 0, 0, 6512, 6511, 1, 0,
		0, 0, 6512, 6513, 1, 0, 0, 0, 6513, 6621, 1, 0, 0, 0, 6514, 6515, 5, 224,
		0, 0, 6515, 6516, 7, 101, 0, 0, 6516, 6518, 5, 237, 0, 0, 6517, 6519, 3,
		612, 306, 0, 6518, 6517, 1, 0, 0, 0, 6518, 6519, 1, 0, 0, 0, 6519, 6521,
		1, 0, 0, 0, 6520, 6522, 5, 225, 0, 0, 6521, 6520, 1, 0, 0, 0, 6521, 6522,
		1, 0, 0, 0, 6522, 6621, 1, 0, 0, 0, 6523, 6524, 5, 224, 0, 0, 6524, 6526,
		7, 102, 0, 0, 6525, 6527, 3, 612, 306, 0, 6526, 6525, 1, 0, 0, 0, 6526,
		6527, 1, 0, 0, 0, 6527, 6529, 1, 0, 0, 0, 6528, 6530, 5, 225, 0, 0, 6529,
		6528, 1, 0, 0, 0, 6529, 6530, 1, 0, 0, 0, 6530, 6621, 1, 0, 0, 0, 6531,
		6532, 5, 517, 0, 0, 6532, 6534, 5, 222, 0, 0, 6533, 6535, 3, 612, 306,
		0, 6534, 6533, 1, 0, 0, 0, 6534, 6535, 1, 0, 0, 0, 6535, 6537, 1, 0, 0,
		0, 6536, 6538, 5, 225, 0, 0, 6537, 6536, 1, 0, 0, 0, 6537, 6538, 1, 0,
		0, 0, 6538, 6621, 1, 0, 0, 0, 6539, 6541, 7, 103, 0, 0, 6540, 6542, 3,
		612, 306, 0, 6541, 6540, 1, 0, 0, 0, 6541, 6542, 1, 0, 0, 0, 6542, 6546,
		1, 0, 0, 0, 6543, 6545, 7, 104, 0, 0, 6544, 6543, 1, 0, 0, 0, 6545, 6548,
		1, 0, 0, 0, 6546, 6544, 1, 0, 0, 0, 6546, 6547, 1, 0, 0, 0, 6547, 6621,
		1, 0, 0, 0, 6548, 6546, 1, 0, 0, 0, 6549, 6551, 5, 207, 0, 0, 6550, 6552,
		3, 614, 307, 0, 6551, 6550, 1, 0, 0, 0, 6551, 6552, 1, 0, 0, 0, 6552, 6556,
		1, 0, 0, 0, 6553, 6555, 7, 104, 0, 0, 6554, 6553, 1, 0, 0, 0, 6555, 6558,
		1, 0, 0, 0, 6556, 6554, 1, 0, 0, 0, 6556, 6557, 1, 0, 0, 0, 6557, 6621,
		1, 0, 0, 0, 6558, 6556, 1, 0, 0, 0, 6559, 6561, 5, 208, 0, 0, 6560, 6562,
		5, 209, 0, 0, 6561, 6560, 1, 0, 0, 0, 6561, 6562, 1, 0, 0, 0, 6562, 6564,
		1, 0, 0, 0, 6563, 6565, 3, 614, 307, 0, 6564, 6563, 1, 0, 0, 0, 6564, 6565,
		1, 0, 0, 0, 6565, 6569, 1, 0, 0, 0, 6566, 6568, 7, 104, 0, 0, 6567, 6566,
		1, 0, 0, 0, 6568, 6571, 1, 0, 0, 0, 6569, 6567, 1, 0, 0, 0, 6569, 6570,
		1, 0, 0, 0, 6570, 6621, 1, 0, 0, 0, 6571, 6569, 1, 0, 0, 0, 6572, 6574,
		7, 105, 0, 0, 6573, 6575, 3, 616, 308, 0, 6574, 6573, 1, 0, 0, 0, 6574,
		6575, 1, 0, 0, 0, 6575, 6579, 1, 0, 0, 0, 6576, 6578, 7, 104, 0, 0, 6577,
		6576, 1, 0, 0, 0, 6578, 6581, 1, 0, 0, 0, 6579, 6577, 1, 0, 0, 0, 6579,
		6580, 1, 0, 0, 0, 6580, 6621, 1, 0, 0, 0, 6581, 6579, 1, 0, 0, 0, 6582,
		6621, 7, 106, 0, 0, 6583, 6585, 7, 107, 0, 0, 6584, 6586, 3, 612, 306,
		0, 6585, 6584, 1, 0, 0, 0, 6585, 6586, 1, 0, 0, 0, 6586, 6621, 1, 0, 0,
		0, 6587, 6588, 7, 108, 0, 0, 6588, 6590, 3, 608, 304, 0, 6589, 6591, 5,
		225, 0, 0, 6590, 6589, 1, 0, 0, 0, 6590, 6591, 1, 0, 0, 0, 6591, 6595,
		1, 0, 0, 0, 6592, 6593, 3, 60, 30, 0, 6593, 6594, 3, 570, 285, 0, 6594,
		6596, 1, 0, 0, 0, 6595, 6592, 1, 0, 0, 0, 6595, 6596, 1, 0, 0, 0, 6596,
		6621, 1, 0, 0, 0, 6597, 6600, 7, 109, 0, 0, 6598, 6599, 5, 1011, 0, 0,
		6599, 6601, 3, 592, 296, 0, 6600, 6598, 1, 0, 0, 0, 6600, 6601, 1, 0, 0,
		0, 6601, 6621, 1, 0, 0, 0, 6602, 6604, 5, 230, 0, 0, 6603, 6605, 5, 222,
		0, 0, 6604, 6603, 1, 0, 0, 0, 6604, 6605, 1, 0, 0, 0, 6605, 6607, 1, 0,
		0, 0, 6606, 6608, 5, 225, 0, 0, 6607, 6606, 1, 0, 0, 0, 6607, 6608, 1,
		0, 0, 0, 6608, 6612, 1, 0, 0, 0, 6609, 6610, 3, 60, 30, 0, 6610, 6611,
		3, 570, 285, 0, 6611, 6613, 1, 0, 0, 0, 6612, 6609, 1, 0, 0, 0, 6612, 6613,
		1, 0, 0, 0, 6613, 6616, 1, 0, 0, 0, 6614, 6615, 5, 26, 0, 0, 6615, 6617,
		3, 572, 286, 0, 6616, 6614, 1, 0, 0, 0, 6616, 6617, 1, 0, 0, 0, 6617, 6621,
		1, 0, 0, 0, 6618, 6619, 5, 230, 0, 0, 6619, 6621, 5, 226, 0, 0, 6620, 6494,
		1, 0, 0, 0, 6620, 6514, 1, 0, 0, 0, 6620, 6523, 1, 0, 0, 0, 6620, 6531,
		1, 0, 0, 0, 6620, 6539, 1, 0, 0, 0, 6620, 6549, 1, 0, 0, 0, 6620, 6559,
		1, 0, 0, 0, 6620, 6572, 1, 0, 0, 0, 6620, 6582, 1, 0, 0, 0, 6620, 6583,
		1, 0, 0, 0, 6620, 6587, 1, 0, 0, 0, 6620, 6597, 1, 0, 0, 0, 6620, 6602,
		1, 0, 0, 0, 6620, 6618, 1, 0, 0, 0, 6621, 607, 1, 0, 0, 0, 6622, 6623,
		5, 1132, 0, 0, 6623, 6628, 5, 1147, 0, 0, 6624, 6625, 5, 1134, 0, 0, 6625,
		6627, 5, 1147, 0, 0, 6626, 6624, 1, 0, 0, 0, 6627, 6630, 1, 0, 0, 0, 6628,
		6626, 1, 0, 0, 0, 6628, 6629, 1, 0, 0, 0, 6629, 6631, 1, 0, 0, 0, 6630,
		6628, 1, 0, 0, 0, 6631, 6632, 5, 1133, 0, 0, 6632, 609, 1, 0, 0, 0, 6633,
		6635, 7, 110, 0, 0, 6634, 6636, 3, 612, 306, 0, 6635, 6634, 1, 0, 0, 0,
		6635, 6636, 1, 0, 0, 0, 6636, 6656, 1, 0, 0, 0, 6637, 6639, 5, 221, 0,
		0, 6638, 6640, 3, 612, 306, 0, 6639, 6638, 1, 0, 0, 0, 6639, 6640, 1, 0,
		0, 0, 6640, 6644, 1, 0, 0, 0, 6641, 6642, 3, 60, 30, 0, 6642, 6643, 3,
		570, 285, 0, 6643, 6645, 1, 0, 0, 0, 6644, 6641, 1, 0, 0, 0, 6644, 6645,
		1, 0, 0, 0, 6645, 6656, 1, 0, 0, 0, 6646, 6656, 7, 111, 0, 0, 6647, 6649,
		7, 112, 0, 0, 6648, 6650, 3, 616, 308, 0, 6649, 6648, 1, 0, 0, 0, 6649,
		6650, 1, 0, 0, 0, 6650, 6656, 1, 0, 0, 0, 6651, 6653, 7, 113, 0, 0, 6652,
		6654, 7, 114, 0, 0, 6653, 6652, 1, 0, 0, 0, 6653, 6654, 1, 0, 0, 0, 6654,
		6656, 1, 0, 0, 0, 6655, 6633, 1, 0, 0, 0, 6655, 6637, 1, 0, 0, 0, 6655,
		6646, 1, 0, 0, 0, 6655, 6647, 1, 0, 0, 0, 6655, 6651, 1, 0, 0, 0, 6656,
		6658, 1, 0, 0, 0, 6657, 6659, 5, 10, 0, 0, 6658, 6657, 1, 0, 0, 0, 6658,
		6659, 1, 0, 0, 0, 6659, 611, 1, 0, 0, 0, 6660, 6661, 5, 1132, 0, 0, 6661,
		6662, 3, 592, 296, 0, 6662, 6663, 5, 1133, 0, 0, 6663, 613, 1, 0, 0, 0,
		6664, 6665, 5, 1132, 0, 0, 6665, 6666, 3, 592, 296, 0, 6666, 6667, 5, 1134,
		0, 0, 6667, 6668, 3, 592, 296, 0, 6668, 6669, 5, 1133, 0, 0, 6669, 615,
		1, 0, 0, 0, 6670, 6671, 5, 1132, 0, 0, 6671, 6674, 3, 592, 296, 0, 6672,
		6673, 5, 1134, 0, 0, 6673, 6675, 3, 592, 296, 0, 6674, 6672, 1, 0, 0, 0,
		6674, 6675, 1, 0, 0, 0, 6675, 6676, 1, 0, 0, 0, 6676, 6677, 5, 1133, 0,
		0, 6677, 617, 1, 0, 0, 0, 6678, 6683, 3, 586, 293, 0, 6679, 6680, 5, 1134,
		0, 0, 6680, 6682, 3, 586, 293, 0, 6681, 6679, 1, 0, 0, 0, 6682, 6685, 1,
		0, 0, 0, 6683, 6681, 1, 0, 0, 0, 6683, 6684, 1, 0, 0, 0, 6684, 619, 1,
		0, 0, 0, 6685, 6683, 1, 0, 0, 0, 6686, 6691, 3, 558, 279, 0, 6687, 6688,
		5, 1134, 0, 0, 6688, 6690, 3, 558, 279, 0, 6689, 6687, 1, 0, 0, 0, 6690,
		6693, 1, 0, 0, 0, 6691, 6689, 1, 0, 0, 0, 6691, 6692, 1, 0, 0, 0, 6692,
		621, 1, 0, 0, 0, 6693, 6691, 1, 0, 0, 0, 6694, 6699, 3, 554, 277, 0, 6695,
		6696, 5, 1134, 0, 0, 6696, 6698, 3, 554, 277, 0, 6697, 6695, 1, 0, 0, 0,
		6698, 6701, 1, 0, 0, 0, 6699, 6697, 1, 0, 0, 0, 6699, 6700, 1, 0, 0, 0,
		6700, 623, 1, 0, 0, 0, 6701, 6699, 1, 0, 0, 0, 6702, 6703, 5, 1132, 0,
		0, 6703, 6708, 3, 560, 280, 0, 6704, 6705, 5, 1134, 0, 0, 6705, 6707, 3,
		560, 280, 0, 6706, 6704, 1, 0, 0, 0, 6707, 6710, 1, 0, 0, 0, 6708, 6706,
		1, 0, 0, 0, 6708, 6709, 1, 0, 0, 0, 6709, 6711, 1, 0, 0, 0, 6710, 6708,
		1, 0, 0, 0, 6711, 6712, 5, 1133, 0, 0, 6712, 625, 1, 0, 0, 0, 6713, 6718,
		3, 690, 345, 0, 6714, 6715, 5, 1134, 0, 0, 6715, 6717, 3, 690, 345, 0,
		6716, 6714, 1, 0, 0, 0, 6717, 6720, 1, 0, 0, 0, 6718, 6716, 1, 0, 0, 0,
		6718, 6719, 1, 0, 0, 0, 6719, 627, 1, 0, 0, 0, 6720, 6718, 1, 0, 0, 0,
		6721, 6726, 3, 640, 320, 0, 6722, 6723, 5, 1134, 0, 0, 6723, 6725, 3, 640,
		320, 0, 6724, 6722, 1, 0, 0, 0, 6725, 6728, 1, 0, 0, 0, 6726, 6724, 1,
		0, 0, 0, 6726, 6727, 1, 0, 0, 0, 6727, 629, 1, 0, 0, 0, 6728, 6726, 1,
		0, 0, 0, 6729, 6734, 3, 604, 302, 0, 6730, 6731, 5, 1134, 0, 0, 6731, 6733,
		3, 604, 302, 0, 6732, 6730, 1, 0, 0, 0, 6733, 6736, 1, 0, 0, 0, 6734, 6732,
		1, 0, 0, 0, 6734, 6735, 1, 0, 0, 0, 6735, 631, 1, 0, 0, 0, 6736, 6734,
		1, 0, 0, 0, 6737, 6742, 5, 1147, 0, 0, 6738, 6739, 5, 1134, 0, 0, 6739,
		6741, 5, 1147, 0, 0, 6740, 6738, 1, 0, 0, 0, 6741, 6744, 1, 0, 0, 0, 6742,
		6740, 1, 0, 0, 0, 6742, 6743, 1, 0, 0, 0, 6743, 633, 1, 0, 0, 0, 6744,
		6742, 1, 0, 0, 0, 6745, 6750, 5, 1158, 0, 0, 6746, 6747, 5, 1134, 0, 0,
		6747, 6749, 5, 1158, 0, 0, 6748, 6746, 1, 0, 0, 0, 6749, 6752, 1, 0, 0,
		0, 6750, 6748, 1, 0, 0, 0, 6750, 6751, 1, 0, 0, 0, 6751, 635, 1, 0, 0,
		0, 6752, 6750, 1, 0, 0, 0, 6753, 6780, 5, 115, 0, 0, 6754, 6755, 5, 22,
		0, 0, 6755, 6756, 5, 1132, 0, 0, 6756, 6757, 3, 690, 345, 0, 6757, 6758,
		5, 11, 0, 0, 6758, 6759, 3, 610, 305, 0, 6759, 6760, 5, 1133, 0, 0, 6760,
		6780, 1, 0, 0, 0, 6761, 6763, 3, 696, 348, 0, 6762, 6761, 1, 0, 0, 0, 6762,
		6763, 1, 0, 0, 0, 6763, 6764, 1, 0, 0, 0, 6764, 6780, 3, 604, 302, 0, 6765,
		6769, 3, 638, 319, 0, 6766, 6767, 5, 117, 0, 0, 6767, 6768, 5, 183, 0,
		0, 6768, 6770, 3, 638, 319, 0, 6769, 6766, 1, 0, 0, 0, 6769, 6770, 1, 0,
		0, 0, 6770, 6780, 1, 0, 0, 0, 6771, 6772, 5, 1132, 0, 0, 6772, 6773, 3,
		690, 345, 0, 6773, 6774, 5, 1133, 0, 0, 6774, 6780, 1, 0, 0, 0, 6775, 6776,
		5, 1132, 0, 0, 6776, 6777, 3, 552, 276, 0, 6777, 6778, 5, 1133, 0, 0, 6778,
		6780, 1, 0, 0, 0, 6779, 6753, 1, 0, 0, 0, 6779, 6754, 1, 0, 0, 0, 6779,
		6762, 1, 0, 0, 0, 6779, 6765, 1, 0, 0, 0, 6779, 6771, 1, 0, 0, 0, 6779,
		6775, 1, 0, 0, 0, 6780, 637, 1, 0, 0, 0, 6781, 6787, 7, 115, 0, 0, 6782,
		6784, 5, 1132, 0, 0, 6783, 6785, 3, 592, 296, 0, 6784, 6783, 1, 0, 0, 0,
		6784, 6785, 1, 0, 0, 0, 6785, 6786, 1, 0, 0, 0, 6786, 6788, 5, 1133, 0,
		0, 6787, 6782, 1, 0, 0, 0, 6787, 6788, 1, 0, 0, 0, 6788, 6796, 1, 0, 0,
		0, 6789, 6790, 5, 322, 0, 0, 6790, 6792, 5, 1132, 0, 0, 6791, 6793, 3,
		592, 296, 0, 6792, 6791, 1, 0, 0, 0, 6792, 6793, 1, 0, 0, 0, 6793, 6794,
		1, 0, 0, 0, 6794, 6796, 5, 1133, 0, 0, 6795, 6781, 1, 0, 0, 0, 6795, 6789,
		1, 0, 0, 0, 6796, 639, 1, 0, 0, 0, 6797, 6800, 3, 690, 345, 0, 6798, 6800,
		5, 41, 0, 0, 6799, 6797, 1, 0, 0, 0, 6799, 6798, 1, 0, 0, 0, 6800, 641,
		1, 0, 0, 0, 6801, 6802, 5, 76, 0, 0, 6802, 6803, 5, 59, 0, 0, 6803, 643,
		1, 0, 0, 0, 6804, 6805, 5, 76, 0, 0, 6805, 6806, 5, 113, 0, 0, 6806, 6807,
		5, 59, 0, 0, 6807, 645, 1, 0, 0, 0, 6808, 6809, 5, 122, 0, 0, 6809, 6810,
		5, 140, 0, 0, 6810, 647, 1, 0, 0, 0, 6811, 6812, 5, 673, 0, 0, 6812, 6815,
		3, 592, 296, 0, 6813, 6815, 5, 526, 0, 0, 6814, 6811, 1, 0, 0, 0, 6814,
		6813, 1, 0, 0, 0, 6815, 649, 1, 0, 0, 0, 6816, 6835, 3, 652, 326, 0, 6817,
		6835, 3, 660, 330, 0, 6818, 6835, 3, 662, 331, 0, 6819, 6820, 3, 682, 341,
		0, 6820, 6822, 5, 1132, 0, 0, 6821, 6823, 3, 686, 343, 0, 6822, 6821, 1,
		0, 0, 0, 6822, 6823, 1, 0, 0, 0, 6823, 6824, 1, 0, 0, 0, 6824, 6825, 5,
		1133, 0, 0, 6825, 6835, 1, 0, 0, 0, 6826, 6827, 3, 552, 276, 0, 6827, 6829,
		5, 1132, 0, 0, 6828, 6830, 3, 686, 343, 0, 6829, 6828, 1, 0, 0, 0, 6829,
		6830, 1, 0, 0, 0, 6830, 6831, 1, 0, 0, 0, 6831, 6832, 5, 1133, 0, 0, 6832,
		6835, 1, 0, 0, 0, 6833, 6835, 3, 684, 342, 0, 6834, 6816, 1, 0, 0, 0, 6834,
		6817, 1, 0, 0, 0, 6834, 6818, 1, 0, 0, 0, 6834, 6819, 1, 0, 0, 0, 6834,
		6826, 1, 0, 0, 0, 6834, 6833, 1, 0, 0, 0, 6835, 651, 1, 0, 0, 0, 6836,
		6839, 7, 116, 0, 0, 6837, 6838, 5, 1132, 0, 0, 6838, 6840, 5, 1133, 0,
		0, 6839, 6837, 1, 0, 0, 0, 6839, 6840, 1, 0, 0, 0, 6840, 7016, 1, 0, 0,
		0, 6841, 7016, 3, 62, 31, 0, 6842, 6843, 5, 31, 0, 0, 6843, 6844, 5, 1132,
		0, 0, 6844, 6845, 3, 690, 345, 0, 6845, 6846, 5, 1134, 0, 0, 6846, 6847,
		3, 610, 305, 0, 6847, 6848, 5, 1133, 0, 0, 6848, 7016, 1, 0, 0, 0, 6849,
		6850, 5, 31, 0, 0, 6850, 6851, 5, 1132, 0, 0, 6851, 6852, 3, 690, 345,
		0, 6852, 6853, 5, 186, 0, 0, 6853, 6854, 3, 570, 285, 0, 6854, 6855, 5,
		1133, 0, 0, 6855, 7016, 1, 0, 0, 0, 6856, 6857, 5, 22, 0, 0, 6857, 6858,
		5, 1132, 0, 0, 6858, 6859, 3, 690, 345, 0, 6859, 6860, 5, 11, 0, 0, 6860,
		6861, 3, 610, 305, 0, 6861, 6862, 5, 1133, 0, 0, 6862, 7016, 1, 0, 0, 0,
		6863, 6864, 5, 187, 0, 0, 6864, 6865, 5, 1132, 0, 0, 6865, 6866, 3, 558,
		279, 0, 6866, 6867, 5, 1133, 0, 0, 6867, 7016, 1, 0, 0, 0, 6868, 6869,
		5, 21, 0, 0, 6869, 6871, 3, 690, 345, 0, 6870, 6872, 3, 654, 327, 0, 6871,
		6870, 1, 0, 0, 0, 6872, 6873, 1, 0, 0, 0, 6873, 6871, 1, 0, 0, 0, 6873,
		6874, 1, 0, 0, 0, 6874, 6877, 1, 0, 0, 0, 6875, 6876, 5, 52, 0, 0, 6876,
		6878, 3, 688, 344, 0, 6877, 6875, 1, 0, 0, 0, 6877, 6878, 1, 0, 0, 0, 6878,
		6879, 1, 0, 0, 0, 6879, 6880, 5, 406, 0, 0, 6880, 7016, 1, 0, 0, 0, 6881,
		6883, 5, 21, 0, 0, 6882, 6884, 3, 654, 327, 0, 6883, 6882, 1, 0, 0, 0,
		6884, 6885, 1, 0, 0, 0, 6885, 6883, 1, 0, 0, 0, 6885, 6886, 1, 0, 0, 0,
		6886, 6889, 1, 0, 0, 0, 6887, 6888, 5, 52, 0, 0, 6888, 6890, 3, 688, 344,
		0, 6889, 6887, 1, 0, 0, 0, 6889, 6890, 1, 0, 0, 0, 6890, 6891, 1, 0, 0,
		0, 6891, 6892, 5, 406, 0, 0, 6892, 7016, 1, 0, 0, 0, 6893, 6894, 5, 221,
		0, 0, 6894, 6895, 5, 1132, 0, 0, 6895, 6898, 3, 686, 343, 0, 6896, 6897,
		5, 186, 0, 0, 6897, 6899, 3, 570, 285, 0, 6898, 6896, 1, 0, 0, 0, 6898,
		6899, 1, 0, 0, 0, 6899, 6900, 1, 0, 0, 0, 6900, 6901, 5, 1133, 0, 0, 6901,
		7016, 1, 0, 0, 0, 6902, 6903, 5, 323, 0, 0, 6903, 6906, 5, 1132, 0, 0,
		6904, 6907, 3, 596, 298, 0, 6905, 6907, 3, 690, 345, 0, 6906, 6904, 1,
		0, 0, 0, 6906, 6905, 1, 0, 0, 0, 6907, 6908, 1, 0, 0, 0, 6908, 6911, 5,
		79, 0, 0, 6909, 6912, 3, 596, 298, 0, 6910, 6912, 3, 690, 345, 0, 6911,
		6909, 1, 0, 0, 0, 6911, 6910, 1, 0, 0, 0, 6912, 6913, 1, 0, 0, 0, 6913,
		6914, 5, 1133, 0, 0, 6914, 7016, 1, 0, 0, 0, 6915, 6916, 7, 117, 0, 0,
		6916, 6919, 5, 1132, 0, 0, 6917, 6920, 3, 596, 298, 0, 6918, 6920, 3, 690,
		345, 0, 6919, 6917, 1, 0, 0, 0, 6919, 6918, 1, 0, 0, 0, 6920, 6921, 1,
		0, 0, 0, 6921, 6924, 5, 67, 0, 0, 6922, 6925, 3, 592, 296, 0, 6923, 6925,
		3, 690, 345, 0, 6924, 6922, 1, 0, 0, 0, 6924, 6923, 1, 0, 0, 0, 6925, 6931,
		1, 0, 0, 0, 6926, 6929, 5, 64, 0, 0, 6927, 6930, 3, 592, 296, 0, 6928,
		6930, 3, 690, 345, 0, 6929, 6927, 1, 0, 0, 0, 6929, 6928, 1, 0, 0, 0, 6930,
		6932, 1, 0, 0, 0, 6931, 6926, 1, 0, 0, 0, 6931, 6932, 1, 0, 0, 0, 6932,
		6933, 1, 0, 0, 0, 6933, 6934, 5, 1133, 0, 0, 6934, 7016, 1, 0, 0, 0, 6935,
		6936, 5, 327, 0, 0, 6936, 6937, 5, 1132, 0, 0, 6937, 6940, 7, 118, 0, 0,
		6938, 6941, 3, 596, 298, 0, 6939, 6941, 3, 690, 345, 0, 6940, 6938, 1,
		0, 0, 0, 6940, 6939, 1, 0, 0, 0, 6940, 6941, 1, 0, 0, 0, 6941, 6942, 1,
		0, 0, 0, 6942, 6945, 5, 67, 0, 0, 6943, 6946, 3, 596, 298, 0, 6944, 6946,
		3, 690, 345, 0, 6945, 6943, 1, 0, 0, 0, 6945, 6944, 1, 0, 0, 0, 6946, 6947,
		1, 0, 0, 0, 6947, 6948, 5, 1133, 0, 0, 6948, 7016, 1, 0, 0, 0, 6949, 6950,
		5, 327, 0, 0, 6950, 6953, 5, 1132, 0, 0, 6951, 6954, 3, 596, 298, 0, 6952,
		6954, 3, 690, 345, 0, 6953, 6951, 1, 0, 0, 0, 6953, 6952, 1, 0, 0, 0, 6954,
		6955, 1, 0, 0, 0, 6955, 6958, 5, 67, 0, 0, 6956, 6959, 3, 596, 298, 0,
		6957, 6959, 3, 690, 345, 0, 6958, 6956, 1, 0, 0, 0, 6958, 6957, 1, 0, 0,
		0, 6959, 6960, 1, 0, 0, 0, 6960, 6961, 5, 1133, 0, 0, 6961, 7016, 1, 0,
		0, 0, 6962, 6963, 5, 1102, 0, 0, 6963, 6966, 5, 1132, 0, 0, 6964, 6967,
		3, 596, 298, 0, 6965, 6967, 3, 690, 345, 0, 6966, 6964, 1, 0, 0, 0, 6966,
		6965, 1, 0, 0, 0, 6967, 6974, 1, 0, 0, 0, 6968, 6969, 5, 11, 0, 0, 6969,
		6970, 7, 119, 0, 0, 6970, 6971, 5, 1132, 0, 0, 6971, 6972, 3, 592, 296,
		0, 6972, 6973, 5, 1133, 0, 0, 6973, 6975, 1, 0, 0, 0, 6974, 6968, 1, 0,
		0, 0, 6974, 6975, 1, 0, 0, 0, 6975, 6977, 1, 0, 0, 0, 6976, 6978, 3, 656,
		328, 0, 6977, 6976, 1, 0, 0, 0, 6977, 6978, 1, 0, 0, 0, 6978, 6979, 1,
		0, 0, 0, 6979, 6980, 5, 1133, 0, 0, 6980, 7016, 1, 0, 0, 0, 6981, 6982,
		5, 320, 0, 0, 6982, 6983, 5, 1132, 0, 0, 6983, 6984, 3, 72, 36, 0, 6984,
		6987, 5, 67, 0, 0, 6985, 6988, 3, 596, 298, 0, 6986, 6988, 3, 690, 345,
		0, 6987, 6985, 1, 0, 0, 0, 6987, 6986, 1, 0, 0, 0, 6988, 6989, 1, 0, 0,
		0, 6989, 6990, 5, 1133, 0, 0, 6990, 7016, 1, 0, 0, 0, 6991, 6992, 5, 899,
		0, 0, 6992, 6993, 5, 1132, 0, 0, 6993, 6994, 7, 120, 0, 0, 6994, 6995,
		5, 1134, 0, 0, 6995, 6996, 3, 596, 298, 0, 6996, 6997, 5, 1133, 0, 0, 6997,
		7016, 1, 0, 0, 0, 6998, 6999, 5, 281, 0, 0, 6999, 7000, 5, 1132, 0, 0,
		7000, 7001, 3, 690, 345, 0, 7001, 7002, 5, 1134, 0, 0, 7002, 7005, 3, 690,
		345, 0, 7003, 7004, 5, 592, 0, 0, 7004, 7006, 3, 610, 305, 0, 7005, 7003,
		1, 0, 0, 0, 7005, 7006, 1, 0, 0, 0, 7006, 7008, 1, 0, 0, 0, 7007, 7009,
		3, 270, 135, 0, 7008, 7007, 1, 0, 0, 0, 7008, 7009, 1, 0, 0, 0, 7009, 7011,
		1, 0, 0, 0, 7010, 7012, 3, 272, 136, 0, 7011, 7010, 1, 0, 0, 0, 7011, 7012,
		1, 0, 0, 0, 7012, 7013, 1, 0, 0, 0, 7013, 7014, 5, 1133, 0, 0, 7014, 7016,
		1, 0, 0, 0, 7015, 6836, 1, 0, 0, 0, 7015, 6841, 1, 0, 0, 0, 7015, 6842,
		1, 0, 0, 0, 7015, 6849, 1, 0, 0, 0, 7015, 6856, 1, 0, 0, 0, 7015, 6863,
		1, 0, 0, 0, 7015, 6868, 1, 0, 0, 0, 7015, 6881, 1, 0, 0, 0, 7015, 6893,
		1, 0, 0, 0, 7015, 6902, 1, 0, 0, 0, 7015, 6915, 1, 0, 0, 0, 7015, 6935,
		1, 0, 0, 0, 7015, 6949, 1, 0, 0, 0, 7015, 6962, 1, 0, 0, 0, 7015, 6981,
		1, 0, 0, 0, 7015, 6991, 1, 0, 0, 0, 7015, 6998, 1, 0, 0, 0, 7016, 653,
		1, 0, 0, 0, 7017, 7018, 5, 188, 0, 0, 7018, 7019, 3, 688, 344, 0, 7019,
		7020, 5, 173, 0, 0, 7020, 7021, 3, 688, 344, 0, 7021, 655, 1, 0, 0, 0,
		7022, 7023, 5, 471, 0, 0, 7023, 7028, 3, 658, 329, 0, 7024, 7025, 5, 1134,
		0, 0, 7025, 7027, 3, 658, 329, 0, 7026, 7024, 1, 0, 0, 0, 7027, 7030, 1,
		0, 0, 0, 7028, 7026, 1, 0, 0, 0, 7028, 7029, 1, 0, 0, 0, 7029, 7037, 1,
		0, 0, 0, 7030, 7028, 1, 0, 0, 0, 7031, 7032, 5, 471, 0, 0, 7032, 7033,
		3, 592, 296, 0, 7033, 7034, 5, 1120, 0, 0, 7034, 7035, 3, 592, 296, 0,
		7035, 7037, 1, 0, 0, 0, 7036, 7022, 1, 0, 0, 0, 7036, 7031, 1, 0, 0, 0,
		7037, 657, 1, 0, 0, 0, 7038, 7040, 3, 592, 296, 0, 7039, 7041, 7, 121,
		0, 0, 7040, 7039, 1, 0, 0, 0, 7040, 7041, 1, 0, 0, 0, 7041, 659, 1, 0,
		0, 0, 7042, 7043, 7, 122, 0, 0, 7043, 7045, 5, 1132, 0, 0, 7044, 7046,
		7, 44, 0, 0, 7045, 7044, 1, 0, 0, 0, 7045, 7046, 1, 0, 0, 0, 7046, 7047,
		1, 0, 0, 0, 7047, 7048, 3, 688, 344, 0, 7048, 7050, 5, 1133, 0, 0, 7049,
		7051, 3, 664, 332, 0, 7050, 7049, 1, 0, 0, 0, 7050, 7051, 1, 0, 0, 0, 7051,
		7102, 1, 0, 0, 0, 7052, 7053, 5, 289, 0, 0, 7053, 7061, 5, 1132, 0, 0,
		7054, 7062, 5, 1116, 0, 0, 7055, 7057, 5, 5, 0, 0, 7056, 7055, 1, 0, 0,
		0, 7056, 7057, 1, 0, 0, 0, 7057, 7058, 1, 0, 0, 0, 7058, 7062, 3, 688,
		344, 0, 7059, 7060, 5, 48, 0, 0, 7060, 7062, 3, 686, 343, 0, 7061, 7054,
		1, 0, 0, 0, 7061, 7056, 1, 0, 0, 0, 7061, 7059, 1, 0, 0, 0, 7062, 7063,
		1, 0, 0, 0, 7063, 7065, 5, 1133, 0, 0, 7064, 7066, 3, 664, 332, 0, 7065,
		7064, 1, 0, 0, 0, 7065, 7066, 1, 0, 0, 0, 7066, 7102, 1, 0, 0, 0, 7067,
		7068, 7, 123, 0, 0, 7068, 7070, 5, 1132, 0, 0, 7069, 7071, 5, 5, 0, 0,
		7070, 7069, 1, 0, 0, 0, 7070, 7071, 1, 0, 0, 0, 7071, 7072, 1, 0, 0, 0,
		7072, 7073, 3, 688, 344, 0, 7073, 7075, 5, 1133, 0, 0, 7074, 7076, 3, 664,
		332, 0, 7075, 7074, 1, 0, 0, 0, 7075, 7076, 1, 0, 0, 0, 7076, 7102, 1,
		0, 0, 0, 7077, 7078, 5, 293, 0, 0, 7078, 7080, 5, 1132, 0, 0, 7079, 7081,
		5, 48, 0, 0, 7080, 7079, 1, 0, 0, 0, 7080, 7081, 1, 0, 0, 0, 7081, 7082,
		1, 0, 0, 0, 7082, 7093, 3, 686, 343, 0, 7083, 7084, 5, 123, 0, 0, 7084,
		7085, 5, 18, 0, 0, 7085, 7090, 3, 232, 116, 0, 7086, 7087, 5, 1134, 0,
		0, 7087, 7089, 3, 232, 116, 0, 7088, 7086, 1, 0, 0, 0, 7089, 7092, 1, 0,
		0, 0, 7090, 7088, 1, 0, 0, 0, 7090, 7091, 1, 0, 0, 0, 7091, 7094, 1, 0,
		0, 0, 7092, 7090, 1, 0, 0, 0, 7093, 7083, 1, 0, 0, 0, 7093, 7094, 1, 0,
		0, 0, 7094, 7097, 1, 0, 0, 0, 7095, 7096, 5, 153, 0, 0, 7096, 7098, 5,
		1147, 0, 0, 7097, 7095, 1, 0, 0, 0, 7097, 7098, 1, 0, 0, 0, 7098, 7099,
		1, 0, 0, 0, 7099, 7100, 5, 1133, 0, 0, 7100, 7102, 1, 0, 0, 0, 7101, 7042,
		1, 0, 0, 0, 7101, 7052, 1, 0, 0, 0, 7101, 7067, 1, 0, 0, 0, 7101, 7077,
		1, 0, 0, 0, 7102, 661, 1, 0, 0, 0, 7103, 7104, 7, 124, 0, 0, 7104, 7105,
		5, 1132, 0, 0, 7105, 7108, 3, 690, 345, 0, 7106, 7107, 5, 1134, 0, 0, 7107,
		7109, 3, 592, 296, 0, 7108, 7106, 1, 0, 0, 0, 7108, 7109, 1, 0, 0, 0, 7109,
		7112, 1, 0, 0, 0, 7110, 7111, 5, 1134, 0, 0, 7111, 7113, 3, 592, 296, 0,
		7112, 7110, 1, 0, 0, 0, 7112, 7113, 1, 0, 0, 0, 7113, 7114, 1, 0, 0, 0,
		7114, 7115, 5, 1133, 0, 0, 7115, 7116, 3, 664, 332, 0, 7116, 7142, 1, 0,
		0, 0, 7117, 7118, 7, 125, 0, 0, 7118, 7119, 5, 1132, 0, 0, 7119, 7120,
		3, 690, 345, 0, 7120, 7121, 5, 1133, 0, 0, 7121, 7122, 3, 664, 332, 0,
		7122, 7142, 1, 0, 0, 0, 7123, 7124, 7, 126, 0, 0, 7124, 7125, 5, 1132,
		0, 0, 7125, 7126, 5, 1133, 0, 0, 7126, 7142, 3, 664, 332, 0, 7127, 7128,
		5, 300, 0, 0, 7128, 7129, 5, 1132, 0, 0, 7129, 7130, 3, 690, 345, 0, 7130,
		7131, 5, 1134, 0, 0, 7131, 7132, 3, 592, 296, 0, 7132, 7133, 5, 1133, 0,
		0, 7133, 7134, 3, 664, 332, 0, 7134, 7142, 1, 0, 0, 0, 7135, 7136, 5, 299,
		0, 0, 7136, 7137, 5, 1132, 0, 0, 7137, 7138, 3, 592, 296, 0, 7138, 7139,
		5, 1133, 0, 0, 7139, 7140, 3, 664, 332, 0, 7140, 7142, 1, 0, 0, 0, 7141,
		7103, 1, 0, 0, 0, 7141, 7117, 1, 0, 0, 0, 7141, 7123, 1, 0, 0, 0, 7141,
		7127, 1, 0, 0, 0, 7141, 7135, 1, 0, 0, 0, 7142, 663, 1, 0, 0, 0, 7143,
		7149, 5, 127, 0, 0, 7144, 7145, 5, 1132, 0, 0, 7145, 7146, 3, 666, 333,
		0, 7146, 7147, 5, 1133, 0, 0, 7147, 7150, 1, 0, 0, 0, 7148, 7150, 3, 668,
		334, 0, 7149, 7144, 1, 0, 0, 0, 7149, 7148, 1, 0, 0, 0, 7150, 665, 1, 0,
		0, 0, 7151, 7153, 3, 668, 334, 0, 7152, 7151, 1, 0, 0, 0, 7152, 7153, 1,
		0, 0, 0, 7153, 7155, 1, 0, 0, 0, 7154, 7156, 3, 680, 340, 0, 7155, 7154,
		1, 0, 0, 0, 7155, 7156, 1, 0, 0, 0, 7156, 7158, 1, 0, 0, 0, 7157, 7159,
		3, 230, 115, 0, 7158, 7157, 1, 0, 0, 0, 7158, 7159, 1, 0, 0, 0, 7159, 7161,
		1, 0, 0, 0, 7160, 7162, 3, 670, 335, 0, 7161, 7160, 1, 0, 0, 0, 7161, 7162,
		1, 0, 0, 0, 7162, 667, 1, 0, 0, 0, 7163, 7164, 3, 586, 293, 0, 7164, 669,
		1, 0, 0, 0, 7165, 7166, 3, 672, 336, 0, 7166, 7167, 3, 674, 337, 0, 7167,
		671, 1, 0, 0, 0, 7168, 7169, 7, 127, 0, 0, 7169, 673, 1, 0, 0, 0, 7170,
		7173, 3, 678, 339, 0, 7171, 7173, 3, 676, 338, 0, 7172, 7170, 1, 0, 0,
		0, 7172, 7171, 1, 0, 0, 0, 7173, 675, 1, 0, 0, 0, 7174, 7175, 5, 15, 0,
		0, 7175, 7176, 3, 678, 339, 0, 7176, 7177, 5, 9, 0, 0, 7177, 7178, 3, 678,
		339, 0, 7178, 677, 1, 0, 0, 0, 7179, 7180, 5, 34, 0, 0, 7180, 7187, 5,
		599, 0, 0, 7181, 7182, 5, 656, 0, 0, 7182, 7187, 7, 128, 0, 0, 7183, 7184,
		3, 690, 345, 0, 7184, 7185, 7, 128, 0, 0, 7185, 7187, 1, 0, 0, 0, 7186,
		7179, 1, 0, 0, 0, 7186, 7181, 1, 0, 0, 0, 7186, 7183, 1, 0, 0, 0, 7187,
		679, 1, 0, 0, 0, 7188, 7189, 5, 128, 0, 0, 7189, 7190, 5, 18, 0, 0, 7190,
		7195, 3, 690, 345, 0, 7191, 7192, 5, 1134, 0, 0, 7192, 7194, 3, 690, 345,
		0, 7193, 7191, 1, 0, 0, 0, 7194, 7197, 1, 0, 0, 0, 7195, 7193, 1, 0, 0,
		0, 7195, 7196, 1, 0, 0, 0, 7196, 681, 1, 0, 0, 0, 7197, 7195, 1, 0, 0,
		0, 7198, 7223, 3, 722, 361, 0, 7199, 7223, 5, 746, 0, 0, 7200, 7223, 5,
		316, 0, 0, 7201, 7223, 5, 312, 0, 0, 7202, 7223, 5, 313, 0, 0, 7203, 7223,
		5, 314, 0, 0, 7204, 7223, 5, 317, 0, 0, 7205, 7223, 5, 318, 0, 0, 7206,
		7223, 5, 319, 0, 0, 7207, 7223, 5, 76, 0, 0, 7208, 7223, 5, 84, 0, 0, 7209,
		7223, 5, 315, 0, 0, 7210, 7223, 5, 321, 0, 0, 7211, 7223, 5, 507, 0, 0,
		7212, 7223, 5, 322, 0, 0, 7213, 7223, 5, 139, 0, 0, 7214, 7223, 5, 140,
		0, 0, 7215, 7223, 5, 324, 0, 0, 7216, 7223, 5, 325, 0, 0, 7217, 7223, 5,
		326, 0, 0, 7218, 7223, 5, 327, 0, 0, 7219, 7223, 5, 328, 0, 0, 7220, 7223,
		5, 329, 0, 0, 7221, 7223, 5, 330, 0, 0, 7222, 7198, 1, 0, 0, 0, 7222, 7199,
		1, 0, 0, 0, 7222, 7200, 1, 0, 0, 0, 7222, 7201, 1, 0, 0, 0, 7222, 7202,
		1, 0, 0, 0, 7222, 7203, 1, 0, 0, 0, 7222, 7204, 1, 0, 0, 0, 7222, 7205,
		1, 0, 0, 0, 7222, 7206, 1, 0, 0, 0, 7222, 7207, 1, 0, 0, 0, 7222, 7208,
		1, 0, 0, 0, 7222, 7209, 1, 0, 0, 0, 7222, 7210, 1, 0, 0, 0, 7222, 7211,
		1, 0, 0, 0, 7222, 7212, 1, 0, 0, 0, 7222, 7213, 1, 0, 0, 0, 7222, 7214,
		1, 0, 0, 0, 7222, 7215, 1, 0, 0, 0, 7222, 7216, 1, 0, 0, 0, 7222, 7217,
		1, 0, 0, 0, 7222, 7218, 1, 0, 0, 0, 7222, 7219, 1, 0, 0, 0, 7222, 7220,
		1, 0, 0, 0, 7222, 7221, 1, 0, 0, 0, 7223, 683, 1, 0, 0, 0, 7224, 7225,
		7, 129, 0, 0, 7225, 7226, 5, 1132, 0, 0, 7226, 7227, 3, 688, 344, 0, 7227,
		7228, 5, 1133, 0, 0, 7228, 685, 1, 0, 0, 0, 7229, 7234, 3, 604, 302, 0,
		7230, 7234, 3, 558, 279, 0, 7231, 7234, 3, 650, 325, 0, 7232, 7234, 3,
		690, 345, 0, 7233, 7229, 1, 0, 0, 0, 7233, 7230, 1, 0, 0, 0, 7233, 7231,
		1, 0, 0, 0, 7233, 7232, 1, 0, 0, 0, 7234, 7244, 1, 0, 0, 0, 7235, 7240,
		5, 1134, 0, 0, 7236, 7241, 3, 604, 302, 0, 7237, 7241, 3, 558, 279, 0,
		7238, 7241, 3, 650, 325, 0, 7239, 7241, 3, 690, 345, 0, 7240, 7236, 1,
		0, 0, 0, 7240, 7237, 1, 0, 0, 0, 7240, 7238, 1, 0, 0, 0, 7240, 7239, 1,
		0, 0, 0, 7241, 7243, 1, 0, 0, 0, 7242, 7235, 1, 0, 0, 0, 7243, 7246, 1,
		0, 0, 0, 7244, 7242, 1, 0, 0, 0, 7244, 7245, 1, 0, 0, 0, 7245, 687, 1,
		0, 0, 0, 7246, 7244, 1, 0, 0, 0, 7247, 7252, 3, 604, 302, 0, 7248, 7252,
		3, 558, 279, 0, 7249, 7252, 3, 650, 325, 0, 7250, 7252, 3, 690, 345, 0,
		7251, 7247, 1, 0, 0, 0, 7251, 7248, 1, 0, 0, 0, 7251, 7249, 1, 0, 0, 0,
		7251, 7250, 1, 0, 0, 0, 7252, 689, 1, 0, 0, 0, 7253, 7254, 6, 345, -1,
		0, 7254, 7255, 7, 130, 0, 0, 7255, 7265, 3, 690, 345, 4, 7256, 7257, 3,
		692, 346, 0, 7257, 7259, 5, 87, 0, 0, 7258, 7260, 5, 113, 0, 0, 7259, 7258,
		1, 0, 0, 0, 7259, 7260, 1, 0, 0, 0, 7260, 7261, 1, 0, 0, 0, 7261, 7262,
		7, 131, 0, 0, 7262, 7265, 1, 0, 0, 0, 7263, 7265, 3, 692, 346, 0, 7264,
		7253, 1, 0, 0, 0, 7264, 7256, 1, 0, 0, 0, 7264, 7263, 1, 0, 0, 0, 7265,
		7272, 1, 0, 0, 0, 7266, 7267, 10, 3, 0, 0, 7267, 7268, 3, 700, 350, 0,
		7268, 7269, 3, 690, 345, 4, 7269, 7271, 1, 0, 0, 0, 7270, 7266, 1, 0, 0,
		0, 7271, 7274, 1, 0, 0, 0, 7272, 7270, 1, 0, 0, 0, 7272, 7273, 1, 0, 0,
		0, 7273, 691, 1, 0, 0, 0, 7274, 7272, 1, 0, 0, 0, 7275, 7276, 6, 346, -1,
		0, 7276, 7277, 3, 694, 347, 0, 7277, 7342, 1, 0, 0, 0, 7278, 7279, 10,
		8, 0, 0, 7279, 7280, 3, 698, 349, 0, 7280, 7281, 3, 692, 346, 9, 7281,
		7341, 1, 0, 0, 0, 7282, 7284, 10, 6, 0, 0, 7283, 7285, 5, 113, 0, 0, 7284,
		7283, 1, 0, 0, 0, 7284, 7285, 1, 0, 0, 0, 7285, 7286, 1, 0, 0, 0, 7286,
		7287, 5, 15, 0, 0, 7287, 7288, 3, 692, 346, 0, 7288, 7289, 5, 9, 0, 0,
		7289, 7290, 3, 692, 346, 7, 7290, 7341, 1, 0, 0, 0, 7291, 7292, 10, 5,
		0, 0, 7292, 7293, 5, 619, 0, 0, 7293, 7294, 5, 97, 0, 0, 7294, 7341, 3,
		692, 346, 6, 7295, 7297, 10, 3, 0, 0, 7296, 7298, 5, 113, 0, 0, 7297, 7296,
		1, 0, 0, 0, 7297, 7298, 1, 0, 0, 0, 7298, 7299, 1, 0, 0, 0, 7299, 7300,
		7, 132, 0, 0, 7300, 7341, 3, 692, 346, 4, 7301, 7303, 10, 10, 0, 0, 7302,
		7304, 5, 113, 0, 0, 7303, 7302, 1, 0, 0, 0, 7303, 7304, 1, 0, 0, 0, 7304,
		7305, 1, 0, 0, 0, 7305, 7306, 5, 79, 0, 0, 7306, 7309, 5, 1132, 0, 0, 7307,
		7310, 3, 200, 100, 0, 7308, 7310, 3, 626, 313, 0, 7309, 7307, 1, 0, 0,
		0, 7309, 7308, 1, 0, 0, 0, 7310, 7311, 1, 0, 0, 0, 7311, 7312, 5, 1133,
		0, 0, 7312, 7341, 1, 0, 0, 0, 7313, 7314, 10, 9, 0, 0, 7314, 7315, 5, 87,
		0, 0, 7315, 7341, 3, 602, 301, 0, 7316, 7317, 10, 7, 0, 0, 7317, 7318,
		3, 698, 349, 0, 7318, 7319, 7, 133, 0, 0, 7319, 7320, 5, 1132, 0, 0, 7320,
		7321, 3, 200, 100, 0, 7321, 7322, 5, 1133, 0, 0, 7322, 7341, 1, 0, 0, 0,
		7323, 7325, 10, 4, 0, 0, 7324, 7326, 5, 113, 0, 0, 7325, 7324, 1, 0, 0,
		0, 7325, 7326, 1, 0, 0, 0, 7326, 7327, 1, 0, 0, 0, 7327, 7328, 5, 97, 0,
		0, 7328, 7331, 3, 692, 346, 0, 7329, 7330, 5, 412, 0, 0, 7330, 7332, 5,
		1147, 0, 0, 7331, 7329, 1, 0, 0, 0, 7331, 7332, 1, 0, 0, 0, 7332, 7341,
		1, 0, 0, 0, 7333, 7334, 10, 2, 0, 0, 7334, 7335, 5, 504, 0, 0, 7335, 7336,
		5, 532, 0, 0, 7336, 7337, 5, 1132, 0, 0, 7337, 7338, 3, 692, 346, 0, 7338,
		7339, 5, 1133, 0, 0, 7339, 7341, 1, 0, 0, 0, 7340, 7278, 1, 0, 0, 0, 7340,
		7282, 1, 0, 0, 0, 7340, 7291, 1, 0, 0, 0, 7340, 7295, 1, 0, 0, 0, 7340,
		7301, 1, 0, 0, 0, 7340, 7313, 1, 0, 0, 0, 7340, 7316, 1, 0, 0, 0, 7340,
		7323, 1, 0, 0, 0, 7340, 7333, 1, 0, 0, 0, 7341, 7344, 1, 0, 0, 0, 7342,
		7340, 1, 0, 0, 0, 7342, 7343, 1, 0, 0, 0, 7343, 693, 1, 0, 0, 0, 7344,
		7342, 1, 0, 0, 0, 7345, 7346, 6, 347, -1, 0, 7346, 7394, 3, 604, 302, 0,
		7347, 7394, 3, 558, 279, 0, 7348, 7394, 3, 650, 325, 0, 7349, 7394, 3,
		568, 284, 0, 7350, 7351, 3, 696, 348, 0, 7351, 7352, 3, 694, 347, 12, 7352,
		7394, 1, 0, 0, 0, 7353, 7354, 5, 225, 0, 0, 7354, 7394, 3, 694, 347, 11,
		7355, 7356, 5, 1158, 0, 0, 7356, 7357, 5, 1107, 0, 0, 7357, 7394, 3, 694,
		347, 10, 7358, 7359, 5, 1132, 0, 0, 7359, 7364, 3, 690, 345, 0, 7360, 7361,
		5, 1134, 0, 0, 7361, 7363, 3, 690, 345, 0, 7362, 7360, 1, 0, 0, 0, 7363,
		7366, 1, 0, 0, 0, 7364, 7362, 1, 0, 0, 0, 7364, 7365, 1, 0, 0, 0, 7365,
		7367, 1, 0, 0, 0, 7366, 7364, 1, 0, 0, 0, 7367, 7368, 5, 1133, 0, 0, 7368,
		7394, 1, 0, 0, 0, 7369, 7370, 5, 599, 0, 0, 7370, 7371, 5, 1132, 0, 0,
		7371, 7374, 3, 690, 345, 0, 7372, 7373, 5, 1134, 0, 0, 7373, 7375, 3, 690,
		345, 0, 7374, 7372, 1, 0, 0, 0, 7375, 7376, 1, 0, 0, 0, 7376, 7374, 1,
		0, 0, 0, 7376, 7377, 1, 0, 0, 0, 7377, 7378, 1, 0, 0, 0, 7378, 7379, 5,
		1133, 0, 0, 7379, 7394, 1, 0, 0, 0, 7380, 7381, 5, 59, 0, 0, 7381, 7382,
		5, 1132, 0, 0, 7382, 7383, 3, 200, 100, 0, 7383, 7384, 5, 1133, 0, 0, 7384,
		7394, 1, 0, 0, 0, 7385, 7386, 5, 1132, 0, 0, 7386, 7387, 3, 200, 100, 0,
		7387, 7388, 5, 1133, 0, 0, 7388, 7394, 1, 0, 0, 0, 7389, 7390, 5, 85, 0,
		0, 7390, 7391, 3, 690, 345, 0, 7391, 7392, 3, 72, 36, 0, 7392, 7394, 1,
		0, 0, 0, 7393, 7345, 1, 0, 0, 0, 7393, 7347, 1, 0, 0, 0, 7393, 7348, 1,
		0, 0, 0, 7393, 7349, 1, 0, 0, 0, 7393, 7350, 1, 0, 0, 0, 7393, 7353, 1,
		0, 0, 0, 7393, 7355, 1, 0, 0, 0, 7393, 7358, 1, 0, 0, 0, 7393, 7369, 1,
		0, 0, 0, 7393, 7380, 1, 0, 0, 0, 7393, 7385, 1, 0, 0, 0, 7393, 7389, 1,
		0, 0, 0, 7394, 7416, 1, 0, 0, 0, 7395, 7396, 10, 4, 0, 0, 7396, 7397, 3,
		702, 351, 0, 7397, 7398, 3, 694, 347, 5, 7398, 7415, 1, 0, 0, 0, 7399,
		7400, 10, 3, 0, 0, 7400, 7401, 3, 704, 352, 0, 7401, 7402, 3, 694, 347,
		4, 7402, 7415, 1, 0, 0, 0, 7403, 7404, 10, 2, 0, 0, 7404, 7405, 3, 706,
		353, 0, 7405, 7406, 3, 694, 347, 3, 7406, 7415, 1, 0, 0, 0, 7407, 7408,
		10, 1, 0, 0, 7408, 7409, 3, 708, 354, 0, 7409, 7410, 3, 694, 347, 2, 7410,
		7415, 1, 0, 0, 0, 7411, 7412, 10, 14, 0, 0, 7412, 7413, 5, 26, 0, 0, 7413,
		7415, 3, 572, 286, 0, 7414, 7395, 1, 0, 0, 0, 7414, 7399, 1, 0, 0, 0, 7414,
		7403, 1, 0, 0, 0, 7414, 7407, 1, 0, 0, 0, 7414, 7411, 1, 0, 0, 0, 7415,
		7418, 1, 0, 0, 0, 7416, 7414, 1, 0, 0, 0, 7416, 7417, 1, 0, 0, 0, 7417,
		695, 1, 0, 0, 0, 7418, 7416, 1, 0, 0, 0, 7419, 7420, 7, 134, 0, 0, 7420,
		697, 1, 0, 0, 0, 7421, 7436, 5, 1123, 0, 0, 7422, 7436, 5, 1124, 0, 0,
		7423, 7436, 5, 1125, 0, 0, 7424, 7425, 5, 1125, 0, 0, 7425, 7436, 5, 1123,
		0, 0, 7426, 7427, 5, 1124, 0, 0, 7427, 7436, 5, 1123, 0, 0, 7428, 7429,
		5, 1125, 0, 0, 7429, 7436, 5, 1124, 0, 0, 7430, 7431, 5, 1126, 0, 0, 7431,
		7436, 5, 1123, 0, 0, 7432, 7433, 5, 1125, 0, 0, 7433, 7434, 5, 1123, 0,
		0, 7434, 7436, 5, 1124, 0, 0, 7435, 7421, 1, 0, 0, 0, 7435, 7422, 1, 0,
		0, 0, 7435, 7423, 1, 0, 0, 0, 7435, 7424, 1, 0, 0, 0, 7435, 7426, 1, 0,
		0, 0, 7435, 7428, 1, 0, 0, 0, 7435, 7430, 1, 0, 0, 0, 7435, 7432, 1, 0,
		0, 0, 7436, 699, 1, 0, 0, 0, 7437, 7445, 5, 9, 0, 0, 7438, 7439, 5, 1129,
		0, 0, 7439, 7445, 5, 1129, 0, 0, 7440, 7445, 5, 193, 0, 0, 7441, 7445,
		5, 122, 0, 0, 7442, 7443, 5, 1128, 0, 0, 7443, 7445, 5, 1128, 0, 0, 7444,
		7437, 1, 0, 0, 0, 7444, 7438, 1, 0, 0, 0, 7444, 7440, 1, 0, 0, 0, 7444,
		7441, 1, 0, 0, 0, 7444, 7442, 1, 0, 0, 0, 7445, 701, 1, 0, 0, 0, 7446,
		7447, 5, 1125, 0, 0, 7447, 7454, 5, 1125, 0, 0, 7448, 7449, 5, 1124, 0,
		0, 7449, 7454, 5, 1124, 0, 0, 7450, 7454, 5, 1129, 0, 0, 7451, 7454, 5,
		1130, 0, 0, 7452, 7454, 5, 1128, 0, 0, 7453, 7446, 1, 0, 0, 0, 7453, 7448,
		1, 0, 0, 0, 7453, 7450, 1, 0, 0, 0, 7453, 7451, 1, 0, 0, 0, 7453, 7452,
		1, 0, 0, 0, 7454, 703, 1, 0, 0, 0, 7455, 7456, 7, 135, 0, 0, 7456, 705,
		1, 0, 0, 0, 7457, 7458, 7, 136, 0, 0, 7458, 707, 1, 0, 0, 0, 7459, 7460,
		5, 1120, 0, 0, 7460, 7465, 5, 1124, 0, 0, 7461, 7462, 5, 1120, 0, 0, 7462,
		7463, 5, 1124, 0, 0, 7463, 7465, 5, 1124, 0, 0, 7464, 7459, 1, 0, 0, 0,
		7464, 7461, 1, 0, 0, 0, 7465, 709, 1, 0, 0, 0, 7466, 7467, 7, 137, 0, 0,
		7467, 711, 1, 0, 0, 0, 7468, 7469, 7, 138, 0, 0, 7469, 713, 1, 0, 0, 0,
		7470, 7471, 7, 139, 0, 0, 7471, 715, 1, 0, 0, 0, 7472, 7473, 7, 140, 0,
		0, 7473, 717, 1, 0, 0, 0, 7474, 7475, 7, 141, 0, 0, 7475, 719, 1, 0, 0,
		0, 7476, 7477, 7, 142, 0, 0, 7477, 721, 1, 0, 0, 0, 7478, 7479, 7, 143,
		0, 0, 7479, 723, 1, 0, 0, 0, 1096, 725, 729, 736, 739, 742, 744, 750, 753,
		756, 765, 807, 822, 833, 850, 855, 870, 897, 906, 911, 917, 922, 926, 935,
		938, 941, 945, 952, 955, 960, 968, 973, 978, 981, 983, 995, 998, 1002,
		1005, 1009, 1012, 1016, 1019, 1022, 1026, 1029, 1033, 1039, 1045, 1051,
		1058, 1065, 1068, 1072, 1077, 1083, 1092, 1097, 1102, 1109, 1126, 1133,
		1137, 1147, 1151, 1155, 1159, 1163, 1168, 1171, 1174, 1177, 1180, 1186,
		1190, 1196, 1201, 1204, 1207, 1209, 1220, 1224, 1227, 1241, 1244, 1248,
		1251, 1255, 1258, 1262, 1265, 1269, 1272, 1275, 1279, 1282, 1286, 1292,
		1305, 1311, 1322, 1327, 1335, 1343, 1348, 1351, 1356, 1364, 1369, 1375,
		1380, 1384, 1386, 1389, 1393, 1397, 1400, 1404, 1408, 1412, 1418, 1421,
		1428, 1433, 1439, 1446, 1452, 1460, 1463, 1470, 1473, 1475, 1481, 1487,
		1504, 1511, 1518, 1530, 1535, 1538, 1541, 1554, 1567, 1572, 1588, 1596,
		1606, 1609, 1612, 1618, 1622, 1625, 1636, 1639, 1644, 1657, 1664, 1671,
		1673, 1680, 1684, 1686, 1691, 1694, 1700, 1705, 1707, 1711, 1714, 1717,
		1723, 1728, 1730, 1735, 1742, 1744, 1751, 1756, 1760, 1763, 1771, 1779,
		1781, 1791, 1795, 1798, 1804, 1809, 1812, 1818, 1821, 1825, 1828, 1832,
		1837, 1842, 1847, 1851, 1855, 1859, 1863, 1867, 1871, 1876, 1881, 1886,
		1892, 1897, 1902, 1907, 1912, 1917, 1923, 1928, 1933, 1938, 1943, 1948,
		1953, 1958, 1965, 1970, 1975, 1980, 1984, 1989, 1997, 2002, 2008, 2020,
		2027, 2029, 2037, 2042, 2045, 2053, 2059, 2063, 2076, 2088, 2090, 2093,
		2101, 2107, 2113, 2126, 2133, 2142, 2147, 2158, 2167, 2172, 2184, 2191,
		2200, 2205, 2217, 2224, 2233, 2238, 2245, 2254, 2259, 2261, 2266, 2274,
		2283, 2287, 2290, 2294, 2299, 2305, 2311, 2316, 2321, 2326, 2331, 2334,
		2339, 2344, 2354, 2358, 2365, 2370, 2373, 2378, 2381, 2385, 2389, 2397,
		2416, 2419, 2422, 2426, 2436, 2449, 2456, 2459, 2464, 2471, 2474, 2477,
		2488, 2491, 2495, 2503, 2506, 2511, 2519, 2525, 2529, 2533, 2538, 2543,
		2550, 2554, 2565, 2573, 2576, 2582, 2588, 2590, 2595, 2598, 2604, 2610,
		2612, 2616, 2619, 2622, 2628, 2634, 2637, 2643, 2649, 2651, 2656, 2664,
		2666, 2675, 2678, 2681, 2686, 2688, 2697, 2700, 2703, 2708, 2710, 2719,
		2724, 2732, 2736, 2744, 2754, 2759, 2766, 2770, 2774, 2793, 2803, 2809,
		2826, 2830, 2840, 2845, 2848, 2857, 2868, 2876, 2882, 2892, 2904, 2911,
		2918, 2933, 2946, 2952, 2958, 2964, 2970, 2976, 2982, 2987, 2994, 3001,
		3008, 3013, 3016, 3018, 3032, 3039, 3046, 3052, 3056, 3060, 3067, 3070,
		3075, 3082, 3089, 3093, 3098, 3105, 3118, 3121, 3126, 3131, 3135, 3141,
		3150, 3159, 3168, 3171, 3175, 3184, 3188, 3191, 3194, 3197, 3203, 3206,
		3210, 3213, 3217, 3220, 3228, 3231, 3242, 3245, 3250, 3253, 3258, 3268,
		3273, 3279, 3281, 3287, 3289, 3295, 3303, 3308, 3316, 3319, 3324, 3327,
		3332, 3340, 3348, 3354, 3362, 3367, 3375, 3378, 3382, 3385, 3393, 3399,
		3408, 3411, 3415, 3419, 3423, 3428, 3432, 3436, 3438, 3441, 3444, 3447,
		3453, 3457, 3460, 3463, 3466, 3469, 3476, 3478, 3482, 3487, 3493, 3498,
		3505, 3511, 3516, 3519, 3525, 3529, 3537, 3541, 3544, 3547, 3550, 3555,
		3558, 3565, 3569, 3572, 3576, 3580, 3583, 3586, 3589, 3594, 3600, 3604,
		3614, 3620, 3624, 3630, 3634, 3640, 3643, 3655, 3659, 3663, 3671, 3675,
		3683, 3686, 3689, 3693, 3696, 3704, 3709, 3712, 3715, 3719, 3722, 3725,
		3734, 3739, 3748, 3753, 3760, 3767, 3775, 3781, 3789, 3792, 3795, 3802,
		3805, 3812, 3815, 3823, 3829, 3840, 3843, 3847, 3853, 3862, 3867, 3871,
		3877, 3883, 3885, 3889, 3898, 3908, 3918, 3922, 3927, 3932, 3936, 3939,
		3942, 3945, 3948, 3952, 3957, 3963, 3966, 3969, 3972, 3975, 3978, 3980,
		3988, 3994, 3997, 4000, 4003, 4006, 4009, 4013, 4019, 4023, 4031, 4035,
		4038, 4040, 4053, 4056, 4063, 4073, 4076, 4081, 4083, 4087, 4095, 4101,
		4110, 4123, 4127, 4133, 4142, 4145, 4149, 4152, 4156, 4160, 4163, 4165,
		4173, 4185, 4191, 4193, 4199, 4201, 4203, 4209, 4217, 4225, 4229, 4233,
		4242, 4247, 4267, 4272, 4278, 4285, 4290, 4299, 4302, 4306, 4309, 4313,
		4317, 4320, 4323, 4326, 4329, 4333, 4337, 4340, 4343, 4346, 4349, 4356,
		4360, 4375, 4379, 4391, 4399, 4409, 4413, 4416, 4422, 4425, 4428, 4437,
		4446, 4456, 4460, 4470, 4480, 4488, 4491, 4500, 4503, 4507, 4512, 4516,
		4525, 4528, 4559, 4562, 4565, 4621, 4626, 4654, 4668, 4675, 4679, 4685,
		4693, 4695, 4706, 4716, 4723, 4729, 4737, 4742, 4750, 4758, 4766, 4774,
		4780, 4785, 4790, 4795, 4801, 4803, 4814, 4819, 4826, 4828, 4842, 4848,
		4853, 4858, 4864, 4871, 4879, 4887, 4892, 4898, 4901, 4909, 4916, 4925,
		4928, 4945, 4953, 4961, 4965, 4972, 4978, 4986, 4995, 5001, 5008, 5015,
		5020, 5023, 5025, 5031, 5033, 5037, 5039, 5046, 5051, 5055, 5061, 5070,
		5076, 5083, 5089, 5095, 5100, 5103, 5105, 5111, 5113, 5117, 5119, 5126,
		5128, 5133, 5140, 5149, 5154, 5163, 5170, 5175, 5178, 5180, 5186, 5188,
		5191, 5199, 5204, 5209, 5213, 5219, 5224, 5228, 5234, 5236, 5247, 5250,
		5257, 5260, 5272, 5278, 5287, 5296, 5301, 5310, 5316, 5327, 5333, 5338,
		5342, 5348, 5353, 5357, 5360, 5372, 5379, 5384, 5414, 5418, 5423, 5430,
		5433, 5439, 5449, 5459, 5469, 5475, 5484, 5490, 5497, 5499, 5509, 5513,
		5517, 5527, 5532, 5604, 5622, 5630, 5642, 5649, 5651, 5661, 5664, 5672,
		5679, 5683, 5690, 5695, 5698, 5701, 5710, 5714, 5718, 5741, 5748, 5752,
		5759, 5766, 5769, 5785, 5788, 5798, 5802, 5808, 5811, 5816, 5820, 5827,
		5830, 5836, 5860, 5863, 5875, 5878, 5888, 5896, 5900, 5907, 5910, 5919,
		5925, 5931, 5941, 5943, 5949, 5952, 5955, 5967, 5970, 5976, 5979, 5987,
		5995, 6001, 6005, 6019, 6031, 6038, 6041, 6048, 6055, 6060, 6073, 6084,
		6090, 6095, 6108, 6110, 6115, 6119, 6122, 6124, 6131, 6138, 6141, 6144,
		6150, 6154, 6160, 6166, 6179, 6184, 6192, 6195, 6200, 6205, 6213, 6216,
		6224, 6228, 6235, 6241, 6244, 6248, 6261, 6267, 6279, 6282, 6291, 6296,
		6302, 6308, 6313, 6315, 6318, 6322, 6324, 6328, 6334, 6337, 6340, 6346,
		6355, 6363, 6367, 6372, 6392, 6399, 6401, 6408, 6410, 6414, 6419, 6430,
		6435, 6441, 6444, 6448, 6453, 6456, 6460, 6464, 6466, 6471, 6476, 6489,
		6492, 6496, 6499, 6502, 6507, 6512, 6518, 6521, 6526, 6529, 6534, 6537,
		6541, 6546, 6551, 6556, 6561, 6564, 6569, 6574, 6579, 6585, 6590, 6595,
		6600, 6604, 6607, 6612, 6616, 6620, 6628, 6635, 6639, 6644, 6649, 6653,
		6655, 6658, 6674, 6683, 6691, 6699, 6708, 6718, 6726, 6734, 6742, 6750,
		6762, 6769, 6779, 6784, 6787, 6792, 6795, 6799, 6814, 6822, 6829, 6834,
		6839, 6873, 6877, 6885, 6889, 6898, 6906, 6911, 6919, 6924, 6929, 6931,
		6940, 6945, 6953, 6958, 6966, 6974, 6977, 6987, 7005, 7008, 7011, 7015,
		7028, 7036, 7040, 7045, 7050, 7056, 7061, 7065, 7070, 7075, 7080, 7090,
		7093, 7097, 7101, 7108, 7112, 7141, 7149, 7152, 7155, 7158, 7161, 7172,
		7186, 7195, 7222, 7233, 7240, 7244, 7251, 7259, 7264, 7272, 7284, 7297,
		7303, 7309, 7325, 7331, 7340, 7342, 7364, 7376, 7393, 7414, 7416, 7435,
		7444, 7453, 7464,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MySqlParserInit initializes any static state used to implement MySqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMySqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MySqlParserInit() {
	staticData := &MySqlParserParserStaticData
	staticData.once.Do(mysqlparserParserInit)
}

// NewMySqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMySqlParser(input antlr.TokenStream) *MySqlParser {
	MySqlParserInit()
	this := new(MySqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &MySqlParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "MySqlParser.g4"

	return this
}

// MySqlParser tokens.
const (
	MySqlParserEOF                               = antlr.TokenEOF
	MySqlParserPROXY_HINT                        = 1
	MySqlParserSPACE                             = 2
	MySqlParserLINE_COMMENT                      = 3
	MySqlParserADD                               = 4
	MySqlParserALL                               = 5
	MySqlParserALTER                             = 6
	MySqlParserALWAYS                            = 7
	MySqlParserANALYZE                           = 8
	MySqlParserAND                               = 9
	MySqlParserARRAY                             = 10
	MySqlParserAS                                = 11
	MySqlParserASC                               = 12
	MySqlParserATTRIBUTE                         = 13
	MySqlParserBEFORE                            = 14
	MySqlParserBETWEEN                           = 15
	MySqlParserBOTH                              = 16
	MySqlParserBUCKETS                           = 17
	MySqlParserBY                                = 18
	MySqlParserCALL                              = 19
	MySqlParserCASCADE                           = 20
	MySqlParserCASE                              = 21
	MySqlParserCAST                              = 22
	MySqlParserCHANGE                            = 23
	MySqlParserCHARACTER                         = 24
	MySqlParserCHECK                             = 25
	MySqlParserCOLLATE                           = 26
	MySqlParserCOLUMN                            = 27
	MySqlParserCONDITION                         = 28
	MySqlParserCONSTRAINT                        = 29
	MySqlParserCONTINUE                          = 30
	MySqlParserCONVERT                           = 31
	MySqlParserCREATE                            = 32
	MySqlParserCROSS                             = 33
	MySqlParserCURRENT                           = 34
	MySqlParserCURRENT_ROLE                      = 35
	MySqlParserCURRENT_USER                      = 36
	MySqlParserCURSOR                            = 37
	MySqlParserDATABASE                          = 38
	MySqlParserDATABASES                         = 39
	MySqlParserDECLARE                           = 40
	MySqlParserDEFAULT                           = 41
	MySqlParserDELAYED                           = 42
	MySqlParserDELETE                            = 43
	MySqlParserDESC                              = 44
	MySqlParserDESCRIBE                          = 45
	MySqlParserDETERMINISTIC                     = 46
	MySqlParserDIAGNOSTICS                       = 47
	MySqlParserDISTINCT                          = 48
	MySqlParserDISTINCTROW                       = 49
	MySqlParserDROP                              = 50
	MySqlParserEACH                              = 51
	MySqlParserELSE                              = 52
	MySqlParserELSEIF                            = 53
	MySqlParserEMPTY                             = 54
	MySqlParserENCLOSED                          = 55
	MySqlParserENFORCED                          = 56
	MySqlParserESCAPED                           = 57
	MySqlParserEXCEPT                            = 58
	MySqlParserEXISTS                            = 59
	MySqlParserEXIT                              = 60
	MySqlParserEXPLAIN                           = 61
	MySqlParserFALSE                             = 62
	MySqlParserFETCH                             = 63
	MySqlParserFOR                               = 64
	MySqlParserFORCE                             = 65
	MySqlParserFOREIGN                           = 66
	MySqlParserFROM                              = 67
	MySqlParserFULLTEXT                          = 68
	MySqlParserGENERATED                         = 69
	MySqlParserGET                               = 70
	MySqlParserGRANT                             = 71
	MySqlParserGROUP                             = 72
	MySqlParserHAVING                            = 73
	MySqlParserHIGH_PRIORITY                     = 74
	MySqlParserHISTOGRAM                         = 75
	MySqlParserIF                                = 76
	MySqlParserIGNORE                            = 77
	MySqlParserIGNORED                           = 78
	MySqlParserIN                                = 79
	MySqlParserINDEX                             = 80
	MySqlParserINFILE                            = 81
	MySqlParserINNER                             = 82
	MySqlParserINOUT                             = 83
	MySqlParserINSERT                            = 84
	MySqlParserINTERVAL                          = 85
	MySqlParserINTO                              = 86
	MySqlParserIS                                = 87
	MySqlParserITERATE                           = 88
	MySqlParserJOIN                              = 89
	MySqlParserKEY                               = 90
	MySqlParserKEYS                              = 91
	MySqlParserKILL                              = 92
	MySqlParserLATERAL                           = 93
	MySqlParserLEADING                           = 94
	MySqlParserLEAVE                             = 95
	MySqlParserLEFT                              = 96
	MySqlParserLIKE                              = 97
	MySqlParserLIMIT                             = 98
	MySqlParserLINEAR                            = 99
	MySqlParserLINES                             = 100
	MySqlParserLOAD                              = 101
	MySqlParserLOCK                              = 102
	MySqlParserLOCKED                            = 103
	MySqlParserLOOP                              = 104
	MySqlParserLOW_PRIORITY                      = 105
	MySqlParserMASTER_BIND                       = 106
	MySqlParserMASTER_SSL_VERIFY_SERVER_CERT     = 107
	MySqlParserMATCH                             = 108
	MySqlParserMAXVALUE                          = 109
	MySqlParserMINVALUE                          = 110
	MySqlParserMODIFIES                          = 111
	MySqlParserNATURAL                           = 112
	MySqlParserNOT                               = 113
	MySqlParserNO_WRITE_TO_BINLOG                = 114
	MySqlParserNULL_LITERAL                      = 115
	MySqlParserNUMBER                            = 116
	MySqlParserON                                = 117
	MySqlParserOPTIMIZE                          = 118
	MySqlParserOPTION                            = 119
	MySqlParserOPTIONAL                          = 120
	MySqlParserOPTIONALLY                        = 121
	MySqlParserOR                                = 122
	MySqlParserORDER                             = 123
	MySqlParserOUT                               = 124
	MySqlParserOUTER                             = 125
	MySqlParserOUTFILE                           = 126
	MySqlParserOVER                              = 127
	MySqlParserPARTITION                         = 128
	MySqlParserPRIMARY                           = 129
	MySqlParserPROCEDURE                         = 130
	MySqlParserPURGE                             = 131
	MySqlParserRANGE                             = 132
	MySqlParserREAD                              = 133
	MySqlParserREADS                             = 134
	MySqlParserREFERENCES                        = 135
	MySqlParserREGEXP                            = 136
	MySqlParserRELEASE                           = 137
	MySqlParserRENAME                            = 138
	MySqlParserREPEAT                            = 139
	MySqlParserREPLACE                           = 140
	MySqlParserREQUIRE                           = 141
	MySqlParserRESIGNAL                          = 142
	MySqlParserRESTRICT                          = 143
	MySqlParserRETAIN                            = 144
	MySqlParserRETURN                            = 145
	MySqlParserREVOKE                            = 146
	MySqlParserRIGHT                             = 147
	MySqlParserRLIKE                             = 148
	MySqlParserSCHEMA                            = 149
	MySqlParserSCHEMAS                           = 150
	MySqlParserSELECT                            = 151
	MySqlParserSET                               = 152
	MySqlParserSEPARATOR                         = 153
	MySqlParserSHOW                              = 154
	MySqlParserSIGNAL                            = 155
	MySqlParserSKIP_                             = 156
	MySqlParserSKIP_QUERY_REWRITE                = 157
	MySqlParserSPATIAL                           = 158
	MySqlParserSQL                               = 159
	MySqlParserSQLEXCEPTION                      = 160
	MySqlParserSQLSTATE                          = 161
	MySqlParserSQLWARNING                        = 162
	MySqlParserSQL_BIG_RESULT                    = 163
	MySqlParserSQL_CALC_FOUND_ROWS               = 164
	MySqlParserSQL_SMALL_RESULT                  = 165
	MySqlParserSSL                               = 166
	MySqlParserSTACKED                           = 167
	MySqlParserSTARTING                          = 168
	MySqlParserSTATEMENT                         = 169
	MySqlParserSTRAIGHT_JOIN                     = 170
	MySqlParserTABLE                             = 171
	MySqlParserTERMINATED                        = 172
	MySqlParserTHEN                              = 173
	MySqlParserTO                                = 174
	MySqlParserTRAILING                          = 175
	MySqlParserTRIGGER                           = 176
	MySqlParserTRUE                              = 177
	MySqlParserUNDO                              = 178
	MySqlParserUNION                             = 179
	MySqlParserUNIQUE                            = 180
	MySqlParserUNLOCK                            = 181
	MySqlParserUNSIGNED                          = 182
	MySqlParserUPDATE                            = 183
	MySqlParserUSAGE                             = 184
	MySqlParserUSE                               = 185
	MySqlParserUSING                             = 186
	MySqlParserVALUES                            = 187
	MySqlParserWHEN                              = 188
	MySqlParserWHERE                             = 189
	MySqlParserWHILE                             = 190
	MySqlParserWITH                              = 191
	MySqlParserWRITE                             = 192
	MySqlParserXOR                               = 193
	MySqlParserZEROFILL                          = 194
	MySqlParserTINYINT                           = 195
	MySqlParserSMALLINT                          = 196
	MySqlParserMEDIUMINT                         = 197
	MySqlParserMIDDLEINT                         = 198
	MySqlParserINT                               = 199
	MySqlParserINT1                              = 200
	MySqlParserINT2                              = 201
	MySqlParserINT3                              = 202
	MySqlParserINT4                              = 203
	MySqlParserINT8                              = 204
	MySqlParserINTEGER                           = 205
	MySqlParserBIGINT                            = 206
	MySqlParserREAL                              = 207
	MySqlParserDOUBLE                            = 208
	MySqlParserPRECISION                         = 209
	MySqlParserFLOAT                             = 210
	MySqlParserFLOAT4                            = 211
	MySqlParserFLOAT8                            = 212
	MySqlParserDECIMAL                           = 213
	MySqlParserDEC                               = 214
	MySqlParserNUMERIC                           = 215
	MySqlParserDATE                              = 216
	MySqlParserTIME                              = 217
	MySqlParserTIMESTAMP                         = 218
	MySqlParserDATETIME                          = 219
	MySqlParserYEAR                              = 220
	MySqlParserCHAR                              = 221
	MySqlParserVARCHAR                           = 222
	MySqlParserNVARCHAR                          = 223
	MySqlParserNATIONAL                          = 224
	MySqlParserBINARY                            = 225
	MySqlParserVARBINARY                         = 226
	MySqlParserTINYBLOB                          = 227
	MySqlParserBLOB                              = 228
	MySqlParserMEDIUMBLOB                        = 229
	MySqlParserLONG                              = 230
	MySqlParserLONGBLOB                          = 231
	MySqlParserTINYTEXT                          = 232
	MySqlParserTEXT                              = 233
	MySqlParserMEDIUMTEXT                        = 234
	MySqlParserLONGTEXT                          = 235
	MySqlParserENUM                              = 236
	MySqlParserVARYING                           = 237
	MySqlParserSERIAL                            = 238
	MySqlParserYEAR_MONTH                        = 239
	MySqlParserDAY_HOUR                          = 240
	MySqlParserDAY_MINUTE                        = 241
	MySqlParserDAY_SECOND                        = 242
	MySqlParserHOUR_MINUTE                       = 243
	MySqlParserHOUR_SECOND                       = 244
	MySqlParserMINUTE_SECOND                     = 245
	MySqlParserSECOND_MICROSECOND                = 246
	MySqlParserMINUTE_MICROSECOND                = 247
	MySqlParserHOUR_MICROSECOND                  = 248
	MySqlParserDAY_MICROSECOND                   = 249
	MySqlParserJSON_ARRAY                        = 250
	MySqlParserJSON_ARRAYAGG                     = 251
	MySqlParserJSON_ARRAY_APPEND                 = 252
	MySqlParserJSON_ARRAY_INSERT                 = 253
	MySqlParserJSON_CONTAINS                     = 254
	MySqlParserJSON_CONTAINS_PATH                = 255
	MySqlParserJSON_DEPTH                        = 256
	MySqlParserJSON_EXTRACT                      = 257
	MySqlParserJSON_INSERT                       = 258
	MySqlParserJSON_KEYS                         = 259
	MySqlParserJSON_LENGTH                       = 260
	MySqlParserJSON_MERGE                        = 261
	MySqlParserJSON_MERGE_PATCH                  = 262
	MySqlParserJSON_MERGE_PRESERVE               = 263
	MySqlParserJSON_OBJECT                       = 264
	MySqlParserJSON_OBJECTAGG                    = 265
	MySqlParserJSON_OVERLAPS                     = 266
	MySqlParserJSON_PRETTY                       = 267
	MySqlParserJSON_QUOTE                        = 268
	MySqlParserJSON_REMOVE                       = 269
	MySqlParserJSON_REPLACE                      = 270
	MySqlParserJSON_SCHEMA_VALID                 = 271
	MySqlParserJSON_SCHEMA_VALIDATION_REPORT     = 272
	MySqlParserJSON_SEARCH                       = 273
	MySqlParserJSON_SET                          = 274
	MySqlParserJSON_STORAGE_FREE                 = 275
	MySqlParserJSON_STORAGE_SIZE                 = 276
	MySqlParserJSON_TABLE                        = 277
	MySqlParserJSON_TYPE                         = 278
	MySqlParserJSON_UNQUOTE                      = 279
	MySqlParserJSON_VALID                        = 280
	MySqlParserJSON_VALUE                        = 281
	MySqlParserNESTED                            = 282
	MySqlParserORDINALITY                        = 283
	MySqlParserPATH                              = 284
	MySqlParserAVG                               = 285
	MySqlParserBIT_AND                           = 286
	MySqlParserBIT_OR                            = 287
	MySqlParserBIT_XOR                           = 288
	MySqlParserCOUNT                             = 289
	MySqlParserCUME_DIST                         = 290
	MySqlParserDENSE_RANK                        = 291
	MySqlParserFIRST_VALUE                       = 292
	MySqlParserGROUP_CONCAT                      = 293
	MySqlParserLAG                               = 294
	MySqlParserLAST_VALUE                        = 295
	MySqlParserLEAD                              = 296
	MySqlParserMAX                               = 297
	MySqlParserMIN                               = 298
	MySqlParserNTILE                             = 299
	MySqlParserNTH_VALUE                         = 300
	MySqlParserPERCENT_RANK                      = 301
	MySqlParserRANK                              = 302
	MySqlParserROW_NUMBER                        = 303
	MySqlParserSTD                               = 304
	MySqlParserSTDDEV                            = 305
	MySqlParserSTDDEV_POP                        = 306
	MySqlParserSTDDEV_SAMP                       = 307
	MySqlParserSUM                               = 308
	MySqlParserVAR_POP                           = 309
	MySqlParserVAR_SAMP                          = 310
	MySqlParserVARIANCE                          = 311
	MySqlParserCURRENT_DATE                      = 312
	MySqlParserCURRENT_TIME                      = 313
	MySqlParserCURRENT_TIMESTAMP                 = 314
	MySqlParserLOCALTIME                         = 315
	MySqlParserCURDATE                           = 316
	MySqlParserCURTIME                           = 317
	MySqlParserDATE_ADD                          = 318
	MySqlParserDATE_SUB                          = 319
	MySqlParserEXTRACT                           = 320
	MySqlParserLOCALTIMESTAMP                    = 321
	MySqlParserNOW                               = 322
	MySqlParserPOSITION                          = 323
	MySqlParserSUBSTR                            = 324
	MySqlParserSUBSTRING                         = 325
	MySqlParserSYSDATE                           = 326
	MySqlParserTRIM                              = 327
	MySqlParserUTC_DATE                          = 328
	MySqlParserUTC_TIME                          = 329
	MySqlParserUTC_TIMESTAMP                     = 330
	MySqlParserACCOUNT                           = 331
	MySqlParserACTION                            = 332
	MySqlParserAFTER                             = 333
	MySqlParserAGGREGATE                         = 334
	MySqlParserALGORITHM                         = 335
	MySqlParserANY                               = 336
	MySqlParserAT                                = 337
	MySqlParserAUTHORS                           = 338
	MySqlParserAUTOCOMMIT                        = 339
	MySqlParserAUTOEXTEND_SIZE                   = 340
	MySqlParserAUTO_INCREMENT                    = 341
	MySqlParserAVG_ROW_LENGTH                    = 342
	MySqlParserBEGIN                             = 343
	MySqlParserBINLOG                            = 344
	MySqlParserBIT                               = 345
	MySqlParserBLOCK                             = 346
	MySqlParserBOOL                              = 347
	MySqlParserBOOLEAN                           = 348
	MySqlParserBTREE                             = 349
	MySqlParserCACHE                             = 350
	MySqlParserCASCADED                          = 351
	MySqlParserCHAIN                             = 352
	MySqlParserCHANGED                           = 353
	MySqlParserCHANNEL                           = 354
	MySqlParserCHECKSUM                          = 355
	MySqlParserPAGE_CHECKSUM                     = 356
	MySqlParserCIPHER                            = 357
	MySqlParserCLASS_ORIGIN                      = 358
	MySqlParserCLIENT                            = 359
	MySqlParserCLOSE                             = 360
	MySqlParserCLUSTERING                        = 361
	MySqlParserCOALESCE                          = 362
	MySqlParserCODE                              = 363
	MySqlParserCOLUMNS                           = 364
	MySqlParserCOLUMN_FORMAT                     = 365
	MySqlParserCOLUMN_NAME                       = 366
	MySqlParserCOMMENT                           = 367
	MySqlParserCOMMIT                            = 368
	MySqlParserCOMPACT                           = 369
	MySqlParserCOMPLETION                        = 370
	MySqlParserCOMPRESSED                        = 371
	MySqlParserCOMPRESSION                       = 372
	MySqlParserCONCURRENT                        = 373
	MySqlParserCONNECT                           = 374
	MySqlParserCONNECTION                        = 375
	MySqlParserCONSISTENT                        = 376
	MySqlParserCONSTRAINT_CATALOG                = 377
	MySqlParserCONSTRAINT_SCHEMA                 = 378
	MySqlParserCONSTRAINT_NAME                   = 379
	MySqlParserCONTAINS                          = 380
	MySqlParserCONTEXT                           = 381
	MySqlParserCONTRIBUTORS                      = 382
	MySqlParserCOPY                              = 383
	MySqlParserCPU                               = 384
	MySqlParserCYCLE                             = 385
	MySqlParserCURSOR_NAME                       = 386
	MySqlParserDATA                              = 387
	MySqlParserDATAFILE                          = 388
	MySqlParserDEALLOCATE                        = 389
	MySqlParserDEFAULT_AUTH                      = 390
	MySqlParserDEFINER                           = 391
	MySqlParserDELAY_KEY_WRITE                   = 392
	MySqlParserDES_KEY_FILE                      = 393
	MySqlParserDIRECTORY                         = 394
	MySqlParserDISABLE                           = 395
	MySqlParserDISCARD                           = 396
	MySqlParserDISK                              = 397
	MySqlParserDO                                = 398
	MySqlParserDUMPFILE                          = 399
	MySqlParserDUPLICATE                         = 400
	MySqlParserDYNAMIC                           = 401
	MySqlParserENABLE                            = 402
	MySqlParserENCRYPTED                         = 403
	MySqlParserENCRYPTION                        = 404
	MySqlParserENCRYPTION_KEY_ID                 = 405
	MySqlParserEND                               = 406
	MySqlParserENDS                              = 407
	MySqlParserENGINE                            = 408
	MySqlParserENGINES                           = 409
	MySqlParserERROR                             = 410
	MySqlParserERRORS                            = 411
	MySqlParserESCAPE                            = 412
	MySqlParserEVEN                              = 413
	MySqlParserEVENT                             = 414
	MySqlParserEVENTS                            = 415
	MySqlParserEVERY                             = 416
	MySqlParserEXCHANGE                          = 417
	MySqlParserEXCLUSIVE                         = 418
	MySqlParserEXPIRE                            = 419
	MySqlParserEXPORT                            = 420
	MySqlParserEXTENDED                          = 421
	MySqlParserEXTENT_SIZE                       = 422
	MySqlParserFAILED_LOGIN_ATTEMPTS             = 423
	MySqlParserFAST                              = 424
	MySqlParserFAULTS                            = 425
	MySqlParserFIELDS                            = 426
	MySqlParserFILE_BLOCK_SIZE                   = 427
	MySqlParserFILTER                            = 428
	MySqlParserFIRST                             = 429
	MySqlParserFIXED                             = 430
	MySqlParserFLUSH                             = 431
	MySqlParserFOLLOWING                         = 432
	MySqlParserFOLLOWS                           = 433
	MySqlParserFOUND                             = 434
	MySqlParserFULL                              = 435
	MySqlParserFUNCTION                          = 436
	MySqlParserGENERAL                           = 437
	MySqlParserGLOBAL                            = 438
	MySqlParserGRANTS                            = 439
	MySqlParserGROUP_REPLICATION                 = 440
	MySqlParserHANDLER                           = 441
	MySqlParserHASH                              = 442
	MySqlParserHELP                              = 443
	MySqlParserHISTORY                           = 444
	MySqlParserHOST                              = 445
	MySqlParserHOSTS                             = 446
	MySqlParserIDENTIFIED                        = 447
	MySqlParserIGNORE_SERVER_IDS                 = 448
	MySqlParserIMPORT                            = 449
	MySqlParserINCREMENT                         = 450
	MySqlParserINDEXES                           = 451
	MySqlParserINITIAL_SIZE                      = 452
	MySqlParserINPLACE                           = 453
	MySqlParserINSERT_METHOD                     = 454
	MySqlParserINSTALL                           = 455
	MySqlParserINSTANCE                          = 456
	MySqlParserINSTANT                           = 457
	MySqlParserINVISIBLE                         = 458
	MySqlParserINVOKER                           = 459
	MySqlParserIO                                = 460
	MySqlParserIO_THREAD                         = 461
	MySqlParserIPC                               = 462
	MySqlParserISOLATION                         = 463
	MySqlParserISSUER                            = 464
	MySqlParserJSON                              = 465
	MySqlParserKEY_BLOCK_SIZE                    = 466
	MySqlParserLANGUAGE                          = 467
	MySqlParserLAST                              = 468
	MySqlParserLEAVES                            = 469
	MySqlParserLESS                              = 470
	MySqlParserLEVEL                             = 471
	MySqlParserLIST                              = 472
	MySqlParserLOCAL                             = 473
	MySqlParserLOGFILE                           = 474
	MySqlParserLOGS                              = 475
	MySqlParserMASTER                            = 476
	MySqlParserMASTER_AUTO_POSITION              = 477
	MySqlParserMASTER_CONNECT_RETRY              = 478
	MySqlParserMASTER_DELAY                      = 479
	MySqlParserMASTER_HEARTBEAT_PERIOD           = 480
	MySqlParserMASTER_HOST                       = 481
	MySqlParserMASTER_LOG_FILE                   = 482
	MySqlParserMASTER_LOG_POS                    = 483
	MySqlParserMASTER_PASSWORD                   = 484
	MySqlParserMASTER_PORT                       = 485
	MySqlParserMASTER_RETRY_COUNT                = 486
	MySqlParserMASTER_SSL                        = 487
	MySqlParserMASTER_SSL_CA                     = 488
	MySqlParserMASTER_SSL_CAPATH                 = 489
	MySqlParserMASTER_SSL_CERT                   = 490
	MySqlParserMASTER_SSL_CIPHER                 = 491
	MySqlParserMASTER_SSL_CRL                    = 492
	MySqlParserMASTER_SSL_CRLPATH                = 493
	MySqlParserMASTER_SSL_KEY                    = 494
	MySqlParserMASTER_TLS_VERSION                = 495
	MySqlParserMASTER_USER                       = 496
	MySqlParserMAX_CONNECTIONS_PER_HOUR          = 497
	MySqlParserMAX_QUERIES_PER_HOUR              = 498
	MySqlParserMAX_ROWS                          = 499
	MySqlParserMAX_SIZE                          = 500
	MySqlParserMAX_UPDATES_PER_HOUR              = 501
	MySqlParserMAX_USER_CONNECTIONS              = 502
	MySqlParserMEDIUM                            = 503
	MySqlParserMEMBER                            = 504
	MySqlParserMERGE                             = 505
	MySqlParserMESSAGE_TEXT                      = 506
	MySqlParserMID                               = 507
	MySqlParserMIGRATE                           = 508
	MySqlParserMIN_ROWS                          = 509
	MySqlParserMODE                              = 510
	MySqlParserMODIFY                            = 511
	MySqlParserMUTEX                             = 512
	MySqlParserMYSQL                             = 513
	MySqlParserMYSQL_ERRNO                       = 514
	MySqlParserNAME                              = 515
	MySqlParserNAMES                             = 516
	MySqlParserNCHAR                             = 517
	MySqlParserNEVER                             = 518
	MySqlParserNEXT                              = 519
	MySqlParserNO                                = 520
	MySqlParserNOCACHE                           = 521
	MySqlParserNOCOPY                            = 522
	MySqlParserNOCYCLE                           = 523
	MySqlParserNOMAXVALUE                        = 524
	MySqlParserNOMINVALUE                        = 525
	MySqlParserNOWAIT                            = 526
	MySqlParserNODEGROUP                         = 527
	MySqlParserNONE                              = 528
	MySqlParserODBC                              = 529
	MySqlParserOFFLINE                           = 530
	MySqlParserOFFSET                            = 531
	MySqlParserOF                                = 532
	MySqlParserOJ                                = 533
	MySqlParserOLD_PASSWORD                      = 534
	MySqlParserONE                               = 535
	MySqlParserONLINE                            = 536
	MySqlParserONLY                              = 537
	MySqlParserOPEN                              = 538
	MySqlParserOPTIMIZER_COSTS                   = 539
	MySqlParserOPTIONS                           = 540
	MySqlParserOWNER                             = 541
	MySqlParserPACK_KEYS                         = 542
	MySqlParserPAGE                              = 543
	MySqlParserPAGE_COMPRESSED                   = 544
	MySqlParserPAGE_COMPRESSION_LEVEL            = 545
	MySqlParserPARSER                            = 546
	MySqlParserPARTIAL                           = 547
	MySqlParserPARTITIONING                      = 548
	MySqlParserPARTITIONS                        = 549
	MySqlParserPASSWORD                          = 550
	MySqlParserPASSWORD_LOCK_TIME                = 551
	MySqlParserPHASE                             = 552
	MySqlParserPLUGIN                            = 553
	MySqlParserPLUGIN_DIR                        = 554
	MySqlParserPLUGINS                           = 555
	MySqlParserPORT                              = 556
	MySqlParserPRECEDES                          = 557
	MySqlParserPRECEDING                         = 558
	MySqlParserPREPARE                           = 559
	MySqlParserPRESERVE                          = 560
	MySqlParserPREV                              = 561
	MySqlParserPROCESSLIST                       = 562
	MySqlParserPROFILE                           = 563
	MySqlParserPROFILES                          = 564
	MySqlParserPROXY                             = 565
	MySqlParserQUERY                             = 566
	MySqlParserQUICK                             = 567
	MySqlParserREBUILD                           = 568
	MySqlParserRECOVER                           = 569
	MySqlParserRECURSIVE                         = 570
	MySqlParserREDO_BUFFER_SIZE                  = 571
	MySqlParserREDUNDANT                         = 572
	MySqlParserRELAY                             = 573
	MySqlParserRELAY_LOG_FILE                    = 574
	MySqlParserRELAY_LOG_POS                     = 575
	MySqlParserRELAYLOG                          = 576
	MySqlParserREMOVE                            = 577
	MySqlParserREORGANIZE                        = 578
	MySqlParserREPAIR                            = 579
	MySqlParserREPLICATE_DO_DB                   = 580
	MySqlParserREPLICATE_DO_TABLE                = 581
	MySqlParserREPLICATE_IGNORE_DB               = 582
	MySqlParserREPLICATE_IGNORE_TABLE            = 583
	MySqlParserREPLICATE_REWRITE_DB              = 584
	MySqlParserREPLICATE_WILD_DO_TABLE           = 585
	MySqlParserREPLICATE_WILD_IGNORE_TABLE       = 586
	MySqlParserREPLICATION                       = 587
	MySqlParserRESET                             = 588
	MySqlParserRESTART                           = 589
	MySqlParserRESUME                            = 590
	MySqlParserRETURNED_SQLSTATE                 = 591
	MySqlParserRETURNING                         = 592
	MySqlParserRETURNS                           = 593
	MySqlParserREUSE                             = 594
	MySqlParserROLE                              = 595
	MySqlParserROLLBACK                          = 596
	MySqlParserROLLUP                            = 597
	MySqlParserROTATE                            = 598
	MySqlParserROW                               = 599
	MySqlParserROWS                              = 600
	MySqlParserROW_FORMAT                        = 601
	MySqlParserRTREE                             = 602
	MySqlParserSAVEPOINT                         = 603
	MySqlParserSCHEDULE                          = 604
	MySqlParserSECURITY                          = 605
	MySqlParserSEQUENCE                          = 606
	MySqlParserSERVER                            = 607
	MySqlParserSESSION                           = 608
	MySqlParserSHARE                             = 609
	MySqlParserSHARED                            = 610
	MySqlParserSIGNED                            = 611
	MySqlParserSIMPLE                            = 612
	MySqlParserSLAVE                             = 613
	MySqlParserSLOW                              = 614
	MySqlParserSNAPSHOT                          = 615
	MySqlParserSOCKET                            = 616
	MySqlParserSOME                              = 617
	MySqlParserSONAME                            = 618
	MySqlParserSOUNDS                            = 619
	MySqlParserSOURCE                            = 620
	MySqlParserSQL_AFTER_GTIDS                   = 621
	MySqlParserSQL_AFTER_MTS_GAPS                = 622
	MySqlParserSQL_BEFORE_GTIDS                  = 623
	MySqlParserSQL_BUFFER_RESULT                 = 624
	MySqlParserSQL_CACHE                         = 625
	MySqlParserSQL_NO_CACHE                      = 626
	MySqlParserSQL_THREAD                        = 627
	MySqlParserSTART                             = 628
	MySqlParserSTARTS                            = 629
	MySqlParserSTATS_AUTO_RECALC                 = 630
	MySqlParserSTATS_PERSISTENT                  = 631
	MySqlParserSTATS_SAMPLE_PAGES                = 632
	MySqlParserSTATUS                            = 633
	MySqlParserSTOP                              = 634
	MySqlParserSTORAGE                           = 635
	MySqlParserSTORED                            = 636
	MySqlParserSTRING                            = 637
	MySqlParserSUBCLASS_ORIGIN                   = 638
	MySqlParserSUBJECT                           = 639
	MySqlParserSUBPARTITION                      = 640
	MySqlParserSUBPARTITIONS                     = 641
	MySqlParserSUSPEND                           = 642
	MySqlParserSWAPS                             = 643
	MySqlParserSWITCHES                          = 644
	MySqlParserTABLE_NAME                        = 645
	MySqlParserTABLESPACE                        = 646
	MySqlParserTABLE_TYPE                        = 647
	MySqlParserTEMPORARY                         = 648
	MySqlParserTEMPTABLE                         = 649
	MySqlParserTHAN                              = 650
	MySqlParserTRADITIONAL                       = 651
	MySqlParserTRANSACTION                       = 652
	MySqlParserTRANSACTIONAL                     = 653
	MySqlParserTRIGGERS                          = 654
	MySqlParserTRUNCATE                          = 655
	MySqlParserUNBOUNDED                         = 656
	MySqlParserUNDEFINED                         = 657
	MySqlParserUNDOFILE                          = 658
	MySqlParserUNDO_BUFFER_SIZE                  = 659
	MySqlParserUNINSTALL                         = 660
	MySqlParserUNKNOWN                           = 661
	MySqlParserUNTIL                             = 662
	MySqlParserUPGRADE                           = 663
	MySqlParserUSER                              = 664
	MySqlParserUSE_FRM                           = 665
	MySqlParserUSER_RESOURCES                    = 666
	MySqlParserVALIDATION                        = 667
	MySqlParserVALUE                             = 668
	MySqlParserVARIABLES                         = 669
	MySqlParserVIEW                              = 670
	MySqlParserVIRTUAL                           = 671
	MySqlParserVISIBLE                           = 672
	MySqlParserWAIT                              = 673
	MySqlParserWARNINGS                          = 674
	MySqlParserWINDOW                            = 675
	MySqlParserWITHOUT                           = 676
	MySqlParserWORK                              = 677
	MySqlParserWRAPPER                           = 678
	MySqlParserX509                              = 679
	MySqlParserXA                                = 680
	MySqlParserXML                               = 681
	MySqlParserYES                               = 682
	MySqlParserEUR                               = 683
	MySqlParserUSA                               = 684
	MySqlParserJIS                               = 685
	MySqlParserISO                               = 686
	MySqlParserINTERNAL                          = 687
	MySqlParserQUARTER                           = 688
	MySqlParserMONTH                             = 689
	MySqlParserDAY                               = 690
	MySqlParserHOUR                              = 691
	MySqlParserMINUTE                            = 692
	MySqlParserWEEK                              = 693
	MySqlParserSECOND                            = 694
	MySqlParserMICROSECOND                       = 695
	MySqlParserADMIN                             = 696
	MySqlParserAPPLICATION_PASSWORD_ADMIN        = 697
	MySqlParserAUDIT_ABORT_EXEMPT                = 698
	MySqlParserAUDIT_ADMIN                       = 699
	MySqlParserAUTHENTICATION_POLICY_ADMIN       = 700
	MySqlParserBACKUP_ADMIN                      = 701
	MySqlParserBINLOG_ADMIN                      = 702
	MySqlParserBINLOG_ENCRYPTION_ADMIN           = 703
	MySqlParserCLONE_ADMIN                       = 704
	MySqlParserCONNECTION_ADMIN                  = 705
	MySqlParserENCRYPTION_KEY_ADMIN              = 706
	MySqlParserEXECUTE                           = 707
	MySqlParserFILE                              = 708
	MySqlParserFIREWALL_ADMIN                    = 709
	MySqlParserFIREWALL_EXEMPT                   = 710
	MySqlParserFIREWALL_USER                     = 711
	MySqlParserFLUSH_OPTIMIZER_COSTS             = 712
	MySqlParserFLUSH_STATUS                      = 713
	MySqlParserFLUSH_TABLES                      = 714
	MySqlParserFLUSH_USER_RESOURCES              = 715
	MySqlParserGROUP_REPLICATION_ADMIN           = 716
	MySqlParserINNODB_REDO_LOG_ARCHIVE           = 717
	MySqlParserINNODB_REDO_LOG_ENABLE            = 718
	MySqlParserINVOKE                            = 719
	MySqlParserLAMBDA                            = 720
	MySqlParserNDB_STORED_USER                   = 721
	MySqlParserPASSWORDLESS_USER_ADMIN           = 722
	MySqlParserPERSIST_RO_VARIABLES_ADMIN        = 723
	MySqlParserPRIVILEGES                        = 724
	MySqlParserPROCESS                           = 725
	MySqlParserRELOAD                            = 726
	MySqlParserREPLICATION_APPLIER               = 727
	MySqlParserREPLICATION_SLAVE_ADMIN           = 728
	MySqlParserRESOURCE_GROUP_ADMIN              = 729
	MySqlParserRESOURCE_GROUP_USER               = 730
	MySqlParserROLE_ADMIN                        = 731
	MySqlParserROUTINE                           = 732
	MySqlParserS3                                = 733
	MySqlParserSERVICE_CONNECTION_ADMIN          = 734
	MySqlParserSESSION_VARIABLES_ADMIN           = 735
	MySqlParserSET_USER_ID                       = 736
	MySqlParserSHOW_ROUTINE                      = 737
	MySqlParserSHUTDOWN                          = 738
	MySqlParserSUPER                             = 739
	MySqlParserSYSTEM_VARIABLES_ADMIN            = 740
	MySqlParserTABLES                            = 741
	MySqlParserTABLE_ENCRYPTION_ADMIN            = 742
	MySqlParserVERSION_TOKEN_ADMIN               = 743
	MySqlParserXA_RECOVER_ADMIN                  = 744
	MySqlParserARMSCII8                          = 745
	MySqlParserASCII                             = 746
	MySqlParserBIG5                              = 747
	MySqlParserCP1250                            = 748
	MySqlParserCP1251                            = 749
	MySqlParserCP1256                            = 750
	MySqlParserCP1257                            = 751
	MySqlParserCP850                             = 752
	MySqlParserCP852                             = 753
	MySqlParserCP866                             = 754
	MySqlParserCP932                             = 755
	MySqlParserDEC8                              = 756
	MySqlParserEUCJPMS                           = 757
	MySqlParserEUCKR                             = 758
	MySqlParserGB18030                           = 759
	MySqlParserGB2312                            = 760
	MySqlParserGBK                               = 761
	MySqlParserGEOSTD8                           = 762
	MySqlParserGREEK                             = 763
	MySqlParserHEBREW                            = 764
	MySqlParserHP8                               = 765
	MySqlParserKEYBCS2                           = 766
	MySqlParserKOI8R                             = 767
	MySqlParserKOI8U                             = 768
	MySqlParserLATIN1                            = 769
	MySqlParserLATIN2                            = 770
	MySqlParserLATIN5                            = 771
	MySqlParserLATIN7                            = 772
	MySqlParserMACCE                             = 773
	MySqlParserMACROMAN                          = 774
	MySqlParserSJIS                              = 775
	MySqlParserSWE7                              = 776
	MySqlParserTIS620                            = 777
	MySqlParserUCS2                              = 778
	MySqlParserUJIS                              = 779
	MySqlParserUTF16                             = 780
	MySqlParserUTF16LE                           = 781
	MySqlParserUTF32                             = 782
	MySqlParserUTF8                              = 783
	MySqlParserUTF8MB3                           = 784
	MySqlParserUTF8MB4                           = 785
	MySqlParserARCHIVE                           = 786
	MySqlParserBLACKHOLE                         = 787
	MySqlParserCSV                               = 788
	MySqlParserFEDERATED                         = 789
	MySqlParserINNODB                            = 790
	MySqlParserMEMORY                            = 791
	MySqlParserMRG_MYISAM                        = 792
	MySqlParserMYISAM                            = 793
	MySqlParserNDB                               = 794
	MySqlParserNDBCLUSTER                        = 795
	MySqlParserPERFORMANCE_SCHEMA                = 796
	MySqlParserTOKUDB                            = 797
	MySqlParserREPEATABLE                        = 798
	MySqlParserCOMMITTED                         = 799
	MySqlParserUNCOMMITTED                       = 800
	MySqlParserSERIALIZABLE                      = 801
	MySqlParserGEOMETRYCOLLECTION                = 802
	MySqlParserGEOMCOLLECTION                    = 803
	MySqlParserGEOMETRY                          = 804
	MySqlParserLINESTRING                        = 805
	MySqlParserMULTILINESTRING                   = 806
	MySqlParserMULTIPOINT                        = 807
	MySqlParserMULTIPOLYGON                      = 808
	MySqlParserPOINT                             = 809
	MySqlParserPOLYGON                           = 810
	MySqlParserABS                               = 811
	MySqlParserACOS                              = 812
	MySqlParserADDDATE                           = 813
	MySqlParserADDTIME                           = 814
	MySqlParserAES_DECRYPT                       = 815
	MySqlParserAES_ENCRYPT                       = 816
	MySqlParserAREA                              = 817
	MySqlParserASBINARY                          = 818
	MySqlParserASIN                              = 819
	MySqlParserASTEXT                            = 820
	MySqlParserASWKB                             = 821
	MySqlParserASWKT                             = 822
	MySqlParserASYMMETRIC_DECRYPT                = 823
	MySqlParserASYMMETRIC_DERIVE                 = 824
	MySqlParserASYMMETRIC_ENCRYPT                = 825
	MySqlParserASYMMETRIC_SIGN                   = 826
	MySqlParserASYMMETRIC_VERIFY                 = 827
	MySqlParserATAN                              = 828
	MySqlParserATAN2                             = 829
	MySqlParserBENCHMARK                         = 830
	MySqlParserBIN                               = 831
	MySqlParserBIT_COUNT                         = 832
	MySqlParserBIT_LENGTH                        = 833
	MySqlParserBUFFER                            = 834
	MySqlParserCATALOG_NAME                      = 835
	MySqlParserCEIL                              = 836
	MySqlParserCEILING                           = 837
	MySqlParserCENTROID                          = 838
	MySqlParserCHARACTER_LENGTH                  = 839
	MySqlParserCHARSET                           = 840
	MySqlParserCHAR_LENGTH                       = 841
	MySqlParserCOERCIBILITY                      = 842
	MySqlParserCOLLATION                         = 843
	MySqlParserCOMPRESS                          = 844
	MySqlParserCONCAT                            = 845
	MySqlParserCONCAT_WS                         = 846
	MySqlParserCONNECTION_ID                     = 847
	MySqlParserCONV                              = 848
	MySqlParserCONVERT_TZ                        = 849
	MySqlParserCOS                               = 850
	MySqlParserCOT                               = 851
	MySqlParserCRC32                             = 852
	MySqlParserCREATE_ASYMMETRIC_PRIV_KEY        = 853
	MySqlParserCREATE_ASYMMETRIC_PUB_KEY         = 854
	MySqlParserCREATE_DH_PARAMETERS              = 855
	MySqlParserCREATE_DIGEST                     = 856
	MySqlParserCROSSES                           = 857
	MySqlParserDATEDIFF                          = 858
	MySqlParserDATE_FORMAT                       = 859
	MySqlParserDAYNAME                           = 860
	MySqlParserDAYOFMONTH                        = 861
	MySqlParserDAYOFWEEK                         = 862
	MySqlParserDAYOFYEAR                         = 863
	MySqlParserDECODE                            = 864
	MySqlParserDEGREES                           = 865
	MySqlParserDES_DECRYPT                       = 866
	MySqlParserDES_ENCRYPT                       = 867
	MySqlParserDIMENSION                         = 868
	MySqlParserDISJOINT                          = 869
	MySqlParserELT                               = 870
	MySqlParserENCODE                            = 871
	MySqlParserENCRYPT                           = 872
	MySqlParserENDPOINT                          = 873
	MySqlParserENGINE_ATTRIBUTE                  = 874
	MySqlParserENVELOPE                          = 875
	MySqlParserEQUALS                            = 876
	MySqlParserEXP                               = 877
	MySqlParserEXPORT_SET                        = 878
	MySqlParserEXTERIORRING                      = 879
	MySqlParserEXTRACTVALUE                      = 880
	MySqlParserFIELD                             = 881
	MySqlParserFIND_IN_SET                       = 882
	MySqlParserFLOOR                             = 883
	MySqlParserFORMAT                            = 884
	MySqlParserFOUND_ROWS                        = 885
	MySqlParserFROM_BASE64                       = 886
	MySqlParserFROM_DAYS                         = 887
	MySqlParserFROM_UNIXTIME                     = 888
	MySqlParserGEOMCOLLFROMTEXT                  = 889
	MySqlParserGEOMCOLLFROMWKB                   = 890
	MySqlParserGEOMETRYCOLLECTIONFROMTEXT        = 891
	MySqlParserGEOMETRYCOLLECTIONFROMWKB         = 892
	MySqlParserGEOMETRYFROMTEXT                  = 893
	MySqlParserGEOMETRYFROMWKB                   = 894
	MySqlParserGEOMETRYN                         = 895
	MySqlParserGEOMETRYTYPE                      = 896
	MySqlParserGEOMFROMTEXT                      = 897
	MySqlParserGEOMFROMWKB                       = 898
	MySqlParserGET_FORMAT                        = 899
	MySqlParserGET_LOCK                          = 900
	MySqlParserGLENGTH                           = 901
	MySqlParserGREATEST                          = 902
	MySqlParserGTID_SUBSET                       = 903
	MySqlParserGTID_SUBTRACT                     = 904
	MySqlParserHEX                               = 905
	MySqlParserIFNULL                            = 906
	MySqlParserINET6_ATON                        = 907
	MySqlParserINET6_NTOA                        = 908
	MySqlParserINET_ATON                         = 909
	MySqlParserINET_NTOA                         = 910
	MySqlParserINSTR                             = 911
	MySqlParserINTERIORRINGN                     = 912
	MySqlParserINTERSECTS                        = 913
	MySqlParserISCLOSED                          = 914
	MySqlParserISEMPTY                           = 915
	MySqlParserISNULL                            = 916
	MySqlParserISSIMPLE                          = 917
	MySqlParserIS_FREE_LOCK                      = 918
	MySqlParserIS_IPV4                           = 919
	MySqlParserIS_IPV4_COMPAT                    = 920
	MySqlParserIS_IPV4_MAPPED                    = 921
	MySqlParserIS_IPV6                           = 922
	MySqlParserIS_USED_LOCK                      = 923
	MySqlParserLAST_INSERT_ID                    = 924
	MySqlParserLCASE                             = 925
	MySqlParserLEAST                             = 926
	MySqlParserLENGTH                            = 927
	MySqlParserLINEFROMTEXT                      = 928
	MySqlParserLINEFROMWKB                       = 929
	MySqlParserLINESTRINGFROMTEXT                = 930
	MySqlParserLINESTRINGFROMWKB                 = 931
	MySqlParserLN                                = 932
	MySqlParserLOAD_FILE                         = 933
	MySqlParserLOCATE                            = 934
	MySqlParserLOG                               = 935
	MySqlParserLOG10                             = 936
	MySqlParserLOG2                              = 937
	MySqlParserLOWER                             = 938
	MySqlParserLPAD                              = 939
	MySqlParserLTRIM                             = 940
	MySqlParserMAKEDATE                          = 941
	MySqlParserMAKETIME                          = 942
	MySqlParserMAKE_SET                          = 943
	MySqlParserMASTER_POS_WAIT                   = 944
	MySqlParserMBRCONTAINS                       = 945
	MySqlParserMBRDISJOINT                       = 946
	MySqlParserMBREQUAL                          = 947
	MySqlParserMBRINTERSECTS                     = 948
	MySqlParserMBROVERLAPS                       = 949
	MySqlParserMBRTOUCHES                        = 950
	MySqlParserMBRWITHIN                         = 951
	MySqlParserMD5                               = 952
	MySqlParserMLINEFROMTEXT                     = 953
	MySqlParserMLINEFROMWKB                      = 954
	MySqlParserMONTHNAME                         = 955
	MySqlParserMPOINTFROMTEXT                    = 956
	MySqlParserMPOINTFROMWKB                     = 957
	MySqlParserMPOLYFROMTEXT                     = 958
	MySqlParserMPOLYFROMWKB                      = 959
	MySqlParserMULTILINESTRINGFROMTEXT           = 960
	MySqlParserMULTILINESTRINGFROMWKB            = 961
	MySqlParserMULTIPOINTFROMTEXT                = 962
	MySqlParserMULTIPOINTFROMWKB                 = 963
	MySqlParserMULTIPOLYGONFROMTEXT              = 964
	MySqlParserMULTIPOLYGONFROMWKB               = 965
	MySqlParserNAME_CONST                        = 966
	MySqlParserNULLIF                            = 967
	MySqlParserNUMGEOMETRIES                     = 968
	MySqlParserNUMINTERIORRINGS                  = 969
	MySqlParserNUMPOINTS                         = 970
	MySqlParserOCT                               = 971
	MySqlParserOCTET_LENGTH                      = 972
	MySqlParserORD                               = 973
	MySqlParserOVERLAPS                          = 974
	MySqlParserPERIOD_ADD                        = 975
	MySqlParserPERIOD_DIFF                       = 976
	MySqlParserPI                                = 977
	MySqlParserPOINTFROMTEXT                     = 978
	MySqlParserPOINTFROMWKB                      = 979
	MySqlParserPOINTN                            = 980
	MySqlParserPOLYFROMTEXT                      = 981
	MySqlParserPOLYFROMWKB                       = 982
	MySqlParserPOLYGONFROMTEXT                   = 983
	MySqlParserPOLYGONFROMWKB                    = 984
	MySqlParserPOW                               = 985
	MySqlParserPOWER                             = 986
	MySqlParserQUOTE                             = 987
	MySqlParserRADIANS                           = 988
	MySqlParserRAND                              = 989
	MySqlParserRANDOM                            = 990
	MySqlParserRANDOM_BYTES                      = 991
	MySqlParserRELEASE_LOCK                      = 992
	MySqlParserREVERSE                           = 993
	MySqlParserROUND                             = 994
	MySqlParserROW_COUNT                         = 995
	MySqlParserRPAD                              = 996
	MySqlParserRTRIM                             = 997
	MySqlParserSEC_TO_TIME                       = 998
	MySqlParserSECONDARY_ENGINE_ATTRIBUTE        = 999
	MySqlParserSESSION_USER                      = 1000
	MySqlParserSHA                               = 1001
	MySqlParserSHA1                              = 1002
	MySqlParserSHA2                              = 1003
	MySqlParserSCHEMA_NAME                       = 1004
	MySqlParserSIGN                              = 1005
	MySqlParserSIN                               = 1006
	MySqlParserSLEEP                             = 1007
	MySqlParserSOUNDEX                           = 1008
	MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS       = 1009
	MySqlParserSQRT                              = 1010
	MySqlParserSRID                              = 1011
	MySqlParserSTARTPOINT                        = 1012
	MySqlParserSTRCMP                            = 1013
	MySqlParserSTR_TO_DATE                       = 1014
	MySqlParserST_AREA                           = 1015
	MySqlParserST_ASBINARY                       = 1016
	MySqlParserST_ASTEXT                         = 1017
	MySqlParserST_ASWKB                          = 1018
	MySqlParserST_ASWKT                          = 1019
	MySqlParserST_BUFFER                         = 1020
	MySqlParserST_CENTROID                       = 1021
	MySqlParserST_CONTAINS                       = 1022
	MySqlParserST_CROSSES                        = 1023
	MySqlParserST_DIFFERENCE                     = 1024
	MySqlParserST_DIMENSION                      = 1025
	MySqlParserST_DISJOINT                       = 1026
	MySqlParserST_DISTANCE                       = 1027
	MySqlParserST_ENDPOINT                       = 1028
	MySqlParserST_ENVELOPE                       = 1029
	MySqlParserST_EQUALS                         = 1030
	MySqlParserST_EXTERIORRING                   = 1031
	MySqlParserST_GEOMCOLLFROMTEXT               = 1032
	MySqlParserST_GEOMCOLLFROMTXT                = 1033
	MySqlParserST_GEOMCOLLFROMWKB                = 1034
	MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1035
	MySqlParserST_GEOMETRYCOLLECTIONFROMWKB      = 1036
	MySqlParserST_GEOMETRYFROMTEXT               = 1037
	MySqlParserST_GEOMETRYFROMWKB                = 1038
	MySqlParserST_GEOMETRYN                      = 1039
	MySqlParserST_GEOMETRYTYPE                   = 1040
	MySqlParserST_GEOMFROMTEXT                   = 1041
	MySqlParserST_GEOMFROMWKB                    = 1042
	MySqlParserST_INTERIORRINGN                  = 1043
	MySqlParserST_INTERSECTION                   = 1044
	MySqlParserST_INTERSECTS                     = 1045
	MySqlParserST_ISCLOSED                       = 1046
	MySqlParserST_ISEMPTY                        = 1047
	MySqlParserST_ISSIMPLE                       = 1048
	MySqlParserST_LINEFROMTEXT                   = 1049
	MySqlParserST_LINEFROMWKB                    = 1050
	MySqlParserST_LINESTRINGFROMTEXT             = 1051
	MySqlParserST_LINESTRINGFROMWKB              = 1052
	MySqlParserST_NUMGEOMETRIES                  = 1053
	MySqlParserST_NUMINTERIORRING                = 1054
	MySqlParserST_NUMINTERIORRINGS               = 1055
	MySqlParserST_NUMPOINTS                      = 1056
	MySqlParserST_OVERLAPS                       = 1057
	MySqlParserST_POINTFROMTEXT                  = 1058
	MySqlParserST_POINTFROMWKB                   = 1059
	MySqlParserST_POINTN                         = 1060
	MySqlParserST_POLYFROMTEXT                   = 1061
	MySqlParserST_POLYFROMWKB                    = 1062
	MySqlParserST_POLYGONFROMTEXT                = 1063
	MySqlParserST_POLYGONFROMWKB                 = 1064
	MySqlParserST_SRID                           = 1065
	MySqlParserST_STARTPOINT                     = 1066
	MySqlParserST_SYMDIFFERENCE                  = 1067
	MySqlParserST_TOUCHES                        = 1068
	MySqlParserST_UNION                          = 1069
	MySqlParserST_WITHIN                         = 1070
	MySqlParserST_X                              = 1071
	MySqlParserST_Y                              = 1072
	MySqlParserSUBDATE                           = 1073
	MySqlParserSUBSTRING_INDEX                   = 1074
	MySqlParserSUBTIME                           = 1075
	MySqlParserSYSTEM_USER                       = 1076
	MySqlParserTAN                               = 1077
	MySqlParserTIMEDIFF                          = 1078
	MySqlParserTIMESTAMPADD                      = 1079
	MySqlParserTIMESTAMPDIFF                     = 1080
	MySqlParserTIME_FORMAT                       = 1081
	MySqlParserTIME_TO_SEC                       = 1082
	MySqlParserTOUCHES                           = 1083
	MySqlParserTO_BASE64                         = 1084
	MySqlParserTO_DAYS                           = 1085
	MySqlParserTO_SECONDS                        = 1086
	MySqlParserTP_CONNECTION_ADMIN               = 1087
	MySqlParserUCASE                             = 1088
	MySqlParserUNCOMPRESS                        = 1089
	MySqlParserUNCOMPRESSED_LENGTH               = 1090
	MySqlParserUNHEX                             = 1091
	MySqlParserUNIX_TIMESTAMP                    = 1092
	MySqlParserUPDATEXML                         = 1093
	MySqlParserUPPER                             = 1094
	MySqlParserUUID                              = 1095
	MySqlParserUUID_SHORT                        = 1096
	MySqlParserVALIDATE_PASSWORD_STRENGTH        = 1097
	MySqlParserVERSION                           = 1098
	MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1099
	MySqlParserWEEKDAY                           = 1100
	MySqlParserWEEKOFYEAR                        = 1101
	MySqlParserWEIGHT_STRING                     = 1102
	MySqlParserWITHIN                            = 1103
	MySqlParserYEARWEEK                          = 1104
	MySqlParserY_FUNCTION                        = 1105
	MySqlParserX_FUNCTION                        = 1106
	MySqlParserVAR_ASSIGN                        = 1107
	MySqlParserPLUS_ASSIGN                       = 1108
	MySqlParserMINUS_ASSIGN                      = 1109
	MySqlParserMULT_ASSIGN                       = 1110
	MySqlParserDIV_ASSIGN                        = 1111
	MySqlParserMOD_ASSIGN                        = 1112
	MySqlParserAND_ASSIGN                        = 1113
	MySqlParserXOR_ASSIGN                        = 1114
	MySqlParserOR_ASSIGN                         = 1115
	MySqlParserSTAR                              = 1116
	MySqlParserDIVIDE                            = 1117
	MySqlParserMODULE                            = 1118
	MySqlParserPLUS                              = 1119
	MySqlParserMINUS                             = 1120
	MySqlParserDIV                               = 1121
	MySqlParserMOD                               = 1122
	MySqlParserEQUAL_SYMBOL                      = 1123
	MySqlParserGREATER_SYMBOL                    = 1124
	MySqlParserLESS_SYMBOL                       = 1125
	MySqlParserEXCLAMATION_SYMBOL                = 1126
	MySqlParserBIT_NOT_OP                        = 1127
	MySqlParserBIT_OR_OP                         = 1128
	MySqlParserBIT_AND_OP                        = 1129
	MySqlParserBIT_XOR_OP                        = 1130
	MySqlParserDOT                               = 1131
	MySqlParserLR_BRACKET                        = 1132
	MySqlParserRR_BRACKET                        = 1133
	MySqlParserCOMMA                             = 1134
	MySqlParserSEMI                              = 1135
	MySqlParserAT_SIGN                           = 1136
	MySqlParserZERO_DECIMAL                      = 1137
	MySqlParserONE_DECIMAL                       = 1138
	MySqlParserTWO_DECIMAL                       = 1139
	MySqlParserSINGLE_QUOTE_SYMB                 = 1140
	MySqlParserDOUBLE_QUOTE_SYMB                 = 1141
	MySqlParserREVERSE_QUOTE_SYMB                = 1142
	MySqlParserCOLON_SYMB                        = 1143
	MySqlParserCHARSET_REVERSE_QOUTE_STRING      = 1144
	MySqlParserFILESIZE_LITERAL                  = 1145
	MySqlParserSTART_NATIONAL_STRING_LITERAL     = 1146
	MySqlParserSTRING_LITERAL                    = 1147
	MySqlParserDECIMAL_LITERAL                   = 1148
	MySqlParserHEXADECIMAL_LITERAL               = 1149
	MySqlParserREAL_LITERAL                      = 1150
	MySqlParserNULL_SPEC_LITERAL                 = 1151
	MySqlParserBIT_STRING                        = 1152
	MySqlParserSTRING_CHARSET_NAME               = 1153
	MySqlParserDOT_ID                            = 1154
	MySqlParserID                                = 1155
	MySqlParserREVERSE_QUOTE_ID                  = 1156
	MySqlParserHOST_IP_ADDRESS                   = 1157
	MySqlParserLOCAL_ID                          = 1158
	MySqlParserGLOBAL_ID                         = 1159
	MySqlParserERROR_RECONGNIGION                = 1160
)

// MySqlParser rules.
const (
	MySqlParserRULE_root                                = 0
	MySqlParserRULE_sqlStatements                       = 1
	MySqlParserRULE_sqlStatement                        = 2
	MySqlParserRULE_emptyStatement_                     = 3
	MySqlParserRULE_ddlStatement                        = 4
	MySqlParserRULE_dmlStatement                        = 5
	MySqlParserRULE_transactionStatement                = 6
	MySqlParserRULE_replicationStatement                = 7
	MySqlParserRULE_preparedStatement                   = 8
	MySqlParserRULE_compoundStatement                   = 9
	MySqlParserRULE_administrationStatement             = 10
	MySqlParserRULE_utilityStatement                    = 11
	MySqlParserRULE_createDatabase                      = 12
	MySqlParserRULE_createEvent                         = 13
	MySqlParserRULE_createIndex                         = 14
	MySqlParserRULE_createLogfileGroup                  = 15
	MySqlParserRULE_createProcedure                     = 16
	MySqlParserRULE_createFunction                      = 17
	MySqlParserRULE_createRole                          = 18
	MySqlParserRULE_createServer                        = 19
	MySqlParserRULE_createTable                         = 20
	MySqlParserRULE_createTablespaceInnodb              = 21
	MySqlParserRULE_createTablespaceNdb                 = 22
	MySqlParserRULE_createTrigger                       = 23
	MySqlParserRULE_withClause                          = 24
	MySqlParserRULE_commonTableExpressions              = 25
	MySqlParserRULE_cteName                             = 26
	MySqlParserRULE_cteColumnName                       = 27
	MySqlParserRULE_createView                          = 28
	MySqlParserRULE_createDatabaseOption                = 29
	MySqlParserRULE_charSet                             = 30
	MySqlParserRULE_currentUserExpression               = 31
	MySqlParserRULE_ownerStatement                      = 32
	MySqlParserRULE_scheduleExpression                  = 33
	MySqlParserRULE_timestampValue                      = 34
	MySqlParserRULE_intervalExpr                        = 35
	MySqlParserRULE_intervalType                        = 36
	MySqlParserRULE_enableType                          = 37
	MySqlParserRULE_indexType                           = 38
	MySqlParserRULE_indexOption                         = 39
	MySqlParserRULE_procedureParameter                  = 40
	MySqlParserRULE_functionParameter                   = 41
	MySqlParserRULE_routineOption                       = 42
	MySqlParserRULE_serverOption                        = 43
	MySqlParserRULE_createDefinitions                   = 44
	MySqlParserRULE_createDefinition                    = 45
	MySqlParserRULE_columnDefinition                    = 46
	MySqlParserRULE_columnConstraint                    = 47
	MySqlParserRULE_tableConstraint                     = 48
	MySqlParserRULE_referenceDefinition                 = 49
	MySqlParserRULE_referenceAction                     = 50
	MySqlParserRULE_referenceControlType                = 51
	MySqlParserRULE_indexColumnDefinition               = 52
	MySqlParserRULE_tableOption                         = 53
	MySqlParserRULE_tableType                           = 54
	MySqlParserRULE_tablespaceStorage                   = 55
	MySqlParserRULE_partitionDefinitions                = 56
	MySqlParserRULE_partitionFunctionDefinition         = 57
	MySqlParserRULE_subpartitionFunctionDefinition      = 58
	MySqlParserRULE_partitionDefinition                 = 59
	MySqlParserRULE_partitionDefinerAtom                = 60
	MySqlParserRULE_partitionDefinerVector              = 61
	MySqlParserRULE_subpartitionDefinition              = 62
	MySqlParserRULE_partitionOption                     = 63
	MySqlParserRULE_alterDatabase                       = 64
	MySqlParserRULE_alterEvent                          = 65
	MySqlParserRULE_alterFunction                       = 66
	MySqlParserRULE_alterInstance                       = 67
	MySqlParserRULE_alterLogfileGroup                   = 68
	MySqlParserRULE_alterProcedure                      = 69
	MySqlParserRULE_alterServer                         = 70
	MySqlParserRULE_alterTable                          = 71
	MySqlParserRULE_alterTablespace                     = 72
	MySqlParserRULE_alterView                           = 73
	MySqlParserRULE_alterSpecification                  = 74
	MySqlParserRULE_alterPartitionSpecification         = 75
	MySqlParserRULE_dropDatabase                        = 76
	MySqlParserRULE_dropEvent                           = 77
	MySqlParserRULE_dropIndex                           = 78
	MySqlParserRULE_dropLogfileGroup                    = 79
	MySqlParserRULE_dropProcedure                       = 80
	MySqlParserRULE_dropFunction                        = 81
	MySqlParserRULE_dropServer                          = 82
	MySqlParserRULE_dropTable                           = 83
	MySqlParserRULE_dropTablespace                      = 84
	MySqlParserRULE_dropTrigger                         = 85
	MySqlParserRULE_dropView                            = 86
	MySqlParserRULE_dropRole                            = 87
	MySqlParserRULE_setRole                             = 88
	MySqlParserRULE_renameTable                         = 89
	MySqlParserRULE_renameTableClause                   = 90
	MySqlParserRULE_truncateTable                       = 91
	MySqlParserRULE_callStatement                       = 92
	MySqlParserRULE_deleteStatement                     = 93
	MySqlParserRULE_doStatement                         = 94
	MySqlParserRULE_handlerStatement                    = 95
	MySqlParserRULE_insertStatement                     = 96
	MySqlParserRULE_loadDataStatement                   = 97
	MySqlParserRULE_loadXmlStatement                    = 98
	MySqlParserRULE_replaceStatement                    = 99
	MySqlParserRULE_selectStatement                     = 100
	MySqlParserRULE_updateStatement                     = 101
	MySqlParserRULE_valuesStatement                     = 102
	MySqlParserRULE_insertStatementValue                = 103
	MySqlParserRULE_updatedElement                      = 104
	MySqlParserRULE_assignmentField                     = 105
	MySqlParserRULE_lockClause                          = 106
	MySqlParserRULE_singleDeleteStatement               = 107
	MySqlParserRULE_multipleDeleteStatement             = 108
	MySqlParserRULE_handlerOpenStatement                = 109
	MySqlParserRULE_handlerReadIndexStatement           = 110
	MySqlParserRULE_handlerReadStatement                = 111
	MySqlParserRULE_handlerCloseStatement               = 112
	MySqlParserRULE_singleUpdateStatement               = 113
	MySqlParserRULE_multipleUpdateStatement             = 114
	MySqlParserRULE_orderByClause                       = 115
	MySqlParserRULE_orderByExpression                   = 116
	MySqlParserRULE_tableSources                        = 117
	MySqlParserRULE_tableSource                         = 118
	MySqlParserRULE_tableSourceItem                     = 119
	MySqlParserRULE_indexHint                           = 120
	MySqlParserRULE_indexHintType                       = 121
	MySqlParserRULE_joinPart                            = 122
	MySqlParserRULE_joinSpec                            = 123
	MySqlParserRULE_queryExpression                     = 124
	MySqlParserRULE_queryExpressionNointo               = 125
	MySqlParserRULE_querySpecification                  = 126
	MySqlParserRULE_proxyHint                           = 127
	MySqlParserRULE_querySpecificationNointo            = 128
	MySqlParserRULE_unionParenthesis                    = 129
	MySqlParserRULE_unionStatement                      = 130
	MySqlParserRULE_lateralStatement                    = 131
	MySqlParserRULE_jsonTable                           = 132
	MySqlParserRULE_jsonColumnList                      = 133
	MySqlParserRULE_jsonColumn                          = 134
	MySqlParserRULE_jsonOnEmpty                         = 135
	MySqlParserRULE_jsonOnError                         = 136
	MySqlParserRULE_selectSpec                          = 137
	MySqlParserRULE_selectElements                      = 138
	MySqlParserRULE_selectElement                       = 139
	MySqlParserRULE_selectIntoExpression                = 140
	MySqlParserRULE_selectFieldsInto                    = 141
	MySqlParserRULE_selectLinesInto                     = 142
	MySqlParserRULE_fromClause                          = 143
	MySqlParserRULE_groupByClause                       = 144
	MySqlParserRULE_havingClause                        = 145
	MySqlParserRULE_windowClause                        = 146
	MySqlParserRULE_groupByItem                         = 147
	MySqlParserRULE_limitClause                         = 148
	MySqlParserRULE_limitClauseAtom                     = 149
	MySqlParserRULE_startTransaction                    = 150
	MySqlParserRULE_beginWork                           = 151
	MySqlParserRULE_commitWork                          = 152
	MySqlParserRULE_rollbackWork                        = 153
	MySqlParserRULE_savepointStatement                  = 154
	MySqlParserRULE_rollbackStatement                   = 155
	MySqlParserRULE_releaseStatement                    = 156
	MySqlParserRULE_lockTables                          = 157
	MySqlParserRULE_unlockTables                        = 158
	MySqlParserRULE_setAutocommitStatement              = 159
	MySqlParserRULE_setTransactionStatement             = 160
	MySqlParserRULE_transactionMode                     = 161
	MySqlParserRULE_lockTableElement                    = 162
	MySqlParserRULE_lockAction                          = 163
	MySqlParserRULE_transactionOption                   = 164
	MySqlParserRULE_transactionLevel                    = 165
	MySqlParserRULE_changeMaster                        = 166
	MySqlParserRULE_changeReplicationFilter             = 167
	MySqlParserRULE_purgeBinaryLogs                     = 168
	MySqlParserRULE_resetMaster                         = 169
	MySqlParserRULE_resetSlave                          = 170
	MySqlParserRULE_startSlave                          = 171
	MySqlParserRULE_stopSlave                           = 172
	MySqlParserRULE_startGroupReplication               = 173
	MySqlParserRULE_stopGroupReplication                = 174
	MySqlParserRULE_masterOption                        = 175
	MySqlParserRULE_stringMasterOption                  = 176
	MySqlParserRULE_decimalMasterOption                 = 177
	MySqlParserRULE_boolMasterOption                    = 178
	MySqlParserRULE_channelOption                       = 179
	MySqlParserRULE_replicationFilter                   = 180
	MySqlParserRULE_tablePair                           = 181
	MySqlParserRULE_threadType                          = 182
	MySqlParserRULE_untilOption                         = 183
	MySqlParserRULE_connectionOption                    = 184
	MySqlParserRULE_gtuidSet                            = 185
	MySqlParserRULE_xaStartTransaction                  = 186
	MySqlParserRULE_xaEndTransaction                    = 187
	MySqlParserRULE_xaPrepareStatement                  = 188
	MySqlParserRULE_xaCommitWork                        = 189
	MySqlParserRULE_xaRollbackWork                      = 190
	MySqlParserRULE_xaRecoverWork                       = 191
	MySqlParserRULE_prepareStatement                    = 192
	MySqlParserRULE_executeStatement                    = 193
	MySqlParserRULE_deallocatePrepare                   = 194
	MySqlParserRULE_routineBody                         = 195
	MySqlParserRULE_blockStatement                      = 196
	MySqlParserRULE_caseStatement                       = 197
	MySqlParserRULE_ifStatement                         = 198
	MySqlParserRULE_iterateStatement                    = 199
	MySqlParserRULE_leaveStatement                      = 200
	MySqlParserRULE_loopStatement                       = 201
	MySqlParserRULE_repeatStatement                     = 202
	MySqlParserRULE_returnStatement                     = 203
	MySqlParserRULE_whileStatement                      = 204
	MySqlParserRULE_cursorStatement                     = 205
	MySqlParserRULE_declareVariable                     = 206
	MySqlParserRULE_declareCondition                    = 207
	MySqlParserRULE_declareCursor                       = 208
	MySqlParserRULE_declareHandler                      = 209
	MySqlParserRULE_handlerConditionValue               = 210
	MySqlParserRULE_procedureSqlStatement               = 211
	MySqlParserRULE_caseAlternative                     = 212
	MySqlParserRULE_elifAlternative                     = 213
	MySqlParserRULE_alterUser                           = 214
	MySqlParserRULE_createUser                          = 215
	MySqlParserRULE_dropUser                            = 216
	MySqlParserRULE_grantStatement                      = 217
	MySqlParserRULE_roleOption                          = 218
	MySqlParserRULE_grantProxy                          = 219
	MySqlParserRULE_renameUser                          = 220
	MySqlParserRULE_revokeStatement                     = 221
	MySqlParserRULE_revokeProxy                         = 222
	MySqlParserRULE_setPasswordStatement                = 223
	MySqlParserRULE_userSpecification                   = 224
	MySqlParserRULE_userAuthOption                      = 225
	MySqlParserRULE_authOptionClause                    = 226
	MySqlParserRULE_authenticationRule                  = 227
	MySqlParserRULE_tlsOption                           = 228
	MySqlParserRULE_userResourceOption                  = 229
	MySqlParserRULE_userPasswordOption                  = 230
	MySqlParserRULE_userLockOption                      = 231
	MySqlParserRULE_privelegeClause                     = 232
	MySqlParserRULE_privilege                           = 233
	MySqlParserRULE_privilegeLevel                      = 234
	MySqlParserRULE_renameUserClause                    = 235
	MySqlParserRULE_analyzeTable                        = 236
	MySqlParserRULE_checkTable                          = 237
	MySqlParserRULE_checksumTable                       = 238
	MySqlParserRULE_optimizeTable                       = 239
	MySqlParserRULE_repairTable                         = 240
	MySqlParserRULE_checkTableOption                    = 241
	MySqlParserRULE_createUdfunction                    = 242
	MySqlParserRULE_installPlugin                       = 243
	MySqlParserRULE_uninstallPlugin                     = 244
	MySqlParserRULE_setStatement                        = 245
	MySqlParserRULE_showStatement                       = 246
	MySqlParserRULE_variableClause                      = 247
	MySqlParserRULE_showCommonEntity                    = 248
	MySqlParserRULE_showFilter                          = 249
	MySqlParserRULE_showGlobalInfoClause                = 250
	MySqlParserRULE_showSchemaEntity                    = 251
	MySqlParserRULE_showProfileType                     = 252
	MySqlParserRULE_binlogStatement                     = 253
	MySqlParserRULE_cacheIndexStatement                 = 254
	MySqlParserRULE_flushStatement                      = 255
	MySqlParserRULE_killStatement                       = 256
	MySqlParserRULE_loadIndexIntoCache                  = 257
	MySqlParserRULE_resetStatement                      = 258
	MySqlParserRULE_shutdownStatement                   = 259
	MySqlParserRULE_tableIndexes                        = 260
	MySqlParserRULE_flushOption                         = 261
	MySqlParserRULE_flushTableOption                    = 262
	MySqlParserRULE_loadedTableIndexes                  = 263
	MySqlParserRULE_simpleDescribeStatement             = 264
	MySqlParserRULE_fullDescribeStatement               = 265
	MySqlParserRULE_helpStatement                       = 266
	MySqlParserRULE_useStatement                        = 267
	MySqlParserRULE_signalStatement                     = 268
	MySqlParserRULE_resignalStatement                   = 269
	MySqlParserRULE_signalConditionInformation          = 270
	MySqlParserRULE_withStatement                       = 271
	MySqlParserRULE_tableStatement                      = 272
	MySqlParserRULE_diagnosticsStatement                = 273
	MySqlParserRULE_diagnosticsConditionInformationName = 274
	MySqlParserRULE_describeObjectClause                = 275
	MySqlParserRULE_fullId                              = 276
	MySqlParserRULE_tableName                           = 277
	MySqlParserRULE_roleName                            = 278
	MySqlParserRULE_fullColumnName                      = 279
	MySqlParserRULE_indexColumnName                     = 280
	MySqlParserRULE_simpleUserName                      = 281
	MySqlParserRULE_hostName                            = 282
	MySqlParserRULE_userName                            = 283
	MySqlParserRULE_mysqlVariable                       = 284
	MySqlParserRULE_charsetName                         = 285
	MySqlParserRULE_collationName                       = 286
	MySqlParserRULE_engineName                          = 287
	MySqlParserRULE_engineNameBase                      = 288
	MySqlParserRULE_uuidSet                             = 289
	MySqlParserRULE_xid                                 = 290
	MySqlParserRULE_xuidStringId                        = 291
	MySqlParserRULE_authPlugin                          = 292
	MySqlParserRULE_uid                                 = 293
	MySqlParserRULE_simpleId                            = 294
	MySqlParserRULE_dottedId                            = 295
	MySqlParserRULE_decimalLiteral                      = 296
	MySqlParserRULE_fileSizeLiteral                     = 297
	MySqlParserRULE_stringLiteral                       = 298
	MySqlParserRULE_booleanLiteral                      = 299
	MySqlParserRULE_hexadecimalLiteral                  = 300
	MySqlParserRULE_nullNotnull                         = 301
	MySqlParserRULE_constant                            = 302
	MySqlParserRULE_dataType                            = 303
	MySqlParserRULE_collectionOptions                   = 304
	MySqlParserRULE_convertedDataType                   = 305
	MySqlParserRULE_lengthOneDimension                  = 306
	MySqlParserRULE_lengthTwoDimension                  = 307
	MySqlParserRULE_lengthTwoOptionalDimension          = 308
	MySqlParserRULE_uidList                             = 309
	MySqlParserRULE_fullColumnNameList                  = 310
	MySqlParserRULE_tables                              = 311
	MySqlParserRULE_indexColumnNames                    = 312
	MySqlParserRULE_expressions                         = 313
	MySqlParserRULE_expressionsWithDefaults             = 314
	MySqlParserRULE_constants                           = 315
	MySqlParserRULE_simpleStrings                       = 316
	MySqlParserRULE_userVariables                       = 317
	MySqlParserRULE_defaultValue                        = 318
	MySqlParserRULE_currentTimestamp                    = 319
	MySqlParserRULE_expressionOrDefault                 = 320
	MySqlParserRULE_ifExists                            = 321
	MySqlParserRULE_ifNotExists                         = 322
	MySqlParserRULE_orReplace                           = 323
	MySqlParserRULE_waitNowaitClause                    = 324
	MySqlParserRULE_functionCall                        = 325
	MySqlParserRULE_specificFunction                    = 326
	MySqlParserRULE_caseFuncAlternative                 = 327
	MySqlParserRULE_levelsInWeightString                = 328
	MySqlParserRULE_levelInWeightListElement            = 329
	MySqlParserRULE_aggregateWindowedFunction           = 330
	MySqlParserRULE_nonAggregateWindowedFunction        = 331
	MySqlParserRULE_overClause                          = 332
	MySqlParserRULE_windowSpec                          = 333
	MySqlParserRULE_windowName                          = 334
	MySqlParserRULE_frameClause                         = 335
	MySqlParserRULE_frameUnits                          = 336
	MySqlParserRULE_frameExtent                         = 337
	MySqlParserRULE_frameBetween                        = 338
	MySqlParserRULE_frameRange                          = 339
	MySqlParserRULE_partitionClause                     = 340
	MySqlParserRULE_scalarFunctionName                  = 341
	MySqlParserRULE_passwordFunctionClause              = 342
	MySqlParserRULE_functionArgs                        = 343
	MySqlParserRULE_functionArg                         = 344
	MySqlParserRULE_expression                          = 345
	MySqlParserRULE_predicate                           = 346
	MySqlParserRULE_expressionAtom                      = 347
	MySqlParserRULE_unaryOperator                       = 348
	MySqlParserRULE_comparisonOperator                  = 349
	MySqlParserRULE_logicalOperator                     = 350
	MySqlParserRULE_bitOperator                         = 351
	MySqlParserRULE_multOperator                        = 352
	MySqlParserRULE_addOperator                         = 353
	MySqlParserRULE_jsonOperator                        = 354
	MySqlParserRULE_charsetNameBase                     = 355
	MySqlParserRULE_transactionLevelBase                = 356
	MySqlParserRULE_privilegesBase                      = 357
	MySqlParserRULE_intervalTypeBase                    = 358
	MySqlParserRULE_dataTypeBase                        = 359
	MySqlParserRULE_keywordsCanBeId                     = 360
	MySqlParserRULE_functionNameBase                    = 361
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	SqlStatements() ISqlStatementsContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySqlParserEOF, 0)
}

func (s *RootContext) SqlStatements() ISqlStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementsContext)
}

func (s *RootContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *RootContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MySqlParserRULE_root)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2307030486109126976) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&2306124490637066243) != 0) || ((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&19509751503569451) != 0) || ((int64((_la-343)) & ^0x3f) == 0 && ((int64(1)<<(_la-343))&36099165796700291) != 0) || ((int64((_la-431)) & ^0x3f) == 0 && ((int64(1)<<(_la-431))&16782337) != 0) || ((int64((_la-559)) & ^0x3f) == 0 && ((int64(1)<<(_la-559))&17730162917377) != 0) || ((int64((_la-628)) & ^0x3f) == 0 && ((int64(1)<<(_la-628))&4503604056555585) != 0) || _la == MySqlParserEXECUTE || _la == MySqlParserSHUTDOWN || _la == MySqlParserLR_BRACKET || _la == MySqlParserSEMI {
		{
			p.SetState(724)
			p.SqlStatements()
		}

	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMINUS {
		{
			p.SetState(727)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(728)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(731)
		p.Match(MySqlParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSqlStatement() []ISqlStatementContext
	SqlStatement(i int) ISqlStatementContext
	AllEmptyStatement_() []IEmptyStatement_Context
	EmptyStatement_(i int) IEmptyStatement_Context
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) AllSqlStatement() []ISqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ISqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlStatementContext); ok {
			tst[i] = t.(ISqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SqlStatement(i int) ISqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SqlStatementsContext) AllEmptyStatement_() []IEmptyStatement_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			len++
		}
	}

	tst := make([]IEmptyStatement_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmptyStatement_Context); ok {
			tst[i] = t.(IEmptyStatement_Context)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) EmptyStatement_(i int) IEmptyStatement_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SqlStatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *SqlStatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *SqlStatementsContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *SqlStatementsContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MySqlParserRULE_sqlStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(742)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserLR_BRACKET:
				{
					p.SetState(733)
					p.SqlStatement()
				}
				p.SetState(736)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserMINUS {
					{
						p.SetState(734)
						p.Match(MySqlParserMINUS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(735)
						p.Match(MySqlParserMINUS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(739)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(738)
						p.Match(MySqlParserSEMI)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case MySqlParserSEMI:
				{
					p.SetState(741)
					p.EmptyStatement_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserLR_BRACKET:
		{
			p.SetState(747)
			p.SqlStatement()
		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			p.SetState(750)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserMINUS {
				{
					p.SetState(748)
					p.Match(MySqlParserMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(749)
					p.Match(MySqlParserMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(752)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserSEMI:
		{
			p.SetState(755)
			p.EmptyStatement_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DdlStatement() IDdlStatementContext
	DmlStatement() IDmlStatementContext
	TransactionStatement() ITransactionStatementContext
	ReplicationStatement() IReplicationStatementContext
	PreparedStatement() IPreparedStatementContext
	AdministrationStatement() IAdministrationStatementContext
	UtilityStatement() IUtilityStatementContext

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatement
	return p
}

func InitEmptySqlStatementContext(p *SqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatement
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DdlStatement() IDdlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDdlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDdlStatementContext)
}

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) TransactionStatement() ITransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionStatementContext)
}

func (s *SqlStatementContext) ReplicationStatement() IReplicationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationStatementContext)
}

func (s *SqlStatementContext) PreparedStatement() IPreparedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreparedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreparedStatementContext)
}

func (s *SqlStatementContext) AdministrationStatement() IAdministrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdministrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdministrationStatementContext)
}

func (s *SqlStatementContext) UtilityStatement() IUtilityStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUtilityStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUtilityStatementContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (s *SqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SqlStatement() (localctx ISqlStatementContext) {
	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MySqlParserRULE_sqlStatement)
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(758)
			p.DdlStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(759)
			p.DmlStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(760)
			p.TransactionStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(761)
			p.ReplicationStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(762)
			p.PreparedStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(763)
			p.AdministrationStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(764)
			p.UtilityStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MySqlParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(MySqlParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDdlStatementContext is an interface to support dynamic dispatch.
type IDdlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateDatabase() ICreateDatabaseContext
	CreateEvent() ICreateEventContext
	CreateIndex() ICreateIndexContext
	CreateLogfileGroup() ICreateLogfileGroupContext
	CreateProcedure() ICreateProcedureContext
	CreateFunction() ICreateFunctionContext
	CreateServer() ICreateServerContext
	CreateTable() ICreateTableContext
	CreateTablespaceInnodb() ICreateTablespaceInnodbContext
	CreateTablespaceNdb() ICreateTablespaceNdbContext
	CreateTrigger() ICreateTriggerContext
	CreateView() ICreateViewContext
	CreateRole() ICreateRoleContext
	AlterDatabase() IAlterDatabaseContext
	AlterEvent() IAlterEventContext
	AlterFunction() IAlterFunctionContext
	AlterInstance() IAlterInstanceContext
	AlterLogfileGroup() IAlterLogfileGroupContext
	AlterProcedure() IAlterProcedureContext
	AlterServer() IAlterServerContext
	AlterTable() IAlterTableContext
	AlterTablespace() IAlterTablespaceContext
	AlterView() IAlterViewContext
	DropDatabase() IDropDatabaseContext
	DropEvent() IDropEventContext
	DropIndex() IDropIndexContext
	DropLogfileGroup() IDropLogfileGroupContext
	DropProcedure() IDropProcedureContext
	DropFunction() IDropFunctionContext
	DropServer() IDropServerContext
	DropTable() IDropTableContext
	DropTablespace() IDropTablespaceContext
	DropTrigger() IDropTriggerContext
	DropView() IDropViewContext
	DropRole() IDropRoleContext
	SetRole() ISetRoleContext
	RenameTable() IRenameTableContext
	TruncateTable() ITruncateTableContext

	// IsDdlStatementContext differentiates from other interfaces.
	IsDdlStatementContext()
}

type DdlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDdlStatementContext() *DdlStatementContext {
	var p = new(DdlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ddlStatement
	return p
}

func InitEmptyDdlStatementContext(p *DdlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ddlStatement
}

func (*DdlStatementContext) IsDdlStatementContext() {}

func NewDdlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DdlStatementContext {
	var p = new(DdlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ddlStatement

	return p
}

func (s *DdlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DdlStatementContext) CreateDatabase() ICreateDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *DdlStatementContext) CreateEvent() ICreateEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateEventContext)
}

func (s *DdlStatementContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *DdlStatementContext) CreateLogfileGroup() ICreateLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateLogfileGroupContext)
}

func (s *DdlStatementContext) CreateProcedure() ICreateProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateProcedureContext)
}

func (s *DdlStatementContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *DdlStatementContext) CreateServer() ICreateServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateServerContext)
}

func (s *DdlStatementContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *DdlStatementContext) CreateTablespaceInnodb() ICreateTablespaceInnodbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceInnodbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceInnodbContext)
}

func (s *DdlStatementContext) CreateTablespaceNdb() ICreateTablespaceNdbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceNdbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceNdbContext)
}

func (s *DdlStatementContext) CreateTrigger() ICreateTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *DdlStatementContext) CreateView() ICreateViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *DdlStatementContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *DdlStatementContext) AlterDatabase() IAlterDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseContext)
}

func (s *DdlStatementContext) AlterEvent() IAlterEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterEventContext)
}

func (s *DdlStatementContext) AlterFunction() IAlterFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterFunctionContext)
}

func (s *DdlStatementContext) AlterInstance() IAlterInstanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterInstanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterInstanceContext)
}

func (s *DdlStatementContext) AlterLogfileGroup() IAlterLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLogfileGroupContext)
}

func (s *DdlStatementContext) AlterProcedure() IAlterProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterProcedureContext)
}

func (s *DdlStatementContext) AlterServer() IAlterServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterServerContext)
}

func (s *DdlStatementContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *DdlStatementContext) AlterTablespace() IAlterTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTablespaceContext)
}

func (s *DdlStatementContext) AlterView() IAlterViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewContext)
}

func (s *DdlStatementContext) DropDatabase() IDropDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *DdlStatementContext) DropEvent() IDropEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropEventContext)
}

func (s *DdlStatementContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *DdlStatementContext) DropLogfileGroup() IDropLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropLogfileGroupContext)
}

func (s *DdlStatementContext) DropProcedure() IDropProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropProcedureContext)
}

func (s *DdlStatementContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *DdlStatementContext) DropServer() IDropServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropServerContext)
}

func (s *DdlStatementContext) DropTable() IDropTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *DdlStatementContext) DropTablespace() IDropTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTablespaceContext)
}

func (s *DdlStatementContext) DropTrigger() IDropTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *DdlStatementContext) DropView() IDropViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *DdlStatementContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *DdlStatementContext) SetRole() ISetRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleContext)
}

func (s *DdlStatementContext) RenameTable() IRenameTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableContext)
}

func (s *DdlStatementContext) TruncateTable() ITruncateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableContext)
}

func (s *DdlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DdlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DdlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDdlStatement(s)
	}
}

func (s *DdlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDdlStatement(s)
	}
}

func (s *DdlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDdlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DdlStatement() (localctx IDdlStatementContext) {
	localctx = NewDdlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MySqlParserRULE_ddlStatement)
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(769)
			p.CreateDatabase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(770)
			p.CreateEvent()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(771)
			p.CreateIndex()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(772)
			p.CreateLogfileGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(773)
			p.CreateProcedure()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(774)
			p.CreateFunction()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(775)
			p.CreateServer()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(776)
			p.CreateTable()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(777)
			p.CreateTablespaceInnodb()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(778)
			p.CreateTablespaceNdb()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(779)
			p.CreateTrigger()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(780)
			p.CreateView()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(781)
			p.CreateRole()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(782)
			p.AlterDatabase()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(783)
			p.AlterEvent()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(784)
			p.AlterFunction()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(785)
			p.AlterInstance()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(786)
			p.AlterLogfileGroup()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(787)
			p.AlterProcedure()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(788)
			p.AlterServer()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(789)
			p.AlterTable()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(790)
			p.AlterTablespace()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(791)
			p.AlterView()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(792)
			p.DropDatabase()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(793)
			p.DropEvent()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(794)
			p.DropIndex()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(795)
			p.DropLogfileGroup()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(796)
			p.DropProcedure()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(797)
			p.DropFunction()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(798)
			p.DropServer()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(799)
			p.DropTable()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(800)
			p.DropTablespace()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(801)
			p.DropTrigger()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(802)
			p.DropView()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(803)
			p.DropRole()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(804)
			p.SetRole()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(805)
			p.RenameTable()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(806)
			p.TruncateTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStatement() ISelectStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	ReplaceStatement() IReplaceStatementContext
	CallStatement() ICallStatementContext
	LoadDataStatement() ILoadDataStatementContext
	LoadXmlStatement() ILoadXmlStatementContext
	DoStatement() IDoStatementContext
	HandlerStatement() IHandlerStatementContext
	ValuesStatement() IValuesStatementContext
	WithStatement() IWithStatementContext
	TableStatement() ITableStatementContext

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dmlStatement
	return p
}

func InitEmptyDmlStatementContext(p *DmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dmlStatement
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DmlStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DmlStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DmlStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DmlStatementContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DmlStatementContext) CallStatement() ICallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *DmlStatementContext) LoadDataStatement() ILoadDataStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadDataStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadDataStatementContext)
}

func (s *DmlStatementContext) LoadXmlStatement() ILoadXmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadXmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadXmlStatementContext)
}

func (s *DmlStatementContext) DoStatement() IDoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *DmlStatementContext) HandlerStatement() IHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerStatementContext)
}

func (s *DmlStatementContext) ValuesStatement() IValuesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesStatementContext)
}

func (s *DmlStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *DmlStatementContext) TableStatement() ITableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDmlStatement(s)
	}
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDmlStatement(s)
	}
}

func (s *DmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DmlStatement() (localctx IDmlStatementContext) {
	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MySqlParserRULE_dmlStatement)
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(809)
			p.SelectStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(810)
			p.InsertStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(811)
			p.UpdateStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(812)
			p.DeleteStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(813)
			p.ReplaceStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(814)
			p.CallStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(815)
			p.LoadDataStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(816)
			p.LoadXmlStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(817)
			p.DoStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(818)
			p.HandlerStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(819)
			p.ValuesStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(820)
			p.WithStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(821)
			p.TableStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionStatementContext is an interface to support dynamic dispatch.
type ITransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StartTransaction() IStartTransactionContext
	BeginWork() IBeginWorkContext
	CommitWork() ICommitWorkContext
	RollbackWork() IRollbackWorkContext
	SavepointStatement() ISavepointStatementContext
	RollbackStatement() IRollbackStatementContext
	ReleaseStatement() IReleaseStatementContext
	LockTables() ILockTablesContext
	UnlockTables() IUnlockTablesContext

	// IsTransactionStatementContext differentiates from other interfaces.
	IsTransactionStatementContext()
}

type TransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionStatementContext() *TransactionStatementContext {
	var p = new(TransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionStatement
	return p
}

func InitEmptyTransactionStatementContext(p *TransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionStatement
}

func (*TransactionStatementContext) IsTransactionStatementContext() {}

func NewTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionStatementContext {
	var p = new(TransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionStatement

	return p
}

func (s *TransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionStatementContext) StartTransaction() IStartTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartTransactionContext)
}

func (s *TransactionStatementContext) BeginWork() IBeginWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginWorkContext)
}

func (s *TransactionStatementContext) CommitWork() ICommitWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitWorkContext)
}

func (s *TransactionStatementContext) RollbackWork() IRollbackWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackWorkContext)
}

func (s *TransactionStatementContext) SavepointStatement() ISavepointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISavepointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISavepointStatementContext)
}

func (s *TransactionStatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *TransactionStatementContext) ReleaseStatement() IReleaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReleaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReleaseStatementContext)
}

func (s *TransactionStatementContext) LockTables() ILockTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTablesContext)
}

func (s *TransactionStatementContext) UnlockTables() IUnlockTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlockTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlockTablesContext)
}

func (s *TransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TransactionStatement() (localctx ITransactionStatementContext) {
	localctx = NewTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MySqlParserRULE_transactionStatement)
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(824)
			p.StartTransaction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)
			p.BeginWork()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(826)
			p.CommitWork()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(827)
			p.RollbackWork()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(828)
			p.SavepointStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(829)
			p.RollbackStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(830)
			p.ReleaseStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(831)
			p.LockTables()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(832)
			p.UnlockTables()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationStatementContext is an interface to support dynamic dispatch.
type IReplicationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ChangeMaster() IChangeMasterContext
	ChangeReplicationFilter() IChangeReplicationFilterContext
	PurgeBinaryLogs() IPurgeBinaryLogsContext
	ResetMaster() IResetMasterContext
	ResetSlave() IResetSlaveContext
	StartSlave() IStartSlaveContext
	StopSlave() IStopSlaveContext
	StartGroupReplication() IStartGroupReplicationContext
	StopGroupReplication() IStopGroupReplicationContext
	XaStartTransaction() IXaStartTransactionContext
	XaEndTransaction() IXaEndTransactionContext
	XaPrepareStatement() IXaPrepareStatementContext
	XaCommitWork() IXaCommitWorkContext
	XaRollbackWork() IXaRollbackWorkContext
	XaRecoverWork() IXaRecoverWorkContext

	// IsReplicationStatementContext differentiates from other interfaces.
	IsReplicationStatementContext()
}

type ReplicationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationStatementContext() *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationStatement
	return p
}

func InitEmptyReplicationStatementContext(p *ReplicationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationStatement
}

func (*ReplicationStatementContext) IsReplicationStatementContext() {}

func NewReplicationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replicationStatement

	return p
}

func (s *ReplicationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationStatementContext) ChangeMaster() IChangeMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterContext)
}

func (s *ReplicationStatementContext) ChangeReplicationFilter() IChangeReplicationFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeReplicationFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeReplicationFilterContext)
}

func (s *ReplicationStatementContext) PurgeBinaryLogs() IPurgeBinaryLogsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPurgeBinaryLogsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPurgeBinaryLogsContext)
}

func (s *ReplicationStatementContext) ResetMaster() IResetMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetMasterContext)
}

func (s *ReplicationStatementContext) ResetSlave() IResetSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetSlaveContext)
}

func (s *ReplicationStatementContext) StartSlave() IStartSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartSlaveContext)
}

func (s *ReplicationStatementContext) StopSlave() IStopSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopSlaveContext)
}

func (s *ReplicationStatementContext) StartGroupReplication() IStartGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartGroupReplicationContext)
}

func (s *ReplicationStatementContext) StopGroupReplication() IStopGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopGroupReplicationContext)
}

func (s *ReplicationStatementContext) XaStartTransaction() IXaStartTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaStartTransactionContext)
}

func (s *ReplicationStatementContext) XaEndTransaction() IXaEndTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaEndTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaEndTransactionContext)
}

func (s *ReplicationStatementContext) XaPrepareStatement() IXaPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaPrepareStatementContext)
}

func (s *ReplicationStatementContext) XaCommitWork() IXaCommitWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaCommitWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaCommitWorkContext)
}

func (s *ReplicationStatementContext) XaRollbackWork() IXaRollbackWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRollbackWorkContext)
}

func (s *ReplicationStatementContext) XaRecoverWork() IXaRecoverWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRecoverWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRecoverWorkContext)
}

func (s *ReplicationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReplicationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReplicationStatement() (localctx IReplicationStatementContext) {
	localctx = NewReplicationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MySqlParserRULE_replicationStatement)
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(835)
			p.ChangeMaster()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(836)
			p.ChangeReplicationFilter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(837)
			p.PurgeBinaryLogs()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(838)
			p.ResetMaster()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(839)
			p.ResetSlave()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(840)
			p.StartSlave()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(841)
			p.StopSlave()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(842)
			p.StartGroupReplication()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(843)
			p.StopGroupReplication()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(844)
			p.XaStartTransaction()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(845)
			p.XaEndTransaction()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(846)
			p.XaPrepareStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(847)
			p.XaCommitWork()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(848)
			p.XaRollbackWork()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(849)
			p.XaRecoverWork()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreparedStatementContext is an interface to support dynamic dispatch.
type IPreparedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocatePrepare() IDeallocatePrepareContext

	// IsPreparedStatementContext differentiates from other interfaces.
	IsPreparedStatementContext()
}

type PreparedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreparedStatementContext() *PreparedStatementContext {
	var p = new(PreparedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_preparedStatement
	return p
}

func InitEmptyPreparedStatementContext(p *PreparedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_preparedStatement
}

func (*PreparedStatementContext) IsPreparedStatementContext() {}

func NewPreparedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreparedStatementContext {
	var p = new(PreparedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_preparedStatement

	return p
}

func (s *PreparedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PreparedStatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *PreparedStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *PreparedStatementContext) DeallocatePrepare() IDeallocatePrepareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocatePrepareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocatePrepareContext)
}

func (s *PreparedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreparedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreparedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPreparedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PreparedStatement() (localctx IPreparedStatementContext) {
	localctx = NewPreparedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MySqlParserRULE_preparedStatement)
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserPREPARE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(852)
			p.PrepareStatement()
		}

	case MySqlParserEXECUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(853)
			p.ExecuteStatement()
		}

	case MySqlParserDROP, MySqlParserDEALLOCATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(854)
			p.DeallocatePrepare()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	CaseStatement() ICaseStatementContext
	IfStatement() IIfStatementContext
	LeaveStatement() ILeaveStatementContext
	LoopStatement() ILoopStatementContext
	RepeatStatement() IRepeatStatementContext
	WhileStatement() IWhileStatementContext
	IterateStatement() IIterateStatementContext
	ReturnStatement() IReturnStatementContext
	CursorStatement() ICursorStatementContext
	WithStatement() IWithStatementContext
	DmlStatement() IDmlStatementContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *CompoundStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *CompoundStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *CompoundStatementContext) LeaveStatement() ILeaveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeaveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeaveStatementContext)
}

func (s *CompoundStatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *CompoundStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *CompoundStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *CompoundStatementContext) IterateStatement() IIterateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterateStatementContext)
}

func (s *CompoundStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CompoundStatementContext) CursorStatement() ICursorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorStatementContext)
}

func (s *CompoundStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *CompoundStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MySqlParserRULE_compoundStatement)
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(857)
			p.BlockStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(858)
			p.CaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(859)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(860)
			p.LeaveStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(861)
			p.LoopStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(862)
			p.RepeatStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(863)
			p.WhileStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(864)
			p.IterateStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(865)
			p.ReturnStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(866)
			p.CursorStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(867)
			p.WithStatement()
		}
		{
			p.SetState(868)
			p.DmlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdministrationStatementContext is an interface to support dynamic dispatch.
type IAdministrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterUser() IAlterUserContext
	CreateUser() ICreateUserContext
	DropUser() IDropUserContext
	GrantStatement() IGrantStatementContext
	GrantProxy() IGrantProxyContext
	RenameUser() IRenameUserContext
	RevokeStatement() IRevokeStatementContext
	RevokeProxy() IRevokeProxyContext
	AnalyzeTable() IAnalyzeTableContext
	CheckTable() ICheckTableContext
	ChecksumTable() IChecksumTableContext
	OptimizeTable() IOptimizeTableContext
	RepairTable() IRepairTableContext
	CreateUdfunction() ICreateUdfunctionContext
	InstallPlugin() IInstallPluginContext
	UninstallPlugin() IUninstallPluginContext
	SetStatement() ISetStatementContext
	ShowStatement() IShowStatementContext
	BinlogStatement() IBinlogStatementContext
	CacheIndexStatement() ICacheIndexStatementContext
	FlushStatement() IFlushStatementContext
	KillStatement() IKillStatementContext
	LoadIndexIntoCache() ILoadIndexIntoCacheContext
	ResetStatement() IResetStatementContext
	ShutdownStatement() IShutdownStatementContext

	// IsAdministrationStatementContext differentiates from other interfaces.
	IsAdministrationStatementContext()
}

type AdministrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdministrationStatementContext() *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_administrationStatement
	return p
}

func InitEmptyAdministrationStatementContext(p *AdministrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_administrationStatement
}

func (*AdministrationStatementContext) IsAdministrationStatementContext() {}

func NewAdministrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_administrationStatement

	return p
}

func (s *AdministrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdministrationStatementContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *AdministrationStatementContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *AdministrationStatementContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *AdministrationStatementContext) GrantStatement() IGrantStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantStatementContext)
}

func (s *AdministrationStatementContext) GrantProxy() IGrantProxyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantProxyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantProxyContext)
}

func (s *AdministrationStatementContext) RenameUser() IRenameUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserContext)
}

func (s *AdministrationStatementContext) RevokeStatement() IRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeStatementContext)
}

func (s *AdministrationStatementContext) RevokeProxy() IRevokeProxyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeProxyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeProxyContext)
}

func (s *AdministrationStatementContext) AnalyzeTable() IAnalyzeTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeTableContext)
}

func (s *AdministrationStatementContext) CheckTable() ICheckTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableContext)
}

func (s *AdministrationStatementContext) ChecksumTable() IChecksumTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChecksumTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChecksumTableContext)
}

func (s *AdministrationStatementContext) OptimizeTable() IOptimizeTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeTableContext)
}

func (s *AdministrationStatementContext) RepairTable() IRepairTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepairTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepairTableContext)
}

func (s *AdministrationStatementContext) CreateUdfunction() ICreateUdfunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUdfunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUdfunctionContext)
}

func (s *AdministrationStatementContext) InstallPlugin() IInstallPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginContext)
}

func (s *AdministrationStatementContext) UninstallPlugin() IUninstallPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginContext)
}

func (s *AdministrationStatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *AdministrationStatementContext) ShowStatement() IShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatementContext)
}

func (s *AdministrationStatementContext) BinlogStatement() IBinlogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinlogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinlogStatementContext)
}

func (s *AdministrationStatementContext) CacheIndexStatement() ICacheIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheIndexStatementContext)
}

func (s *AdministrationStatementContext) FlushStatement() IFlushStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushStatementContext)
}

func (s *AdministrationStatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *AdministrationStatementContext) LoadIndexIntoCache() ILoadIndexIntoCacheContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadIndexIntoCacheContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadIndexIntoCacheContext)
}

func (s *AdministrationStatementContext) ResetStatement() IResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetStatementContext)
}

func (s *AdministrationStatementContext) ShutdownStatement() IShutdownStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShutdownStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShutdownStatementContext)
}

func (s *AdministrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdministrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdministrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAdministrationStatement(s)
	}
}

func (s *AdministrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAdministrationStatement(s)
	}
}

func (s *AdministrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAdministrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AdministrationStatement() (localctx IAdministrationStatementContext) {
	localctx = NewAdministrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MySqlParserRULE_administrationStatement)
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.AlterUser()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(873)
			p.CreateUser()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(874)
			p.DropUser()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(875)
			p.GrantStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(876)
			p.GrantProxy()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(877)
			p.RenameUser()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(878)
			p.RevokeStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(879)
			p.RevokeProxy()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(880)
			p.AnalyzeTable()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(881)
			p.CheckTable()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(882)
			p.ChecksumTable()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(883)
			p.OptimizeTable()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(884)
			p.RepairTable()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(885)
			p.CreateUdfunction()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(886)
			p.InstallPlugin()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(887)
			p.UninstallPlugin()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(888)
			p.SetStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(889)
			p.ShowStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(890)
			p.BinlogStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(891)
			p.CacheIndexStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(892)
			p.FlushStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(893)
			p.KillStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(894)
			p.LoadIndexIntoCache()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(895)
			p.ResetStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(896)
			p.ShutdownStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUtilityStatementContext is an interface to support dynamic dispatch.
type IUtilityStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleDescribeStatement() ISimpleDescribeStatementContext
	FullDescribeStatement() IFullDescribeStatementContext
	HelpStatement() IHelpStatementContext
	UseStatement() IUseStatementContext
	SignalStatement() ISignalStatementContext
	ResignalStatement() IResignalStatementContext
	DiagnosticsStatement() IDiagnosticsStatementContext

	// IsUtilityStatementContext differentiates from other interfaces.
	IsUtilityStatementContext()
}

type UtilityStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtilityStatementContext() *UtilityStatementContext {
	var p = new(UtilityStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_utilityStatement
	return p
}

func InitEmptyUtilityStatementContext(p *UtilityStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_utilityStatement
}

func (*UtilityStatementContext) IsUtilityStatementContext() {}

func NewUtilityStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UtilityStatementContext {
	var p = new(UtilityStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_utilityStatement

	return p
}

func (s *UtilityStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UtilityStatementContext) SimpleDescribeStatement() ISimpleDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDescribeStatementContext)
}

func (s *UtilityStatementContext) FullDescribeStatement() IFullDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullDescribeStatementContext)
}

func (s *UtilityStatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *UtilityStatementContext) UseStatement() IUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *UtilityStatementContext) SignalStatement() ISignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalStatementContext)
}

func (s *UtilityStatementContext) ResignalStatement() IResignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignalStatementContext)
}

func (s *UtilityStatementContext) DiagnosticsStatement() IDiagnosticsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsStatementContext)
}

func (s *UtilityStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UtilityStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UtilityStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUtilityStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UtilityStatement() (localctx IUtilityStatementContext) {
	localctx = NewUtilityStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MySqlParserRULE_utilityStatement)
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.SimpleDescribeStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.FullDescribeStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(901)
			p.HelpStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(902)
			p.UseStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(903)
			p.SignalStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(904)
			p.ResignalStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(905)
			p.DiagnosticsStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token

	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllCreateDatabaseOption() []ICreateDatabaseOptionContext
	CreateDatabaseOption(i int) ICreateDatabaseOptionContext

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabase
	return p
}

func InitEmptyCreateDatabaseContext(p *CreateDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabase
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *CreateDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MySqlParserRULE_createDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(909)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(911)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(910)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(913)
		p.Uid()
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2199107141632) != 0) || _la == MySqlParserREAD || _la == MySqlParserCHAR || _la == MySqlParserENCRYPTION || _la == MySqlParserCHARSET {
		{
			p.SetState(914)
			p.CreateDatabaseOption()
		}

		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateEventContext is an interface to support dynamic dispatch.
type ICreateEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OwnerStatement() IOwnerStatementContext
	IfNotExists() IIfNotExistsContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsCreateEventContext differentiates from other interfaces.
	IsCreateEventContext()
}

type CreateEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateEventContext() *CreateEventContext {
	var p = new(CreateEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createEvent
	return p
}

func InitEmptyCreateEventContext(p *CreateEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createEvent
}

func (*CreateEventContext) IsCreateEventContext() {}

func NewCreateEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateEventContext {
	var p = new(CreateEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createEvent

	return p
}

func (s *CreateEventContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateEventContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *CreateEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *CreateEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *CreateEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *CreateEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *CreateEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *CreateEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateEventContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *CreateEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *CreateEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *CreateEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *CreateEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateEvent(s)
	}
}

func (s *CreateEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateEvent(s)
	}
}

func (s *CreateEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateEvent() (localctx ICreateEventContext) {
	localctx = NewCreateEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MySqlParserRULE_createEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(920)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(921)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(924)
		p.Match(MySqlParserEVENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(925)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(928)
		p.FullId()
	}
	{
		p.SetState(929)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(930)
		p.Match(MySqlParserSCHEDULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(931)
		p.ScheduleExpression()
	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserON {
		{
			p.SetState(932)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(933)
			p.Match(MySqlParserCOMPLETION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(934)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(937)
			p.Match(MySqlParserPRESERVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDISABLE || _la == MySqlParserENABLE {
		{
			p.SetState(940)
			p.EnableType()
		}

	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(943)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(944)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(947)
		p.Match(MySqlParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(948)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// GetIndexCategory returns the indexCategory token.
	GetIndexCategory() antlr.Token

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// SetIndexCategory sets the indexCategory token.
	SetIndexCategory(antlr.Token)

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	IndexType() IIndexTypeContext
	AllIndexOption() []IIndexOptionContext
	IndexOption(i int) IIndexOptionContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	FULLTEXT() antlr.TerminalNode
	SPATIAL() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	intimeAction  antlr.Token
	indexCategory antlr.Token
	algType       antlr.Token
	lockType      antlr.Token
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createIndex
	return p
}

func InitEmptyCreateIndexContext(p *CreateIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createIndex
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *CreateIndexContext) GetIndexCategory() antlr.Token { return s.indexCategory }

func (s *CreateIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateIndexContext) GetLockType() antlr.Token { return s.lockType }

func (s *CreateIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *CreateIndexContext) SetIndexCategory(v antlr.Token) { s.indexCategory = v }

func (s *CreateIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateIndexContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *CreateIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *CreateIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *CreateIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *CreateIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserALGORITHM)
}

func (s *CreateIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, i)
}

func (s *CreateIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCK)
}

func (s *CreateIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, i)
}

func (s *CreateIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *CreateIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *CreateIndexContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *CreateIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *CreateIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *CreateIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *CreateIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *CreateIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserINPLACE)
}

func (s *CreateIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, i)
}

func (s *CreateIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOPY)
}

func (s *CreateIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, i)
}

func (s *CreateIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNONE)
}

func (s *CreateIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, i)
}

func (s *CreateIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSHARED)
}

func (s *CreateIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, i)
}

func (s *CreateIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEXCLUSIVE)
}

func (s *CreateIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, i)
}

func (s *CreateIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (s *CreateIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateIndex() (localctx ICreateIndexContext) {
	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MySqlParserRULE_createIndex)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserOFFLINE || _la == MySqlParserONLINE {
		{
			p.SetState(951)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL || _la == MySqlParserUNIQUE {
		{
			p.SetState(954)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).indexCategory = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL || _la == MySqlParserUNIQUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).indexCategory = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(957)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(958)
		p.Uid()
	}
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUSING {
		{
			p.SetState(959)
			p.IndexType()
		}

	}
	{
		p.SetState(962)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(963)
		p.TableName()
	}
	{
		p.SetState(964)
		p.IndexColumnNames()
	}
	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(965)
				p.IndexOption()
			}

		}
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(981)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALGORITHM:
				{
					p.SetState(971)
					p.Match(MySqlParserALGORITHM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(973)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(972)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(975)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case MySqlParserLOCK:
				{
					p.SetState(976)
					p.Match(MySqlParserLOCK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(978)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(977)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(980)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateLogfileGroupContext is an interface to support dynamic dispatch.
type ICreateLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUndoFile returns the undoFile token.
	GetUndoFile() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetUndoFile sets the undoFile token.
	SetUndoFile(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetInitSize returns the initSize rule contexts.
	GetInitSize() IFileSizeLiteralContext

	// GetUndoSize returns the undoSize rule contexts.
	GetUndoSize() IFileSizeLiteralContext

	// GetRedoSize returns the redoSize rule contexts.
	GetRedoSize() IFileSizeLiteralContext

	// SetInitSize sets the initSize rule contexts.
	SetInitSize(IFileSizeLiteralContext)

	// SetUndoSize sets the undoSize rule contexts.
	SetUndoSize(IFileSizeLiteralContext)

	// SetRedoSize sets the redoSize rule contexts.
	SetRedoSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateLogfileGroupContext differentiates from other interfaces.
	IsCreateLogfileGroupContext()
}

type CreateLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	undoFile antlr.Token
	initSize IFileSizeLiteralContext
	undoSize IFileSizeLiteralContext
	redoSize IFileSizeLiteralContext
	comment  antlr.Token
}

func NewEmptyCreateLogfileGroupContext() *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createLogfileGroup
	return p
}

func InitEmptyCreateLogfileGroupContext(p *CreateLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createLogfileGroup
}

func (*CreateLogfileGroupContext) IsCreateLogfileGroupContext() {}

func NewCreateLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createLogfileGroup

	return p
}

func (s *CreateLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateLogfileGroupContext) GetUndoFile() antlr.Token { return s.undoFile }

func (s *CreateLogfileGroupContext) GetComment() antlr.Token { return s.comment }

func (s *CreateLogfileGroupContext) SetUndoFile(v antlr.Token) { s.undoFile = v }

func (s *CreateLogfileGroupContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateLogfileGroupContext) GetInitSize() IFileSizeLiteralContext { return s.initSize }

func (s *CreateLogfileGroupContext) GetUndoSize() IFileSizeLiteralContext { return s.undoSize }

func (s *CreateLogfileGroupContext) GetRedoSize() IFileSizeLiteralContext { return s.redoSize }

func (s *CreateLogfileGroupContext) SetInitSize(v IFileSizeLiteralContext) { s.initSize = v }

func (s *CreateLogfileGroupContext) SetUndoSize(v IFileSizeLiteralContext) { s.undoSize = v }

func (s *CreateLogfileGroupContext) SetRedoSize(v IFileSizeLiteralContext) { s.redoSize = v }

func (s *CreateLogfileGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *CreateLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *CreateLogfileGroupContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *CreateLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateLogfileGroupContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CreateLogfileGroupContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CreateLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *CreateLogfileGroupContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *CreateLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *CreateLogfileGroupContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateLogfileGroupContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateLogfileGroup() (localctx ICreateLogfileGroupContext) {
	localctx = NewCreateLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MySqlParserRULE_createLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(987)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(988)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(989)
		p.Uid()
	}
	{
		p.SetState(990)
		p.Match(MySqlParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(991)
		p.Match(MySqlParserUNDOFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(992)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateLogfileGroupContext).undoFile = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(998)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(993)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(994)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(997)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).initSize = _x
		}

	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUNDO_BUFFER_SIZE {
		{
			p.SetState(1000)
			p.Match(MySqlParserUNDO_BUFFER_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1001)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1004)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).undoSize = _x
		}

	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserREDO_BUFFER_SIZE {
		{
			p.SetState(1007)
			p.Match(MySqlParserREDO_BUFFER_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1008)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1011)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).redoSize = _x
		}

	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNODEGROUP {
		{
			p.SetState(1014)
			p.Match(MySqlParserNODEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1015)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1018)
			p.Uid()
		}

	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(1021)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(1024)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1025)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1028)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*CreateLogfileGroupContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1031)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(1032)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1035)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateProcedureContext is an interface to support dynamic dispatch.
type ICreateProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OwnerStatement() IOwnerStatementContext
	AllProcedureParameter() []IProcedureParameterContext
	ProcedureParameter(i int) IProcedureParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateProcedureContext differentiates from other interfaces.
	IsCreateProcedureContext()
}

type CreateProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateProcedureContext() *CreateProcedureContext {
	var p = new(CreateProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createProcedure
	return p
}

func InitEmptyCreateProcedureContext(p *CreateProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createProcedure
}

func (*CreateProcedureContext) IsCreateProcedureContext() {}

func NewCreateProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createProcedure

	return p
}

func (s *CreateProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateProcedureContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateProcedureContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateProcedureContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateProcedureContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateProcedureContext) AllProcedureParameter() []IProcedureParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			len++
		}
	}

	tst := make([]IProcedureParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureParameterContext); ok {
			tst[i] = t.(IProcedureParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) ProcedureParameter(i int) IProcedureParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureParameterContext)
}

func (s *CreateProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateProcedure() (localctx ICreateProcedureContext) {
	localctx = NewCreateProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MySqlParserRULE_createProcedure)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1037)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1038)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1041)
		p.Match(MySqlParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1042)
		p.FullId()
	}
	{
		p.SetState(1043)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&151169654698547409) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		{
			p.SetState(1044)
			p.ProcedureParameter()
		}

	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1047)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1048)
			p.ProcedureParameter()
		}

		p.SetState(1053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1054)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1055)
				p.RoutineOption()
			}

		}
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1061)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	DataType() IDataTypeContext
	RoutineBody() IRoutineBodyContext
	ReturnStatement() IReturnStatementContext
	OwnerStatement() IOwnerStatementContext
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllFunctionParameter() []IFunctionParameterContext
	FunctionParameter(i int) IFunctionParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createFunction
	return p
}

func InitEmptyCreateFunctionContext(p *CreateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createFunction
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *CreateFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *CreateFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateFunctionContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateFunctionContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CreateFunctionContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *CreateFunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionContext) AllFunctionParameter() []IFunctionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParameterContext); ok {
			tst[i] = t.(IFunctionParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) FunctionParameter(i int) IFunctionParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *CreateFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (s *CreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateFunction() (localctx ICreateFunctionContext) {
	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MySqlParserRULE_createFunction)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1064)
			p.OwnerStatement()
		}

	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAGGREGATE {
		{
			p.SetState(1067)
			p.Match(MySqlParserAGGREGATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1070)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1071)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1074)
		p.FullId()
	}
	{
		p.SetState(1075)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		{
			p.SetState(1076)
			p.FunctionParameter()
		}

	}
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1079)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.FunctionParameter()
		}

		p.SetState(1085)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1086)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1087)
		p.Match(MySqlParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1088)
		p.DataType()
	}
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1089)
				p.RoutineOption()
			}

		}
		p.SetState(1094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALTER, MySqlParserANALYZE, MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCONDITION, MySqlParserCREATE, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDIAGNOSTICS, MySqlParserDROP, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserKILL, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserLOAD, MySqlParserLOCK, MySqlParserNUMBER, MySqlParserOPTIMIZE, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserLR_BRACKET, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		{
			p.SetState(1095)
			p.RoutineBody()
		}

	case MySqlParserRETURN:
		{
			p.SetState(1096)
			p.ReturnStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfNotExists() IIfNotExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createRole
	return p
}

func InitEmptyCreateRoleContext(p *CreateRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createRole
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *CreateRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *CreateRoleContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateRole() (localctx ICreateRoleContext) {
	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MySqlParserRULE_createRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1100)
		p.Match(MySqlParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1101)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1104)
		p.RoleName()
	}
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1105)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1106)
			p.RoleName()
		}

		p.SetState(1111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateServerContext is an interface to support dynamic dispatch.
type ICreateServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWrapperName returns the wrapperName token.
	GetWrapperName() antlr.Token

	// SetWrapperName sets the wrapperName token.
	SetWrapperName(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	FOREIGN() antlr.TerminalNode
	DATA() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateServerContext differentiates from other interfaces.
	IsCreateServerContext()
}

type CreateServerContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	wrapperName antlr.Token
}

func NewEmptyCreateServerContext() *CreateServerContext {
	var p = new(CreateServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createServer
	return p
}

func InitEmptyCreateServerContext(p *CreateServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createServer
}

func (*CreateServerContext) IsCreateServerContext() {}

func NewCreateServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServerContext {
	var p = new(CreateServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createServer

	return p
}

func (s *CreateServerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServerContext) GetWrapperName() antlr.Token { return s.wrapperName }

func (s *CreateServerContext) SetWrapperName(v antlr.Token) { s.wrapperName = v }

func (s *CreateServerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *CreateServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateServerContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *CreateServerContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *CreateServerContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRAPPER, 0)
}

func (s *CreateServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *CreateServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *CreateServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateServerContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *CreateServerContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateServer(s)
	}
}

func (s *CreateServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateServer(s)
	}
}

func (s *CreateServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateServer() (localctx ICreateServerContext) {
	localctx = NewCreateServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MySqlParserRULE_createServer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1112)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1113)
		p.Match(MySqlParserSERVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1114)
		p.Uid()
	}
	{
		p.SetState(1115)
		p.Match(MySqlParserFOREIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1116)
		p.Match(MySqlParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1117)
		p.Match(MySqlParserWRAPPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1118)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateServerContext).wrapperName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMYSQL || _la == MySqlParserSTRING_LITERAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateServerContext).wrapperName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1119)
		p.Match(MySqlParserOPTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1120)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1121)
		p.ServerOption()
	}
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1122)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1123)
			p.ServerOption()
		}

		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1129)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTable
	return p
}

func InitEmptyCreateTableContext(p *CreateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTable
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) CopyAll(ctx *CreateTableContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CopyCreateTableContext struct {
	CreateTableContext
	parenthesisTable ITableNameContext
}

func NewCopyCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CopyCreateTableContext {
	var p = new(CopyCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}

func (s *CopyCreateTableContext) GetParenthesisTable() ITableNameContext { return s.parenthesisTable }

func (s *CopyCreateTableContext) SetParenthesisTable(v ITableNameContext) { s.parenthesisTable = v }

func (s *CopyCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CopyCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *CopyCreateTableContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *CopyCreateTableContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CopyCreateTableContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *CopyCreateTableContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CopyCreateTableContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CopyCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *CopyCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CopyCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCopyCreateTable(s)
	}
}

func (s *CopyCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCopyCreateTable(s)
	}
}

func (s *CopyCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCopyCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnCreateTableContext struct {
	CreateTableContext
}

func NewColumnCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnCreateTableContext {
	var p = new(ColumnCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}

func (s *ColumnCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ColumnCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ColumnCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ColumnCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *ColumnCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *ColumnCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ColumnCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *ColumnCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *ColumnCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ColumnCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ColumnCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnCreateTable(s)
	}
}

func (s *ColumnCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnCreateTable(s)
	}
}

func (s *ColumnCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitColumnCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryCreateTableContext struct {
	CreateTableContext
	keyViolate antlr.Token
}

func NewQueryCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryCreateTableContext {
	var p = new(QueryCreateTableContext)

	InitEmptyCreateTableContext(&p.CreateTableContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateTableContext))

	return p
}

func (s *QueryCreateTableContext) GetKeyViolate() antlr.Token { return s.keyViolate }

func (s *QueryCreateTableContext) SetKeyViolate(v antlr.Token) { s.keyViolate = v }

func (s *QueryCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *QueryCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *QueryCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *QueryCreateTableContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *QueryCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *QueryCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *QueryCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *QueryCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *QueryCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *QueryCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *QueryCreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *QueryCreateTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *QueryCreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *QueryCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *QueryCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *QueryCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryCreateTable(s)
	}
}

func (s *QueryCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryCreateTable(s)
	}
}

func (s *QueryCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateTable() (localctx ICreateTableContext) {
	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MySqlParserRULE_createTable)
	var _la int

	var _alt int

	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCopyCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1131)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1132)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1135)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1137)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1136)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1139)
			p.TableName()
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLIKE:
			{
				p.SetState(1140)
				p.Match(MySqlParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1141)
				p.TableName()
			}

		case MySqlParserLR_BRACKET:
			{
				p.SetState(1142)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1143)
				p.Match(MySqlParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1144)

				var _x = p.TableName()

				localctx.(*CopyCreateTableContext).parenthesisTable = _x
			}
			{
				p.SetState(1145)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewQueryCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1149)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1150)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1153)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1154)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1157)
			p.TableName()
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1158)
				p.CreateDefinitions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&72057594038059013) != 0) || _la == MySqlParserUNION || _la == MySqlParserCHAR || ((int64((_la-340)) & ^0x3f) == 0 && ((int64(1)<<(_la-340))&4644375904747527) != 0) || ((int64((_la-404)) & ^0x3f) == 0 && ((int64(1)<<(_la-404))&4612811918334230547) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&2366149022974977) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&4609173815820289) != 0) || _la == MySqlParserCHARSET || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserSTRING_LITERAL {
			{
				p.SetState(1161)
				p.TableOption()
			}
			p.SetState(1168)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&72057594038059013) != 0) || _la == MySqlParserUNION || _la == MySqlParserCHAR || ((int64((_la-340)) & ^0x3f) == 0 && ((int64(1)<<(_la-340))&4644375904747527) != 0) || ((int64((_la-404)) & ^0x3f) == 0 && ((int64(1)<<(_la-404))&4612811918334230547) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&2366149022974977) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&4609173815820289) != 0) || _la == MySqlParserCHARSET || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserCOMMA || _la == MySqlParserSTRING_LITERAL {
				p.SetState(1163)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserCOMMA {
					{
						p.SetState(1162)
						p.Match(MySqlParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1165)
					p.TableOption()
				}

				p.SetState(1170)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPARTITION {
			{
				p.SetState(1173)
				p.PartitionDefinitions()
			}

		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
			{
				p.SetState(1176)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*QueryCreateTableContext).keyViolate = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*QueryCreateTableContext).keyViolate = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(1179)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1182)
			p.SelectStatement()
		}

	case 3:
		localctx = NewColumnCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1184)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1185)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1188)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1190)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1189)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1192)
			p.TableName()
		}
		{
			p.SetState(1193)
			p.CreateDefinitions()
		}
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1194)
				p.TableOption()
			}
			p.SetState(1201)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(1196)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserCOMMA {
						{
							p.SetState(1195)
							p.Match(MySqlParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(1198)
						p.TableOption()
					}

				}
				p.SetState(1203)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPARTITION {
			{
				p.SetState(1206)
				p.PartitionDefinitions()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTablespaceInnodbContext is an interface to support dynamic dispatch.
type ICreateTablespaceInnodbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token

	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token)

	// GetFileBlockSize returns the fileBlockSize rule contexts.
	GetFileBlockSize() IFileSizeLiteralContext

	// SetFileBlockSize sets the fileBlockSize rule contexts.
	SetFileBlockSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	FileSizeLiteral() IFileSizeLiteralContext

	// IsCreateTablespaceInnodbContext differentiates from other interfaces.
	IsCreateTablespaceInnodbContext()
}

type CreateTablespaceInnodbContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	datafile      antlr.Token
	fileBlockSize IFileSizeLiteralContext
}

func NewEmptyCreateTablespaceInnodbContext() *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb
	return p
}

func InitEmptyCreateTablespaceInnodbContext(p *CreateTablespaceInnodbContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb
}

func (*CreateTablespaceInnodbContext) IsCreateTablespaceInnodbContext() {}

func NewCreateTablespaceInnodbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb

	return p
}

func (s *CreateTablespaceInnodbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceInnodbContext) GetDatafile() antlr.Token { return s.datafile }

func (s *CreateTablespaceInnodbContext) SetDatafile(v antlr.Token) { s.datafile = v }

func (s *CreateTablespaceInnodbContext) GetFileBlockSize() IFileSizeLiteralContext {
	return s.fileBlockSize
}

func (s *CreateTablespaceInnodbContext) SetFileBlockSize(v IFileSizeLiteralContext) {
	s.fileBlockSize = v
}

func (s *CreateTablespaceInnodbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTablespaceInnodbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *CreateTablespaceInnodbContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceInnodbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateTablespaceInnodbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *CreateTablespaceInnodbContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateTablespaceInnodbContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE_BLOCK_SIZE, 0)
}

func (s *CreateTablespaceInnodbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceInnodbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceInnodbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateTablespaceInnodbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceInnodbContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceInnodbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceInnodbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTablespaceInnodbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTablespaceInnodb(s)
	}
}

func (s *CreateTablespaceInnodbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTablespaceInnodb(s)
	}
}

func (s *CreateTablespaceInnodbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateTablespaceInnodb(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateTablespaceInnodb() (localctx ICreateTablespaceInnodbContext) {
	localctx = NewCreateTablespaceInnodbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MySqlParserRULE_createTablespaceInnodb)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1211)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1212)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1213)
		p.Uid()
	}
	{
		p.SetState(1214)
		p.Match(MySqlParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1215)
		p.Match(MySqlParserDATAFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1216)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateTablespaceInnodbContext).datafile = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFILE_BLOCK_SIZE {
		{
			p.SetState(1217)
			p.Match(MySqlParserFILE_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1218)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1219)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceInnodbContext).fileBlockSize = _x
		}

	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserENGINE {
		{
			p.SetState(1222)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1223)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1226)
			p.EngineName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTablespaceNdbContext is an interface to support dynamic dispatch.
type ICreateTablespaceNdbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetExtentSize returns the extentSize rule contexts.
	GetExtentSize() IFileSizeLiteralContext

	// GetInitialSize returns the initialSize rule contexts.
	GetInitialSize() IFileSizeLiteralContext

	// GetAutoextendSize returns the autoextendSize rule contexts.
	GetAutoextendSize() IFileSizeLiteralContext

	// GetMaxSize returns the maxSize rule contexts.
	GetMaxSize() IFileSizeLiteralContext

	// SetExtentSize sets the extentSize rule contexts.
	SetExtentSize(IFileSizeLiteralContext)

	// SetInitialSize sets the initialSize rule contexts.
	SetInitialSize(IFileSizeLiteralContext)

	// SetAutoextendSize sets the autoextendSize rule contexts.
	SetAutoextendSize(IFileSizeLiteralContext)

	// SetMaxSize sets the maxSize rule contexts.
	SetMaxSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	USE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateTablespaceNdbContext differentiates from other interfaces.
	IsCreateTablespaceNdbContext()
}

type CreateTablespaceNdbContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	datafile       antlr.Token
	extentSize     IFileSizeLiteralContext
	initialSize    IFileSizeLiteralContext
	autoextendSize IFileSizeLiteralContext
	maxSize        IFileSizeLiteralContext
	comment        antlr.Token
}

func NewEmptyCreateTablespaceNdbContext() *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb
	return p
}

func InitEmptyCreateTablespaceNdbContext(p *CreateTablespaceNdbContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb
}

func (*CreateTablespaceNdbContext) IsCreateTablespaceNdbContext() {}

func NewCreateTablespaceNdbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb

	return p
}

func (s *CreateTablespaceNdbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceNdbContext) GetDatafile() antlr.Token { return s.datafile }

func (s *CreateTablespaceNdbContext) GetComment() antlr.Token { return s.comment }

func (s *CreateTablespaceNdbContext) SetDatafile(v antlr.Token) { s.datafile = v }

func (s *CreateTablespaceNdbContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateTablespaceNdbContext) GetExtentSize() IFileSizeLiteralContext { return s.extentSize }

func (s *CreateTablespaceNdbContext) GetInitialSize() IFileSizeLiteralContext { return s.initialSize }

func (s *CreateTablespaceNdbContext) GetAutoextendSize() IFileSizeLiteralContext {
	return s.autoextendSize
}

func (s *CreateTablespaceNdbContext) GetMaxSize() IFileSizeLiteralContext { return s.maxSize }

func (s *CreateTablespaceNdbContext) SetExtentSize(v IFileSizeLiteralContext) { s.extentSize = v }

func (s *CreateTablespaceNdbContext) SetInitialSize(v IFileSizeLiteralContext) { s.initialSize = v }

func (s *CreateTablespaceNdbContext) SetAutoextendSize(v IFileSizeLiteralContext) {
	s.autoextendSize = v
}

func (s *CreateTablespaceNdbContext) SetMaxSize(v IFileSizeLiteralContext) { s.maxSize = v }

func (s *CreateTablespaceNdbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTablespaceNdbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *CreateTablespaceNdbContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceNdbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateTablespaceNdbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *CreateTablespaceNdbContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *CreateTablespaceNdbContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *CreateTablespaceNdbContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *CreateTablespaceNdbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateTablespaceNdbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceNdbContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CreateTablespaceNdbContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CreateTablespaceNdbContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENT_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *CreateTablespaceNdbContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *CreateTablespaceNdbContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateTablespaceNdbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceNdbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceNdbContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceNdbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceNdbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTablespaceNdbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTablespaceNdb(s)
	}
}

func (s *CreateTablespaceNdbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTablespaceNdb(s)
	}
}

func (s *CreateTablespaceNdbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateTablespaceNdb(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateTablespaceNdb() (localctx ICreateTablespaceNdbContext) {
	localctx = NewCreateTablespaceNdbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MySqlParserRULE_createTablespaceNdb)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1230)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1231)
		p.Uid()
	}
	{
		p.SetState(1232)
		p.Match(MySqlParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1233)
		p.Match(MySqlParserDATAFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1234)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateTablespaceNdbContext).datafile = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1235)
		p.Match(MySqlParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1236)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1237)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1238)
		p.Uid()
	}
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENT_SIZE {
		{
			p.SetState(1239)
			p.Match(MySqlParserEXTENT_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1240)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1243)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).extentSize = _x
		}

	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(1246)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1247)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1250)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).initialSize = _x
		}

	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAUTOEXTEND_SIZE {
		{
			p.SetState(1253)
			p.Match(MySqlParserAUTOEXTEND_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1254)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1257)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).autoextendSize = _x
		}

	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMAX_SIZE {
		{
			p.SetState(1260)
			p.Match(MySqlParserMAX_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1261)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1264)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).maxSize = _x
		}

	}
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNODEGROUP {
		{
			p.SetState(1267)
			p.Match(MySqlParserNODEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1268)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1271)
			p.Uid()
		}

	}
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(1274)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(1277)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1278)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1281)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*CreateTablespaceNdbContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1284)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(1285)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1288)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTriggerTime returns the triggerTime token.
	GetTriggerTime() antlr.Token

	// GetTriggerEvent returns the triggerEvent token.
	GetTriggerEvent() antlr.Token

	// GetTriggerPlace returns the triggerPlace token.
	GetTriggerPlace() antlr.Token

	// SetTriggerTime sets the triggerTime token.
	SetTriggerTime(antlr.Token)

	// SetTriggerEvent sets the triggerEvent token.
	SetTriggerEvent(antlr.Token)

	// SetTriggerPlace sets the triggerPlace token.
	SetTriggerPlace(antlr.Token)

	// GetThisTrigger returns the thisTrigger rule contexts.
	GetThisTrigger() IFullIdContext

	// GetOtherTrigger returns the otherTrigger rule contexts.
	GetOtherTrigger() IFullIdContext

	// SetThisTrigger sets the thisTrigger rule contexts.
	SetThisTrigger(IFullIdContext)

	// SetOtherTrigger sets the otherTrigger rule contexts.
	SetOtherTrigger(IFullIdContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	FOR() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	BEFORE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	FOLLOWS() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	thisTrigger  IFullIdContext
	triggerTime  antlr.Token
	triggerEvent antlr.Token
	triggerPlace antlr.Token
	otherTrigger IFullIdContext
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTrigger
	return p
}

func InitEmptyCreateTriggerContext(p *CreateTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createTrigger
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) GetTriggerTime() antlr.Token { return s.triggerTime }

func (s *CreateTriggerContext) GetTriggerEvent() antlr.Token { return s.triggerEvent }

func (s *CreateTriggerContext) GetTriggerPlace() antlr.Token { return s.triggerPlace }

func (s *CreateTriggerContext) SetTriggerTime(v antlr.Token) { s.triggerTime = v }

func (s *CreateTriggerContext) SetTriggerEvent(v antlr.Token) { s.triggerEvent = v }

func (s *CreateTriggerContext) SetTriggerPlace(v antlr.Token) { s.triggerPlace = v }

func (s *CreateTriggerContext) GetThisTrigger() IFullIdContext { return s.thisTrigger }

func (s *CreateTriggerContext) GetOtherTrigger() IFullIdContext { return s.otherTrigger }

func (s *CreateTriggerContext) SetThisTrigger(v IFullIdContext) { s.thisTrigger = v }

func (s *CreateTriggerContext) SetOtherTrigger(v IFullIdContext) { s.otherTrigger = v }

func (s *CreateTriggerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *CreateTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *CreateTriggerContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTriggerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *CreateTriggerContext) EACH() antlr.TerminalNode {
	return s.GetToken(MySqlParserEACH, 0)
}

func (s *CreateTriggerContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *CreateTriggerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *CreateTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateTriggerContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEFORE, 0)
}

func (s *CreateTriggerContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *CreateTriggerContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *CreateTriggerContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *CreateTriggerContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *CreateTriggerContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateTriggerContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWS, 0)
}

func (s *CreateTriggerContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDES, 0)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateTrigger() (localctx ICreateTriggerContext) {
	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MySqlParserRULE_createTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1290)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1291)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1294)
		p.Match(MySqlParserTRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1295)

		var _x = p.FullId()

		localctx.(*CreateTriggerContext).thisTrigger = _x
	}
	{
		p.SetState(1296)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerTime = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBEFORE || _la == MySqlParserAFTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerTime = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1297)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerEvent = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDELETE || _la == MySqlParserINSERT || _la == MySqlParserUPDATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerEvent = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1298)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1299)
		p.TableName()
	}
	{
		p.SetState(1300)
		p.Match(MySqlParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1301)
		p.Match(MySqlParserEACH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1302)
		p.Match(MySqlParserROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1305)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1303)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTriggerContext).triggerPlace = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWS || _la == MySqlParserPRECEDES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTriggerContext).triggerPlace = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1304)

			var _x = p.FullId()

			localctx.(*CreateTriggerContext).otherTrigger = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1307)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext
	RECURSIVE() antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *WithClauseContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *WithClauseContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MySqlParserRULE_withClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.Match(MySqlParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1310)
			p.Match(MySqlParserRECURSIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1313)
		p.CommonTableExpressions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionsContext is an interface to support dynamic dispatch.
type ICommonTableExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CteName() ICteNameContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	DmlStatement() IDmlStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCteColumnName() []ICteColumnNameContext
	CteColumnName(i int) ICteColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext

	// IsCommonTableExpressionsContext differentiates from other interfaces.
	IsCommonTableExpressionsContext()
}

type CommonTableExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonTableExpressionsContext() *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commonTableExpressions
	return p
}

func InitEmptyCommonTableExpressionsContext(p *CommonTableExpressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commonTableExpressions
}

func (*CommonTableExpressionsContext) IsCommonTableExpressionsContext() {}

func NewCommonTableExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_commonTableExpressions

	return p
}

func (s *CommonTableExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionsContext) CteName() ICteNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteNameContext)
}

func (s *CommonTableExpressionsContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *CommonTableExpressionsContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *CommonTableExpressionsContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *CommonTableExpressionsContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *CommonTableExpressionsContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) AllCteColumnName() []ICteColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			len++
		}
	}

	tst := make([]ICteColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICteColumnNameContext); ok {
			tst[i] = t.(ICteColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *CommonTableExpressionsContext) CteColumnName(i int) ICteColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteColumnNameContext)
}

func (s *CommonTableExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CommonTableExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CommonTableExpressionsContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *CommonTableExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommonTableExpressions(s)
	}
}

func (s *CommonTableExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommonTableExpressions(s)
	}
}

func (s *CommonTableExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCommonTableExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CommonTableExpressions() (localctx ICommonTableExpressionsContext) {
	localctx = NewCommonTableExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MySqlParserRULE_commonTableExpressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.CteName()
	}
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(1316)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1317)
			p.CteColumnName()
		}
		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(1318)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1319)
				p.CteColumnName()
			}

			p.SetState(1324)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1325)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1329)
		p.Match(MySqlParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1330)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1331)
		p.DmlStatement()
	}
	{
		p.SetState(1332)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1333)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.CommonTableExpressions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteNameContext is an interface to support dynamic dispatch.
type ICteNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteNameContext differentiates from other interfaces.
	IsCteNameContext()
}

type CteNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteNameContext() *CteNameContext {
	var p = new(CteNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteName
	return p
}

func InitEmptyCteNameContext(p *CteNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteName
}

func (*CteNameContext) IsCteNameContext() {}

func NewCteNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteNameContext {
	var p = new(CteNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cteName

	return p
}

func (s *CteNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCteName(s)
	}
}

func (s *CteNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCteName(s)
	}
}

func (s *CteNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCteName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CteName() (localctx ICteNameContext) {
	localctx = NewCteNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MySqlParserRULE_cteName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteColumnNameContext is an interface to support dynamic dispatch.
type ICteColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteColumnNameContext differentiates from other interfaces.
	IsCteColumnNameContext()
}

type CteColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteColumnNameContext() *CteColumnNameContext {
	var p = new(CteColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteColumnName
	return p
}

func InitEmptyCteColumnNameContext(p *CteColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cteColumnName
}

func (*CteColumnNameContext) IsCteColumnNameContext() {}

func NewCteColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteColumnNameContext {
	var p = new(CteColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cteColumnName

	return p
}

func (s *CteColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCteColumnName(s)
	}
}

func (s *CteColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCteColumnName(s)
	}
}

func (s *CteColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCteColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CteColumnName() (localctx ICteColumnNameContext) {
	localctx = NewCteColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MySqlParserRULE_cteColumnName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1339)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token

	// GetCheckOption returns the checkOption token.
	GetCheckOption() antlr.Token

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token)

	// SetCheckOption sets the checkOption token.
	SetCheckOption(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	OrReplace() IOrReplaceContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	UidList() IUidListContext
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	WithClause() IWithClauseContext
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	algType     antlr.Token
	secContext  antlr.Token
	checkOption antlr.Token
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createView
	return p
}

func InitEmptyCreateViewContext(p *CreateViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createView
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *CreateViewContext) GetCheckOption() antlr.Token { return s.checkOption }

func (s *CreateViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *CreateViewContext) SetCheckOption(v antlr.Token) { s.checkOption = v }

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *CreateViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *CreateViewContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *CreateViewContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *CreateViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CreateViewContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *CreateViewContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *CreateViewContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *CreateViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *CreateViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *CreateViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *CreateViewContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CreateViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *CreateViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *CreateViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *CreateViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *CreateViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *CreateViewContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *CreateViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *CreateViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CreateViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *CreateViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *CreateViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateView() (localctx ICreateViewContext) {
	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MySqlParserRULE_createView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1341)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserOR {
		{
			p.SetState(1342)
			p.OrReplace()
		}

	}
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALGORITHM {
		{
			p.SetState(1345)
			p.Match(MySqlParserALGORITHM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1346)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1347)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMERGE || _la == MySqlParserTEMPTABLE || _la == MySqlParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1350)
			p.OwnerStatement()
		}

	}
	p.SetState(1356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSQL {
		{
			p.SetState(1353)
			p.Match(MySqlParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1354)
			p.Match(MySqlParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1355)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1358)
		p.Match(MySqlParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1359)
		p.FullId()
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(1360)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1361)
			p.UidList()
		}
		{
			p.SetState(1362)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1366)
		p.Match(MySqlParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1367)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWITH {
			{
				p.SetState(1368)
				p.WithClause()
			}

		}
		{
			p.SetState(1371)
			p.SelectStatement()
		}
		{
			p.SetState(1372)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWITH {
			{
				p.SetState(1374)
				p.WithClause()
			}

		}
		{
			p.SetState(1377)
			p.SelectStatement()
		}
		p.SetState(1384)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1378)
				p.Match(MySqlParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1380)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserCASCADED || _la == MySqlParserLOCAL {
				{
					p.SetState(1379)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateViewContext).checkOption = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserCASCADED || _la == MySqlParserLOCAL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateViewContext).checkOption = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1382)
				p.Match(MySqlParserCHECK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1383)
				p.Match(MySqlParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseOptionContext is an interface to support dynamic dispatch.
type ICreateDatabaseOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext
	ENCRYPTION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsCreateDatabaseOptionContext differentiates from other interfaces.
	IsCreateDatabaseOptionContext()
}

type CreateDatabaseOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseOptionContext() *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabaseOption
	return p
}

func InitEmptyCreateDatabaseOptionContext(p *CreateDatabaseOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabaseOption
}

func (*CreateDatabaseOptionContext) IsCreateDatabaseOptionContext() {}

func NewCreateDatabaseOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDatabaseOption

	return p
}

func (s *CreateDatabaseOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseOptionContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CreateDatabaseOptionContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CreateDatabaseOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *CreateDatabaseOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *CreateDatabaseOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *CreateDatabaseOptionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CreateDatabaseOptionContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CreateDatabaseOptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *CreateDatabaseOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateDatabaseOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *CreateDatabaseOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *CreateDatabaseOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateDatabaseOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateDatabaseOption() (localctx ICreateDatabaseOptionContext) {
	localctx = NewCreateDatabaseOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MySqlParserRULE_createDatabaseOption)
	var _la int

	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1388)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1391)
			p.CharSet()
		}
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1392)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(1395)
				p.CharsetName()
			}

		case MySqlParserDEFAULT:
			{
				p.SetState(1396)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1399)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1402)
			p.Match(MySqlParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1403)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1406)
			p.CollationName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1407)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1410)
			p.Match(MySqlParserENCRYPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1411)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1414)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1415)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1416)
			p.Match(MySqlParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1417)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1420)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharSetContext is an interface to support dynamic dispatch.
type ICharSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR() antlr.TerminalNode

	// IsCharSetContext differentiates from other interfaces.
	IsCharSetContext()
}

type CharSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharSetContext() *CharSetContext {
	var p = new(CharSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charSet
	return p
}

func InitEmptyCharSetContext(p *CharSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charSet
}

func (*CharSetContext) IsCharSetContext() {}

func NewCharSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharSetContext {
	var p = new(CharSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charSet

	return p
}

func (s *CharSetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharSetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *CharSetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *CharSetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *CharSetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *CharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharSet(s)
	}
}

func (s *CharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharSet(s)
	}
}

func (s *CharSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CharSet() (localctx ICharSetContext) {
	localctx = NewCharSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MySqlParserRULE_charSet)
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1423)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1424)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1425)
			p.Match(MySqlParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1426)
			p.Match(MySqlParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICurrentUserExpressionContext is an interface to support dynamic dispatch.
type ICurrentUserExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_USER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsCurrentUserExpressionContext differentiates from other interfaces.
	IsCurrentUserExpressionContext()
}

type CurrentUserExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentUserExpressionContext() *CurrentUserExpressionContext {
	var p = new(CurrentUserExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentUserExpression
	return p
}

func InitEmptyCurrentUserExpressionContext(p *CurrentUserExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentUserExpression
}

func (*CurrentUserExpressionContext) IsCurrentUserExpressionContext() {}

func NewCurrentUserExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentUserExpressionContext {
	var p = new(CurrentUserExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_currentUserExpression

	return p
}

func (s *CurrentUserExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentUserExpressionContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *CurrentUserExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CurrentUserExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CurrentUserExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentUserExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentUserExpression(s)
	}
}

func (s *CurrentUserExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentUserExpression(s)
	}
}

func (s *CurrentUserExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentUserExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CurrentUserExpression() (localctx ICurrentUserExpressionContext) {
	localctx = NewCurrentUserExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MySqlParserRULE_currentUserExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1430)
		p.Match(MySqlParserCURRENT_USER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1433)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1431)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1432)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOwnerStatementContext is an interface to support dynamic dispatch.
type IOwnerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFINER() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	UserName() IUserNameContext
	CurrentUserExpression() ICurrentUserExpressionContext

	// IsOwnerStatementContext differentiates from other interfaces.
	IsOwnerStatementContext()
}

type OwnerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwnerStatementContext() *OwnerStatementContext {
	var p = new(OwnerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ownerStatement
	return p
}

func InitEmptyOwnerStatementContext(p *OwnerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ownerStatement
}

func (*OwnerStatementContext) IsOwnerStatementContext() {}

func NewOwnerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OwnerStatementContext {
	var p = new(OwnerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ownerStatement

	return p
}

func (s *OwnerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OwnerStatementContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *OwnerStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *OwnerStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *OwnerStatementContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}

func (s *OwnerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OwnerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OwnerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOwnerStatement(s)
	}
}

func (s *OwnerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOwnerStatement(s)
	}
}

func (s *OwnerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOwnerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OwnerStatement() (localctx IOwnerStatementContext) {
	localctx = NewOwnerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MySqlParserRULE_ownerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1435)
		p.Match(MySqlParserDEFINER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1436)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1437)
			p.UserName()
		}

	case 2:
		{
			p.SetState(1438)
			p.CurrentUserExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScheduleExpressionContext is an interface to support dynamic dispatch.
type IScheduleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsScheduleExpressionContext differentiates from other interfaces.
	IsScheduleExpressionContext()
}

type ScheduleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScheduleExpressionContext() *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scheduleExpression
	return p
}

func InitEmptyScheduleExpressionContext(p *ScheduleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scheduleExpression
}

func (*ScheduleExpressionContext) IsScheduleExpressionContext() {}

func NewScheduleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_scheduleExpression

	return p
}

func (s *ScheduleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScheduleExpressionContext) CopyAll(ctx *ScheduleExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ScheduleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScheduleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PreciseScheduleContext struct {
	ScheduleExpressionContext
}

func NewPreciseScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreciseScheduleContext {
	var p = new(PreciseScheduleContext)

	InitEmptyScheduleExpressionContext(&p.ScheduleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ScheduleExpressionContext))

	return p
}

func (s *PreciseScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreciseScheduleContext) AT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT, 0)
}

func (s *PreciseScheduleContext) TimestampValue() ITimestampValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *PreciseScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *PreciseScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}

func (s *PreciseScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPreciseSchedule(s)
	}
}

func (s *PreciseScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPreciseSchedule(s)
	}
}

func (s *PreciseScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPreciseSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalScheduleContext struct {
	ScheduleExpressionContext
	startTimestamp ITimestampValueContext
	_intervalExpr  IIntervalExprContext
	startIntervals []IIntervalExprContext
	endTimestamp   ITimestampValueContext
	endIntervals   []IIntervalExprContext
}

func NewIntervalScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalScheduleContext {
	var p = new(IntervalScheduleContext)

	InitEmptyScheduleExpressionContext(&p.ScheduleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ScheduleExpressionContext))

	return p
}

func (s *IntervalScheduleContext) GetStartTimestamp() ITimestampValueContext { return s.startTimestamp }

func (s *IntervalScheduleContext) Get_intervalExpr() IIntervalExprContext { return s._intervalExpr }

func (s *IntervalScheduleContext) GetEndTimestamp() ITimestampValueContext { return s.endTimestamp }

func (s *IntervalScheduleContext) SetStartTimestamp(v ITimestampValueContext) { s.startTimestamp = v }

func (s *IntervalScheduleContext) Set_intervalExpr(v IIntervalExprContext) { s._intervalExpr = v }

func (s *IntervalScheduleContext) SetEndTimestamp(v ITimestampValueContext) { s.endTimestamp = v }

func (s *IntervalScheduleContext) GetStartIntervals() []IIntervalExprContext { return s.startIntervals }

func (s *IntervalScheduleContext) GetEndIntervals() []IIntervalExprContext { return s.endIntervals }

func (s *IntervalScheduleContext) SetStartIntervals(v []IIntervalExprContext) { s.startIntervals = v }

func (s *IntervalScheduleContext) SetEndIntervals(v []IIntervalExprContext) { s.endIntervals = v }

func (s *IntervalScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVERY, 0)
}

func (s *IntervalScheduleContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalScheduleContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalScheduleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTS, 0)
}

func (s *IntervalScheduleContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDS, 0)
}

func (s *IntervalScheduleContext) AllTimestampValue() []ITimestampValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITimestampValueContext); ok {
			len++
		}
	}

	tst := make([]ITimestampValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITimestampValueContext); ok {
			tst[i] = t.(ITimestampValueContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) TimestampValue(i int) ITimestampValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *IntervalScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}

func (s *IntervalScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalSchedule(s)
	}
}

func (s *IntervalScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalSchedule(s)
	}
}

func (s *IntervalScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ScheduleExpression() (localctx IScheduleExpressionContext) {
	localctx = NewScheduleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MySqlParserRULE_scheduleExpression)
	var _la int

	p.SetState(1475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAT:
		localctx = NewPreciseScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1441)
			p.Match(MySqlParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1442)
			p.TimestampValue()
		}
		p.SetState(1446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserPLUS {
			{
				p.SetState(1443)
				p.IntervalExpr()
			}

			p.SetState(1448)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MySqlParserEVERY:
		localctx = NewIntervalScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1449)
			p.Match(MySqlParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1450)
				p.DecimalLiteral()
			}

		case 2:
			{
				p.SetState(1451)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1454)
			p.IntervalType()
		}
		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTARTS {
			{
				p.SetState(1455)
				p.Match(MySqlParserSTARTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1456)

				var _x = p.TimestampValue()

				localctx.(*IntervalScheduleContext).startTimestamp = _x
			}
			p.SetState(1460)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserPLUS {
				{
					p.SetState(1457)

					var _x = p.IntervalExpr()

					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).startIntervals = append(localctx.(*IntervalScheduleContext).startIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)

				p.SetState(1462)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENDS {
			{
				p.SetState(1465)
				p.Match(MySqlParserENDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1466)

				var _x = p.TimestampValue()

				localctx.(*IntervalScheduleContext).endTimestamp = _x
			}
			p.SetState(1470)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserPLUS {
				{
					p.SetState(1467)

					var _x = p.IntervalExpr()

					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).endIntervals = append(localctx.(*IntervalScheduleContext).endIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)

				p.SetState(1472)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimestampValueContext is an interface to support dynamic dispatch.
type ITimestampValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_TIMESTAMP() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsTimestampValueContext differentiates from other interfaces.
	IsTimestampValueContext()
}

type TimestampValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampValueContext() *TimestampValueContext {
	var p = new(TimestampValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_timestampValue
	return p
}

func InitEmptyTimestampValueContext(p *TimestampValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_timestampValue
}

func (*TimestampValueContext) IsTimestampValueContext() {}

func NewTimestampValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampValueContext {
	var p = new(TimestampValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_timestampValue

	return p
}

func (s *TimestampValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampValueContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *TimestampValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TimestampValueContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TimestampValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TimestampValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimestampValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTimestampValue(s)
	}
}

func (s *TimestampValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTimestampValue(s)
	}
}

func (s *TimestampValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTimestampValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TimestampValue() (localctx ITimestampValueContext) {
	localctx = NewTimestampValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MySqlParserRULE_timestampValue)
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1477)
			p.Match(MySqlParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1478)
			p.StringLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1479)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1480)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalExprContext is an interface to support dynamic dispatch.
type IIntervalExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	IntervalType() IIntervalTypeContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsIntervalExprContext differentiates from other interfaces.
	IsIntervalExprContext()
}

type IntervalExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalExprContext() *IntervalExprContext {
	var p = new(IntervalExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalExpr
	return p
}

func InitEmptyIntervalExprContext(p *IntervalExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalExpr
}

func (*IntervalExprContext) IsIntervalExprContext() {}

func NewIntervalExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalExprContext {
	var p = new(IntervalExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalExpr

	return p
}

func (s *IntervalExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *IntervalExprContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *IntervalExprContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExprContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalExpr(s)
	}
}

func (s *IntervalExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalExpr(s)
	}
}

func (s *IntervalExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IntervalExpr() (localctx IIntervalExprContext) {
	localctx = NewIntervalExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MySqlParserRULE_intervalExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Match(MySqlParserPLUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1484)
		p.Match(MySqlParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1485)
			p.DecimalLiteral()
		}

	case 2:
		{
			p.SetState(1486)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1489)
		p.IntervalType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTypeContext is an interface to support dynamic dispatch.
type IIntervalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalTypeBase() IIntervalTypeBaseContext
	YEAR() antlr.TerminalNode
	YEAR_MONTH() antlr.TerminalNode
	DAY_HOUR() antlr.TerminalNode
	DAY_MINUTE() antlr.TerminalNode
	DAY_SECOND() antlr.TerminalNode
	HOUR_MINUTE() antlr.TerminalNode
	HOUR_SECOND() antlr.TerminalNode
	MINUTE_SECOND() antlr.TerminalNode
	SECOND_MICROSECOND() antlr.TerminalNode
	MINUTE_MICROSECOND() antlr.TerminalNode
	HOUR_MICROSECOND() antlr.TerminalNode
	DAY_MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeContext differentiates from other interfaces.
	IsIntervalTypeContext()
}

type IntervalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeContext() *IntervalTypeContext {
	var p = new(IntervalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalType
	return p
}

func InitEmptyIntervalTypeContext(p *IntervalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalType
}

func (*IntervalTypeContext) IsIntervalTypeContext() {}

func NewIntervalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalType

	return p
}

func (s *IntervalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *IntervalTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *IntervalTypeContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR_MONTH, 0)
}

func (s *IntervalTypeContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_HOUR, 0)
}

func (s *IntervalTypeContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MINUTE, 0)
}

func (s *IntervalTypeContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_SECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MINUTE, 0)
}

func (s *IntervalTypeContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_SECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_SECOND, 0)
}

func (s *IntervalTypeContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND_MICROSECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_MICROSECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MICROSECOND, 0)
}

func (s *IntervalTypeContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MICROSECOND, 0)
}

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (s *IntervalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IntervalType() (localctx IIntervalTypeContext) {
	localctx = NewIntervalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MySqlParserRULE_intervalType)
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1491)
			p.IntervalTypeBase()
		}

	case MySqlParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1492)
			p.Match(MySqlParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserYEAR_MONTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1493)
			p.Match(MySqlParserYEAR_MONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDAY_HOUR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1494)
			p.Match(MySqlParserDAY_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDAY_MINUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1495)
			p.Match(MySqlParserDAY_MINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDAY_SECOND:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1496)
			p.Match(MySqlParserDAY_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserHOUR_MINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1497)
			p.Match(MySqlParserHOUR_MINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserHOUR_SECOND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1498)
			p.Match(MySqlParserHOUR_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMINUTE_SECOND:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1499)
			p.Match(MySqlParserMINUTE_SECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSECOND_MICROSECOND:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1500)
			p.Match(MySqlParserSECOND_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMINUTE_MICROSECOND:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1501)
			p.Match(MySqlParserMINUTE_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserHOUR_MICROSECOND:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1502)
			p.Match(MySqlParserHOUR_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDAY_MICROSECOND:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1503)
			p.Match(MySqlParserDAY_MICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnableTypeContext is an interface to support dynamic dispatch.
type IEnableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENABLE() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SLAVE() antlr.TerminalNode

	// IsEnableTypeContext differentiates from other interfaces.
	IsEnableTypeContext()
}

type EnableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableTypeContext() *EnableTypeContext {
	var p = new(EnableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_enableType
	return p
}

func InitEmptyEnableTypeContext(p *EnableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_enableType
}

func (*EnableTypeContext) IsEnableTypeContext() {}

func NewEnableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableTypeContext {
	var p = new(EnableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_enableType

	return p
}

func (s *EnableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableTypeContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *EnableTypeContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *EnableTypeContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *EnableTypeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *EnableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEnableType(s)
	}
}

func (s *EnableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEnableType(s)
	}
}

func (s *EnableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEnableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) EnableType() (localctx IEnableTypeContext) {
	localctx = NewEnableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MySqlParserRULE_enableType)
	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1506)
			p.Match(MySqlParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1507)
			p.Match(MySqlParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1508)
			p.Match(MySqlParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1509)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1510)
			p.Match(MySqlParserSLAVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	HASH() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *IndexTypeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBTREE, 0)
}

func (s *IndexTypeContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MySqlParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1513)
		p.Match(MySqlParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1514)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBTREE || _la == MySqlParserHASH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	EQUAL_SYMBOL() antlr.TerminalNode
	IndexType() IIndexTypeContext
	WITH() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	Uid() IUidContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexOption
	return p
}

func InitEmptyIndexOptionContext(p *IndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexOption
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *IndexOptionContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *IndexOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IndexOptionContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *IndexOptionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARSER, 0)
}

func (s *IndexOptionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexOptionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *IndexOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *IndexOptionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *IndexOptionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *IndexOptionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (s *IndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexOption() (localctx IIndexOptionContext) {
	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MySqlParserRULE_indexOption)
	var _la int

	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserKEY_BLOCK_SIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1516)
			p.Match(MySqlParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1517)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1520)
			p.FileSizeLiteral()
		}

	case MySqlParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1521)
			p.IndexType()
		}

	case MySqlParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1522)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)
			p.Match(MySqlParserPARSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1524)
			p.Uid()
		}

	case MySqlParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1525)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1526)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserINVISIBLE, MySqlParserVISIBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1527)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1528)
			p.Match(MySqlParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1529)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1532)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSECONDARY_ENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1533)
			p.Match(MySqlParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1534)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1537)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureParameterContext is an interface to support dynamic dispatch.
type IProcedureParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDirection returns the direction token.
	GetDirection() antlr.Token

	// SetDirection sets the direction token.
	SetDirection(antlr.Token)

	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode
	INOUT() antlr.TerminalNode

	// IsProcedureParameterContext differentiates from other interfaces.
	IsProcedureParameterContext()
}

type ProcedureParameterContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	direction antlr.Token
}

func NewEmptyProcedureParameterContext() *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureParameter
	return p
}

func InitEmptyProcedureParameterContext(p *ProcedureParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureParameter
}

func (*ProcedureParameterContext) IsProcedureParameterContext() {}

func NewProcedureParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_procedureParameter

	return p
}

func (s *ProcedureParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureParameterContext) GetDirection() antlr.Token { return s.direction }

func (s *ProcedureParameterContext) SetDirection(v antlr.Token) { s.direction = v }

func (s *ProcedureParameterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ProcedureParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ProcedureParameterContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ProcedureParameterContext) OUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUT, 0)
}

func (s *ProcedureParameterContext) INOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINOUT, 0)
}

func (s *ProcedureParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitProcedureParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ProcedureParameter() (localctx IProcedureParameterContext) {
	localctx = NewProcedureParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MySqlParserRULE_procedureParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&35184372088849) != 0 {
		{
			p.SetState(1540)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ProcedureParameterContext).direction = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&35184372088849) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ProcedureParameterContext).direction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1543)
		p.Uid()
	}
	{
		p.SetState(1544)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionParameter
	return p
}

func InitEmptyFunctionParameterContext(p *FunctionParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionParameter
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FunctionParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionParameter() (localctx IFunctionParameterContext) {
	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MySqlParserRULE_functionParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1546)
		p.Uid()
	}
	{
		p.SetState(1547)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineOptionContext is an interface to support dynamic dispatch.
type IRoutineOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRoutineOptionContext differentiates from other interfaces.
	IsRoutineOptionContext()
}

type RoutineOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineOptionContext() *RoutineOptionContext {
	var p = new(RoutineOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineOption
	return p
}

func InitEmptyRoutineOptionContext(p *RoutineOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineOption
}

func (*RoutineOptionContext) IsRoutineOptionContext() {}

func NewRoutineOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineOptionContext {
	var p = new(RoutineOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_routineOption

	return p
}

func (s *RoutineOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineOptionContext) CopyAll(ctx *RoutineOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RoutineOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RoutineBehaviorContext struct {
	RoutineOptionContext
}

func NewRoutineBehaviorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineBehaviorContext {
	var p = new(RoutineBehaviorContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBehaviorContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDETERMINISTIC, 0)
}

func (s *RoutineBehaviorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *RoutineBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineBehavior(s)
	}
}

func (s *RoutineBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineBehavior(s)
	}
}

func (s *RoutineBehaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineBehavior(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineLanguageContext struct {
	RoutineOptionContext
}

func NewRoutineLanguageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineLanguageContext {
	var p = new(RoutineLanguageContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineLanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineLanguageContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLANGUAGE, 0)
}

func (s *RoutineLanguageContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineLanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineLanguage(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineCommentContext struct {
	RoutineOptionContext
}

func NewRoutineCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineCommentContext {
	var p = new(RoutineCommentContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *RoutineCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *RoutineCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineComment(s)
	}
}

func (s *RoutineCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineComment(s)
	}
}

func (s *RoutineCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineComment(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineSecurityContext struct {
	RoutineOptionContext
	context antlr.Token
}

func NewRoutineSecurityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineSecurityContext {
	var p = new(RoutineSecurityContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineSecurityContext) GetContext() antlr.Token { return s.context }

func (s *RoutineSecurityContext) SetContext(v antlr.Token) { s.context = v }

func (s *RoutineSecurityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineSecurityContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineSecurityContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *RoutineSecurityContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *RoutineSecurityContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *RoutineSecurityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineSecurity(s)
	}
}

func (s *RoutineSecurityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineSecurity(s)
	}
}

func (s *RoutineSecurityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineSecurity(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoutineDataContext struct {
	RoutineOptionContext
}

func NewRoutineDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineDataContext {
	var p = new(RoutineDataContext)

	InitEmptyRoutineOptionContext(&p.RoutineOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineDataContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTAINS, 0)
}

func (s *RoutineDataContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineDataContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *RoutineDataContext) READS() antlr.TerminalNode {
	return s.GetToken(MySqlParserREADS, 0)
}

func (s *RoutineDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *RoutineDataContext) MODIFIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFIES, 0)
}

func (s *RoutineDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineData(s)
	}
}

func (s *RoutineDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineData(s)
	}
}

func (s *RoutineDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RoutineOption() (localctx IRoutineOptionContext) {
	localctx = NewRoutineOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MySqlParserRULE_routineOption)
	var _la int

	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCOMMENT:
		localctx = NewRoutineCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1549)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1550)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserLANGUAGE:
		localctx = NewRoutineLanguageContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1551)
			p.Match(MySqlParserLANGUAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1552)
			p.Match(MySqlParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDETERMINISTIC, MySqlParserNOT:
		localctx = NewRoutineBehaviorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(1553)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1556)
			p.Match(MySqlParserDETERMINISTIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMODIFIES, MySqlParserREADS, MySqlParserCONTAINS, MySqlParserNO:
		localctx = NewRoutineDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCONTAINS:
			{
				p.SetState(1557)
				p.Match(MySqlParserCONTAINS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1558)
				p.Match(MySqlParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserNO:
			{
				p.SetState(1559)
				p.Match(MySqlParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1560)
				p.Match(MySqlParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserREADS:
			{
				p.SetState(1561)
				p.Match(MySqlParserREADS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1562)
				p.Match(MySqlParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1563)
				p.Match(MySqlParserDATA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserMODIFIES:
			{
				p.SetState(1564)
				p.Match(MySqlParserMODIFIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1565)
				p.Match(MySqlParserSQL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1566)
				p.Match(MySqlParserDATA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserSQL:
		localctx = NewRoutineSecurityContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1569)
			p.Match(MySqlParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1570)
			p.Match(MySqlParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1571)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RoutineSecurityContext).context = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RoutineSecurityContext).context = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerOptionContext is an interface to support dynamic dispatch.
type IServerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOST() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	USER() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PORT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsServerOptionContext differentiates from other interfaces.
	IsServerOptionContext()
}

type ServerOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerOptionContext() *ServerOptionContext {
	var p = new(ServerOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_serverOption
	return p
}

func InitEmptyServerOptionContext(p *ServerOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_serverOption
}

func (*ServerOptionContext) IsServerOptionContext() {}

func NewServerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerOptionContext {
	var p = new(ServerOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_serverOption

	return p
}

func (s *ServerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerOptionContext) HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST, 0)
}

func (s *ServerOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ServerOptionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *ServerOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *ServerOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *ServerOptionContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOCKET, 0)
}

func (s *ServerOptionContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOWNER, 0)
}

func (s *ServerOptionContext) PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPORT, 0)
}

func (s *ServerOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ServerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterServerOption(s)
	}
}

func (s *ServerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitServerOption(s)
	}
}

func (s *ServerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitServerOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ServerOption() (localctx IServerOptionContext) {
	localctx = NewServerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MySqlParserRULE_serverOption)
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserHOST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1574)
			p.Match(MySqlParserHOST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1576)
			p.Match(MySqlParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1577)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserUSER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1578)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1579)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPASSWORD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1580)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1581)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSOCKET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1582)
			p.Match(MySqlParserSOCKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1583)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserOWNER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1584)
			p.Match(MySqlParserOWNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPORT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1586)
			p.Match(MySqlParserPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1587)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDefinitionsContext is an interface to support dynamic dispatch.
type ICreateDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllCreateDefinition() []ICreateDefinitionContext
	CreateDefinition(i int) ICreateDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateDefinitionsContext differentiates from other interfaces.
	IsCreateDefinitionsContext()
}

type CreateDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionsContext() *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinitions
	return p
}

func InitEmptyCreateDefinitionsContext(p *CreateDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinitions
}

func (*CreateDefinitionsContext) IsCreateDefinitionsContext() {}

func NewCreateDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDefinitions

	return p
}

func (s *CreateDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *CreateDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateDefinitions() (localctx ICreateDefinitionsContext) {
	localctx = NewCreateDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MySqlParserRULE_createDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1590)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1591)
		p.CreateDefinition()
	}
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1592)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1593)
			p.CreateDefinition()
		}

		p.SetState(1598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1599)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDefinitionContext is an interface to support dynamic dispatch.
type ICreateDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateDefinitionContext differentiates from other interfaces.
	IsCreateDefinitionContext()
}

type CreateDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionContext() *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinition
	return p
}

func InitEmptyCreateDefinitionContext(p *CreateDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinition
}

func (*CreateDefinitionContext) IsCreateDefinitionContext() {}

func NewCreateDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDefinition

	return p
}

func (s *CreateDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionContext) CopyAll(ctx *CreateDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnDeclarationContext struct {
	CreateDefinitionContext
}

func NewColumnDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnDeclarationContext {
	var p = new(ColumnDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ColumnDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDeclarationContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ColumnDeclarationContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ColumnDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitColumnDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstraintDeclarationContext struct {
	CreateDefinitionContext
}

func NewConstraintDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintDeclarationContext {
	var p = new(ConstraintDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ConstraintDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintDeclarationContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *ConstraintDeclarationContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ConstraintDeclarationContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *ConstraintDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstraintDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexDeclarationContext struct {
	CreateDefinitionContext
}

func NewIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexDeclarationContext {
	var p = new(IndexDeclarationContext)

	InitEmptyCreateDefinitionContext(&p.CreateDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateDefinitionContext))

	return p
}

func (s *IndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDeclarationContext) IndexColumnDefinition() IIndexColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnDefinitionContext)
}

func (s *IndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateDefinition() (localctx ICreateDefinitionContext) {
	localctx = NewCreateDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MySqlParserRULE_createDefinition)
	var _la int

	p.SetState(1612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1601)
			p.FullColumnName()
		}
		{
			p.SetState(1602)
			p.ColumnDefinition()
		}

	case 2:
		localctx = NewConstraintDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.TableConstraint()
		}
		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(1605)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENFORCED {
			{
				p.SetState(1608)
				p.Match(MySqlParserENFORCED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1611)
			p.IndexColumnDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	AllColumnConstraint() []IColumnConstraintContext
	ColumnConstraint(i int) IColumnConstraintContext
	NOT() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllColumnConstraint() []IColumnConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnConstraintContext); ok {
			tst[i] = t.(IColumnConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ColumnDefinitionContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MySqlParserRULE_columnDefinition)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1614)
		p.DataType()
	}
	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1615)
				p.ColumnConstraint()
			}

		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOT {
		{
			p.SetState(1621)
			p.Match(MySqlParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserENFORCED {
		{
			p.SetState(1624)
			p.Match(MySqlParserENFORCED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnConstraint
	return p
}

func InitEmptyColumnConstraintContext(p *ColumnConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_columnConstraint
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) CopyAll(ctx *ColumnConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StorageColumnConstraintContext struct {
	ColumnConstraintContext
	storageval antlr.Token
}

func NewStorageColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StorageColumnConstraintContext {
	var p = new(StorageColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *StorageColumnConstraintContext) GetStorageval() antlr.Token { return s.storageval }

func (s *StorageColumnConstraintContext) SetStorageval(v antlr.Token) { s.storageval = v }

func (s *StorageColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageColumnConstraintContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *StorageColumnConstraintContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *StorageColumnConstraintContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *StorageColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *StorageColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStorageColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type VisibilityColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewVisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VisibilityColumnConstraintContext {
	var p = new(VisibilityColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *VisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityColumnConstraintContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *VisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitVisibilityColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type AutoIncrementColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewAutoIncrementColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AutoIncrementColumnConstraintContext {
	var p = new(AutoIncrementColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *AutoIncrementColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoIncrementColumnConstraintContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *AutoIncrementColumnConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *AutoIncrementColumnConstraintContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *AutoIncrementColumnConstraintContext) CurrentTimestamp() ICurrentTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *AutoIncrementColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAutoIncrementColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommentColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCommentColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentColumnConstraintContext {
	var p = new(CommentColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CommentColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentColumnConstraintContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CommentColumnConstraintContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CommentColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCommentColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type UniqueKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewUniqueKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyColumnConstraintContext {
	var p = new(UniqueKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *UniqueKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *UniqueKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *UniqueKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUniqueKeyColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type SerialDefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewSerialDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerialDefaultColumnConstraintContext {
	var p = new(SerialDefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *SerialDefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerialDefaultColumnConstraintContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *SerialDefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SerialDefaultColumnConstraintContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *SerialDefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSerialDefaultColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type GeneratedColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewGeneratedColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratedColumnConstraintContext {
	var p = new(GeneratedColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *GeneratedColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnConstraintContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *GeneratedColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERATED, 0)
}

func (s *GeneratedColumnConstraintContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserALWAYS, 0)
}

func (s *GeneratedColumnConstraintContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIRTUAL, 0)
}

func (s *GeneratedColumnConstraintContext) STORED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORED, 0)
}

func (s *GeneratedColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGeneratedColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type FormatColumnConstraintContext struct {
	ColumnConstraintContext
	colformat antlr.Token
}

func NewFormatColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FormatColumnConstraintContext {
	var p = new(FormatColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *FormatColumnConstraintContext) GetColformat() antlr.Token { return s.colformat }

func (s *FormatColumnConstraintContext) SetColformat(v antlr.Token) { s.colformat = v }

func (s *FormatColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatColumnConstraintContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_FORMAT, 0)
}

func (s *FormatColumnConstraintContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *FormatColumnConstraintContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *FormatColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *FormatColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFormatColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewCollateColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateColumnConstraintContext {
	var p = new(CollateColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CollateColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateColumnConstraintContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CollateColumnConstraintContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollateColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryKeyColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewPrimaryKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyColumnConstraintContext {
	var p = new(PrimaryKeyColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *PrimaryKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrimaryKeyColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CheckColumnConstraintContext struct {
	ColumnConstraintContext
	name IUidContext
}

func NewCheckColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckColumnConstraintContext {
	var p = new(CheckColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CheckColumnConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckColumnConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *CheckColumnConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewNullColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullColumnConstraintContext {
	var p = new(NullColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *NullColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullColumnConstraintContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *NullColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNullColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefaultColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultColumnConstraintContext {
	var p = new(DefaultColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *DefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *DefaultColumnConstraintContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *DefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefaultColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReferenceColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewReferenceColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferenceColumnConstraintContext {
	var p = new(ReferenceColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *ReferenceColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceColumnConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ReferenceColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type InvisibilityColumnConstraintContext struct {
	ColumnConstraintContext
}

func NewInvisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvisibilityColumnConstraintContext {
	var p = new(InvisibilityColumnConstraintContext)

	InitEmptyColumnConstraintContext(&p.ColumnConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnConstraintContext))

	return p
}

func (s *InvisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvisibilityColumnConstraintContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *InvisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInvisibilityColumnConstraint(s)
	}
}

func (s *InvisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInvisibilityColumnConstraint(s)
	}
}

func (s *InvisibilityColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInvisibilityColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MySqlParserRULE_columnConstraint)
	var _la int

	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserNULL_SPEC_LITERAL:
		localctx = NewNullColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1627)
			p.NullNotnull()
		}

	case MySqlParserDEFAULT:
		localctx = NewDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1628)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1629)
			p.DefaultValue()
		}

	case MySqlParserVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1630)
			p.Match(MySqlParserVISIBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserINVISIBLE:
		localctx = NewInvisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1631)
			p.Match(MySqlParserINVISIBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserON, MySqlParserAUTO_INCREMENT:
		localctx = NewAutoIncrementColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserAUTO_INCREMENT:
			{
				p.SetState(1632)
				p.Match(MySqlParserAUTO_INCREMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserON:
			{
				p.SetState(1633)
				p.Match(MySqlParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1634)
				p.Match(MySqlParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1635)
				p.CurrentTimestamp()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserKEY, MySqlParserPRIMARY:
		localctx = NewPrimaryKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRIMARY {
			{
				p.SetState(1638)
				p.Match(MySqlParserPRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1641)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserUNIQUE:
		localctx = NewUniqueKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1642)
			p.Match(MySqlParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1644)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1643)
				p.Match(MySqlParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserCOMMENT:
		localctx = NewCommentColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1646)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCOLUMN_FORMAT:
		localctx = NewFormatColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1648)
			p.Match(MySqlParserCOLUMN_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1649)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FormatColumnConstraintContext).colformat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserDYNAMIC || _la == MySqlParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FormatColumnConstraintContext).colformat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserSTORAGE:
		localctx = NewStorageColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1650)
			p.Match(MySqlParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1651)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StorageColumnConstraintContext).storageval = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserDISK || _la == MySqlParserMEMORY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StorageColumnConstraintContext).storageval = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserREFERENCES:
		localctx = NewReferenceColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1652)
			p.ReferenceDefinition()
		}

	case MySqlParserCOLLATE:
		localctx = NewCollateColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1653)
			p.Match(MySqlParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1654)
			p.CollationName()
		}

	case MySqlParserAS, MySqlParserGENERATED:
		localctx = NewGeneratedColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserGENERATED {
			{
				p.SetState(1655)
				p.Match(MySqlParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1656)
				p.Match(MySqlParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1659)
			p.Match(MySqlParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1660)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1661)
			p.expression(0)
		}
		{
			p.SetState(1662)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTORED || _la == MySqlParserVIRTUAL {
			{
				p.SetState(1663)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserSTORED || _la == MySqlParserVIRTUAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case MySqlParserSERIAL:
		localctx = NewSerialDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1666)
			p.Match(MySqlParserSERIAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1667)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1668)
			p.Match(MySqlParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCHECK, MySqlParserCONSTRAINT:
		localctx = NewCheckColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(1673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1669)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1671)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(1670)

					var _x = p.Uid()

					localctx.(*CheckColumnConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1675)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1677)
			p.expression(0)
		}
		{
			p.SetState(1678)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableConstraint
	return p
}

func InitEmptyTableConstraintContext(p *TableConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableConstraint
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CopyAll(ctx *TableConstraintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UniqueKeyTableConstraintContext struct {
	TableConstraintContext
	name        IUidContext
	indexFormat antlr.Token
	index       IUidContext
}

func NewUniqueKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyTableConstraintContext {
	var p = new(UniqueKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *UniqueKeyTableConstraintContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *UniqueKeyTableConstraintContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *UniqueKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *UniqueKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *UniqueKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *UniqueKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *UniqueKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyTableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *UniqueKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *UniqueKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *UniqueKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UniqueKeyTableConstraintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *UniqueKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *UniqueKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUniqueKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CheckTableConstraintContext struct {
	TableConstraintContext
	name IUidContext
}

func NewCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckTableConstraintContext {
	var p = new(CheckTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *CheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *CheckTableConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryKeyTableConstraintContext struct {
	TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewPrimaryKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyTableConstraintContext {
	var p = new(PrimaryKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *PrimaryKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *PrimaryKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *PrimaryKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *PrimaryKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *PrimaryKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyTableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *PrimaryKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *PrimaryKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PrimaryKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *PrimaryKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrimaryKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrimaryKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForeignKeyTableConstraintContext struct {
	TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewForeignKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForeignKeyTableConstraintContext {
	var p = new(ForeignKeyTableConstraintContext)

	InitEmptyTableConstraintContext(&p.TableConstraintContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableConstraintContext))

	return p
}

func (s *ForeignKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *ForeignKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *ForeignKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *ForeignKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *ForeignKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyTableConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *ForeignKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *ForeignKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ForeignKeyTableConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ForeignKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *ForeignKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *ForeignKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ForeignKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitForeignKeyTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MySqlParserRULE_tableConstraint)
	var _la int

	p.SetState(1751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1686)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1682)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1684)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1683)

					var _x = p.Uid()

					localctx.(*PrimaryKeyTableConstraintContext).name = _x
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(1688)
			p.Match(MySqlParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1689)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(1690)

				var _x = p.Uid()

				localctx.(*PrimaryKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(1693)
				p.IndexType()
			}

		}
		{
			p.SetState(1696)
			p.IndexColumnNames()
		}
		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1697)
				p.IndexOption()
			}

			p.SetState(1702)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewUniqueKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1703)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1705)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(1704)

					var _x = p.Uid()

					localctx.(*UniqueKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1709)
			p.Match(MySqlParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(1710)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UniqueKeyTableConstraintContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UniqueKeyTableConstraintContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(1713)

				var _x = p.Uid()

				localctx.(*UniqueKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(1716)
				p.IndexType()
			}

		}
		{
			p.SetState(1719)
			p.IndexColumnNames()
		}
		p.SetState(1723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1720)
				p.IndexOption()
			}

			p.SetState(1725)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewForeignKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1726)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1728)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(1727)

					var _x = p.Uid()

					localctx.(*ForeignKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1732)
			p.Match(MySqlParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(1734)

				var _x = p.Uid()

				localctx.(*ForeignKeyTableConstraintContext).index = _x
			}

		}
		{
			p.SetState(1737)
			p.IndexColumnNames()
		}
		{
			p.SetState(1738)
			p.ReferenceDefinition()
		}

	case 4:
		localctx = NewCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1740)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1742)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(1741)

					var _x = p.Uid()

					localctx.(*CheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1746)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1747)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1748)
			p.expression(0)
		}
		{
			p.SetState(1749)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceDefinitionContext is an interface to support dynamic dispatch.
type IReferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatchType returns the matchType token.
	GetMatchType() antlr.Token

	// SetMatchType sets the matchType token.
	SetMatchType(antlr.Token)

	// Getter signatures
	REFERENCES() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	MATCH() antlr.TerminalNode
	ReferenceAction() IReferenceActionContext
	FULL() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode

	// IsReferenceDefinitionContext differentiates from other interfaces.
	IsReferenceDefinitionContext()
}

type ReferenceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	matchType antlr.Token
}

func NewEmptyReferenceDefinitionContext() *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceDefinition
	return p
}

func InitEmptyReferenceDefinitionContext(p *ReferenceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceDefinition
}

func (*ReferenceDefinitionContext) IsReferenceDefinitionContext() {}

func NewReferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceDefinition

	return p
}

func (s *ReferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceDefinitionContext) GetMatchType() antlr.Token { return s.matchType }

func (s *ReferenceDefinitionContext) SetMatchType(v antlr.Token) { s.matchType = v }

func (s *ReferenceDefinitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserREFERENCES, 0)
}

func (s *ReferenceDefinitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReferenceDefinitionContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ReferenceDefinitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMATCH, 0)
}

func (s *ReferenceDefinitionContext) ReferenceAction() IReferenceActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceActionContext)
}

func (s *ReferenceDefinitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ReferenceDefinitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTIAL, 0)
}

func (s *ReferenceDefinitionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIMPLE, 0)
}

func (s *ReferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReferenceDefinition() (localctx IReferenceDefinitionContext) {
	localctx = NewReferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MySqlParserRULE_referenceDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1753)
		p.Match(MySqlParserREFERENCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1754)
		p.TableName()
	}
	p.SetState(1756)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1755)
			p.IndexColumnNames()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMATCH {
		{
			p.SetState(1758)
			p.Match(MySqlParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1759)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferenceDefinitionContext).matchType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULL || _la == MySqlParserPARTIAL || _la == MySqlParserSIMPLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferenceDefinitionContext).matchType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1762)
			p.ReferenceAction()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceActionContext is an interface to support dynamic dispatch.
type IReferenceActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnDelete returns the onDelete rule contexts.
	GetOnDelete() IReferenceControlTypeContext

	// GetOnUpdate returns the onUpdate rule contexts.
	GetOnUpdate() IReferenceControlTypeContext

	// SetOnDelete sets the onDelete rule contexts.
	SetOnDelete(IReferenceControlTypeContext)

	// SetOnUpdate sets the onUpdate rule contexts.
	SetOnUpdate(IReferenceControlTypeContext)

	// Getter signatures
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	DELETE() antlr.TerminalNode
	AllReferenceControlType() []IReferenceControlTypeContext
	ReferenceControlType(i int) IReferenceControlTypeContext
	UPDATE() antlr.TerminalNode

	// IsReferenceActionContext differentiates from other interfaces.
	IsReferenceActionContext()
}

type ReferenceActionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	onDelete IReferenceControlTypeContext
	onUpdate IReferenceControlTypeContext
}

func NewEmptyReferenceActionContext() *ReferenceActionContext {
	var p = new(ReferenceActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceAction
	return p
}

func InitEmptyReferenceActionContext(p *ReferenceActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceAction
}

func (*ReferenceActionContext) IsReferenceActionContext() {}

func NewReferenceActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceActionContext {
	var p = new(ReferenceActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceAction

	return p
}

func (s *ReferenceActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceActionContext) GetOnDelete() IReferenceControlTypeContext { return s.onDelete }

func (s *ReferenceActionContext) GetOnUpdate() IReferenceControlTypeContext { return s.onUpdate }

func (s *ReferenceActionContext) SetOnDelete(v IReferenceControlTypeContext) { s.onDelete = v }

func (s *ReferenceActionContext) SetOnUpdate(v IReferenceControlTypeContext) { s.onUpdate = v }

func (s *ReferenceActionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *ReferenceActionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *ReferenceActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *ReferenceActionContext) AllReferenceControlType() []IReferenceControlTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			len++
		}
	}

	tst := make([]IReferenceControlTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReferenceControlTypeContext); ok {
			tst[i] = t.(IReferenceControlTypeContext)
			i++
		}
	}

	return tst
}

func (s *ReferenceActionContext) ReferenceControlType(i int) IReferenceControlTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceControlTypeContext)
}

func (s *ReferenceActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *ReferenceActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceAction(s)
	}
}

func (s *ReferenceActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceAction(s)
	}
}

func (s *ReferenceActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReferenceAction() (localctx IReferenceActionContext) {
	localctx = NewReferenceActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MySqlParserRULE_referenceAction)
	p.SetState(1781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1765)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1766)
			p.Match(MySqlParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1767)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onDelete = _x
		}
		p.SetState(1771)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1768)
				p.Match(MySqlParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1769)
				p.Match(MySqlParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1770)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onUpdate = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1773)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1774)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1775)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onUpdate = _x
		}
		p.SetState(1779)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1776)
				p.Match(MySqlParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1777)
				p.Match(MySqlParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1778)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onDelete = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceControlTypeContext is an interface to support dynamic dispatch.
type IReferenceControlTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsReferenceControlTypeContext differentiates from other interfaces.
	IsReferenceControlTypeContext()
}

type ReferenceControlTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceControlTypeContext() *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceControlType
	return p
}

func InitEmptyReferenceControlTypeContext(p *ReferenceControlTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceControlType
}

func (*ReferenceControlTypeContext) IsReferenceControlTypeContext() {}

func NewReferenceControlTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceControlType

	return p
}

func (s *ReferenceControlTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceControlTypeContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *ReferenceControlTypeContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *ReferenceControlTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ReferenceControlTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *ReferenceControlTypeContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *ReferenceControlTypeContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserACTION, 0)
}

func (s *ReferenceControlTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *ReferenceControlTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceControlTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceControlTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReferenceControlType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReferenceControlType() (localctx IReferenceControlTypeContext) {
	localctx = NewReferenceControlTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MySqlParserRULE_referenceControlType)
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1783)
			p.Match(MySqlParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1784)
			p.Match(MySqlParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1785)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1786)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1787)
			p.Match(MySqlParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1788)
			p.Match(MySqlParserACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1789)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1790)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnDefinitionContext is an interface to support dynamic dispatch.
type IIndexColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIndexColumnDefinitionContext differentiates from other interfaces.
	IsIndexColumnDefinitionContext()
}

type IndexColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnDefinitionContext() *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition
	return p
}

func InitEmptyIndexColumnDefinitionContext(p *IndexColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition
}

func (*IndexColumnDefinitionContext) IsIndexColumnDefinitionContext() {}

func NewIndexColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition

	return p
}

func (s *IndexColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnDefinitionContext) CopyAll(ctx *IndexColumnDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IndexColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecialIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSpecialIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialIndexDeclarationContext {
	var p = new(SpecialIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SpecialIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SpecialIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SpecialIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SpecialIndexDeclarationContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *SpecialIndexDeclarationContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *SpecialIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SpecialIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SpecialIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *SpecialIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SpecialIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpecialIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleIndexDeclarationContext struct {
	IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSimpleIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleIndexDeclarationContext {
	var p = new(SimpleIndexDeclarationContext)

	InitEmptyIndexColumnDefinitionContext(&p.IndexColumnDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SimpleIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SimpleIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SimpleIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SimpleIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *SimpleIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SimpleIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleIndexDeclarationContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *SimpleIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SimpleIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexColumnDefinition() (localctx IIndexColumnDefinitionContext) {
	localctx = NewIndexColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MySqlParserRULE_indexColumnDefinition)
	var _la int

	p.SetState(1821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserINDEX, MySqlParserKEY:
		localctx = NewSimpleIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1793)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleIndexDeclarationContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleIndexDeclarationContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(1794)
				p.Uid()
			}

		}
		p.SetState(1798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(1797)
				p.IndexType()
			}

		}
		{
			p.SetState(1800)
			p.IndexColumnNames()
		}
		p.SetState(1804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1801)
				p.IndexOption()
			}

			p.SetState(1806)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MySqlParserFULLTEXT, MySqlParserSPATIAL:
		localctx = NewSpecialIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1807)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(1808)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SpecialIndexDeclarationContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SpecialIndexDeclarationContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(1811)
				p.Uid()
			}

		}
		{
			p.SetState(1814)
			p.IndexColumnNames()
		}
		p.SetState(1818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1815)
				p.IndexOption()
			}

			p.SetState(1820)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionContext is an interface to support dynamic dispatch.
type ITableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableOptionContext differentiates from other interfaces.
	IsTableOptionContext()
}

type TableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionContext() *TableOptionContext {
	var p = new(TableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableOption
	return p
}

func InitEmptyTableOptionContext(p *TableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableOption
}

func (*TableOptionContext) IsTableOptionContext() {}

func NewTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionContext {
	var p = new(TableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableOption

	return p
}

func (s *TableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionContext) CopyAll(ctx *TableOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableOptionEngineContext struct {
	TableOptionContext
}

func NewTableOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineContext {
	var p = new(TableOptionEngineContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *TableOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *TableOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEngine(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionMaxRowsContext struct {
	TableOptionContext
}

func NewTableOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMaxRowsContext {
	var p = new(TableOptionMaxRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *TableOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionMaxRows(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCollateContext struct {
	TableOptionContext
}

func NewTableOptionCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCollateContext {
	var p = new(TableOptionCollateContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *TableOptionCollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *TableOptionCollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionCollateContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPersistentContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPersistentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPersistentContext {
	var p = new(TableOptionPersistentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPersistentContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPersistentContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPersistentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPersistentContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_PERSISTENT, 0)
}

func (s *TableOptionPersistentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionPersistentContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPersistentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPersistent(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionTablespaceContext struct {
	TableOptionContext
}

func NewTableOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTablespaceContext {
	var p = new(TableOptionTablespaceContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *TableOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *TableOptionTablespaceContext) TablespaceStorage() ITablespaceStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceStorageContext)
}

func (s *TableOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionAutoextendSizeContext struct {
	TableOptionContext
}

func NewTableOptionAutoextendSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoextendSizeContext {
	var p = new(TableOptionAutoextendSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoextendSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoextendSizeContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *TableOptionAutoextendSizeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoextendSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoextendSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionAutoextendSize(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPageCompressedContext struct {
	TableOptionContext
}

func NewTableOptionPageCompressedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressedContext {
	var p = new(TableOptionPageCompressedContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressedContext) PAGE_COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_COMPRESSED, 0)
}

func (s *TableOptionPageCompressedContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressedContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPageCompressedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPageCompressed(s)
	}
}

func (s *TableOptionPageCompressedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPageCompressed(s)
	}
}

func (s *TableOptionPageCompressedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPageCompressed(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionStartTransactionContext struct {
	TableOptionContext
}

func NewTableOptionStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionStartTransactionContext {
	var p = new(TableOptionStartTransactionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *TableOptionStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *TableOptionStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPackKeysContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPackKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPackKeysContext {
	var p = new(TableOptionPackKeysContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPackKeysContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPackKeysContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPackKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPackKeysContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPACK_KEYS, 0)
}

func (s *TableOptionPackKeysContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionPackKeysContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPackKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPackKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPasswordContext struct {
	TableOptionContext
}

func NewTableOptionPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPasswordContext {
	var p = new(TableOptionPasswordContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *TableOptionPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPasswordContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionUnionContext struct {
	TableOptionContext
}

func NewTableOptionUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionUnionContext {
	var p = new(TableOptionUnionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionUnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *TableOptionUnionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableOptionUnionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableOptionUnionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableOptionUnionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionUnion(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionSamplePageContext struct {
	TableOptionContext
}

func NewTableOptionSamplePageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSamplePageContext {
	var p = new(TableOptionSamplePageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSamplePageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSamplePageContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_SAMPLE_PAGES, 0)
}

func (s *TableOptionSamplePageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionSamplePageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionSamplePageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSamplePageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionSamplePage(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCharsetContext struct {
	TableOptionContext
}

func NewTableOptionCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCharsetContext {
	var p = new(TableOptionCharsetContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *TableOptionCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *TableOptionCharsetContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *TableOptionCharsetContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *TableOptionCharsetContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionIndexDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionIndexDirectoryContext {
	var p = new(TableOptionIndexDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *TableOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionIndexDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionTableTypeContext struct {
	TableOptionContext
}

func NewTableOptionTableTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTableTypeContext {
	var p = new(TableOptionTableTypeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTableTypeContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_TYPE, 0)
}

func (s *TableOptionTableTypeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTableTypeContext) TableType() ITableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}

func (s *TableOptionTableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionTableType(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionKeyBlockSizeContext struct {
	TableOptionContext
}

func NewTableOptionKeyBlockSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionKeyBlockSizeContext {
	var p = new(TableOptionKeyBlockSizeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionKeyBlockSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionKeyBlockSizeContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *TableOptionKeyBlockSizeContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *TableOptionKeyBlockSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionKeyBlockSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionKeyBlockSize(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionEncryptionContext struct {
	TableOptionContext
}

func NewTableOptionEncryptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionContext {
	var p = new(TableOptionEncryptionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *TableOptionEncryptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionEncryptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEncryption(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionDataDirectoryContext struct {
	TableOptionContext
}

func NewTableOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDataDirectoryContext {
	var p = new(TableOptionDataDirectoryContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *TableOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *TableOptionDataDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionDataDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionRecalculationContext struct {
	TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionRecalculationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRecalculationContext {
	var p = new(TableOptionRecalculationContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRecalculationContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionRecalculationContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionRecalculationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRecalculationContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_AUTO_RECALC, 0)
}

func (s *TableOptionRecalculationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionRecalculationContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRecalculationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionRecalculation(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionAutoIncrementContext struct {
	TableOptionContext
}

func NewTableOptionAutoIncrementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoIncrementContext {
	var p = new(TableOptionAutoIncrementContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoIncrementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoIncrementContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *TableOptionAutoIncrementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoIncrementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoIncrementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionAutoIncrement(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionEncryptionKeyIdContext struct {
	TableOptionContext
}

func NewTableOptionEncryptionKeyIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionKeyIdContext {
	var p = new(TableOptionEncryptionKeyIdContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionKeyIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionKeyIdContext) ENCRYPTION_KEY_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ID, 0)
}

func (s *TableOptionEncryptionKeyIdContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionEncryptionKeyIdContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionKeyIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEncryptionKeyId(s)
	}
}

func (s *TableOptionEncryptionKeyIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEncryptionKeyId(s)
	}
}

func (s *TableOptionEncryptionKeyIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEncryptionKeyId(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionChecksumContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionChecksumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionChecksumContext {
	var p = new(TableOptionChecksumContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionChecksumContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionChecksumContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionChecksumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionChecksumContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *TableOptionChecksumContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_CHECKSUM, 0)
}

func (s *TableOptionChecksumContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionChecksumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionChecksum(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionDelayContext struct {
	TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionDelayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDelayContext {
	var p = new(TableOptionDelayContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDelayContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionDelayContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionDelayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDelayContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAY_KEY_WRITE, 0)
}

func (s *TableOptionDelayContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionDelayContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionDelayContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDelayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionDelay(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionConnectionContext struct {
	TableOptionContext
}

func NewTableOptionConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionConnectionContext {
	var p = new(TableOptionConnectionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *TableOptionConnectionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionConnectionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionConnection(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionTransactionalContext struct {
	TableOptionContext
}

func NewTableOptionTransactionalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTransactionalContext {
	var p = new(TableOptionTransactionalContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTransactionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTransactionalContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTIONAL, 0)
}

func (s *TableOptionTransactionalContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTransactionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTransactional(s)
	}
}

func (s *TableOptionTransactionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTransactional(s)
	}
}

func (s *TableOptionTransactionalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionTransactional(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionPageCompressionLevelContext struct {
	TableOptionContext
}

func NewTableOptionPageCompressionLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressionLevelContext {
	var p = new(TableOptionPageCompressionLevelContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressionLevelContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionPageCompressionLevelContext) PAGE_COMPRESSION_LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_COMPRESSION_LEVEL, 0)
}

func (s *TableOptionPageCompressionLevelContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressionLevelContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPageCompressionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPageCompressionLevel(s)
	}
}

func (s *TableOptionPageCompressionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPageCompressionLevel(s)
	}
}

func (s *TableOptionPageCompressionLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionPageCompressionLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionSecondaryEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionSecondaryEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSecondaryEngineAttributeContext {
	var p = new(TableOptionSecondaryEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSecondaryEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSecondaryEngineAttributeContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionSecondaryEngineAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCommentContext struct {
	TableOptionContext
}

func NewTableOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCommentContext {
	var p = new(TableOptionCommentContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *TableOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionComment(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionAverageContext struct {
	TableOptionContext
}

func NewTableOptionAverageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAverageContext {
	var p = new(TableOptionAverageContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAverageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAverageContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG_ROW_LENGTH, 0)
}

func (s *TableOptionAverageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAverageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAverageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionAverage(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionRowFormatContext struct {
	TableOptionContext
	rowFormat antlr.Token
}

func NewTableOptionRowFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRowFormatContext {
	var p = new(TableOptionRowFormatContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRowFormatContext) GetRowFormat() antlr.Token { return s.rowFormat }

func (s *TableOptionRowFormatContext) SetRowFormat(v antlr.Token) { s.rowFormat = v }

func (s *TableOptionRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRowFormatContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_FORMAT, 0)
}

func (s *TableOptionRowFormatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionRowFormatContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *TableOptionRowFormatContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *TableOptionRowFormatContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSED, 0)
}

func (s *TableOptionRowFormatContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDUNDANT, 0)
}

func (s *TableOptionRowFormatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPACT, 0)
}

func (s *TableOptionRowFormatContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *TableOptionRowFormatContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionRowFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionCompressionContext struct {
	TableOptionContext
}

func NewTableOptionCompressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCompressionContext {
	var p = new(TableOptionCompressionContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCompressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCompressionContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSION, 0)
}

func (s *TableOptionCompressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionCompressionContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *TableOptionCompressionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCompressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionCompression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionInsertMethodContext struct {
	TableOptionContext
	insertMethod antlr.Token
}

func NewTableOptionInsertMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionInsertMethodContext {
	var p = new(TableOptionInsertMethodContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionInsertMethodContext) GetInsertMethod() antlr.Token { return s.insertMethod }

func (s *TableOptionInsertMethodContext) SetInsertMethod(v antlr.Token) { s.insertMethod = v }

func (s *TableOptionInsertMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionInsertMethodContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT_METHOD, 0)
}

func (s *TableOptionInsertMethodContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *TableOptionInsertMethodContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *TableOptionInsertMethodContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *TableOptionInsertMethodContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionInsertMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionInsertMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionEngineAttributeContext struct {
	TableOptionContext
}

func NewTableOptionEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineAttributeContext {
	var p = new(TableOptionEngineAttributeContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineAttributeContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionEngineAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableOptionMinRowsContext struct {
	TableOptionContext
}

func NewTableOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMinRowsContext {
	var p = new(TableOptionMinRowsContext)

	InitEmptyTableOptionContext(&p.TableOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *TableOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableOptionMinRows(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableOption() (localctx ITableOptionContext) {
	localctx = NewTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MySqlParserRULE_tableOption)
	var _la int

	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1823)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1824)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1827)
				p.EngineName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewTableOptionEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1830)
			p.Match(MySqlParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1831)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1834)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableOptionAutoextendSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1835)
			p.Match(MySqlParserAUTOEXTEND_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1836)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1839)
			p.DecimalLiteral()
		}

	case 4:
		localctx = NewTableOptionAutoIncrementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1840)
			p.Match(MySqlParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1841)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1844)
			p.DecimalLiteral()
		}

	case 5:
		localctx = NewTableOptionAverageContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1845)
			p.Match(MySqlParserAVG_ROW_LENGTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1846)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1849)
			p.DecimalLiteral()
		}

	case 6:
		localctx = NewTableOptionCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1850)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1853)
			p.CharSet()
		}
		p.SetState(1855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1854)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(1857)
				p.CharsetName()
			}

		case MySqlParserDEFAULT:
			{
				p.SetState(1858)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 7:
		localctx = NewTableOptionChecksumContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1861)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHECKSUM || _la == MySqlParserPAGE_CHECKSUM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1862)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1865)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionChecksumContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionChecksumContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		localctx = NewTableOptionCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1866)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1869)
			p.Match(MySqlParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1870)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1873)
			p.CollationName()
		}

	case 9:
		localctx = NewTableOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1874)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1875)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1878)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewTableOptionCompressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1879)
			p.Match(MySqlParserCOMPRESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1880)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1883)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSTRING_LITERAL || _la == MySqlParserID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		localctx = NewTableOptionConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1884)
			p.Match(MySqlParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1885)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1888)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewTableOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1889)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserDATA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1890)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1891)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1894)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewTableOptionDelayContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1895)
			p.Match(MySqlParserDELAY_KEY_WRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1896)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1899)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionDelayContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionDelayContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		localctx = NewTableOptionEncryptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1900)
			p.Match(MySqlParserENCRYPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1901)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1904)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewTableOptionPageCompressedContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1905)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPAGE_COMPRESSED || _la == MySqlParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1906)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1909)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 16:
		localctx = NewTableOptionPageCompressionLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1910)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPAGE_COMPRESSION_LEVEL || _la == MySqlParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1911)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1914)
			p.DecimalLiteral()
		}

	case 17:
		localctx = NewTableOptionEncryptionKeyIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1915)
			p.Match(MySqlParserENCRYPTION_KEY_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1916)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1919)
			p.DecimalLiteral()
		}

	case 18:
		localctx = NewTableOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1920)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1921)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1922)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1925)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewTableOptionInsertMethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1926)
			p.Match(MySqlParserINSERT_METHOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1927)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1930)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionInsertMethodContext).insertMethod = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST || _la == MySqlParserLAST || _la == MySqlParserNO) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionInsertMethodContext).insertMethod = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		localctx = NewTableOptionKeyBlockSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1931)
			p.Match(MySqlParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1932)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1935)
			p.FileSizeLiteral()
		}

	case 21:
		localctx = NewTableOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1936)
			p.Match(MySqlParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1937)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1940)
			p.DecimalLiteral()
		}

	case 22:
		localctx = NewTableOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1941)
			p.Match(MySqlParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1942)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1945)
			p.DecimalLiteral()
		}

	case 23:
		localctx = NewTableOptionPackKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1946)
			p.Match(MySqlParserPACK_KEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1947)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1950)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPackKeysContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPackKeysContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 24:
		localctx = NewTableOptionPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1951)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1952)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1955)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewTableOptionRowFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1956)
			p.Match(MySqlParserROW_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1957)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1960)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRowFormatContext).rowFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || ((int64((_la-369)) & ^0x3f) == 0 && ((int64(1)<<(_la-369))&2305843013508661253) != 0) || _la == MySqlParserREDUNDANT || _la == MySqlParserID) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRowFormatContext).rowFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 26:
		localctx = NewTableOptionStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1961)
			p.Match(MySqlParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1962)
			p.Match(MySqlParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		localctx = NewTableOptionSecondaryEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1963)
			p.Match(MySqlParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1964)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1967)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		localctx = NewTableOptionRecalculationContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1968)
			p.Match(MySqlParserSTATS_AUTO_RECALC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1969)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1972)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRecalculationContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRecalculationContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 29:
		localctx = NewTableOptionPersistentContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1973)
			p.Match(MySqlParserSTATS_PERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1974)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1977)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPersistentContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPersistentContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 30:
		localctx = NewTableOptionSamplePageContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1978)
			p.Match(MySqlParserSTATS_SAMPLE_PAGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1979)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(1982)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(1983)
				p.DecimalLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 31:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1986)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1987)
			p.Uid()
		}
		p.SetState(1989)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1988)
				p.TablespaceStorage()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 32:
		localctx = NewTableOptionTableTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1991)
			p.Match(MySqlParserTABLE_TYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1992)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1993)
			p.TableType()
		}

	case 33:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1994)
			p.TablespaceStorage()
		}

	case 34:
		localctx = NewTableOptionTransactionalContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1995)
			p.Match(MySqlParserTRANSACTIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1996)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1999)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 35:
		localctx = NewTableOptionUnionContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2000)
			p.Match(MySqlParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2001)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2004)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2005)
			p.Tables()
		}
		{
			p.SetState(2006)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableTypeContext is an interface to support dynamic dispatch.
type ITableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MYSQL() antlr.TerminalNode
	ODBC() antlr.TerminalNode

	// IsTableTypeContext differentiates from other interfaces.
	IsTableTypeContext()
}

type TableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeContext() *TableTypeContext {
	var p = new(TableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableType
	return p
}

func InitEmptyTableTypeContext(p *TableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableType
}

func (*TableTypeContext) IsTableTypeContext() {}

func NewTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeContext {
	var p = new(TableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableType

	return p
}

func (s *TableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *TableTypeContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MySqlParserODBC, 0)
}

func (s *TableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableType(s)
	}
}

func (s *TableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableType(s)
	}
}

func (s *TableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableType() (localctx ITableTypeContext) {
	localctx = NewTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MySqlParserRULE_tableType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2010)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMYSQL || _la == MySqlParserODBC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceStorageContext is an interface to support dynamic dispatch.
type ITablespaceStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsTablespaceStorageContext differentiates from other interfaces.
	IsTablespaceStorageContext()
}

type TablespaceStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceStorageContext() *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablespaceStorage
	return p
}

func InitEmptyTablespaceStorageContext(p *TablespaceStorageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablespaceStorage
}

func (*TablespaceStorageContext) IsTablespaceStorageContext() {}

func NewTablespaceStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tablespaceStorage

	return p
}

func (s *TablespaceStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceStorageContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *TablespaceStorageContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *TablespaceStorageContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *TablespaceStorageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TablespaceStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTablespaceStorage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TablespaceStorage() (localctx ITablespaceStorageContext) {
	localctx = NewTablespaceStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MySqlParserRULE_tablespaceStorage)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2012)
		p.Match(MySqlParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2013)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDEFAULT || _la == MySqlParserDISK || _la == MySqlParserMEMORY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCount returns the count rule contexts.
	GetCount() IDecimalLiteralContext

	// GetSubCount returns the subCount rule contexts.
	GetSubCount() IDecimalLiteralContext

	// SetCount sets the count rule contexts.
	SetCount(IDecimalLiteralContext)

	// SetSubCount sets the subCount rule contexts.
	SetSubCount(IDecimalLiteralContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	PartitionFunctionDefinition() IPartitionFunctionDefinitionContext
	PARTITIONS() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinition() []IPartitionDefinitionContext
	PartitionDefinition(i int) IPartitionDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	SUBPARTITIONS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	count    IDecimalLiteralContext
	subCount IDecimalLiteralContext
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinitions
	return p
}

func InitEmptyPartitionDefinitionsContext(p *PartitionDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinitions
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) GetCount() IDecimalLiteralContext { return s.count }

func (s *PartitionDefinitionsContext) GetSubCount() IDecimalLiteralContext { return s.subCount }

func (s *PartitionDefinitionsContext) SetCount(v IDecimalLiteralContext) { s.count = v }

func (s *PartitionDefinitionsContext) SetSubCount(v IDecimalLiteralContext) { s.subCount = v }

func (s *PartitionDefinitionsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionDefinitionsContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBY)
}

func (s *PartitionDefinitionsContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, i)
}

func (s *PartitionDefinitionsContext) PartitionFunctionDefinition() IPartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *PartitionDefinitionsContext) SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionDefinitionsContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MySqlParserRULE_partitionDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2015)
		p.Match(MySqlParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2016)
		p.Match(MySqlParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2017)
		p.PartitionFunctionDefinition()
	}
	p.SetState(2020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITIONS {
		{
			p.SetState(2018)
			p.Match(MySqlParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2019)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionDefinitionsContext).count = _x
		}

	}
	p.SetState(2029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSUBPARTITION {
		{
			p.SetState(2022)
			p.Match(MySqlParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2023)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2024)
			p.SubpartitionFunctionDefinition()
		}
		p.SetState(2027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSUBPARTITIONS {
			{
				p.SetState(2025)
				p.Match(MySqlParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2026)

				var _x = p.DecimalLiteral()

				localctx.(*PartitionDefinitionsContext).subCount = _x
			}

		}

	}
	p.SetState(2042)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2031)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2032)
			p.PartitionDefinition()
		}
		p.SetState(2037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2033)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2034)
				p.PartitionDefinition()
			}

			p.SetState(2039)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2040)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionFunctionDefinitionContext differentiates from other interfaces.
	IsPartitionFunctionDefinitionContext()
}

type PartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionFunctionDefinitionContext() *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition
	return p
}

func InitEmptyPartitionFunctionDefinitionContext(p *PartitionFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition
}

func (*PartitionFunctionDefinitionContext) IsPartitionFunctionDefinitionContext() {}

func NewPartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition

	return p
}

func (s *PartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFunctionDefinitionContext) CopyAll(ctx *PartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionFunctionKeyContext struct {
	PartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionKeyContext {
	var p = new(PartitionFunctionKeyContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *PartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *PartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *PartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *PartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionFunctionHashContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionHashContext {
	var p = new(PartitionFunctionHashContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *PartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *PartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionHash(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionFunctionListContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionListContext {
	var p = new(PartitionFunctionListContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionListContext) LIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIST, 0)
}

func (s *PartitionFunctionListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *PartitionFunctionListContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionList(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionFunctionRangeContext struct {
	PartitionFunctionDefinitionContext
}

func NewPartitionFunctionRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionRangeContext {
	var p = new(PartitionFunctionRangeContext)

	InitEmptyPartitionFunctionDefinitionContext(&p.PartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionRangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANGE, 0)
}

func (s *PartitionFunctionRangeContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionRangeContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *PartitionFunctionRangeContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionFunctionRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PartitionFunctionDefinition() (localctx IPartitionFunctionDefinitionContext) {
	localctx = NewPartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MySqlParserRULE_partitionFunctionDefinition)
	var _la int

	p.SetState(2090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2044)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2047)
			p.Match(MySqlParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2048)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2049)
			p.expression(0)
		}
		{
			p.SetState(2050)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2052)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2055)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserALGORITHM {
			{
				p.SetState(2056)
				p.Match(MySqlParserALGORITHM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2057)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2058)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserONE_DECIMAL || _la == MySqlParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2061)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(2062)
				p.UidList()
			}

		}
		{
			p.SetState(2065)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPartitionFunctionRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2066)
			p.Match(MySqlParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLR_BRACKET:
			{
				p.SetState(2067)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2068)
				p.expression(0)
			}
			{
				p.SetState(2069)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserCOLUMNS:
			{
				p.SetState(2071)
				p.Match(MySqlParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2072)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2073)
				p.UidList()
			}
			{
				p.SetState(2074)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewPartitionFunctionListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2078)
			p.Match(MySqlParserLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLR_BRACKET:
			{
				p.SetState(2079)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2080)
				p.expression(0)
			}
			{
				p.SetState(2081)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserCOLUMNS:
			{
				p.SetState(2083)
				p.Match(MySqlParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2084)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2085)
				p.UidList()
			}
			{
				p.SetState(2086)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSubpartitionFunctionDefinitionContext differentiates from other interfaces.
	IsSubpartitionFunctionDefinitionContext()
}

type SubpartitionFunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionFunctionDefinitionContext() *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition
	return p
}

func InitEmptySubpartitionFunctionDefinitionContext(p *SubpartitionFunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition
}

func (*SubpartitionFunctionDefinitionContext) IsSubpartitionFunctionDefinitionContext() {}

func NewSubpartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition

	return p
}

func (s *SubpartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionFunctionDefinitionContext) CopyAll(ctx *SubpartitionFunctionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SubpartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubPartitionFunctionHashContext struct {
	SubpartitionFunctionDefinitionContext
}

func NewSubPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionHashContext {
	var p = new(SubPartitionFunctionHashContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *SubPartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubPartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *SubPartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubPartitionFunctionHash(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubPartitionFunctionKeyContext struct {
	SubpartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewSubPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionKeyContext {
	var p = new(SubPartitionFunctionKeyContext)

	InitEmptySubpartitionFunctionDefinitionContext(&p.SubpartitionFunctionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *SubPartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *SubPartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SubPartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SubPartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *SubPartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *SubPartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SubPartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubPartitionFunctionKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SubpartitionFunctionDefinition() (localctx ISubpartitionFunctionDefinitionContext) {
	localctx = NewSubpartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MySqlParserRULE_subpartitionFunctionDefinition)
	var _la int

	p.SetState(2113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSubPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2092)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2095)
			p.Match(MySqlParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2097)
			p.expression(0)
		}
		{
			p.SetState(2098)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSubPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2100)
				p.Match(MySqlParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2103)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserALGORITHM {
			{
				p.SetState(2104)
				p.Match(MySqlParserALGORITHM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2105)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2106)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SubPartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserONE_DECIMAL || _la == MySqlParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SubPartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2109)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.UidList()
		}
		{
			p.SetState(2111)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinition
	return p
}

func InitEmptyPartitionDefinitionContext(p *PartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinition
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) CopyAll(ctx *PartitionDefinitionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionComparisonContext struct {
	PartitionDefinitionContext
}

func NewPartitionComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionComparisonContext {
	var p = new(PartitionComparisonContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionComparisonContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionComparisonContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionComparisonContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS, 0)
}

func (s *PartitionComparisonContext) THAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHAN, 0)
}

func (s *PartitionComparisonContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionComparisonContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionComparisonContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionComparisonContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionComparisonContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionComparisonContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionComparisonContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionListAtomContext struct {
	PartitionDefinitionContext
}

func NewPartitionListAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListAtomContext {
	var p = new(PartitionListAtomContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListAtomContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionListAtomContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListAtomContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionListAtomContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PartitionListAtomContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionListAtomContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionListAtomContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionListAtomContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionListAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionListAtomContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListAtomContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionListAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionListVectorContext struct {
	PartitionDefinitionContext
}

func NewPartitionListVectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListVectorContext {
	var p = new(PartitionListVectorContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListVectorContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionListVectorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListVectorContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionListVectorContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PartitionListVectorContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionListVectorContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllPartitionDefinerVector() []IPartitionDefinerVectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerVectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerVectorContext); ok {
			tst[i] = t.(IPartitionDefinerVectorContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionDefinerVector(i int) IPartitionDefinerVectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerVectorContext)
}

func (s *PartitionListVectorContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionListVectorContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionListVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionListVectorContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListVectorContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionListVector(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionSimpleContext struct {
	PartitionDefinitionContext
}

func NewPartitionSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionSimpleContext {
	var p = new(PartitionSimpleContext)

	InitEmptyPartitionDefinitionContext(&p.PartitionDefinitionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSimpleContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionSimpleContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionSimpleContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionSimpleContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionSimpleContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionSimpleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionSimple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MySqlParserRULE_partitionDefinition)
	var _la int

	p.SetState(2261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2115)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.Uid()
		}
		{
			p.SetState(2117)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2118)
			p.Match(MySqlParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2119)
			p.Match(MySqlParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2120)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)
			p.PartitionDefinerAtom()
		}
		p.SetState(2126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2122)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2123)
				p.PartitionDefinerAtom()
			}

			p.SetState(2128)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2129)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-367)) & ^0x3f) == 0 && ((int64(1)<<(_la-367))&2199024304129) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2130)
				p.PartitionOption()
			}

			p.SetState(2135)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2136)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2137)
				p.SubpartitionDefinition()
			}
			p.SetState(2142)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2138)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2139)
					p.SubpartitionDefinition()
				}

				p.SetState(2144)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2145)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2149)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2150)
			p.Uid()
		}
		{
			p.SetState(2151)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2152)
			p.Match(MySqlParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2153)
			p.Match(MySqlParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2154)
			p.PartitionDefinerAtom()
		}
		p.SetState(2158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-367)) & ^0x3f) == 0 && ((int64(1)<<(_la-367))&2199024304129) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2155)
				p.PartitionOption()
			}

			p.SetState(2160)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2161)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2162)
				p.SubpartitionDefinition()
			}
			p.SetState(2167)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2163)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2164)
					p.SubpartitionDefinition()
				}

				p.SetState(2169)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2170)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewPartitionListAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2174)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.Uid()
		}
		{
			p.SetState(2176)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2177)
			p.Match(MySqlParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2178)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2179)
			p.PartitionDefinerAtom()
		}
		p.SetState(2184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2180)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2181)
				p.PartitionDefinerAtom()
			}

			p.SetState(2186)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2187)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-367)) & ^0x3f) == 0 && ((int64(1)<<(_la-367))&2199024304129) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2188)
				p.PartitionOption()
			}

			p.SetState(2193)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2194)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2195)
				p.SubpartitionDefinition()
			}
			p.SetState(2200)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2196)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2197)
					p.SubpartitionDefinition()
				}

				p.SetState(2202)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2203)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewPartitionListVectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2207)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2208)
			p.Uid()
		}
		{
			p.SetState(2209)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2210)
			p.Match(MySqlParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2211)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2212)
			p.PartitionDefinerVector()
		}
		p.SetState(2217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2213)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2214)
				p.PartitionDefinerVector()
			}

			p.SetState(2219)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2220)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-367)) & ^0x3f) == 0 && ((int64(1)<<(_la-367))&2199024304129) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2221)
				p.PartitionOption()
			}

			p.SetState(2226)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2227)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2228)
				p.SubpartitionDefinition()
			}
			p.SetState(2233)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2229)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2230)
					p.SubpartitionDefinition()
				}

				p.SetState(2235)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2236)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewPartitionSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2240)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2241)
			p.Uid()
		}
		p.SetState(2245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-367)) & ^0x3f) == 0 && ((int64(1)<<(_la-367))&2199024304129) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2242)
				p.PartitionOption()
			}

			p.SetState(2247)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2248)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2249)
				p.SubpartitionDefinition()
			}
			p.SetState(2254)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2250)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2251)
					p.SubpartitionDefinition()
				}

				p.SetState(2256)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2257)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinerAtomContext is an interface to support dynamic dispatch.
type IPartitionDefinerAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	Expression() IExpressionContext
	MAXVALUE() antlr.TerminalNode

	// IsPartitionDefinerAtomContext differentiates from other interfaces.
	IsPartitionDefinerAtomContext()
}

type PartitionDefinerAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerAtomContext() *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom
	return p
}

func InitEmptyPartitionDefinerAtomContext(p *PartitionDefinerAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom
}

func (*PartitionDefinerAtomContext) IsPartitionDefinerAtomContext() {}

func NewPartitionDefinerAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom

	return p
}

func (s *PartitionDefinerAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionDefinerAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionDefinerAtomContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAXVALUE, 0)
}

func (s *PartitionDefinerAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionDefinerAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PartitionDefinerAtom() (localctx IPartitionDefinerAtomContext) {
	localctx = NewPartitionDefinerAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MySqlParserRULE_partitionDefinerAtom)
	p.SetState(2266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2263)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2264)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2265)
			p.Match(MySqlParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinerVectorContext is an interface to support dynamic dispatch.
type IPartitionDefinerVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinerAtom() []IPartitionDefinerAtomContext
	PartitionDefinerAtom(i int) IPartitionDefinerAtomContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinerVectorContext differentiates from other interfaces.
	IsPartitionDefinerVectorContext()
}

type PartitionDefinerVectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerVectorContext() *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector
	return p
}

func InitEmptyPartitionDefinerVectorContext(p *PartitionDefinerVectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector
}

func (*PartitionDefinerVectorContext) IsPartitionDefinerVectorContext() {}

func NewPartitionDefinerVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector

	return p
}

func (s *PartitionDefinerVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerVectorContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinerVectorContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionDefinerVectorContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionDefinerVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionDefinerVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionDefinerVector(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PartitionDefinerVector() (localctx IPartitionDefinerVectorContext) {
	localctx = NewPartitionDefinerVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MySqlParserRULE_partitionDefinerVector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2268)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2269)
		p.PartitionDefinerAtom()
	}
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySqlParserCOMMA {
		{
			p.SetState(2270)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2271)
			p.PartitionDefinerAtom()
		}

		p.SetState(2274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2276)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Uid() IUidContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition
	return p
}

func InitEmptySubpartitionDefinitionContext(p *SubpartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *SubpartitionDefinitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubpartitionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MySqlParserRULE_subpartitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2278)
		p.Match(MySqlParserSUBPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2279)
		p.Uid()
	}
	p.SetState(2283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-367)) & ^0x3f) == 0 && ((int64(1)<<(_la-367))&2199024304129) != 0) || ((int64((_la-499)) & ^0x3f) == 0 && ((int64(1)<<(_la-499))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
		{
			p.SetState(2280)
			p.PartitionOption()
		}

		p.SetState(2285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionOption
	return p
}

func InitEmptyPartitionOptionContext(p *PartitionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionOption
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) CopyAll(ctx *PartitionOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionOptionCommentContext struct {
	PartitionOptionContext
	comment antlr.Token
}

func NewPartitionOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionCommentContext {
	var p = new(PartitionOptionCommentContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionCommentContext) GetComment() antlr.Token { return s.comment }

func (s *PartitionOptionCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *PartitionOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *PartitionOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionComment(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionNodeGroupContext struct {
	PartitionOptionContext
	nodegroup IUidContext
}

func NewPartitionOptionNodeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionNodeGroupContext {
	var p = new(PartitionOptionNodeGroupContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionNodeGroupContext) GetNodegroup() IUidContext { return s.nodegroup }

func (s *PartitionOptionNodeGroupContext) SetNodegroup(v IUidContext) { s.nodegroup = v }

func (s *PartitionOptionNodeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionNodeGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *PartitionOptionNodeGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionNodeGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionNodeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionNodeGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionIndexDirectoryContext struct {
	PartitionOptionContext
	indexDirectory antlr.Token
}

func NewPartitionOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionIndexDirectoryContext {
	var p = new(PartitionOptionIndexDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionIndexDirectoryContext) GetIndexDirectory() antlr.Token {
	return s.indexDirectory
}

func (s *PartitionOptionIndexDirectoryContext) SetIndexDirectory(v antlr.Token) { s.indexDirectory = v }

func (s *PartitionOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *PartitionOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *PartitionOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionIndexDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionMaxRowsContext struct {
	PartitionOptionContext
	maxRows IDecimalLiteralContext
}

func NewPartitionOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMaxRowsContext {
	var p = new(PartitionOptionMaxRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMaxRowsContext) GetMaxRows() IDecimalLiteralContext { return s.maxRows }

func (s *PartitionOptionMaxRowsContext) SetMaxRows(v IDecimalLiteralContext) { s.maxRows = v }

func (s *PartitionOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *PartitionOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionMaxRows(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionTablespaceContext struct {
	PartitionOptionContext
	tablespace IUidContext
}

func NewPartitionOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionTablespaceContext {
	var p = new(PartitionOptionTablespaceContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionTablespaceContext) GetTablespace() IUidContext { return s.tablespace }

func (s *PartitionOptionTablespaceContext) SetTablespace(v IUidContext) { s.tablespace = v }

func (s *PartitionOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *PartitionOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionEngineContext struct {
	PartitionOptionContext
}

func NewPartitionOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionEngineContext {
	var p = new(PartitionOptionEngineContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *PartitionOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *PartitionOptionEngineContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *PartitionOptionEngineContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *PartitionOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionEngine(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionMinRowsContext struct {
	PartitionOptionContext
	minRows IDecimalLiteralContext
}

func NewPartitionOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMinRowsContext {
	var p = new(PartitionOptionMinRowsContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMinRowsContext) GetMinRows() IDecimalLiteralContext { return s.minRows }

func (s *PartitionOptionMinRowsContext) SetMinRows(v IDecimalLiteralContext) { s.minRows = v }

func (s *PartitionOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *PartitionOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionMinRows(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionOptionDataDirectoryContext struct {
	PartitionOptionContext
	dataDirectory antlr.Token
}

func NewPartitionOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionDataDirectoryContext {
	var p = new(PartitionOptionDataDirectoryContext)

	InitEmptyPartitionOptionContext(&p.PartitionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionDataDirectoryContext) GetDataDirectory() antlr.Token { return s.dataDirectory }

func (s *PartitionOptionDataDirectoryContext) SetDataDirectory(v antlr.Token) { s.dataDirectory = v }

func (s *PartitionOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *PartitionOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *PartitionOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionOptionDataDirectory(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PartitionOption() (localctx IPartitionOptionContext) {
	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MySqlParserRULE_partitionOption)
	var _la int

	p.SetState(2334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDEFAULT, MySqlParserENGINE, MySqlParserSTORAGE:
		localctx = NewPartitionOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(2286)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTORAGE {
			{
				p.SetState(2289)
				p.Match(MySqlParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2292)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2293)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2296)
			p.EngineName()
		}

	case MySqlParserCOMMENT:
		localctx = NewPartitionOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2297)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2298)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2301)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionCommentContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDATA:
		localctx = NewPartitionOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2302)
			p.Match(MySqlParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2303)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2304)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2307)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionDataDirectoryContext).dataDirectory = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserINDEX:
		localctx = NewPartitionOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2308)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2309)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2310)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2313)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionIndexDirectoryContext).indexDirectory = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMAX_ROWS:
		localctx = NewPartitionOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2314)
			p.Match(MySqlParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2315)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2318)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMaxRowsContext).maxRows = _x
		}

	case MySqlParserMIN_ROWS:
		localctx = NewPartitionOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2319)
			p.Match(MySqlParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2320)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2323)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMinRowsContext).minRows = _x
		}

	case MySqlParserTABLESPACE:
		localctx = NewPartitionOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2324)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2325)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2328)

			var _x = p.Uid()

			localctx.(*PartitionOptionTablespaceContext).tablespace = _x
		}

	case MySqlParserNODEGROUP:
		localctx = NewPartitionOptionNodeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2329)
			p.Match(MySqlParserNODEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2330)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2333)

			var _x = p.Uid()

			localctx.(*PartitionOptionNodeGroupContext).nodegroup = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseContext is an interface to support dynamic dispatch.
type IAlterDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterDatabaseContext differentiates from other interfaces.
	IsAlterDatabaseContext()
}

type AlterDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseContext() *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterDatabase
	return p
}

func InitEmptyAlterDatabaseContext(p *AlterDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterDatabase
}

func (*AlterDatabaseContext) IsAlterDatabaseContext() {}

func NewAlterDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterDatabase

	return p
}

func (s *AlterDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseContext) CopyAll(ctx *AlterDatabaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterUpgradeNameContext struct {
	AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterUpgradeNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUpgradeNameContext {
	var p = new(AlterUpgradeNameContext)

	InitEmptyAlterDatabaseContext(&p.AlterDatabaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterDatabaseContext))

	return p
}

func (s *AlterUpgradeNameContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *AlterUpgradeNameContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterUpgradeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUpgradeNameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUpgradeNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterUpgradeNameContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *AlterUpgradeNameContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *AlterUpgradeNameContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *AlterUpgradeNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME, 0)
}

func (s *AlterUpgradeNameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *AlterUpgradeNameContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *AlterUpgradeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUpgradeName(s)
	}
}

func (s *AlterUpgradeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUpgradeName(s)
	}
}

func (s *AlterUpgradeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterUpgradeName(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterSimpleDatabaseContext struct {
	AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterSimpleDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSimpleDatabaseContext {
	var p = new(AlterSimpleDatabaseContext)

	InitEmptyAlterDatabaseContext(&p.AlterDatabaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterDatabaseContext))

	return p
}

func (s *AlterSimpleDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *AlterSimpleDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterSimpleDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSimpleDatabaseContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterSimpleDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *AlterSimpleDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *AlterSimpleDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterSimpleDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterSimpleDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *AlterSimpleDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterSimpleDatabase(s)
	}
}

func (s *AlterSimpleDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterSimpleDatabase(s)
	}
}

func (s *AlterSimpleDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterSimpleDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterDatabase() (localctx IAlterDatabaseContext) {
	localctx = NewAlterDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MySqlParserRULE_alterDatabase)
	var _la int

	p.SetState(2354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterSimpleDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2336)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2337)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterSimpleDatabaseContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterSimpleDatabaseContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2339)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2338)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2199107141632) != 0) || _la == MySqlParserREAD || _la == MySqlParserCHAR || _la == MySqlParserENCRYPTION || _la == MySqlParserCHARSET {
			{
				p.SetState(2341)
				p.CreateDatabaseOption()
			}

			p.SetState(2344)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAlterUpgradeNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2346)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2347)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterUpgradeNameContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterUpgradeNameContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2348)
			p.Uid()
		}
		{
			p.SetState(2349)
			p.Match(MySqlParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2350)
			p.Match(MySqlParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2351)
			p.Match(MySqlParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2352)
			p.Match(MySqlParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterEventContext is an interface to support dynamic dispatch.
type IAlterEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	OwnerStatement() IOwnerStatementContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	NOT() antlr.TerminalNode

	// IsAlterEventContext differentiates from other interfaces.
	IsAlterEventContext()
}

type AlterEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterEventContext() *AlterEventContext {
	var p = new(AlterEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterEvent
	return p
}

func InitEmptyAlterEventContext(p *AlterEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterEvent
}

func (*AlterEventContext) IsAlterEventContext() {}

func NewAlterEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterEventContext {
	var p = new(AlterEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterEvent

	return p
}

func (s *AlterEventContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterEventContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *AlterEventContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *AlterEventContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *AlterEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *AlterEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *AlterEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *AlterEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *AlterEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *AlterEventContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterEventContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *AlterEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *AlterEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *AlterEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *AlterEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterEvent(s)
	}
}

func (s *AlterEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterEvent(s)
	}
}

func (s *AlterEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterEvent() (localctx IAlterEventContext) {
	localctx = NewAlterEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MySqlParserRULE_alterEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2356)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(2357)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(2360)
		p.Match(MySqlParserEVENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2361)
		p.FullId()
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2362)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2363)
			p.Match(MySqlParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2364)
			p.ScheduleExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserON {
		{
			p.SetState(2367)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2368)
			p.Match(MySqlParserCOMPLETION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(2369)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2372)
			p.Match(MySqlParserPRESERVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2375)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2376)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2377)
			p.FullId()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDISABLE || _la == MySqlParserENABLE {
		{
			p.SetState(2380)
			p.EnableType()
		}

	}
	p.SetState(2385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(2383)
			p.Match(MySqlParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2384)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2389)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2387)
			p.Match(MySqlParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2388)
			p.RoutineBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterFunctionContext is an interface to support dynamic dispatch.
type IAlterFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterFunctionContext differentiates from other interfaces.
	IsAlterFunctionContext()
}

type AlterFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterFunctionContext() *AlterFunctionContext {
	var p = new(AlterFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterFunction
	return p
}

func InitEmptyAlterFunctionContext(p *AlterFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterFunction
}

func (*AlterFunctionContext) IsAlterFunctionContext() {}

func NewAlterFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterFunction

	return p
}

func (s *AlterFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *AlterFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

func (s *AlterFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterFunction() (localctx IAlterFunctionContext) {
	localctx = NewAlterFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MySqlParserRULE_alterFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2392)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2393)
		p.FullId()
	}
	p.SetState(2397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDETERMINISTIC || ((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&281474985099269) != 0) || _la == MySqlParserCOMMENT || _la == MySqlParserCONTAINS || _la == MySqlParserLANGUAGE || _la == MySqlParserNO {
		{
			p.SetState(2394)
			p.RoutineOption()
		}

		p.SetState(2399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterInstanceContext is an interface to support dynamic dispatch.
type IAlterInstanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsAlterInstanceContext differentiates from other interfaces.
	IsAlterInstanceContext()
}

type AlterInstanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterInstanceContext() *AlterInstanceContext {
	var p = new(AlterInstanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterInstance
	return p
}

func InitEmptyAlterInstanceContext(p *AlterInstanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterInstance
}

func (*AlterInstanceContext) IsAlterInstanceContext() {}

func NewAlterInstanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterInstanceContext {
	var p = new(AlterInstanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterInstance

	return p
}

func (s *AlterInstanceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterInstanceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterInstanceContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANCE, 0)
}

func (s *AlterInstanceContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROTATE, 0)
}

func (s *AlterInstanceContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB, 0)
}

func (s *AlterInstanceContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *AlterInstanceContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterInstanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterInstanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterInstanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterInstance(s)
	}
}

func (s *AlterInstanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterInstance(s)
	}
}

func (s *AlterInstanceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterInstance(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterInstance() (localctx IAlterInstanceContext) {
	localctx = NewAlterInstanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MySqlParserRULE_alterInstance)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2400)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2401)
		p.Match(MySqlParserINSTANCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2402)
		p.Match(MySqlParserROTATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2403)
		p.Match(MySqlParserINNODB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2404)
		p.Match(MySqlParserMASTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2405)
		p.Match(MySqlParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLogfileGroupContext is an interface to support dynamic dispatch.
type IAlterLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	INITIAL_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsAlterLogfileGroupContext differentiates from other interfaces.
	IsAlterLogfileGroupContext()
}

type AlterLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLogfileGroupContext() *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup
	return p
}

func InitEmptyAlterLogfileGroupContext(p *AlterLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup
}

func (*AlterLogfileGroupContext) IsAlterLogfileGroupContext() {}

func NewAlterLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup

	return p
}

func (s *AlterLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLogfileGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *AlterLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *AlterLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *AlterLogfileGroupContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *AlterLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *AlterLogfileGroupContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *AlterLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterLogfileGroup() (localctx IAlterLogfileGroupContext) {
	localctx = NewAlterLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MySqlParserRULE_alterLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2407)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2408)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2409)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2410)
		p.Uid()
	}
	{
		p.SetState(2411)
		p.Match(MySqlParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2412)
		p.Match(MySqlParserUNDOFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2413)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(2414)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2415)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2418)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(2421)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2424)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(2425)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2428)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterProcedureContext is an interface to support dynamic dispatch.
type IAlterProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterProcedureContext differentiates from other interfaces.
	IsAlterProcedureContext()
}

type AlterProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProcedureContext() *AlterProcedureContext {
	var p = new(AlterProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterProcedure
	return p
}

func InitEmptyAlterProcedureContext(p *AlterProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterProcedure
}

func (*AlterProcedureContext) IsAlterProcedureContext() {}

func NewAlterProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProcedureContext {
	var p = new(AlterProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterProcedure

	return p
}

func (s *AlterProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *AlterProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterProcedure() (localctx IAlterProcedureContext) {
	localctx = NewAlterProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MySqlParserRULE_alterProcedure)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2430)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2431)
		p.Match(MySqlParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2432)
		p.FullId()
	}
	p.SetState(2436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDETERMINISTIC || ((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&281474985099269) != 0) || _la == MySqlParserCOMMENT || _la == MySqlParserCONTAINS || _la == MySqlParserLANGUAGE || _la == MySqlParserNO {
		{
			p.SetState(2433)
			p.RoutineOption()
		}

		p.SetState(2438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterServerContext is an interface to support dynamic dispatch.
type IAlterServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterServerContext differentiates from other interfaces.
	IsAlterServerContext()
}

type AlterServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServerContext() *AlterServerContext {
	var p = new(AlterServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterServer
	return p
}

func InitEmptyAlterServerContext(p *AlterServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterServer
}

func (*AlterServerContext) IsAlterServerContext() {}

func NewAlterServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServerContext {
	var p = new(AlterServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterServer

	return p
}

func (s *AlterServerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *AlterServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *AlterServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *AlterServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterServer(s)
	}
}

func (s *AlterServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterServer(s)
	}
}

func (s *AlterServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterServer() (localctx IAlterServerContext) {
	localctx = NewAlterServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MySqlParserRULE_alterServer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2439)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2440)
		p.Match(MySqlParserSERVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2441)
		p.Uid()
	}
	{
		p.SetState(2442)
		p.Match(MySqlParserOPTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2443)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2444)
		p.ServerOption()
	}
	p.SetState(2449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(2445)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2446)
			p.ServerOption()
		}

		p.SetState(2451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2452)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	IGNORE() antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext
	AllAlterSpecification() []IAlterSpecificationContext
	AlterSpecification(i int) IAlterSpecificationContext
	PartitionDefinitions() IPartitionDefinitionsContext
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	intimeAction antlr.Token
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTable
	return p
}

func InitEmptyAlterTableContext(p *AlterTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTable
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *AlterTableContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AlterTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *AlterTableContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *AlterTableContext) AllAlterSpecification() []IAlterSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IAlterSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterSpecificationContext); ok {
			tst[i] = t.(IAlterSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterSpecification(i int) IAlterSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSpecificationContext)
}

func (s *AlterTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *AlterTableContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *AlterTableContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (s *AlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterTable() (localctx IAlterTableContext) {
	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MySqlParserRULE_alterTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2454)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserOFFLINE || _la == MySqlParserONLINE {
		{
			p.SetState(2455)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterTableContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterTableContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(2458)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2461)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2462)
		p.TableName()
	}
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOWAIT || _la == MySqlParserWAIT {
		{
			p.SetState(2463)
			p.WaitNowaitClause()
		}

	}
	p.SetState(2474)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2466)
			p.AlterSpecification()
		}
		p.SetState(2471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2467)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2468)
				p.AlterSpecification()
			}

			p.SetState(2473)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(2476)
			p.PartitionDefinitions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTablespaceContext is an interface to support dynamic dispatch.
type IAlterTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetObjectAction returns the objectAction token.
	GetObjectAction() antlr.Token

	// SetObjectAction sets the objectAction token.
	SetObjectAction(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode

	// IsAlterTablespaceContext differentiates from other interfaces.
	IsAlterTablespaceContext()
}

type AlterTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	objectAction antlr.Token
}

func NewEmptyAlterTablespaceContext() *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTablespace
	return p
}

func InitEmptyAlterTablespaceContext(p *AlterTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTablespace
}

func (*AlterTablespaceContext) IsAlterTablespaceContext() {}

func NewAlterTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterTablespace

	return p
}

func (s *AlterTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTablespaceContext) GetObjectAction() antlr.Token { return s.objectAction }

func (s *AlterTablespaceContext) SetObjectAction(v antlr.Token) { s.objectAction = v }

func (s *AlterTablespaceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterTablespaceContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *AlterTablespaceContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *AlterTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterTablespaceContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterTablespaceContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *AlterTablespaceContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterTablespaceContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterTablespaceContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterTablespaceContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *AlterTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterTablespace() (localctx IAlterTablespaceContext) {
	localctx = NewAlterTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MySqlParserRULE_alterTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2479)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2480)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2481)
		p.Uid()
	}
	{
		p.SetState(2482)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AlterTablespaceContext).objectAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserADD || _la == MySqlParserDROP) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AlterTablespaceContext).objectAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2483)
		p.Match(MySqlParserDATAFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2484)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(2485)
			p.Match(MySqlParserINITIAL_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2486)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2487)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(2490)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2493)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(2494)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2497)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewContext is an interface to support dynamic dispatch.
type IAlterViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token

	// GetCheckOpt returns the checkOpt token.
	GetCheckOpt() antlr.Token

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token)

	// SetCheckOpt sets the checkOpt token.
	SetCheckOpt(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsAlterViewContext differentiates from other interfaces.
	IsAlterViewContext()
}

type AlterViewContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	algType    antlr.Token
	secContext antlr.Token
	checkOpt   antlr.Token
}

func NewEmptyAlterViewContext() *AlterViewContext {
	var p = new(AlterViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterView
	return p
}

func InitEmptyAlterViewContext(p *AlterViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterView
}

func (*AlterViewContext) IsAlterViewContext() {}

func NewAlterViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewContext {
	var p = new(AlterViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterView

	return p
}

func (s *AlterViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *AlterViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *AlterViewContext) GetCheckOpt() antlr.Token { return s.checkOpt }

func (s *AlterViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *AlterViewContext) SetCheckOpt(v antlr.Token) { s.checkOpt = v }

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *AlterViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AlterViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *AlterViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *AlterViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AlterViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *AlterViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *AlterViewContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterViewContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterViewContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *AlterViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *AlterViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *AlterViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *AlterViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *AlterViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *AlterViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *AlterViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

func (s *AlterViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterView() (localctx IAlterViewContext) {
	localctx = NewAlterViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MySqlParserRULE_alterView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2499)
		p.Match(MySqlParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALGORITHM {
		{
			p.SetState(2500)
			p.Match(MySqlParserALGORITHM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2501)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2502)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMERGE || _la == MySqlParserTEMPTABLE || _la == MySqlParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(2505)
			p.OwnerStatement()
		}

	}
	p.SetState(2511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSQL {
		{
			p.SetState(2508)
			p.Match(MySqlParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2509)
			p.Match(MySqlParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2510)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2513)
		p.Match(MySqlParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2514)
		p.FullId()
	}
	p.SetState(2519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(2515)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2516)
			p.UidList()
		}
		{
			p.SetState(2517)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2521)
		p.Match(MySqlParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2522)
		p.SelectStatement()
	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2523)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCASCADED || _la == MySqlParserLOCAL {
			{
				p.SetState(2524)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterViewContext).checkOpt = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCASCADED || _la == MySqlParserLOCAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterViewContext).checkOpt = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2527)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2528)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSpecificationContext is an interface to support dynamic dispatch.
type IAlterSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSpecificationContext differentiates from other interfaces.
	IsAlterSpecificationContext()
}

type AlterSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSpecificationContext() *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterSpecification
	return p
}

func InitEmptyAlterSpecificationContext(p *AlterSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterSpecification
}

func (*AlterSpecificationContext) IsAlterSpecificationContext() {}

func NewAlterSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterSpecification

	return p
}

func (s *AlterSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSpecificationContext) CopyAll(ctx *AlterSpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterByAlterColumnDefaultContext struct {
	AlterSpecificationContext
}

func NewAlterByAlterColumnDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterColumnDefaultContext {
	var p = new(AlterByAlterColumnDefaultContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterColumnDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterColumnDefaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterColumnDefaultContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterColumnDefaultContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByAlterColumnDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByAlterColumnDefaultContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByAlterColumnDefaultContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAlterColumnDefaultContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *AlterByAlterColumnDefaultContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *AlterByAlterColumnDefaultContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAlterColumnDefaultContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAlterColumnDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAlterColumnDefaultContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAlterColumnDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterColumnDefault(s)
	}
}

func (s *AlterByAlterColumnDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterColumnDefault(s)
	}
}

func (s *AlterByAlterColumnDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAlterColumnDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDisableKeysContext struct {
	AlterSpecificationContext
}

func NewAlterByDisableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDisableKeysContext {
	var p = new(AlterByDisableKeysContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDisableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDisableKeysContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *AlterByDisableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}

func (s *AlterByDisableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDisableKeys(s)
	}
}

func (s *AlterByDisableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDisableKeys(s)
	}
}

func (s *AlterByDisableKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDisableKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDefaultCharsetContext struct {
	AlterSpecificationContext
}

func NewAlterByDefaultCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDefaultCharsetContext {
	var p = new(AlterByDefaultCharsetContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDefaultCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDefaultCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *AlterByDefaultCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByDefaultCharsetContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterByDefaultCharsetContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterByDefaultCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByDefaultCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByDefaultCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *AlterByDefaultCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *AlterByDefaultCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDefaultCharset(s)
	}
}

func (s *AlterByDefaultCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDefaultCharset(s)
	}
}

func (s *AlterByDefaultCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDefaultCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRenameColumnContext struct {
	AlterSpecificationContext
	oldColumn IUidContext
	newColumn IUidContext
}

func NewAlterByRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameColumnContext {
	var p = new(AlterByRenameColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByRenameColumnContext) GetNewColumn() IUidContext { return s.newColumn }

func (s *AlterByRenameColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByRenameColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByRenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByRenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRenameColumn(s)
	}
}

func (s *AlterByRenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRenameColumn(s)
	}
}

func (s *AlterByRenameColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRenameColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByConvertCharsetContext struct {
	AlterSpecificationContext
}

func NewAlterByConvertCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByConvertCharsetContext {
	var p = new(AlterByConvertCharsetContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByConvertCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByConvertCharsetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *AlterByConvertCharsetContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByConvertCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByConvertCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *AlterByConvertCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *AlterByConvertCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByConvertCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *AlterByConvertCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *AlterByConvertCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByConvertCharset(s)
	}
}

func (s *AlterByConvertCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByConvertCharset(s)
	}
}

func (s *AlterByConvertCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByConvertCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddForeignKeyContext struct {
	AlterSpecificationContext
	name      IUidContext
	indexName IUidContext
}

func NewAlterByAddForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddForeignKeyContext {
	var p = new(AlterByAddForeignKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddForeignKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddForeignKeyContext) GetIndexName() IUidContext { return s.indexName }

func (s *AlterByAddForeignKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddForeignKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddForeignKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *AlterByAddForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddForeignKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddForeignKeyContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *AlterByAddForeignKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddForeignKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddForeignKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddForeignKey(s)
	}
}

func (s *AlterByAddForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddForeignKey(s)
	}
}

func (s *AlterByAddForeignKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddForeignKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRenameIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByRenameIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameIndexContext {
	var p = new(AlterByRenameIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByRenameIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByRenameIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameIndexContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameIndexContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameIndexContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameIndexContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByRenameIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByRenameIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRenameIndex(s)
	}
}

func (s *AlterByRenameIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRenameIndex(s)
	}
}

func (s *AlterByRenameIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRenameIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRenameContext struct {
	AlterSpecificationContext
	renameFormat antlr.Token
}

func NewAlterByRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameContext {
	var p = new(AlterByRenameContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameContext) GetRenameFormat() antlr.Token { return s.renameFormat }

func (s *AlterByRenameContext) SetRenameFormat(v antlr.Token) { s.renameFormat = v }

func (s *AlterByRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterByRenameContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AlterByRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRename(s)
	}
}

func (s *AlterByRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRename(s)
	}
}

func (s *AlterByRenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRename(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByImportTablespaceContext struct {
	AlterSpecificationContext
}

func NewAlterByImportTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportTablespaceContext {
	var p = new(AlterByImportTablespaceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByImportTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportTablespaceContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *AlterByImportTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByImportTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByImportTablespace(s)
	}
}

func (s *AlterByImportTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByImportTablespace(s)
	}
}

func (s *AlterByImportTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByImportTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddDefinitionsContext struct {
	AlterSpecificationContext
}

func NewAlterByAddDefinitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddDefinitionsContext {
	var p = new(AlterByAddDefinitionsContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddDefinitionsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *AlterByAddDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByAddDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddDefinitions(s)
	}
}

func (s *AlterByAddDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddDefinitions(s)
	}
}

func (s *AlterByAddDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAlterCheckTableConstraintContext struct {
	AlterSpecificationContext
	name IUidContext
}

func NewAlterByAlterCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterCheckTableConstraintContext {
	var p = new(AlterByAlterCheckTableConstraintContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterCheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *AlterByAlterCheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAlterCheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterCheckTableConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAlterCheckTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterCheckTableConstraintContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAlterCheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAlterCheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterCheckTableConstraint(s)
	}
}

func (s *AlterByAlterCheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterCheckTableConstraint(s)
	}
}

func (s *AlterByAlterCheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAlterCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropConstraintCheckContext struct {
	AlterSpecificationContext
}

func NewAlterByDropConstraintCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropConstraintCheckContext {
	var p = new(AlterByDropConstraintCheckContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropConstraintCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropConstraintCheckContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropConstraintCheckContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropConstraintCheckContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByDropConstraintCheckContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByDropConstraintCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropConstraintCheck(s)
	}
}

func (s *AlterByDropConstraintCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropConstraintCheck(s)
	}
}

func (s *AlterByDropConstraintCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropConstraintCheck(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddColumnsContext struct {
	AlterSpecificationContext
}

func NewAlterByAddColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnsContext {
	var p = new(AlterByAddColumnsContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddColumnsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnsContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddColumnsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddColumnsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByAddColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddColumns(s)
	}
}

func (s *AlterByAddColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddColumns(s)
	}
}

func (s *AlterByAddColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAlterIndexVisibilityContext struct {
	AlterSpecificationContext
}

func NewAlterByAlterIndexVisibilityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterIndexVisibilityContext {
	var p = new(AlterByAlterIndexVisibilityContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterIndexVisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterIndexVisibilityContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAlterIndexVisibilityContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterIndexVisibilityContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *AlterByAlterIndexVisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterIndexVisibility(s)
	}
}

func (s *AlterByAlterIndexVisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterIndexVisibility(s)
	}
}

func (s *AlterByAlterIndexVisibilityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAlterIndexVisibility(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropForeignKeyContext struct {
	AlterSpecificationContext
}

func NewAlterByDropForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropForeignKeyContext {
	var p = new(AlterByDropForeignKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropForeignKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *AlterByDropForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByDropForeignKeyContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropForeignKey(s)
	}
}

func (s *AlterByDropForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropForeignKey(s)
	}
}

func (s *AlterByDropForeignKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropForeignKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddCheckTableConstraintContext struct {
	AlterSpecificationContext
	name IUidContext
}

func NewAlterByAddCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddCheckTableConstraintContext {
	var p = new(AlterByAddCheckTableConstraintContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddCheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *AlterByAddCheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddCheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddCheckTableConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByAddCheckTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddCheckTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddCheckTableConstraintContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAddCheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAddCheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddCheckTableConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterByAddCheckTableConstraintContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *AlterByAddCheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddCheckTableConstraint(s)
	}
}

func (s *AlterByAddCheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddCheckTableConstraint(s)
	}
}

func (s *AlterByAddCheckTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddCheckTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterPartitionContext struct {
	AlterSpecificationContext
}

func NewAlterPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterPartitionContext {
	var p = new(AlterPartitionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPartitionContext) AlterPartitionSpecification() IAlterPartitionSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPartitionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPartitionSpecificationContext)
}

func (s *AlterPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterPartition(s)
	}
}

func (s *AlterPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterPartition(s)
	}
}

func (s *AlterPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByAddIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddIndexContext {
	var p = new(AlterByAddIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddIndex(s)
	}
}

func (s *AlterByAddIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddIndex(s)
	}
}

func (s *AlterByAddIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropColumnContext {
	var p = new(AlterByDropColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropColumnContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByDropColumnContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *AlterByDropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropColumn(s)
	}
}

func (s *AlterByDropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropColumn(s)
	}
}

func (s *AlterByDropColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByChangeDefaultContext struct {
	AlterSpecificationContext
}

func NewAlterByChangeDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeDefaultContext {
	var p = new(AlterByChangeDefaultContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByChangeDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeDefaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByChangeDefaultContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeDefaultContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByChangeDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByChangeDefaultContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AlterByChangeDefaultContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByChangeDefaultContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByChangeDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByChangeDefault(s)
	}
}

func (s *AlterByChangeDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByChangeDefault(s)
	}
}

func (s *AlterByChangeDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByChangeDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByForceContext struct {
	AlterSpecificationContext
}

func NewAlterByForceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByForceContext {
	var p = new(AlterByForceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByForceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByForceContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORCE, 0)
}

func (s *AlterByForceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByForce(s)
	}
}

func (s *AlterByForceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByForce(s)
	}
}

func (s *AlterByForceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByForce(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddSpecialIndexContext struct {
	AlterSpecificationContext
	keyType     antlr.Token
	indexFormat antlr.Token
}

func NewAlterByAddSpecialIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddSpecialIndexContext {
	var p = new(AlterByAddSpecialIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddSpecialIndexContext) GetKeyType() antlr.Token { return s.keyType }

func (s *AlterByAddSpecialIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddSpecialIndexContext) SetKeyType(v antlr.Token) { s.keyType = v }

func (s *AlterByAddSpecialIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddSpecialIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddSpecialIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddSpecialIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddSpecialIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *AlterByAddSpecialIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *AlterByAddSpecialIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddSpecialIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddSpecialIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddSpecialIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddSpecialIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddSpecialIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddSpecialIndex(s)
	}
}

func (s *AlterByAddSpecialIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddSpecialIndex(s)
	}
}

func (s *AlterByAddSpecialIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddSpecialIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByModifyColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByModifyColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByModifyColumnContext {
	var p = new(AlterByModifyColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByModifyColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByModifyColumnContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFY, 0)
}

func (s *AlterByModifyColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByModifyColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByModifyColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByModifyColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByModifyColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByModifyColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *AlterByModifyColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByModifyColumn(s)
	}
}

func (s *AlterByModifyColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByModifyColumn(s)
	}
}

func (s *AlterByModifyColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByModifyColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByTableOptionContext struct {
	AlterSpecificationContext
}

func NewAlterByTableOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTableOptionContext {
	var p = new(AlterByTableOptionContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTableOptionContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByTableOptionContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *AlterByTableOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByTableOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByTableOption(s)
	}
}

func (s *AlterByTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByTableOption(s)
	}
}

func (s *AlterByTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropPrimaryKeyContext struct {
	AlterSpecificationContext
}

func NewAlterByDropPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPrimaryKeyContext {
	var p = new(AlterByDropPrimaryKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPrimaryKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *AlterByDropPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByDropPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropPrimaryKey(s)
	}
}

func (s *AlterByDropPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropPrimaryKey(s)
	}
}

func (s *AlterByDropPrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByLockContext struct {
	AlterSpecificationContext
	lockType antlr.Token
}

func NewAlterByLockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByLockContext {
	var p = new(AlterByLockContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByLockContext) GetLockType() antlr.Token { return s.lockType }

func (s *AlterByLockContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *AlterByLockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByLockContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *AlterByLockContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByLockContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *AlterByLockContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, 0)
}

func (s *AlterByLockContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, 0)
}

func (s *AlterByLockContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AlterByLockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByLock(s)
	}
}

func (s *AlterByLockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByLock(s)
	}
}

func (s *AlterByLockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByLock(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDiscardTablespaceContext struct {
	AlterSpecificationContext
}

func NewAlterByDiscardTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardTablespaceContext {
	var p = new(AlterByDiscardTablespaceContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDiscardTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardTablespaceContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *AlterByDiscardTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByDiscardTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDiscardTablespace(s)
	}
}

func (s *AlterByDiscardTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDiscardTablespace(s)
	}
}

func (s *AlterByDiscardTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDiscardTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByValidateContext struct {
	AlterSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByValidateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByValidateContext {
	var p = new(AlterByValidateContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByValidateContext) GetValidationFormat() antlr.Token { return s.validationFormat }

func (s *AlterByValidateContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByValidateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByValidateContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *AlterByValidateContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *AlterByValidateContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterByValidateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByValidate(s)
	}
}

func (s *AlterByValidateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByValidate(s)
	}
}

func (s *AlterByValidateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByValidate(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddPrimaryKeyContext struct {
	AlterSpecificationContext
	name  IUidContext
	index IUidContext
}

func NewAlterByAddPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPrimaryKeyContext {
	var p = new(AlterByAddPrimaryKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddPrimaryKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddPrimaryKeyContext) GetIndex() IUidContext { return s.index }

func (s *AlterByAddPrimaryKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddPrimaryKeyContext) SetIndex(v IUidContext) { s.index = v }

func (s *AlterByAddPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPrimaryKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *AlterByAddPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddPrimaryKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddPrimaryKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddPrimaryKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddPrimaryKey(s)
	}
}

func (s *AlterByAddPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddPrimaryKey(s)
	}
}

func (s *AlterByAddPrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByEnableKeysContext struct {
	AlterSpecificationContext
}

func NewAlterByEnableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByEnableKeysContext {
	var p = new(AlterByEnableKeysContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByEnableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByEnableKeysContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *AlterByEnableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}

func (s *AlterByEnableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByEnableKeys(s)
	}
}

func (s *AlterByEnableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByEnableKeys(s)
	}
}

func (s *AlterByEnableKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByEnableKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterBySetAlgorithmContext struct {
	AlterSpecificationContext
	algType antlr.Token
}

func NewAlterBySetAlgorithmContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterBySetAlgorithmContext {
	var p = new(AlterBySetAlgorithmContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterBySetAlgorithmContext) GetAlgType() antlr.Token { return s.algType }

func (s *AlterBySetAlgorithmContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterBySetAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterBySetAlgorithmContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *AlterBySetAlgorithmContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterBySetAlgorithmContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANT, 0)
}

func (s *AlterBySetAlgorithmContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, 0)
}

func (s *AlterBySetAlgorithmContext) COPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, 0)
}

func (s *AlterBySetAlgorithmContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AlterBySetAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterBySetAlgorithm(s)
	}
}

func (s *AlterBySetAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterBySetAlgorithm(s)
	}
}

func (s *AlterBySetAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterBySetAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByChangeColumnContext struct {
	AlterSpecificationContext
	oldColumn   IUidContext
	newColumn   IUidContext
	afterColumn IUidContext
}

func NewAlterByChangeColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeColumnContext {
	var p = new(AlterByChangeColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByChangeColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByChangeColumnContext) GetNewColumn() IUidContext { return s.newColumn }

func (s *AlterByChangeColumnContext) GetAfterColumn() IUidContext { return s.afterColumn }

func (s *AlterByChangeColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByChangeColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByChangeColumnContext) SetAfterColumn(v IUidContext) { s.afterColumn = v }

func (s *AlterByChangeColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeColumnContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *AlterByChangeColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByChangeColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByChangeColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByChangeColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByChangeColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *AlterByChangeColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByChangeColumn(s)
	}
}

func (s *AlterByChangeColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByChangeColumn(s)
	}
}

func (s *AlterByChangeColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByChangeColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddUniqueKeyContext struct {
	AlterSpecificationContext
	name        IUidContext
	indexFormat antlr.Token
	indexName   IUidContext
}

func NewAlterByAddUniqueKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddUniqueKeyContext {
	var p = new(AlterByAddUniqueKeyContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddUniqueKeyContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddUniqueKeyContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddUniqueKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddUniqueKeyContext) GetIndexName() IUidContext { return s.indexName }

func (s *AlterByAddUniqueKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddUniqueKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddUniqueKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddUniqueKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddUniqueKeyContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *AlterByAddUniqueKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddUniqueKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddUniqueKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddUniqueKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddUniqueKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddUniqueKeyContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddUniqueKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddUniqueKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddUniqueKey(s)
	}
}

func (s *AlterByAddUniqueKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddUniqueKey(s)
	}
}

func (s *AlterByAddUniqueKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddUniqueKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropIndexContext struct {
	AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropIndexContext {
	var p = new(AlterByDropIndexContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByDropIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByDropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByDropIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByDropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropIndex(s)
	}
}

func (s *AlterByDropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropIndex(s)
	}
}

func (s *AlterByDropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddColumnContext struct {
	AlterSpecificationContext
}

func NewAlterByAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnContext {
	var p = new(AlterByAddColumnContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByAddColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *AlterByAddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddColumn(s)
	}
}

func (s *AlterByAddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddColumn(s)
	}
}

func (s *AlterByAddColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByOrderContext struct {
	AlterSpecificationContext
}

func NewAlterByOrderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOrderContext {
	var p = new(AlterByOrderContext)

	InitEmptyAlterSpecificationContext(&p.AlterSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *AlterByOrderContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AlterByOrderContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByOrder(s)
	}
}

func (s *AlterByOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByOrder(s)
	}
}

func (s *AlterByOrderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByOrder(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterSpecification() (localctx IAlterSpecificationContext) {
	localctx = NewAlterSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MySqlParserRULE_alterSpecification)
	var _la int

	var _alt int

	p.SetState(2882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 369, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterByTableOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2531)
			p.TableOption()
		}
		p.SetState(2538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2533)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserCOMMA {
					{
						p.SetState(2532)
						p.Match(MySqlParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(2535)
					p.TableOption()
				}

			}
			p.SetState(2540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewAlterByAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2541)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2542)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2545)
			p.Uid()
		}
		{
			p.SetState(2546)
			p.ColumnDefinition()
		}
		p.SetState(2550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2547)
				p.Match(MySqlParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserAFTER:
			{
				p.SetState(2548)
				p.Match(MySqlParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2549)
				p.Uid()
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 3:
		localctx = NewAlterByAddColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2552)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2553)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2556)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2557)
			p.Uid()
		}
		{
			p.SetState(2558)
			p.ColumnDefinition()
		}
		p.SetState(2565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2559)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2560)
				p.Uid()
			}
			{
				p.SetState(2561)
				p.ColumnDefinition()
			}

			p.SetState(2567)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2568)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAlterByAddIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2570)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2571)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(2572)
				p.Uid()
			}

		}
		p.SetState(2576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(2575)
				p.IndexType()
			}

		}
		{
			p.SetState(2578)
			p.IndexColumnNames()
		}
		p.SetState(2582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2579)
					p.IndexOption()
				}

			}
			p.SetState(2584)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 5:
		localctx = NewAlterByAddPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2585)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2586)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2588)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2587)

					var _x = p.Uid()

					localctx.(*AlterByAddPrimaryKeyContext).name = _x
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(2592)
			p.Match(MySqlParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2593)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(2594)

				var _x = p.Uid()

				localctx.(*AlterByAddPrimaryKeyContext).index = _x
			}

		}
		p.SetState(2598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(2597)
				p.IndexType()
			}

		}
		{
			p.SetState(2600)
			p.IndexColumnNames()
		}
		p.SetState(2604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2601)
					p.IndexOption()
				}

			}
			p.SetState(2606)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 6:
		localctx = NewAlterByAddUniqueKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2607)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2608)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2610)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(2609)

					var _x = p.Uid()

					localctx.(*AlterByAddUniqueKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2614)
			p.Match(MySqlParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(2615)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddUniqueKeyContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddUniqueKeyContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(2618)

				var _x = p.Uid()

				localctx.(*AlterByAddUniqueKeyContext).indexName = _x
			}

		}
		p.SetState(2622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(2621)
				p.IndexType()
			}

		}
		{
			p.SetState(2624)
			p.IndexColumnNames()
		}
		p.SetState(2628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2625)
					p.IndexOption()
				}

			}
			p.SetState(2630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 7:
		localctx = NewAlterByAddSpecialIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2631)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2632)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddSpecialIndexContext).keyType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddSpecialIndexContext).keyType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(2633)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddSpecialIndexContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddSpecialIndexContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(2636)
				p.Uid()
			}

		}
		{
			p.SetState(2639)
			p.IndexColumnNames()
		}
		p.SetState(2643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2640)
					p.IndexOption()
				}

			}
			p.SetState(2645)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 8:
		localctx = NewAlterByAddForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2646)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2647)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2649)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(2648)

					var _x = p.Uid()

					localctx.(*AlterByAddForeignKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2653)
			p.Match(MySqlParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2654)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(2655)

				var _x = p.Uid()

				localctx.(*AlterByAddForeignKeyContext).indexName = _x
			}

		}
		{
			p.SetState(2658)
			p.IndexColumnNames()
		}
		{
			p.SetState(2659)
			p.ReferenceDefinition()
		}

	case 9:
		localctx = NewAlterByAddCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2661)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2662)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2664)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(2663)

					var _x = p.Uid()

					localctx.(*AlterByAddCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2668)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2669)
				p.Uid()
			}

		case 2:
			{
				p.SetState(2670)
				p.StringLiteral()
			}

		case 3:
			{
				p.SetState(2671)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2672)
				p.expression(0)
			}
			{
				p.SetState(2673)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(2678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(2677)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENFORCED {
			{
				p.SetState(2680)
				p.Match(MySqlParserENFORCED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 10:
		localctx = NewAlterByAlterCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2683)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2684)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2686)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(2685)

					var _x = p.Uid()

					localctx.(*AlterByAlterCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2690)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2691)
				p.Uid()
			}

		case 2:
			{
				p.SetState(2692)
				p.StringLiteral()
			}

		case 3:
			{
				p.SetState(2693)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2694)
				p.expression(0)
			}
			{
				p.SetState(2695)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(2700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(2699)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENFORCED {
			{
				p.SetState(2702)
				p.Match(MySqlParserENFORCED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewAlterByAddCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2705)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2706)
				p.Match(MySqlParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2708)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
				{
					p.SetState(2707)

					var _x = p.Uid()

					localctx.(*AlterByAddCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2712)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2713)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2714)
			p.expression(0)
		}
		{
			p.SetState(2715)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewAlterBySetAlgorithmContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2717)
			p.Match(MySqlParserALGORITHM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2718)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2721)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterBySetAlgorithmContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE || _la == MySqlParserINSTANT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterBySetAlgorithmContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 13:
		localctx = NewAlterByChangeDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2722)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2723)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2726)
			p.Uid()
		}
		p.SetState(2732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSET:
			{
				p.SetState(2727)
				p.Match(MySqlParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2728)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2729)
				p.DefaultValue()
			}

		case MySqlParserDROP:
			{
				p.SetState(2730)
				p.Match(MySqlParserDROP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2731)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 14:
		localctx = NewAlterByChangeColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2734)
			p.Match(MySqlParserCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2735)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2738)

			var _x = p.Uid()

			localctx.(*AlterByChangeColumnContext).oldColumn = _x
		}
		{
			p.SetState(2739)

			var _x = p.Uid()

			localctx.(*AlterByChangeColumnContext).newColumn = _x
		}
		{
			p.SetState(2740)
			p.ColumnDefinition()
		}
		p.SetState(2744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2741)
				p.Match(MySqlParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserAFTER:
			{
				p.SetState(2742)
				p.Match(MySqlParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2743)

				var _x = p.Uid()

				localctx.(*AlterByChangeColumnContext).afterColumn = _x
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 15:
		localctx = NewAlterByRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2746)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2747)
			p.Match(MySqlParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2748)

			var _x = p.Uid()

			localctx.(*AlterByRenameColumnContext).oldColumn = _x
		}
		{
			p.SetState(2749)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)

			var _x = p.Uid()

			localctx.(*AlterByRenameColumnContext).newColumn = _x
		}

	case 16:
		localctx = NewAlterByLockContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2752)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2753)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2756)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByLockContext).lockType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByLockContext).lockType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		localctx = NewAlterByModifyColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2757)
			p.Match(MySqlParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2758)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2761)
			p.Uid()
		}
		{
			p.SetState(2762)
			p.ColumnDefinition()
		}
		p.SetState(2766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2763)
				p.Match(MySqlParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserAFTER:
			{
				p.SetState(2764)
				p.Match(MySqlParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2765)
				p.Uid()
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 18:
		localctx = NewAlterByDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2768)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2769)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2772)
			p.Uid()
		}
		p.SetState(2774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserRESTRICT {
			{
				p.SetState(2773)
				p.Match(MySqlParserRESTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 19:
		localctx = NewAlterByDropConstraintCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2776)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2777)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHECK || _la == MySqlParserCONSTRAINT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2778)
			p.Uid()
		}

	case 20:
		localctx = NewAlterByDropPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2779)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2780)
			p.Match(MySqlParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2781)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewAlterByDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2782)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2783)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByDropIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByDropIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2784)
			p.Uid()
		}

	case 22:
		localctx = NewAlterByRenameIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2785)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2786)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByRenameIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByRenameIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2787)
			p.Uid()
		}
		{
			p.SetState(2788)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2789)
			p.Uid()
		}

	case 23:
		localctx = NewAlterByAlterColumnDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2791)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2792)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2795)
			p.Uid()
		}
		p.SetState(2809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2796)
				p.Match(MySqlParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2797)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2803)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSTART_NATIONAL_STRING_LITERAL, MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
				{
					p.SetState(2798)
					p.StringLiteral()
				}

			case MySqlParserLR_BRACKET:
				{
					p.SetState(2799)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2800)
					p.expression(0)
				}
				{
					p.SetState(2801)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case 2:
			{
				p.SetState(2805)
				p.Match(MySqlParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2806)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case 3:
			{
				p.SetState(2807)
				p.Match(MySqlParserDROP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2808)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 24:
		localctx = NewAlterByAlterIndexVisibilityContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2811)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2812)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2813)
			p.Uid()
		}
		{
			p.SetState(2814)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 25:
		localctx = NewAlterByDropForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2816)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2817)
			p.Match(MySqlParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2818)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2819)
			p.Uid()
		}

	case 26:
		localctx = NewAlterByDisableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2820)
			p.Match(MySqlParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2821)
			p.Match(MySqlParserKEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		localctx = NewAlterByEnableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2822)
			p.Match(MySqlParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2823)
			p.Match(MySqlParserKEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		localctx = NewAlterByRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2824)
			p.Match(MySqlParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS || _la == MySqlParserTO {
			{
				p.SetState(2825)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByRenameContext).renameFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserAS || _la == MySqlParserTO) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByRenameContext).renameFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2828)
				p.Uid()
			}

		case 2:
			{
				p.SetState(2829)
				p.FullId()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 29:
		localctx = NewAlterByOrderContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2832)
			p.Match(MySqlParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2833)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2834)
			p.UidList()
		}

	case 30:
		localctx = NewAlterByConvertCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2835)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2836)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCHARSET:
			{
				p.SetState(2837)
				p.Match(MySqlParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserCHARACTER:
			{
				p.SetState(2838)
				p.Match(MySqlParserCHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2839)
				p.Match(MySqlParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2842)
			p.CharsetName()
		}
		p.SetState(2845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLLATE {
			{
				p.SetState(2843)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2844)
				p.CollationName()
			}

		}

	case 31:
		localctx = NewAlterByDefaultCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		p.SetState(2848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(2847)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2850)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2851)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2852)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2853)
			p.CharsetName()
		}
		p.SetState(2857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLLATE {
			{
				p.SetState(2854)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2855)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2856)
				p.CollationName()
			}

		}

	case 32:
		localctx = NewAlterByDiscardTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2859)
			p.Match(MySqlParserDISCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2860)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		localctx = NewAlterByImportTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2861)
			p.Match(MySqlParserIMPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2862)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		localctx = NewAlterByForceContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2863)
			p.Match(MySqlParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		localctx = NewAlterByValidateContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2864)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByValidateContext).validationFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserWITH || _la == MySqlParserWITHOUT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByValidateContext).validationFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2865)
			p.Match(MySqlParserVALIDATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		localctx = NewAlterByAddDefinitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2866)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2867)
				p.Match(MySqlParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2870)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2871)
			p.CreateDefinition()
		}
		p.SetState(2876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2872)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2873)
				p.CreateDefinition()
			}

			p.SetState(2878)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2879)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		localctx = NewAlterPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2881)
			p.AlterPartitionSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPartitionSpecificationContext is an interface to support dynamic dispatch.
type IAlterPartitionSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterPartitionSpecificationContext differentiates from other interfaces.
	IsAlterPartitionSpecificationContext()
}

type AlterPartitionSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPartitionSpecificationContext() *AlterPartitionSpecificationContext {
	var p = new(AlterPartitionSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterPartitionSpecification
	return p
}

func InitEmptyAlterPartitionSpecificationContext(p *AlterPartitionSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterPartitionSpecification
}

func (*AlterPartitionSpecificationContext) IsAlterPartitionSpecificationContext() {}

func NewAlterPartitionSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPartitionSpecificationContext {
	var p = new(AlterPartitionSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterPartitionSpecification

	return p
}

func (s *AlterPartitionSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPartitionSpecificationContext) CopyAll(ctx *AlterPartitionSpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterPartitionSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPartitionSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterByImportPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByImportPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportPartitionContext {
	var p = new(AlterByImportPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByImportPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportPartitionContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *AlterByImportPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByImportPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByImportPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByImportPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByImportPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByImportPartition(s)
	}
}

func (s *AlterByImportPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByImportPartition(s)
	}
}

func (s *AlterByImportPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByImportPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDropPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByDropPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPartitionContext {
	var p = new(AlterByDropPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByDropPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPartitionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByDropPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByDropPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropPartition(s)
	}
}

func (s *AlterByDropPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropPartition(s)
	}
}

func (s *AlterByDropPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDropPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByDiscardPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByDiscardPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardPartitionContext {
	var p = new(AlterByDiscardPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByDiscardPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardPartitionContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *AlterByDiscardPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByDiscardPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByDiscardPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByDiscardPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByDiscardPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDiscardPartition(s)
	}
}

func (s *AlterByDiscardPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDiscardPartition(s)
	}
}

func (s *AlterByDiscardPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByDiscardPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAddPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByAddPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPartitionContext {
	var p = new(AlterByAddPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByAddPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPartitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByAddPartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByAddPartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddPartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByAddPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddPartition(s)
	}
}

func (s *AlterByAddPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddPartition(s)
	}
}

func (s *AlterByAddPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAddPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRemovePartitioningContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByRemovePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRemovePartitioningContext {
	var p = new(AlterByRemovePartitioningContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByRemovePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRemovePartitioningContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREMOVE, 0)
}

func (s *AlterByRemovePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *AlterByRemovePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRemovePartitioning(s)
	}
}

func (s *AlterByRemovePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRemovePartitioning(s)
	}
}

func (s *AlterByRemovePartitioningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRemovePartitioning(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByOptimizePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByOptimizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOptimizePartitionContext {
	var p = new(AlterByOptimizePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByOptimizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOptimizePartitionContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZE, 0)
}

func (s *AlterByOptimizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByOptimizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByOptimizePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByOptimizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByOptimizePartition(s)
	}
}

func (s *AlterByOptimizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByOptimizePartition(s)
	}
}

func (s *AlterByOptimizePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByOptimizePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByCheckPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByCheckPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCheckPartitionContext {
	var p = new(AlterByCheckPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByCheckPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCheckPartitionContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByCheckPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByCheckPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByCheckPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByCheckPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByCheckPartition(s)
	}
}

func (s *AlterByCheckPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByCheckPartition(s)
	}
}

func (s *AlterByCheckPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByCheckPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByCoalescePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByCoalescePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCoalescePartitionContext {
	var p = new(AlterByCoalescePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByCoalescePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCoalescePartitionContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOALESCE, 0)
}

func (s *AlterByCoalescePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByCoalescePartitionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AlterByCoalescePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByCoalescePartition(s)
	}
}

func (s *AlterByCoalescePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByCoalescePartition(s)
	}
}

func (s *AlterByCoalescePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByCoalescePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByReorganizePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByReorganizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByReorganizePartitionContext {
	var p = new(AlterByReorganizePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByReorganizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByReorganizePartitionContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREORGANIZE, 0)
}

func (s *AlterByReorganizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByReorganizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByReorganizePartitionContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *AlterByReorganizePartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByReorganizePartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByReorganizePartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByReorganizePartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByReorganizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByReorganizePartition(s)
	}
}

func (s *AlterByReorganizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByReorganizePartition(s)
	}
}

func (s *AlterByReorganizePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByReorganizePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByAnalyzePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByAnalyzePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAnalyzePartitionContext {
	var p = new(AlterByAnalyzePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByAnalyzePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAnalyzePartitionContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserANALYZE, 0)
}

func (s *AlterByAnalyzePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByAnalyzePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByAnalyzePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByAnalyzePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAnalyzePartition(s)
	}
}

func (s *AlterByAnalyzePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAnalyzePartition(s)
	}
}

func (s *AlterByAnalyzePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByAnalyzePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRebuildPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByRebuildPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRebuildPartitionContext {
	var p = new(AlterByRebuildPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByRebuildPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRebuildPartitionContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MySqlParserREBUILD, 0)
}

func (s *AlterByRebuildPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByRebuildPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRebuildPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByRebuildPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRebuildPartition(s)
	}
}

func (s *AlterByRebuildPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRebuildPartition(s)
	}
}

func (s *AlterByRebuildPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRebuildPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByUpgradePartitioningContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByUpgradePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByUpgradePartitioningContext {
	var p = new(AlterByUpgradePartitioningContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByUpgradePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByUpgradePartitioningContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *AlterByUpgradePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *AlterByUpgradePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByUpgradePartitioning(s)
	}
}

func (s *AlterByUpgradePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByUpgradePartitioning(s)
	}
}

func (s *AlterByUpgradePartitioningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByUpgradePartitioning(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByTruncatePartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByTruncatePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTruncatePartitionContext {
	var p = new(AlterByTruncatePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByTruncatePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTruncatePartitionContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *AlterByTruncatePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByTruncatePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByTruncatePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByTruncatePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByTruncatePartition(s)
	}
}

func (s *AlterByTruncatePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByTruncatePartition(s)
	}
}

func (s *AlterByTruncatePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByTruncatePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByRepairPartitionContext struct {
	AlterPartitionSpecificationContext
}

func NewAlterByRepairPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRepairPartitionContext {
	var p = new(AlterByRepairPartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByRepairPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRepairPartitionContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *AlterByRepairPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByRepairPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRepairPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByRepairPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRepairPartition(s)
	}
}

func (s *AlterByRepairPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRepairPartition(s)
	}
}

func (s *AlterByRepairPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByRepairPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterByExchangePartitionContext struct {
	AlterPartitionSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByExchangePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByExchangePartitionContext {
	var p = new(AlterByExchangePartitionContext)

	InitEmptyAlterPartitionSpecificationContext(&p.AlterPartitionSpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterPartitionSpecificationContext))

	return p
}

func (s *AlterByExchangePartitionContext) GetValidationFormat() antlr.Token {
	return s.validationFormat
}

func (s *AlterByExchangePartitionContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByExchangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByExchangePartitionContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCHANGE, 0)
}

func (s *AlterByExchangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByExchangePartitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByExchangePartitionContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWITH)
}

func (s *AlterByExchangePartitionContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, i)
}

func (s *AlterByExchangePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AlterByExchangePartitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterByExchangePartitionContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *AlterByExchangePartitionContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *AlterByExchangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByExchangePartition(s)
	}
}

func (s *AlterByExchangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByExchangePartition(s)
	}
}

func (s *AlterByExchangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterByExchangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterPartitionSpecification() (localctx IAlterPartitionSpecificationContext) {
	localctx = NewAlterPartitionSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MySqlParserRULE_alterPartitionSpecification)
	var _la int

	p.SetState(2982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserADD:
		localctx = NewAlterByAddPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2884)
			p.Match(MySqlParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2885)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2886)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2887)
			p.PartitionDefinition()
		}
		p.SetState(2892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2888)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2889)
				p.PartitionDefinition()
			}

			p.SetState(2894)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2895)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDROP:
		localctx = NewAlterByDropPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2897)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2898)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2899)
			p.UidList()
		}

	case MySqlParserDISCARD:
		localctx = NewAlterByDiscardPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2900)
			p.Match(MySqlParserDISCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2901)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2902)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2903)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2906)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserIMPORT:
		localctx = NewAlterByImportPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2907)
			p.Match(MySqlParserIMPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2908)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2909)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2910)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2913)
			p.Match(MySqlParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserTRUNCATE:
		localctx = NewAlterByTruncatePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2914)
			p.Match(MySqlParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2915)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2916)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2917)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserCOALESCE:
		localctx = NewAlterByCoalescePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2920)
			p.Match(MySqlParserCOALESCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2921)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2922)
			p.DecimalLiteral()
		}

	case MySqlParserREORGANIZE:
		localctx = NewAlterByReorganizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2923)
			p.Match(MySqlParserREORGANIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2924)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2925)
			p.UidList()
		}
		{
			p.SetState(2926)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2927)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2928)
			p.PartitionDefinition()
		}
		p.SetState(2933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2929)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2930)
				p.PartitionDefinition()
			}

			p.SetState(2935)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2936)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserEXCHANGE:
		localctx = NewAlterByExchangePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2938)
			p.Match(MySqlParserEXCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2939)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2940)
			p.Uid()
		}
		{
			p.SetState(2941)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2942)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2943)
			p.TableName()
		}
		p.SetState(2946)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2944)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByExchangePartitionContext).validationFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserWITH || _la == MySqlParserWITHOUT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByExchangePartitionContext).validationFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2945)
				p.Match(MySqlParserVALIDATION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserANALYZE:
		localctx = NewAlterByAnalyzePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2948)
			p.Match(MySqlParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2949)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2952)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2950)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2951)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserCHECK:
		localctx = NewAlterByCheckPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2954)
			p.Match(MySqlParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2955)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2956)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2957)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserOPTIMIZE:
		localctx = NewAlterByOptimizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2960)
			p.Match(MySqlParserOPTIMIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2961)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2962)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2963)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserREBUILD:
		localctx = NewAlterByRebuildPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2966)
			p.Match(MySqlParserREBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2967)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2968)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2969)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserREPAIR:
		localctx = NewAlterByRepairPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2972)
			p.Match(MySqlParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2973)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(2974)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2975)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserREMOVE:
		localctx = NewAlterByRemovePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2978)
			p.Match(MySqlParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2979)
			p.Match(MySqlParserPARTITIONING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserUPGRADE:
		localctx = NewAlterByUpgradePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2980)
			p.Match(MySqlParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.Match(MySqlParserPARTITIONING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token

	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropDatabase
	return p
}

func InitEmptyDropDatabaseContext(p *DropDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropDatabase
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *DropDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *DropDatabaseContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (s *DropDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropDatabase() (localctx IDropDatabaseContext) {
	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MySqlParserRULE_dropDatabase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2984)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2985)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DropDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DropDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2987)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2986)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2989)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropEventContext is an interface to support dynamic dispatch.
type IDropEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropEventContext differentiates from other interfaces.
	IsDropEventContext()
}

type DropEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropEventContext() *DropEventContext {
	var p = new(DropEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropEvent
	return p
}

func InitEmptyDropEventContext(p *DropEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropEvent
}

func (*DropEventContext) IsDropEventContext() {}

func NewDropEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropEventContext {
	var p = new(DropEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropEvent

	return p
}

func (s *DropEventContext) GetParser() antlr.Parser { return s.parser }

func (s *DropEventContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *DropEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropEventContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropEvent(s)
	}
}

func (s *DropEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropEvent(s)
	}
}

func (s *DropEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropEvent() (localctx IDropEventContext) {
	localctx = NewDropEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MySqlParserRULE_dropEvent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2991)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2992)
		p.Match(MySqlParserEVENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2994)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2993)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2996)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	intimeAction antlr.Token
	algType      antlr.Token
	lockType     antlr.Token
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropIndex
	return p
}

func InitEmptyDropIndexContext(p *DropIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropIndex
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *DropIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *DropIndexContext) GetLockType() antlr.Token { return s.lockType }

func (s *DropIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *DropIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *DropIndexContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *DropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DropIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DropIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserALGORITHM)
}

func (s *DropIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, i)
}

func (s *DropIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCK)
}

func (s *DropIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, i)
}

func (s *DropIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *DropIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *DropIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *DropIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *DropIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserINPLACE)
}

func (s *DropIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, i)
}

func (s *DropIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOPY)
}

func (s *DropIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, i)
}

func (s *DropIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNONE)
}

func (s *DropIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, i)
}

func (s *DropIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSHARED)
}

func (s *DropIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, i)
}

func (s *DropIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEXCLUSIVE)
}

func (s *DropIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, i)
}

func (s *DropIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *DropIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (s *DropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropIndex() (localctx IDropIndexContext) {
	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MySqlParserRULE_dropIndex)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2998)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2999)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3001)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3000)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3003)
		p.Uid()
	}
	{
		p.SetState(3004)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3005)
		p.TableName()
	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3016)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALGORITHM:
				{
					p.SetState(3006)
					p.Match(MySqlParserALGORITHM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3008)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(3007)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3010)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case MySqlParserLOCK:
				{
					p.SetState(3011)
					p.Match(MySqlParserLOCK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3013)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(3012)
						p.Match(MySqlParserEQUAL_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3015)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(3020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropLogfileGroupContext is an interface to support dynamic dispatch.
type IDropLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EngineName() IEngineNameContext

	// IsDropLogfileGroupContext differentiates from other interfaces.
	IsDropLogfileGroupContext()
}

type DropLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropLogfileGroupContext() *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup
	return p
}

func InitEmptyDropLogfileGroupContext(p *DropLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup
}

func (*DropLogfileGroupContext) IsDropLogfileGroupContext() {}

func NewDropLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup

	return p
}

func (s *DropLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DropLogfileGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *DropLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *DropLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *DropLogfileGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DropLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropLogfileGroup() (localctx IDropLogfileGroupContext) {
	localctx = NewDropLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MySqlParserRULE_dropLogfileGroup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3021)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3022)
		p.Match(MySqlParserLOGFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3023)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3024)
		p.Uid()
	}
	{
		p.SetState(3025)
		p.Match(MySqlParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3026)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3027)
		p.EngineName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropProcedureContext is an interface to support dynamic dispatch.
type IDropProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropProcedureContext differentiates from other interfaces.
	IsDropProcedureContext()
}

type DropProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropProcedureContext() *DropProcedureContext {
	var p = new(DropProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropProcedure
	return p
}

func InitEmptyDropProcedureContext(p *DropProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropProcedure
}

func (*DropProcedureContext) IsDropProcedureContext() {}

func NewDropProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropProcedureContext {
	var p = new(DropProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropProcedure

	return p
}

func (s *DropProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *DropProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropProcedureContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (s *DropProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropProcedure() (localctx IDropProcedureContext) {
	localctx = NewDropProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MySqlParserRULE_dropProcedure)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3029)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3030)
		p.Match(MySqlParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3032)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3031)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3034)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropFunction
	return p
}

func InitEmptyDropFunctionContext(p *DropFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropFunction
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *DropFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropFunctionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropFunction() (localctx IDropFunctionContext) {
	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MySqlParserRULE_dropFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3036)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3037)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3039)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3038)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3041)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropServerContext is an interface to support dynamic dispatch.
type IDropServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	IfExists() IIfExistsContext

	// IsDropServerContext differentiates from other interfaces.
	IsDropServerContext()
}

type DropServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropServerContext() *DropServerContext {
	var p = new(DropServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropServer
	return p
}

func InitEmptyDropServerContext(p *DropServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropServer
}

func (*DropServerContext) IsDropServerContext() {}

func NewDropServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropServerContext {
	var p = new(DropServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropServer

	return p
}

func (s *DropServerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropServerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *DropServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropServerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropServer(s)
	}
}

func (s *DropServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropServer(s)
	}
}

func (s *DropServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropServer() (localctx IDropServerContext) {
	localctx = NewDropServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MySqlParserRULE_dropServer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3043)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3044)
		p.Match(MySqlParserSERVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3046)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 391, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3045)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3048)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token

	// SetDropType sets the dropType token.
	SetDropType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	TEMPORARY() antlr.TerminalNode
	IfExists() IIfExistsContext
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTable
	return p
}

func InitEmptyDropTableContext(p *DropTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTable
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) GetDropType() antlr.Token { return s.dropType }

func (s *DropTableContext) SetDropType(v antlr.Token) { s.dropType = v }

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *DropTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DropTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *DropTableContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *DropTableContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropTable() (localctx IDropTableContext) {
	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, MySqlParserRULE_dropTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3050)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserTEMPORARY {
		{
			p.SetState(3051)
			p.Match(MySqlParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3054)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3055)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3058)
		p.Tables()
	}
	p.SetState(3060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCASCADE || _la == MySqlParserRESTRICT {
		{
			p.SetState(3059)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropTableContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCASCADE || _la == MySqlParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropTableContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTablespaceContext is an interface to support dynamic dispatch.
type IDropTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	EQUAL_SYMBOL() antlr.TerminalNode

	// IsDropTablespaceContext differentiates from other interfaces.
	IsDropTablespaceContext()
}

type DropTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTablespaceContext() *DropTablespaceContext {
	var p = new(DropTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTablespace
	return p
}

func InitEmptyDropTablespaceContext(p *DropTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTablespace
}

func (*DropTablespaceContext) IsDropTablespaceContext() {}

func NewDropTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTablespaceContext {
	var p = new(DropTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTablespace

	return p
}

func (s *DropTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *DropTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *DropTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DropTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTablespace(s)
	}
}

func (s *DropTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTablespace(s)
	}
}

func (s *DropTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropTablespace() (localctx IDropTablespaceContext) {
	localctx = NewDropTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MySqlParserRULE_dropTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3062)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3063)
		p.Match(MySqlParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3064)
		p.Uid()
	}
	p.SetState(3070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserENGINE {
		{
			p.SetState(3065)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(3066)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3069)
			p.EngineName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTrigger
	return p
}

func InitEmptyDropTriggerContext(p *DropTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTrigger
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *DropTriggerContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropTriggerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (s *DropTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropTrigger() (localctx IDropTriggerContext) {
	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MySqlParserRULE_dropTrigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3072)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3073)
		p.Match(MySqlParserTRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3075)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 397, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3074)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3077)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token

	// SetDropType sets the dropType token.
	SetDropType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropView
	return p
}

func InitEmptyDropViewContext(p *DropViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropView
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) GetDropType() antlr.Token { return s.dropType }

func (s *DropViewContext) SetDropType(v antlr.Token) { s.dropType = v }

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *DropViewContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *DropViewContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropViewContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropViewContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *DropViewContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropView() (localctx IDropViewContext) {
	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MySqlParserRULE_dropView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3079)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3080)
		p.Match(MySqlParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3082)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3081)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3084)
		p.FullId()
	}
	p.SetState(3089)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3085)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3086)
			p.FullId()
		}

		p.SetState(3091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCASCADE || _la == MySqlParserRESTRICT {
		{
			p.SetState(3092)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropViewContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCASCADE || _la == MySqlParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropViewContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropRole
	return p
}

func InitEmptyDropRoleContext(p *DropRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropRole
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *DropRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *DropRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *DropRoleContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropRole() (localctx IDropRoleContext) {
	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, MySqlParserRULE_dropRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3095)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3096)
		p.Match(MySqlParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3098)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3097)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3100)
		p.RoleName()
	}
	p.SetState(3105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3101)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3102)
			p.RoleName()
		}

		p.SetState(3107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleContext is an interface to support dynamic dispatch.
type ISetRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RoleOption() IRoleOptionContext

	// IsSetRoleContext differentiates from other interfaces.
	IsSetRoleContext()
}

type SetRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleContext() *SetRoleContext {
	var p = new(SetRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setRole
	return p
}

func InitEmptySetRoleContext(p *SetRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setRole
}

func (*SetRoleContext) IsSetRoleContext() {}

func NewSetRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleContext {
	var p = new(SetRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setRole

	return p
}

func (s *SetRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetRoleContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *SetRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *SetRoleContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *SetRoleContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SetRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *SetRoleContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetRoleContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SetRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetRoleContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SetRole() (localctx ISetRoleContext) {
	localctx = NewSetRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MySqlParserRULE_setRole)
	var _la int

	p.SetState(3141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 408, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3108)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3109)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3110)
			p.Match(MySqlParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 404, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3111)
				p.Match(MySqlParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3112)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(3113)
				p.RoleName()
			}
			p.SetState(3118)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(3114)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3115)
					p.RoleName()
				}

				p.SetState(3120)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3123)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3124)
				p.UserName()
			}

		case 2:
			{
				p.SetState(3125)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3128)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3131)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3129)
					p.UserName()
				}

			case 2:
				{
					p.SetState(3130)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(3137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3138)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3139)
			p.Match(MySqlParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3140)
			p.RoleOption()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameTableContext is an interface to support dynamic dispatch.
type IRenameTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllRenameTableClause() []IRenameTableClauseContext
	RenameTableClause(i int) IRenameTableClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameTableContext differentiates from other interfaces.
	IsRenameTableContext()
}

type RenameTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableContext() *RenameTableContext {
	var p = new(RenameTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTable
	return p
}

func InitEmptyRenameTableContext(p *RenameTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTable
}

func (*RenameTableContext) IsRenameTableContext() {}

func NewRenameTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableContext {
	var p = new(RenameTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameTable

	return p
}

func (s *RenameTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *RenameTableContext) AllRenameTableClause() []IRenameTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameTableClauseContext); ok {
			tst[i] = t.(IRenameTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableContext) RenameTableClause(i int) IRenameTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableClauseContext)
}

func (s *RenameTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RenameTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

func (s *RenameTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RenameTable() (localctx IRenameTableContext) {
	localctx = NewRenameTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MySqlParserRULE_renameTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3143)
		p.Match(MySqlParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3144)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3145)
		p.RenameTableClause()
	}
	p.SetState(3150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3146)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3147)
			p.RenameTableClause()
		}

		p.SetState(3152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameTableClauseContext is an interface to support dynamic dispatch.
type IRenameTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	TO() antlr.TerminalNode

	// IsRenameTableClauseContext differentiates from other interfaces.
	IsRenameTableClauseContext()
}

type RenameTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableClauseContext() *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTableClause
	return p
}

func InitEmptyRenameTableClauseContext(p *RenameTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTableClause
}

func (*RenameTableClauseContext) IsRenameTableClauseContext() {}

func NewRenameTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameTableClause

	return p
}

func (s *RenameTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableClauseContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableClauseContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *RenameTableClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RenameTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameTableClause(s)
	}
}

func (s *RenameTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameTableClause(s)
	}
}

func (s *RenameTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RenameTableClause() (localctx IRenameTableClauseContext) {
	localctx = NewRenameTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MySqlParserRULE_renameTableClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		p.TableName()
	}
	{
		p.SetState(3154)
		p.Match(MySqlParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3155)
		p.TableName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateTableContext is an interface to support dynamic dispatch.
type ITruncateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TableName() ITableNameContext
	TABLE() antlr.TerminalNode

	// IsTruncateTableContext differentiates from other interfaces.
	IsTruncateTableContext()
}

type TruncateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableContext() *TruncateTableContext {
	var p = new(TruncateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_truncateTable
	return p
}

func InitEmptyTruncateTableContext(p *TruncateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_truncateTable
}

func (*TruncateTableContext) IsTruncateTableContext() {}

func NewTruncateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableContext {
	var p = new(TruncateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_truncateTable

	return p
}

func (s *TruncateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (s *TruncateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTruncateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TruncateTable() (localctx ITruncateTableContext) {
	localctx = NewTruncateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MySqlParserRULE_truncateTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3157)
		p.Match(MySqlParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserTABLE {
		{
			p.SetState(3158)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3161)
		p.TableName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	Expressions() IExpressionsContext

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_callStatement
	return p
}

func InitEmptyCallStatementContext(p *CallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_callStatement
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCALL, 0)
}

func (s *CallStatementContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CallStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CallStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CallStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *CallStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (s *CallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CallStatement() (localctx ICallStatementContext) {
	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MySqlParserRULE_callStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3163)
		p.Match(MySqlParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3164)
		p.FullId()
	}
	p.SetState(3171)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 412, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3165)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3168)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3166)
				p.Constants()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3167)
				p.Expressions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3170)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleDeleteStatement() ISingleDeleteStatementContext
	MultipleDeleteStatement() IMultipleDeleteStatementContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) SingleDeleteStatement() ISingleDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleDeleteStatementContext)
}

func (s *DeleteStatementContext) MultipleDeleteStatement() IMultipleDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleDeleteStatementContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MySqlParserRULE_deleteStatement)
	p.SetState(3175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3173)
			p.SingleDeleteStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3174)
			p.MultipleDeleteStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Expressions() IExpressionsContext

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_doStatement
	return p
}

func InitEmptyDoStatementContext(p *DoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_doStatement
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *DoStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DoStatement() (localctx IDoStatementContext) {
	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MySqlParserRULE_doStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3177)
		p.Match(MySqlParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3178)
		p.Expressions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerStatementContext is an interface to support dynamic dispatch.
type IHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HandlerOpenStatement() IHandlerOpenStatementContext
	HandlerReadIndexStatement() IHandlerReadIndexStatementContext
	HandlerReadStatement() IHandlerReadStatementContext
	HandlerCloseStatement() IHandlerCloseStatementContext

	// IsHandlerStatementContext differentiates from other interfaces.
	IsHandlerStatementContext()
}

type HandlerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerStatementContext() *HandlerStatementContext {
	var p = new(HandlerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerStatement
	return p
}

func InitEmptyHandlerStatementContext(p *HandlerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerStatement
}

func (*HandlerStatementContext) IsHandlerStatementContext() {}

func NewHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerStatementContext {
	var p = new(HandlerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerStatement

	return p
}

func (s *HandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerStatementContext) HandlerOpenStatement() IHandlerOpenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerOpenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerOpenStatementContext)
}

func (s *HandlerStatementContext) HandlerReadIndexStatement() IHandlerReadIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadIndexStatementContext)
}

func (s *HandlerStatementContext) HandlerReadStatement() IHandlerReadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadStatementContext)
}

func (s *HandlerStatementContext) HandlerCloseStatement() IHandlerCloseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerCloseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerCloseStatementContext)
}

func (s *HandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HandlerStatement() (localctx IHandlerStatementContext) {
	localctx = NewHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MySqlParserRULE_handlerStatement)
	p.SetState(3184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3180)
			p.HandlerOpenStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3181)
			p.HandlerReadIndexStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3182)
			p.HandlerReadStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3183)
			p.HandlerCloseStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IFullColumnNameListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext

	// GetDuplicatedFirst returns the duplicatedFirst rule contexts.
	GetDuplicatedFirst() IUpdatedElementContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IFullColumnNameListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)

	// SetDuplicatedFirst sets the duplicatedFirst rule contexts.
	SetDuplicatedFirst(IUpdatedElementContext)

	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext

	// GetDuplicatedElements returns the duplicatedElements rule context list.
	GetDuplicatedElements() []IUpdatedElementContext

	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext)

	// SetDuplicatedElements sets the duplicatedElements rule context list.
	SetDuplicatedElements([]IUpdatedElementContext)

	// Getter signatures
	INSERT() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	IGNORE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	ON() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	UidList() IUidListContext
	AS() antlr.TerminalNode
	FullColumnNameList() IFullColumnNameListContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	priority           antlr.Token
	partitions         IUidListContext
	columns            IFullColumnNameListContext
	setFirst           IUpdatedElementContext
	_updatedElement    IUpdatedElementContext
	setElements        []IUpdatedElementContext
	duplicatedFirst    IUpdatedElementContext
	duplicatedElements []IUpdatedElementContext
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *InsertStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *InsertStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *InsertStatementContext) GetColumns() IFullColumnNameListContext { return s.columns }

func (s *InsertStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *InsertStatementContext) Get_updatedElement() IUpdatedElementContext {
	return s._updatedElement
}

func (s *InsertStatementContext) GetDuplicatedFirst() IUpdatedElementContext {
	return s.duplicatedFirst
}

func (s *InsertStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *InsertStatementContext) SetColumns(v IFullColumnNameListContext) { s.columns = v }

func (s *InsertStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *InsertStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }

func (s *InsertStatementContext) SetDuplicatedFirst(v IUpdatedElementContext) { s.duplicatedFirst = v }

func (s *InsertStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }

func (s *InsertStatementContext) GetDuplicatedElements() []IUpdatedElementContext {
	return s.duplicatedElements
}

func (s *InsertStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }

func (s *InsertStatementContext) SetDuplicatedElements(v []IUpdatedElementContext) {
	s.duplicatedElements = v
}

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *InsertStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *InsertStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *InsertStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *InsertStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *InsertStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *InsertStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *InsertStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *InsertStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *InsertStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *InsertStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *InsertStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *InsertStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *InsertStatementContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUPLICATE, 0)
}

func (s *InsertStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *InsertStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *InsertStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *InsertStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAYED, 0)
}

func (s *InsertStatementContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *InsertStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *InsertStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *InsertStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *InsertStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *InsertStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *InsertStatementContext) FullColumnNameList() IFullColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameListContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MySqlParserRULE_insertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3186)
		p.Match(MySqlParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(3187)
			p.ProxyHint()
		}

	}
	p.SetState(3191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-42)) & ^0x3f) == 0 && ((int64(1)<<(_la-42))&-9223372032559808511) != 0 {
		{
			p.SetState(3190)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-42)) & ^0x3f) == 0 && ((int64(1)<<(_la-42))&-9223372032559808511) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3193)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINTO {
		{
			p.SetState(3196)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3199)
		p.TableName()
	}
	p.SetState(3206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3200)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3201)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(3202)

				var _x = p.UidList()

				localctx.(*InsertStatementContext).partitions = _x
			}

		}
		{
			p.SetState(3205)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserVALUES, MySqlParserVALUE, MySqlParserLR_BRACKET:
		p.SetState(3213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3208)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3210)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3209)

					var _x = p.FullColumnNameList()

					localctx.(*InsertStatementContext).columns = _x
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3212)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3215)
			p.InsertStatementValue()
		}
		p.SetState(3220)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) == 1 {
			p.SetState(3217)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(3216)
					p.Match(MySqlParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3219)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserSET:
		{
			p.SetState(3222)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3223)

			var _x = p.UpdatedElement()

			localctx.(*InsertStatementContext).setFirst = _x
		}
		p.SetState(3228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3224)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3225)

				var _x = p.UpdatedElement()

				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).setElements = append(localctx.(*InsertStatementContext).setElements, localctx.(*InsertStatementContext)._updatedElement)

			p.SetState(3230)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserON {
		{
			p.SetState(3233)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3234)
			p.Match(MySqlParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3235)
			p.Match(MySqlParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3236)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3237)

			var _x = p.UpdatedElement()

			localctx.(*InsertStatementContext).duplicatedFirst = _x
		}
		p.SetState(3242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3238)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3239)

				var _x = p.UpdatedElement()

				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).duplicatedElements = append(localctx.(*InsertStatementContext).duplicatedElements, localctx.(*InsertStatementContext)._updatedElement)

			p.SetState(3244)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadDataStatementContext is an interface to support dynamic dispatch.
type ILoadDataStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// GetFilename returns the filename token.
	GetFilename() antlr.Token

	// GetViolation returns the violation token.
	GetViolation() antlr.Token

	// GetFieldsFormat returns the fieldsFormat token.
	GetFieldsFormat() antlr.Token

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// SetFilename sets the filename token.
	SetFilename(antlr.Token)

	// SetViolation sets the violation token.
	SetViolation(antlr.Token)

	// SetFieldsFormat sets the fieldsFormat token.
	SetFieldsFormat(antlr.Token)

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token)

	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext

	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	STRING_LITERAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	UidList() IUidListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllLINES() []antlr.TerminalNode
	LINES(i int) antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	AllSelectFieldsInto() []ISelectFieldsIntoContext
	SelectFieldsInto(i int) ISelectFieldsIntoContext
	AllSelectLinesInto() []ISelectLinesIntoContext
	SelectLinesInto(i int) ISelectLinesIntoContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadDataStatementContext differentiates from other interfaces.
	IsLoadDataStatementContext()
}

type LoadDataStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	priority     antlr.Token
	filename     antlr.Token
	violation    antlr.Token
	charset      ICharsetNameContext
	fieldsFormat antlr.Token
	linesFormat  antlr.Token
}

func NewEmptyLoadDataStatementContext() *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadDataStatement
	return p
}

func InitEmptyLoadDataStatementContext(p *LoadDataStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadDataStatement
}

func (*LoadDataStatementContext) IsLoadDataStatementContext() {}

func NewLoadDataStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadDataStatement

	return p
}

func (s *LoadDataStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadDataStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadDataStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadDataStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadDataStatementContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *LoadDataStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }

func (s *LoadDataStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadDataStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadDataStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadDataStatementContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *LoadDataStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }

func (s *LoadDataStatementContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *LoadDataStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *LoadDataStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadDataStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *LoadDataStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINFILE, 0)
}

func (s *LoadDataStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadDataStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LoadDataStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadDataStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *LoadDataStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LoadDataStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *LoadDataStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *LoadDataStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *LoadDataStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadDataStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *LoadDataStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *LoadDataStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *LoadDataStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSET)
}

func (s *LoadDataStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, i)
}

func (s *LoadDataStatementContext) AllLINES() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLINES)
}

func (s *LoadDataStatementContext) LINES(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, i)
}

func (s *LoadDataStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIGNORE)
}

func (s *LoadDataStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, i)
}

func (s *LoadDataStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadDataStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadDataStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadDataStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadDataStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LoadDataStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *LoadDataStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *LoadDataStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *LoadDataStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *LoadDataStatementContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *LoadDataStatementContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *LoadDataStatementContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *LoadDataStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadDataStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadDataStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadDataStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadDataStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadDataStatement(s)
	}
}

func (s *LoadDataStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadDataStatement(s)
	}
}

func (s *LoadDataStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadDataStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LoadDataStatement() (localctx ILoadDataStatementContext) {
	localctx = NewLoadDataStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MySqlParserRULE_loadDataStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3247)
		p.Match(MySqlParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3248)
		p.Match(MySqlParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT {
		{
			p.SetState(3249)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOCAL {
		{
			p.SetState(3252)
			p.Match(MySqlParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3255)
		p.Match(MySqlParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3256)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*LoadDataStatementContext).filename = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
		{
			p.SetState(3257)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3260)
		p.Match(MySqlParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3261)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3262)
		p.TableName()
	}
	p.SetState(3268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3263)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3264)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3265)
			p.UidList()
		}
		{
			p.SetState(3266)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCHARACTER {
		{
			p.SetState(3270)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3271)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3272)

			var _x = p.CharsetName()

			localctx.(*LoadDataStatementContext).charset = _x
		}

	}
	p.SetState(3281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS {
		{
			p.SetState(3275)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).fieldsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).fieldsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserENCLOSED || _la == MySqlParserESCAPED || _la == MySqlParserOPTIONALLY || _la == MySqlParserTERMINATED {
			{
				p.SetState(3276)
				p.SelectFieldsInto()
			}

			p.SetState(3279)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLINES {
		{
			p.SetState(3283)
			p.Match(MySqlParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserSTARTING || _la == MySqlParserTERMINATED {
			{
				p.SetState(3284)
				p.SelectLinesInto()
			}

			p.SetState(3287)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3291)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3292)
			p.DecimalLiteral()
		}
		{
			p.SetState(3293)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLINES || _la == MySqlParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3308)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3297)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3298)
			p.AssignmentField()
		}
		p.SetState(3303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3299)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3300)
				p.AssignmentField()
			}

			p.SetState(3305)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3306)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3319)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 442, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3310)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3311)
			p.UpdatedElement()
		}
		p.SetState(3316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3312)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3313)
				p.UpdatedElement()
			}

			p.SetState(3318)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadXmlStatementContext is an interface to support dynamic dispatch.
type ILoadXmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// GetFilename returns the filename token.
	GetFilename() antlr.Token

	// GetViolation returns the violation token.
	GetViolation() antlr.Token

	// GetTag returns the tag token.
	GetTag() antlr.Token

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// SetFilename sets the filename token.
	SetFilename(antlr.Token)

	// SetViolation sets the violation token.
	SetViolation(antlr.Token)

	// SetTag sets the tag token.
	SetTag(antlr.Token)

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token)

	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext

	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	XML() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllROWS() []antlr.TerminalNode
	ROWS(i int) antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	LR_BRACKET() antlr.TerminalNode
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	RR_BRACKET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadXmlStatementContext differentiates from other interfaces.
	IsLoadXmlStatementContext()
}

type LoadXmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	priority    antlr.Token
	filename    antlr.Token
	violation   antlr.Token
	charset     ICharsetNameContext
	tag         antlr.Token
	linesFormat antlr.Token
}

func NewEmptyLoadXmlStatementContext() *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadXmlStatement
	return p
}

func InitEmptyLoadXmlStatementContext(p *LoadXmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadXmlStatement
}

func (*LoadXmlStatementContext) IsLoadXmlStatementContext() {}

func NewLoadXmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadXmlStatement

	return p
}

func (s *LoadXmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadXmlStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadXmlStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadXmlStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadXmlStatementContext) GetTag() antlr.Token { return s.tag }

func (s *LoadXmlStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }

func (s *LoadXmlStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadXmlStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadXmlStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadXmlStatementContext) SetTag(v antlr.Token) { s.tag = v }

func (s *LoadXmlStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }

func (s *LoadXmlStatementContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *LoadXmlStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *LoadXmlStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadXmlStatementContext) XML() antlr.TerminalNode {
	return s.GetToken(MySqlParserXML, 0)
}

func (s *LoadXmlStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINFILE, 0)
}

func (s *LoadXmlStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadXmlStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LoadXmlStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadXmlStatementContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *LoadXmlStatementContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *LoadXmlStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LoadXmlStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *LoadXmlStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSET)
}

func (s *LoadXmlStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, i)
}

func (s *LoadXmlStatementContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserROWS)
}

func (s *LoadXmlStatementContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, i)
}

func (s *LoadXmlStatementContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *LoadXmlStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *LoadXmlStatementContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIGNORE)
}

func (s *LoadXmlStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, i)
}

func (s *LoadXmlStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadXmlStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadXmlStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadXmlStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadXmlStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LoadXmlStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *LoadXmlStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *LoadXmlStatementContext) LINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, 0)
}

func (s *LoadXmlStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadXmlStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadXmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadXmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadXmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadXmlStatement(s)
	}
}

func (s *LoadXmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadXmlStatement(s)
	}
}

func (s *LoadXmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadXmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LoadXmlStatement() (localctx ILoadXmlStatementContext) {
	localctx = NewLoadXmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MySqlParserRULE_loadXmlStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3321)
		p.Match(MySqlParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3322)
		p.Match(MySqlParserXML)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT {
		{
			p.SetState(3323)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOCAL {
		{
			p.SetState(3326)
			p.Match(MySqlParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3329)
		p.Match(MySqlParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3330)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*LoadXmlStatementContext).filename = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
		{
			p.SetState(3331)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3334)
		p.Match(MySqlParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3335)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3336)
		p.TableName()
	}
	p.SetState(3340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCHARACTER {
		{
			p.SetState(3337)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3338)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3339)

			var _x = p.CharsetName()

			localctx.(*LoadXmlStatementContext).charset = _x
		}

	}
	p.SetState(3348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserROWS {
		{
			p.SetState(3342)
			p.Match(MySqlParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3343)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3344)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3345)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3346)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*LoadXmlStatementContext).tag = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3347)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3350)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3351)
			p.DecimalLiteral()
		}
		{
			p.SetState(3352)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLINES || _la == MySqlParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3367)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 450, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3356)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3357)
			p.AssignmentField()
		}
		p.SetState(3362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3358)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3359)
				p.AssignmentField()
			}

			p.SetState(3364)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3365)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3378)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3369)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3370)
			p.UpdatedElement()
		}
		p.SetState(3375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3371)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3372)
				p.UpdatedElement()
			}

			p.SetState(3377)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceStatementContext is an interface to support dynamic dispatch.
type IReplaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IUidListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IUidListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)

	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext

	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext)

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReplaceStatementContext differentiates from other interfaces.
	IsReplaceStatementContext()
}

type ReplaceStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	priority        antlr.Token
	partitions      IUidListContext
	columns         IUidListContext
	setFirst        IUpdatedElementContext
	_updatedElement IUpdatedElementContext
	setElements     []IUpdatedElementContext
}

func NewEmptyReplaceStatementContext() *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replaceStatement
	return p
}

func InitEmptyReplaceStatementContext(p *ReplaceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replaceStatement
}

func (*ReplaceStatementContext) IsReplaceStatementContext() {}

func NewReplaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replaceStatement

	return p
}

func (s *ReplaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *ReplaceStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *ReplaceStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *ReplaceStatementContext) GetColumns() IUidListContext { return s.columns }

func (s *ReplaceStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *ReplaceStatementContext) Get_updatedElement() IUpdatedElementContext {
	return s._updatedElement
}

func (s *ReplaceStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *ReplaceStatementContext) SetColumns(v IUidListContext) { s.columns = v }

func (s *ReplaceStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *ReplaceStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }

func (s *ReplaceStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }

func (s *ReplaceStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }

func (s *ReplaceStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *ReplaceStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReplaceStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *ReplaceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ReplaceStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *ReplaceStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *ReplaceStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *ReplaceStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *ReplaceStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *ReplaceStatementContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *ReplaceStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *ReplaceStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAYED, 0)
}

func (s *ReplaceStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ReplaceStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ReplaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReplaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReplaceStatement() (localctx IReplaceStatementContext) {
	localctx = NewReplaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MySqlParserRULE_replaceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3380)
		p.Match(MySqlParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDELAYED || _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3381)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReplaceStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDELAYED || _la == MySqlParserLOW_PRIORITY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReplaceStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINTO {
		{
			p.SetState(3384)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3387)
		p.TableName()
	}
	p.SetState(3393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3388)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3389)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3390)

			var _x = p.UidList()

			localctx.(*ReplaceStatementContext).partitions = _x
		}
		{
			p.SetState(3391)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserVALUES, MySqlParserVALUE, MySqlParserLR_BRACKET:
		p.SetState(3399)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3395)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3396)

				var _x = p.UidList()

				localctx.(*ReplaceStatementContext).columns = _x
			}
			{
				p.SetState(3397)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3401)
			p.InsertStatementValue()
		}

	case MySqlParserSET:
		{
			p.SetState(3402)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3403)

			var _x = p.UpdatedElement()

			localctx.(*ReplaceStatementContext).setFirst = _x
		}
		p.SetState(3408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3404)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3405)

				var _x = p.UpdatedElement()

				localctx.(*ReplaceStatementContext)._updatedElement = _x
			}
			localctx.(*ReplaceStatementContext).setElements = append(localctx.(*ReplaceStatementContext).setElements, localctx.(*ReplaceStatementContext)._updatedElement)

			p.SetState(3410)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) CopyAll(ctx *SelectStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnionSelectContext struct {
	SelectStatementContext
	unionType antlr.Token
}

func NewUnionSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionSelectContext {
	var p = new(UnionSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionSelectContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionSelectContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionSelectContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionSelectContext) AllUnionStatement() []IUnionStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionStatementContext); ok {
			len++
		}
	}

	tst := make([]IUnionStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionStatementContext); ok {
			tst[i] = t.(IUnionStatementContext)
			i++
		}
	}

	return tst
}

func (s *UnionSelectContext) UnionStatement(i int) IUnionStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionStatementContext)
}

func (s *UnionSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *UnionSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionSelect(s)
	}
}

func (s *UnionSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionSelect(s)
	}
}

func (s *UnionSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnionParenthesisSelectContext struct {
	SelectStatementContext
	unionType antlr.Token
}

func NewUnionParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionParenthesisSelectContext {
	var p = new(UnionParenthesisSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionParenthesisSelectContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionParenthesisSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisSelectContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisSelectContext) AllUnionParenthesis() []IUnionParenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			len++
		}
	}

	tst := make([]IUnionParenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionParenthesisContext); ok {
			tst[i] = t.(IUnionParenthesisContext)
			i++
		}
	}

	return tst
}

func (s *UnionParenthesisSelectContext) UnionParenthesis(i int) IUnionParenthesisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionParenthesisContext)
}

func (s *UnionParenthesisSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionParenthesisSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionParenthesisSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionParenthesisSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionParenthesisSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleSelectContext struct {
	SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext {
	var p = new(SimpleSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *SimpleSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *SimpleSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesisSelectContext struct {
	SelectStatementContext
}

func NewParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisSelectContext {
	var p = new(ParenthesisSelectContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *ParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *ParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *ParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type WithLateralStatementContext struct {
	SelectStatementContext
}

func NewWithLateralStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithLateralStatementContext {
	var p = new(WithLateralStatementContext)

	InitEmptySelectStatementContext(&p.SelectStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectStatementContext))

	return p
}

func (s *WithLateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithLateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *WithLateralStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WithLateralStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WithLateralStatementContext) AllLateralStatement() []ILateralStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralStatementContext); ok {
			len++
		}
	}

	tst := make([]ILateralStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralStatementContext); ok {
			tst[i] = t.(ILateralStatementContext)
			i++
		}
	}

	return tst
}

func (s *WithLateralStatementContext) LateralStatement(i int) ILateralStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralStatementContext)
}

func (s *WithLateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithLateralStatement(s)
	}
}

func (s *WithLateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithLateralStatement(s)
	}
}

func (s *WithLateralStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWithLateralStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MySqlParserRULE_selectStatement)
	var _la int

	var _alt int

	p.SetState(3478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 476, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3413)
			p.QuerySpecification()
		}
		p.SetState(3415)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3414)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3417)
			p.QueryExpression()
		}
		p.SetState(3419)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3418)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewUnionSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT:
			{
				p.SetState(3421)
				p.QuerySpecificationNointo()
			}

		case MySqlParserLR_BRACKET:
			{
				p.SetState(3422)
				p.QueryExpressionNointo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3425)
					p.UnionStatement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3428)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 462, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNION {
			{
				p.SetState(3430)
				p.Match(MySqlParserUNION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3432)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
				{
					p.SetState(3431)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(3436)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSELECT:
				{
					p.SetState(3434)
					p.QuerySpecification()
				}

			case MySqlParserLR_BRACKET:
				{
					p.SetState(3435)
					p.QueryExpression()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(3441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3440)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(3443)
				p.LimitClause()
			}

		}
		p.SetState(3447)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3446)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewUnionParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3449)
			p.QueryExpressionNointo()
		}
		p.SetState(3451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3450)
					p.UnionParenthesis()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3453)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 469, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNION {
			{
				p.SetState(3455)
				p.Match(MySqlParserUNION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3457)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
				{
					p.SetState(3456)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionParenthesisSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionParenthesisSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(3459)
				p.QueryExpression()
			}

		}
		p.SetState(3463)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3462)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(3465)
				p.LimitClause()
			}

		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 474, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3468)
				p.LockClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewWithLateralStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3471)
			p.QuerySpecificationNointo()
		}
		p.SetState(3474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserCOMMA {
			{
				p.SetState(3472)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3473)
				p.LateralStatement()
			}

			p.SetState(3476)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleUpdateStatement() ISingleUpdateStatementContext
	MultipleUpdateStatement() IMultipleUpdateStatementContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) SingleUpdateStatement() ISingleUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleUpdateStatementContext)
}

func (s *UpdateStatementContext) MultipleUpdateStatement() IMultipleUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleUpdateStatementContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MySqlParserRULE_updateStatement)
	p.SetState(3482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 477, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3480)
			p.SingleUpdateStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3481)
			p.MultipleUpdateStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesStatementContext is an interface to support dynamic dispatch.
type IValuesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesStatementContext differentiates from other interfaces.
	IsValuesStatementContext()
}

type ValuesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesStatementContext() *ValuesStatementContext {
	var p = new(ValuesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_valuesStatement
	return p
}

func InitEmptyValuesStatementContext(p *ValuesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_valuesStatement
}

func (*ValuesStatementContext) IsValuesStatementContext() {}

func NewValuesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesStatementContext {
	var p = new(ValuesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_valuesStatement

	return p
}

func (s *ValuesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *ValuesStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *ValuesStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *ValuesStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *ValuesStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *ValuesStatementContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *ValuesStatementContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *ValuesStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ValuesStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ValuesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValuesStatement(s)
	}
}

func (s *ValuesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValuesStatement(s)
	}
}

func (s *ValuesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitValuesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ValuesStatement() (localctx IValuesStatementContext) {
	localctx = NewValuesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MySqlParserRULE_valuesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3484)
		p.Match(MySqlParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3485)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3487)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 478, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3486)
			p.ExpressionsWithDefaults()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3489)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3490)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3491)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3492)
				p.ExpressionsWithDefaults()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3495)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementValueContext is an interface to support dynamic dispatch.
type IInsertStatementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInsertFormat returns the insertFormat token.
	GetInsertFormat() antlr.Token

	// SetInsertFormat sets the insertFormat token.
	SetInsertFormat(antlr.Token)

	// Getter signatures
	SelectStatement() ISelectStatementContext
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInsertStatementValueContext differentiates from other interfaces.
	IsInsertStatementValueContext()
}

type InsertStatementValueContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	insertFormat antlr.Token
}

func NewEmptyInsertStatementValueContext() *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatementValue
	return p
}

func InitEmptyInsertStatementValueContext(p *InsertStatementValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatementValue
}

func (*InsertStatementValueContext) IsInsertStatementValueContext() {}

func NewInsertStatementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_insertStatementValue

	return p
}

func (s *InsertStatementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementValueContext) GetInsertFormat() antlr.Token { return s.insertFormat }

func (s *InsertStatementValueContext) SetInsertFormat(v antlr.Token) { s.insertFormat = v }

func (s *InsertStatementValueContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InsertStatementValueContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *InsertStatementValueContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *InsertStatementValueContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *InsertStatementValueContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *InsertStatementValueContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *InsertStatementValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *InsertStatementValueContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementValueContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *InsertStatementValueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *InsertStatementValueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *InsertStatementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInsertStatementValue(s)
	}
}

func (s *InsertStatementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInsertStatementValue(s)
	}
}

func (s *InsertStatementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInsertStatementValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) InsertStatementValue() (localctx IInsertStatementValueContext) {
	localctx = NewInsertStatementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MySqlParserRULE_insertStatementValue)
	var _la int

	p.SetState(3519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3501)
			p.SelectStatement()
		}

	case MySqlParserVALUES, MySqlParserVALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3502)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementValueContext).insertFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVALUES || _la == MySqlParserVALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementValueContext).insertFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3503)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3505)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3504)
				p.ExpressionsWithDefaults()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3507)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3508)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3509)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3511)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 482, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3510)
					p.ExpressionsWithDefaults()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3513)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3518)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdatedElementContext is an interface to support dynamic dispatch.
type IUpdatedElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	EQUAL_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdatedElementContext differentiates from other interfaces.
	IsUpdatedElementContext()
}

type UpdatedElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatedElementContext() *UpdatedElementContext {
	var p = new(UpdatedElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updatedElement
	return p
}

func InitEmptyUpdatedElementContext(p *UpdatedElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_updatedElement
}

func (*UpdatedElementContext) IsUpdatedElementContext() {}

func NewUpdatedElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatedElementContext {
	var p = new(UpdatedElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_updatedElement

	return p
}

func (s *UpdatedElementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatedElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *UpdatedElementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *UpdatedElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdatedElementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *UpdatedElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatedElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatedElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUpdatedElement(s)
	}
}

func (s *UpdatedElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUpdatedElement(s)
	}
}

func (s *UpdatedElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUpdatedElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UpdatedElement() (localctx IUpdatedElementContext) {
	localctx = NewUpdatedElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MySqlParserRULE_updatedElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3521)
		p.FullColumnName()
	}
	{
		p.SetState(3522)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3523)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(3524)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentFieldContext is an interface to support dynamic dispatch.
type IAssignmentFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	LOCAL_ID() antlr.TerminalNode

	// IsAssignmentFieldContext differentiates from other interfaces.
	IsAssignmentFieldContext()
}

type AssignmentFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentFieldContext() *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_assignmentField
	return p
}

func InitEmptyAssignmentFieldContext(p *AssignmentFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_assignmentField
}

func (*AssignmentFieldContext) IsAssignmentFieldContext() {}

func NewAssignmentFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_assignmentField

	return p
}

func (s *AssignmentFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentFieldContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AssignmentFieldContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *AssignmentFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAssignmentField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AssignmentField() (localctx IAssignmentFieldContext) {
	localctx = NewAssignmentFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MySqlParserRULE_assignmentField)
	p.SetState(3529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3527)
			p.Uid()
		}

	case MySqlParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3528)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockClauseContext is an interface to support dynamic dispatch.
type ILockClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	IN() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	MODE() antlr.TerminalNode

	// IsLockClauseContext differentiates from other interfaces.
	IsLockClauseContext()
}

type LockClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockClauseContext() *LockClauseContext {
	var p = new(LockClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
	return p
}

func InitEmptyLockClauseContext(p *LockClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
}

func (*LockClauseContext) IsLockClauseContext() {}

func NewLockClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockClauseContext {
	var p = new(LockClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockClause

	return p
}

func (s *LockClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *LockClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *LockClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *LockClauseContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *LockClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *LockClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockClause(s)
	}
}

func (s *LockClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockClause(s)
	}
}

func (s *LockClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LockClause() (localctx ILockClauseContext) {
	localctx = NewLockClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MySqlParserRULE_lockClause)
	p.SetState(3537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3531)
			p.Match(MySqlParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3532)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3533)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3534)
			p.Match(MySqlParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3535)
			p.Match(MySqlParserSHARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3536)
			p.Match(MySqlParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleDeleteStatementContext is an interface to support dynamic dispatch.
type ISingleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TableName() ITableNameContext
	ProxyHint() IProxyHintContext
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	Uid() IUidContext
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	LOW_PRIORITY() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsSingleDeleteStatementContext differentiates from other interfaces.
	IsSingleDeleteStatementContext()
}

type SingleDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptySingleDeleteStatementContext() *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement
	return p
}

func InitEmptySingleDeleteStatementContext(p *SingleDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement
}

func (*SingleDeleteStatementContext) IsSingleDeleteStatementContext() {}

func NewSingleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement

	return p
}

func (s *SingleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *SingleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *SingleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *SingleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *SingleDeleteStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleDeleteStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *SingleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *SingleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *SingleDeleteStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SingleDeleteStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *SingleDeleteStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SingleDeleteStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *SingleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleDeleteStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleDeleteStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *SingleDeleteStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *SingleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *SingleDeleteStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SingleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSingleDeleteStatement(s)
	}
}

func (s *SingleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSingleDeleteStatement(s)
	}
}

func (s *SingleDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSingleDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SingleDeleteStatement() (localctx ISingleDeleteStatementContext) {
	localctx = NewSingleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MySqlParserRULE_singleDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3539)
		p.Match(MySqlParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(3540)
			p.ProxyHint()
		}

	}
	p.SetState(3544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3543)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*SingleDeleteStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserQUICK {
		{
			p.SetState(3546)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3549)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3552)
		p.Match(MySqlParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3553)
		p.TableName()
	}
	p.SetState(3558)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) == 1 {
		p.SetState(3555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3554)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3557)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3560)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3561)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3562)
			p.UidList()
		}
		{
			p.SetState(3563)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3567)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3568)
			p.expression(0)
		}

	}
	p.SetState(3572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserORDER {
		{
			p.SetState(3571)
			p.OrderByClause()
		}

	}
	p.SetState(3576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3574)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3575)
			p.LimitClauseAtom()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipleDeleteStatementContext is an interface to support dynamic dispatch.
type IMultipleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	DELETE() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	USING() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultipleDeleteStatementContext differentiates from other interfaces.
	IsMultipleDeleteStatementContext()
}

type MultipleDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleDeleteStatementContext() *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement
	return p
}

func InitEmptyMultipleDeleteStatementContext(p *MultipleDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement
}

func (*MultipleDeleteStatementContext) IsMultipleDeleteStatementContext() {}

func NewMultipleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement

	return p
}

func (s *MultipleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *MultipleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *MultipleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *MultipleDeleteStatementContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *MultipleDeleteStatementContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MultipleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *MultipleDeleteStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleDeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *MultipleDeleteStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *MultipleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *MultipleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *MultipleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *MultipleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *MultipleDeleteStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDOT)
}

func (s *MultipleDeleteStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, i)
}

func (s *MultipleDeleteStatementContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTAR)
}

func (s *MultipleDeleteStatementContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, i)
}

func (s *MultipleDeleteStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MultipleDeleteStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MultipleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultipleDeleteStatement(s)
	}
}

func (s *MultipleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultipleDeleteStatement(s)
	}
}

func (s *MultipleDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMultipleDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) MultipleDeleteStatement() (localctx IMultipleDeleteStatementContext) {
	localctx = NewMultipleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MySqlParserRULE_multipleDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3578)
		p.Match(MySqlParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(3579)
			p.ProxyHint()
		}

	}
	p.SetState(3583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3582)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*MultipleDeleteStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3586)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3585)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3588)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		{
			p.SetState(3591)
			p.TableName()
		}
		p.SetState(3594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDOT {
			{
				p.SetState(3592)
				p.Match(MySqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3593)
				p.Match(MySqlParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3596)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3597)
				p.TableName()
			}
			p.SetState(3600)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserDOT {
				{
					p.SetState(3598)
					p.Match(MySqlParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3599)
					p.Match(MySqlParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

			p.SetState(3606)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3607)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3608)
			p.TableSources()
		}

	case MySqlParserFROM:
		{
			p.SetState(3610)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3611)
			p.TableName()
		}
		p.SetState(3614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDOT {
			{
				p.SetState(3612)
				p.Match(MySqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3613)
				p.Match(MySqlParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3616)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3617)
				p.TableName()
			}
			p.SetState(3620)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserDOT {
				{
					p.SetState(3618)
					p.Match(MySqlParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3619)
					p.Match(MySqlParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

			p.SetState(3626)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3627)
			p.Match(MySqlParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3628)
			p.TableSources()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3632)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3633)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerOpenStatementContext is an interface to support dynamic dispatch.
type IHandlerOpenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	OPEN() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsHandlerOpenStatementContext differentiates from other interfaces.
	IsHandlerOpenStatementContext()
}

type HandlerOpenStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerOpenStatementContext() *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement
	return p
}

func InitEmptyHandlerOpenStatementContext(p *HandlerOpenStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement
}

func (*HandlerOpenStatementContext) IsHandlerOpenStatementContext() {}

func NewHandlerOpenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement

	return p
}

func (s *HandlerOpenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerOpenStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerOpenStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerOpenStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *HandlerOpenStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerOpenStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *HandlerOpenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerOpenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerOpenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerOpenStatement(s)
	}
}

func (s *HandlerOpenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerOpenStatement(s)
	}
}

func (s *HandlerOpenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerOpenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HandlerOpenStatement() (localctx IHandlerOpenStatementContext) {
	localctx = NewHandlerOpenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, MySqlParserRULE_handlerOpenStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3636)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3637)
		p.TableName()
	}
	{
		p.SetState(3638)
		p.Match(MySqlParserOPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3643)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 511, p.GetParserRuleContext()) == 1 {
		p.SetState(3640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3639)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3642)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerReadIndexStatementContext is an interface to support dynamic dispatch.
type IHandlerReadIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token

	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token)

	// GetIndex returns the index rule contexts.
	GetIndex() IUidContext

	// SetIndex sets the index rule contexts.
	SetIndex(IUidContext)

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	Uid() IUidContext
	ComparisonOperator() IComparisonOperatorContext
	LR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	PREV() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsHandlerReadIndexStatementContext differentiates from other interfaces.
	IsHandlerReadIndexStatementContext()
}

type HandlerReadIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	index     IUidContext
	moveOrder antlr.Token
}

func NewEmptyHandlerReadIndexStatementContext() *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement
	return p
}

func InitEmptyHandlerReadIndexStatementContext(p *HandlerReadIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement
}

func (*HandlerReadIndexStatementContext) IsHandlerReadIndexStatementContext() {}

func NewHandlerReadIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement

	return p
}

func (s *HandlerReadIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadIndexStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }

func (s *HandlerReadIndexStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }

func (s *HandlerReadIndexStatementContext) GetIndex() IUidContext { return s.index }

func (s *HandlerReadIndexStatementContext) SetIndex(v IUidContext) { s.index = v }

func (s *HandlerReadIndexStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerReadIndexStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadIndexStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *HandlerReadIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerReadIndexStatementContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *HandlerReadIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *HandlerReadIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *HandlerReadIndexStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadIndexStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *HandlerReadIndexStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadIndexStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *HandlerReadIndexStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *HandlerReadIndexStatementContext) PREV() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREV, 0)
}

func (s *HandlerReadIndexStatementContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *HandlerReadIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerReadIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerReadIndexStatement(s)
	}
}

func (s *HandlerReadIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerReadIndexStatement(s)
	}
}

func (s *HandlerReadIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerReadIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HandlerReadIndexStatement() (localctx IHandlerReadIndexStatementContext) {
	localctx = NewHandlerReadIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, MySqlParserRULE_handlerReadIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3645)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3646)
		p.TableName()
	}
	{
		p.SetState(3647)
		p.Match(MySqlParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3648)

		var _x = p.Uid()

		localctx.(*HandlerReadIndexStatementContext).index = _x
	}
	p.SetState(3655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserEQUAL_SYMBOL, MySqlParserGREATER_SYMBOL, MySqlParserLESS_SYMBOL, MySqlParserEXCLAMATION_SYMBOL:
		{
			p.SetState(3649)
			p.ComparisonOperator()
		}
		{
			p.SetState(3650)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3651)
			p.Constants()
		}
		{
			p.SetState(3652)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserFIRST, MySqlParserLAST, MySqlParserNEXT, MySqlParserPREV:
		{
			p.SetState(3654)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*HandlerReadIndexStatementContext).moveOrder = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST || _la == MySqlParserLAST || _la == MySqlParserNEXT || _la == MySqlParserPREV) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*HandlerReadIndexStatementContext).moveOrder = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3657)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3658)
			p.expression(0)
		}

	}
	p.SetState(3663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3661)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3662)
			p.LimitClauseAtom()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerReadStatementContext is an interface to support dynamic dispatch.
type IHandlerReadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token

	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token)

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext

	// IsHandlerReadStatementContext differentiates from other interfaces.
	IsHandlerReadStatementContext()
}

type HandlerReadStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	moveOrder antlr.Token
}

func NewEmptyHandlerReadStatementContext() *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadStatement
	return p
}

func InitEmptyHandlerReadStatementContext(p *HandlerReadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadStatement
}

func (*HandlerReadStatementContext) IsHandlerReadStatementContext() {}

func NewHandlerReadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerReadStatement

	return p
}

func (s *HandlerReadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }

func (s *HandlerReadStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }

func (s *HandlerReadStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerReadStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *HandlerReadStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *HandlerReadStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *HandlerReadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *HandlerReadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *HandlerReadStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerReadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerReadStatement(s)
	}
}

func (s *HandlerReadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerReadStatement(s)
	}
}

func (s *HandlerReadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerReadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HandlerReadStatement() (localctx IHandlerReadStatementContext) {
	localctx = NewHandlerReadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, MySqlParserRULE_handlerReadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3665)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3666)
		p.TableName()
	}
	{
		p.SetState(3667)
		p.Match(MySqlParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3668)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*HandlerReadStatementContext).moveOrder = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFIRST || _la == MySqlParserNEXT) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*HandlerReadStatementContext).moveOrder = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3669)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3670)
			p.expression(0)
		}

	}
	p.SetState(3675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3673)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3674)
			p.LimitClauseAtom()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerCloseStatementContext is an interface to support dynamic dispatch.
type IHandlerCloseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	CLOSE() antlr.TerminalNode

	// IsHandlerCloseStatementContext differentiates from other interfaces.
	IsHandlerCloseStatementContext()
}

type HandlerCloseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerCloseStatementContext() *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement
	return p
}

func InitEmptyHandlerCloseStatementContext(p *HandlerCloseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement
}

func (*HandlerCloseStatementContext) IsHandlerCloseStatementContext() {}

func NewHandlerCloseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement

	return p
}

func (s *HandlerCloseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerCloseStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerCloseStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerCloseStatementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *HandlerCloseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerCloseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerCloseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerCloseStatement(s)
	}
}

func (s *HandlerCloseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerCloseStatement(s)
	}
}

func (s *HandlerCloseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerCloseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HandlerCloseStatement() (localctx IHandlerCloseStatementContext) {
	localctx = NewHandlerCloseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, MySqlParserRULE_handlerCloseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3677)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3678)
		p.TableName()
	}
	{
		p.SetState(3679)
		p.Match(MySqlParserCLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleUpdateStatementContext is an interface to support dynamic dispatch.
type ISingleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableName() ITableNameContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	ProxyHint() IProxyHintContext
	IGNORE() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	LOW_PRIORITY() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsSingleUpdateStatementContext differentiates from other interfaces.
	IsSingleUpdateStatementContext()
}

type SingleUpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptySingleUpdateStatementContext() *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement
	return p
}

func InitEmptySingleUpdateStatementContext(p *SingleUpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement
}

func (*SingleUpdateStatementContext) IsSingleUpdateStatementContext() {}

func NewSingleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement

	return p
}

func (s *SingleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *SingleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *SingleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *SingleUpdateStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SingleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *SingleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *SingleUpdateStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *SingleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *SingleUpdateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SingleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SingleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SingleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *SingleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleUpdateStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleUpdateStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SingleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *SingleUpdateStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SingleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSingleUpdateStatement(s)
	}
}

func (s *SingleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSingleUpdateStatement(s)
	}
}

func (s *SingleUpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSingleUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SingleUpdateStatement() (localctx ISingleUpdateStatementContext) {
	localctx = NewSingleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, MySqlParserRULE_singleUpdateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3681)
		p.Match(MySqlParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(3682)
			p.ProxyHint()
		}

	}
	p.SetState(3686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3685)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*SingleUpdateStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3688)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3691)
		p.TableName()
	}
	p.SetState(3696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256563200) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		p.SetState(3693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3692)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3695)
			p.Uid()
		}

	}
	{
		p.SetState(3698)
		p.Match(MySqlParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3699)
		p.UpdatedElement()
	}
	p.SetState(3704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3700)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3701)
			p.UpdatedElement()
		}

		p.SetState(3706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3707)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3708)
			p.expression(0)
		}

	}
	p.SetState(3712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserORDER {
		{
			p.SetState(3711)
			p.OrderByClause()
		}

	}
	p.SetState(3715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3714)
			p.LimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipleUpdateStatementContext is an interface to support dynamic dispatch.
type IMultipleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableSources() ITableSourcesContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	ProxyHint() IProxyHintContext
	IGNORE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode

	// IsMultipleUpdateStatementContext differentiates from other interfaces.
	IsMultipleUpdateStatementContext()
}

type MultipleUpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleUpdateStatementContext() *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement
	return p
}

func InitEmptyMultipleUpdateStatementContext(p *MultipleUpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement
}

func (*MultipleUpdateStatementContext) IsMultipleUpdateStatementContext() {}

func NewMultipleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement

	return p
}

func (s *MultipleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *MultipleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *MultipleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *MultipleUpdateStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *MultipleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *MultipleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *MultipleUpdateStatementContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *MultipleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *MultipleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MultipleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MultipleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *MultipleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *MultipleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultipleUpdateStatement(s)
	}
}

func (s *MultipleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultipleUpdateStatement(s)
	}
}

func (s *MultipleUpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMultipleUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) MultipleUpdateStatement() (localctx IMultipleUpdateStatementContext) {
	localctx = NewMultipleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, MySqlParserRULE_multipleUpdateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3717)
		p.Match(MySqlParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(3718)
			p.ProxyHint()
		}

	}
	p.SetState(3722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3721)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*MultipleUpdateStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3724)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3727)
		p.TableSources()
	}
	{
		p.SetState(3728)
		p.Match(MySqlParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3729)
		p.UpdatedElement()
	}
	p.SetState(3734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3730)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3731)
			p.UpdatedElement()
		}

		p.SetState(3736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3737)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3738)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, MySqlParserRULE_orderByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3741)
		p.Match(MySqlParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3742)
		p.Match(MySqlParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3743)
		p.OrderByExpression()
	}
	p.SetState(3748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3744)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3745)
				p.OrderByExpression()
			}

		}
		p.SetState(3750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByExpressionContext is an interface to support dynamic dispatch.
type IOrderByExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsOrderByExpressionContext differentiates from other interfaces.
	IsOrderByExpressionContext()
}

type OrderByExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyOrderByExpressionContext() *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByExpression
	return p
}

func InitEmptyOrderByExpressionContext(p *OrderByExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByExpression
}

func (*OrderByExpressionContext) IsOrderByExpressionContext() {}

func NewOrderByExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByExpression

	return p
}

func (s *OrderByExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByExpressionContext) GetOrder() antlr.Token { return s.order }

func (s *OrderByExpressionContext) SetOrder(v antlr.Token) { s.order = v }

func (s *OrderByExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderByExpressionContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *OrderByExpressionContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *OrderByExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrderByExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OrderByExpression() (localctx IOrderByExpressionContext) {
	localctx = NewOrderByExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, MySqlParserRULE_orderByExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3751)
		p.expression(0)
	}
	p.SetState(3753)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3752)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderByExpressionContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderByExpressionContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableSource() []ITableSourceContext
	TableSource(i int) ITableSourceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableSourcesContext differentiates from other interfaces.
	IsTableSourcesContext()
}

type TableSourcesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext {
	var p = new(TableSourcesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
	return p
}

func InitEmptyTableSourcesContext(p *TableSourcesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
}

func (*TableSourcesContext) IsTableSourcesContext() {}

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext {
	var p = new(TableSourcesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSources

	return p
}

func (s *TableSourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableSourceContext); ok {
			len++
		}
	}

	tst := make([]ITableSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableSourceContext); ok {
			tst[i] = t.(ITableSourceContext)
			i++
		}
	}

	return tst
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSources(s)
	}
}

func (s *TableSourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSources(s)
	}
}

func (s *TableSourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSources(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSources() (localctx ITableSourcesContext) {
	localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, MySqlParserRULE_tableSources)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3755)
		p.TableSource()
	}
	p.SetState(3760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3756)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3757)
				p.TableSource()
			}

		}
		p.SetState(3762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
	return p
}

func InitEmptyTableSourceContext(p *TableSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) CopyAll(ctx *TableSourceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableJsonContext struct {
	TableSourceContext
}

func NewTableJsonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableJsonContext {
	var p = new(TableJsonContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableJsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableJsonContext) JsonTable() IJsonTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonTableContext)
}

func (s *TableJsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableJson(s)
	}
}

func (s *TableJsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableJson(s)
	}
}

func (s *TableJsonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableJson(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourceNestedContext struct {
	TableSourceContext
}

func NewTableSourceNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceNestedContext {
	var p = new(TableSourceNestedContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceNestedContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourceNestedContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceNestedContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableSourceNestedContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceNestedContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceNested(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourceBaseContext struct {
	TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext {
	var p = new(TableSourceBaseContext)

	InitEmptyTableSourceContext(&p.TableSourceContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceBaseContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceBaseContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceBaseContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSource() (localctx ITableSourceContext) {
	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, MySqlParserRULE_tableSource)
	var _la int

	var _alt int

	p.SetState(3781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableSourceBaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3763)
			p.TableSourceItem()
		}
		p.SetState(3767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3764)
					p.JoinPart()
				}

			}
			p.SetState(3769)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewTableSourceNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3770)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3771)
			p.TableSourceItem()
		}
		p.SetState(3775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&-9150751492863426559) != 0) || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&288230410511450113) != 0) {
			{
				p.SetState(3772)
				p.JoinPart()
			}

			p.SetState(3777)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3778)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableJsonContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3780)
			p.JsonTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSourceItemContext is an interface to support dynamic dispatch.
type ITableSourceItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceItemContext differentiates from other interfaces.
	IsTableSourceItemContext()
}

type TableSourceItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceItemContext() *TableSourceItemContext {
	var p = new(TableSourceItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSourceItem
	return p
}

func InitEmptyTableSourceItemContext(p *TableSourceItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSourceItem
}

func (*TableSourceItemContext) IsTableSourceItemContext() {}

func NewTableSourceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceItemContext {
	var p = new(TableSourceItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSourceItem

	return p
}

func (s *TableSourceItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceItemContext) CopyAll(ctx *TableSourceItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableSourceItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryTableItemContext struct {
	TableSourceItemContext
	parenthesisSubquery ISelectStatementContext
	alias               IUidContext
}

func NewSubqueryTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryTableItemContext {
	var p = new(SubqueryTableItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}

func (s *SubqueryTableItemContext) GetParenthesisSubquery() ISelectStatementContext {
	return s.parenthesisSubquery
}

func (s *SubqueryTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *SubqueryTableItemContext) SetParenthesisSubquery(v ISelectStatementContext) {
	s.parenthesisSubquery = v
}

func (s *SubqueryTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *SubqueryTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubqueryTableItemContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SubqueryTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}

type AtomTableItemContext struct {
	TableSourceItemContext
	alias IUidContext
}

func NewAtomTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtomTableItemContext {
	var p = new(AtomTableItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}

func (s *AtomTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *AtomTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *AtomTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTableItemContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AtomTableItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AtomTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AtomTableItemContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AtomTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AtomTableItemContext) AllIndexHint() []IIndexHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexHintContext); ok {
			len++
		}
	}

	tst := make([]IIndexHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexHintContext); ok {
			tst[i] = t.(IIndexHintContext)
			i++
		}
	}

	return tst
}

func (s *AtomTableItemContext) IndexHint(i int) IIndexHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintContext)
}

func (s *AtomTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AtomTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AtomTableItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AtomTableItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AtomTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAtomTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourcesItemContext struct {
	TableSourceItemContext
}

func NewTableSourcesItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourcesItemContext {
	var p = new(TableSourcesItemContext)

	InitEmptyTableSourceItemContext(&p.TableSourceItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSourceItemContext))

	return p
}

func (s *TableSourcesItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourcesItemContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *TableSourcesItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableSourcesItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourcesItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSourceItem() (localctx ITableSourceItemContext) {
	localctx = NewTableSourceItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, MySqlParserRULE_tableSourceItem)
	var _la int

	var _alt int

	p.SetState(3823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 544, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAtomTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3783)
			p.TableName()
		}
		p.SetState(3789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPARTITION {
			{
				p.SetState(3784)
				p.Match(MySqlParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3785)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3786)
				p.UidList()
			}
			{
				p.SetState(3787)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3795)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext()) == 1 {
			p.SetState(3792)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(3791)
					p.Match(MySqlParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3794)

				var _x = p.Uid()

				localctx.(*AtomTableItemContext).alias = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3805)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3797)
				p.IndexHint()
			}
			p.SetState(3802)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 540, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3798)
						p.Match(MySqlParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(3799)
						p.IndexHint()
					}

				}
				p.SetState(3804)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 540, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSubqueryTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3807)
				p.SelectStatement()
			}

		case 2:
			{
				p.SetState(3808)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3809)

				var _x = p.SelectStatement()

				localctx.(*SubqueryTableItemContext).parenthesisSubquery = _x
			}
			{
				p.SetState(3810)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3814)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3817)

			var _x = p.Uid()

			localctx.(*SubqueryTableItemContext).alias = _x
		}

	case 3:
		localctx = NewTableSourcesItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3819)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3820)
			p.TableSources()
		}
		{
			p.SetState(3821)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintContext is an interface to support dynamic dispatch.
type IIndexHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexHintAction returns the indexHintAction token.
	GetIndexHintAction() antlr.Token

	// GetKeyFormat returns the keyFormat token.
	GetKeyFormat() antlr.Token

	// SetIndexHintAction sets the indexHintAction token.
	SetIndexHintAction(antlr.Token)

	// SetKeyFormat sets the keyFormat token.
	SetKeyFormat(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	USE() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	IndexHintType() IIndexHintTypeContext

	// IsIndexHintContext differentiates from other interfaces.
	IsIndexHintContext()
}

type IndexHintContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	indexHintAction antlr.Token
	keyFormat       antlr.Token
}

func NewEmptyIndexHintContext() *IndexHintContext {
	var p = new(IndexHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHint
	return p
}

func InitEmptyIndexHintContext(p *IndexHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHint
}

func (*IndexHintContext) IsIndexHintContext() {}

func NewIndexHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintContext {
	var p = new(IndexHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHint

	return p
}

func (s *IndexHintContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintContext) GetIndexHintAction() antlr.Token { return s.indexHintAction }

func (s *IndexHintContext) GetKeyFormat() antlr.Token { return s.keyFormat }

func (s *IndexHintContext) SetIndexHintAction(v antlr.Token) { s.indexHintAction = v }

func (s *IndexHintContext) SetKeyFormat(v antlr.Token) { s.keyFormat = v }

func (s *IndexHintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexHintContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IndexHintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexHintContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *IndexHintContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *IndexHintContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORCE, 0)
}

func (s *IndexHintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *IndexHintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *IndexHintContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *IndexHintContext) IndexHintType() IIndexHintTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintTypeContext)
}

func (s *IndexHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHint(s)
	}
}

func (s *IndexHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHint(s)
	}
}

func (s *IndexHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexHint() (localctx IIndexHintContext) {
	localctx = NewIndexHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, MySqlParserRULE_indexHint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3825)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).indexHintAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFORCE || _la == MySqlParserIGNORE || _la == MySqlParserUSE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).indexHintAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3826)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).keyFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).keyFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(3827)
			p.Match(MySqlParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3828)
			p.IndexHintType()
		}

	}
	{
		p.SetState(3831)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3832)
		p.UidList()
	}
	{
		p.SetState(3833)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintTypeContext is an interface to support dynamic dispatch.
type IIndexHintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	GROUP() antlr.TerminalNode

	// IsIndexHintTypeContext differentiates from other interfaces.
	IsIndexHintTypeContext()
}

type IndexHintTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintTypeContext() *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHintType
	return p
}

func InitEmptyIndexHintTypeContext(p *IndexHintTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHintType
}

func (*IndexHintTypeContext) IsIndexHintTypeContext() {}

func NewIndexHintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHintType

	return p
}

func (s *IndexHintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *IndexHintTypeContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *IndexHintTypeContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *IndexHintTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *IndexHintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexHintType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexHintType() (localctx IIndexHintTypeContext) {
	localctx = NewIndexHintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, MySqlParserRULE_indexHintType)
	p.SetState(3840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3835)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserORDER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3836)
			p.Match(MySqlParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3837)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserGROUP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3838)
			p.Match(MySqlParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3839)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinPartContext is an interface to support dynamic dispatch.
type IJoinPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinPartContext differentiates from other interfaces.
	IsJoinPartContext()
}

type JoinPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinPartContext() *JoinPartContext {
	var p = new(JoinPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinPart
	return p
}

func InitEmptyJoinPartContext(p *JoinPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinPart
}

func (*JoinPartContext) IsJoinPartContext() {}

func NewJoinPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinPartContext {
	var p = new(JoinPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_joinPart

	return p
}

func (s *JoinPartContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinPartContext) CopyAll(ctx *JoinPartContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InnerJoinContext struct {
	JoinPartContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *InnerJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *InnerJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *InnerJoinContext) AllJoinSpec() []IJoinSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinSpecContext); ok {
			len++
		}
	}

	tst := make([]IJoinSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinSpecContext); ok {
			tst[i] = t.(IJoinSpecContext)
			i++
		}
	}

	return tst
}

func (s *InnerJoinContext) JoinSpec(i int) IJoinSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSpecContext)
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNER, 0)
}

func (s *InnerJoinContext) CROSS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSS, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

func (s *InnerJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInnerJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type NaturalJoinContext struct {
	JoinPartContext
}

func NewNaturalJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NaturalJoinContext {
	var p = new(NaturalJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *NaturalJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalJoinContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATURAL, 0)
}

func (s *NaturalJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *NaturalJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *NaturalJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *NaturalJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *NaturalJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}

func (s *NaturalJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNaturalJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type OuterJoinContext struct {
	JoinPartContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *OuterJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *OuterJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *OuterJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}

func (s *OuterJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *OuterJoinContext) AllJoinSpec() []IJoinSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinSpecContext); ok {
			len++
		}
	}

	tst := make([]IJoinSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinSpecContext); ok {
			tst[i] = t.(IJoinSpecContext)
			i++
		}
	}

	return tst
}

func (s *OuterJoinContext) JoinSpec(i int) IJoinSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinSpecContext)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (s *OuterJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOuterJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type StraightJoinContext struct {
	JoinPartContext
}

func NewStraightJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StraightJoinContext {
	var p = new(StraightJoinContext)

	InitEmptyJoinPartContext(&p.JoinPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinPartContext))

	return p
}

func (s *StraightJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StraightJoinContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *StraightJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *StraightJoinContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *StraightJoinContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *StraightJoinContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StraightJoinContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StraightJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStraightJoin(s)
	}
}

func (s *StraightJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStraightJoin(s)
	}
}

func (s *StraightJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStraightJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JoinPart() (localctx IJoinPartContext) {
	localctx = NewJoinPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, MySqlParserRULE_joinPart)
	var _la int

	var _alt int

	p.SetState(3889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCROSS, MySqlParserINNER, MySqlParserJOIN:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCROSS || _la == MySqlParserINNER {
			{
				p.SetState(3842)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCROSS || _la == MySqlParserINNER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3845)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3847)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 548, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3846)
				p.Match(MySqlParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3849)
			p.TableSourceItem()
		}
		p.SetState(3853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3850)
					p.JoinSpec()
				}

			}
			p.SetState(3855)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySqlParserSTRAIGHT_JOIN:
		localctx = NewStraightJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3856)
			p.Match(MySqlParserSTRAIGHT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3857)
			p.TableSourceItem()
		}
		p.SetState(3862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 550, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3858)
					p.Match(MySqlParserON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3859)
					p.expression(0)
				}

			}
			p.SetState(3864)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 550, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySqlParserLEFT, MySqlParserRIGHT:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3865)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserOUTER {
			{
				p.SetState(3866)
				p.Match(MySqlParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3869)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3871)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 552, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3870)
				p.Match(MySqlParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3873)
			p.TableSourceItem()
		}
		p.SetState(3877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3874)
					p.JoinSpec()
				}

			}
			p.SetState(3879)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySqlParserNATURAL:
		localctx = NewNaturalJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3880)
			p.Match(MySqlParserNATURAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLEFT || _la == MySqlParserRIGHT {
			{
				p.SetState(3881)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(3883)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserOUTER {
				{
					p.SetState(3882)
					p.Match(MySqlParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(3887)
			p.Match(MySqlParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3888)
			p.TableSourceItem()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinSpecContext is an interface to support dynamic dispatch.
type IJoinSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	USING() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode

	// IsJoinSpecContext differentiates from other interfaces.
	IsJoinSpecContext()
}

type JoinSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinSpecContext() *JoinSpecContext {
	var p = new(JoinSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinSpec
	return p
}

func InitEmptyJoinSpecContext(p *JoinSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_joinSpec
}

func (*JoinSpecContext) IsJoinSpecContext() {}

func NewJoinSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinSpecContext {
	var p = new(JoinSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_joinSpec

	return p
}

func (s *JoinSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinSpecContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JoinSpecContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinSpecContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *JoinSpecContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JoinSpecContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *JoinSpecContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JoinSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJoinSpec(s)
	}
}

func (s *JoinSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJoinSpec(s)
	}
}

func (s *JoinSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJoinSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JoinSpec() (localctx IJoinSpecContext) {
	localctx = NewJoinSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, MySqlParserRULE_joinSpec)
	p.SetState(3898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3891)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3892)
			p.expression(0)
		}

	case MySqlParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3893)
			p.Match(MySqlParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3894)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3895)
			p.UidList()
		}
		{
			p.SetState(3896)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecification() IQuerySpecificationContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpression() IQueryExpressionContext

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpression
	return p
}

func InitEmptyQueryExpressionContext(p *QueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpression
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QueryExpression() (localctx IQueryExpressionContext) {
	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, MySqlParserRULE_queryExpression)
	p.SetState(3908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3900)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3901)
			p.QuerySpecification()
		}
		{
			p.SetState(3902)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3904)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3905)
			p.QueryExpression()
		}
		{
			p.SetState(3906)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionNointoContext is an interface to support dynamic dispatch.
type IQueryExpressionNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext

	// IsQueryExpressionNointoContext differentiates from other interfaces.
	IsQueryExpressionNointoContext()
}

type QueryExpressionNointoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionNointoContext() *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo
	return p
}

func InitEmptyQueryExpressionNointoContext(p *QueryExpressionNointoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo
}

func (*QueryExpressionNointoContext) IsQueryExpressionNointoContext() {}

func NewQueryExpressionNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo

	return p
}

func (s *QueryExpressionNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionNointoContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *QueryExpressionNointoContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *QueryExpressionNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryExpressionNointo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QueryExpressionNointo() (localctx IQueryExpressionNointoContext) {
	localctx = NewQueryExpressionNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, MySqlParserRULE_queryExpressionNointo)
	p.SetState(3918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 559, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3910)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3911)
			p.QuerySpecificationNointo()
		}
		{
			p.SetState(3912)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3914)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3915)
			p.QueryExpressionNointo()
		}
		{
			p.SetState(3916)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	FromClause() IFromClauseContext
	ProxyHint() IProxyHintContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	SelectIntoExpression() ISelectIntoExpressionContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *QuerySpecificationContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationContext) SelectIntoExpression() ISelectIntoExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectIntoExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectIntoExpressionContext)
}

func (s *QuerySpecificationContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, MySqlParserRULE_querySpecification)
	var _la int

	var _alt int

	p.SetState(3980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 576, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3920)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3922)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3921)
				p.ProxyHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3924)
					p.SelectSpec()
				}

			}
			p.SetState(3929)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3930)
			p.SelectElements()
		}
		p.SetState(3932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTO {
			{
				p.SetState(3931)
				p.SelectIntoExpression()
			}

		}
		{
			p.SetState(3934)
			p.FromClause()
		}
		p.SetState(3936)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 563, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3935)
				p.GroupByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserHAVING {
			{
				p.SetState(3938)
				p.HavingClause()
			}

		}
		p.SetState(3942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWINDOW {
			{
				p.SetState(3941)
				p.WindowClause()
			}

		}
		p.SetState(3945)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 566, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3944)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3948)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 567, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3947)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3950)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3952)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 568, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3951)
				p.ProxyHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 569, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3954)
					p.SelectSpec()
				}

			}
			p.SetState(3959)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 569, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3960)
			p.SelectElements()
		}
		{
			p.SetState(3961)
			p.FromClause()
		}
		p.SetState(3963)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 570, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3962)
				p.GroupByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserHAVING {
			{
				p.SetState(3965)
				p.HavingClause()
			}

		}
		p.SetState(3969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWINDOW {
			{
				p.SetState(3968)
				p.WindowClause()
			}

		}
		p.SetState(3972)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 573, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3971)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3975)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 574, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3974)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTO {
			{
				p.SetState(3977)
				p.SelectIntoExpression()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProxyHintContext is an interface to support dynamic dispatch.
type IProxyHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROXY_HINT() antlr.TerminalNode

	// IsProxyHintContext differentiates from other interfaces.
	IsProxyHintContext()
}

type ProxyHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProxyHintContext() *ProxyHintContext {
	var p = new(ProxyHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_proxyHint
	return p
}

func InitEmptyProxyHintContext(p *ProxyHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_proxyHint
}

func (*ProxyHintContext) IsProxyHintContext() {}

func NewProxyHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProxyHintContext {
	var p = new(ProxyHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_proxyHint

	return p
}

func (s *ProxyHintContext) GetParser() antlr.Parser { return s.parser }

func (s *ProxyHintContext) PROXY_HINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY_HINT, 0)
}

func (s *ProxyHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProxyHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProxyHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProxyHint(s)
	}
}

func (s *ProxyHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProxyHint(s)
	}
}

func (s *ProxyHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitProxyHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ProxyHint() (localctx IProxyHintContext) {
	localctx = NewProxyHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, MySqlParserRULE_proxyHint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3982)
		p.Match(MySqlParserPROXY_HINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationNointoContext is an interface to support dynamic dispatch.
type IQuerySpecificationNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	FromClause() IFromClauseContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	UnionStatement() IUnionStatementContext

	// IsQuerySpecificationNointoContext differentiates from other interfaces.
	IsQuerySpecificationNointoContext()
}

type QuerySpecificationNointoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationNointoContext() *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo
	return p
}

func InitEmptyQuerySpecificationNointoContext(p *QuerySpecificationNointoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo
}

func (*QuerySpecificationNointoContext) IsQuerySpecificationNointoContext() {}

func NewQuerySpecificationNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo

	return p
}

func (s *QuerySpecificationNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationNointoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationNointoContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationNointoContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationNointoContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationNointoContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationNointoContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationNointoContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationNointoContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationNointoContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationNointoContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationNointoContext) UnionStatement() IUnionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionStatementContext)
}

func (s *QuerySpecificationNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecificationNointo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QuerySpecificationNointo() (localctx IQuerySpecificationNointoContext) {
	localctx = NewQuerySpecificationNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, MySqlParserRULE_querySpecificationNointo)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3984)
		p.Match(MySqlParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 577, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3985)
				p.SelectSpec()
			}

		}
		p.SetState(3990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 577, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(3991)
		p.SelectElements()
	}
	{
		p.SetState(3992)
		p.FromClause()
	}
	p.SetState(3994)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3993)
			p.GroupByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserHAVING {
		{
			p.SetState(3996)
			p.HavingClause()
		}

	}
	p.SetState(4000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWINDOW {
		{
			p.SetState(3999)
			p.WindowClause()
		}

	}
	p.SetState(4003)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4002)
			p.OrderByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4006)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 582, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4005)
			p.LimitClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4009)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 583, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4008)
			p.UnionStatement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionParenthesisContext is an interface to support dynamic dispatch.
type IUnionParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// Getter signatures
	UNION() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionParenthesisContext differentiates from other interfaces.
	IsUnionParenthesisContext()
}

type UnionParenthesisContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionParenthesisContext() *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionParenthesis
	return p
}

func InitEmptyUnionParenthesisContext(p *UnionParenthesisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionParenthesis
}

func (*UnionParenthesisContext) IsUnionParenthesisContext() {}

func NewUnionParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionParenthesis

	return p
}

func (s *UnionParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionParenthesisContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionParenthesisContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionParenthesisContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionParenthesisContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnionParenthesis() (localctx IUnionParenthesisContext) {
	localctx = NewUnionParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, MySqlParserRULE_unionParenthesis)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4011)
		p.Match(MySqlParserUNION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(4012)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionParenthesisContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionParenthesisContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4015)
		p.QueryExpressionNointo()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionStatementContext is an interface to support dynamic dispatch.
type IUnionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// Getter signatures
	UNION() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionStatementContext differentiates from other interfaces.
	IsUnionStatementContext()
}

type UnionStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionStatementContext() *UnionStatementContext {
	var p = new(UnionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionStatement
	return p
}

func InitEmptyUnionStatementContext(p *UnionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unionStatement
}

func (*UnionStatementContext) IsUnionStatementContext() {}

func NewUnionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionStatementContext {
	var p = new(UnionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionStatement

	return p
}

func (s *UnionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionStatementContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionStatementContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionStatementContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionStatementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionStatement(s)
	}
}

func (s *UnionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionStatement(s)
	}
}

func (s *UnionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnionStatement() (localctx IUnionStatementContext) {
	localctx = NewUnionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, MySqlParserRULE_unionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4017)
		p.Match(MySqlParserUNION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(4018)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionStatementContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionStatementContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT:
		{
			p.SetState(4021)
			p.QuerySpecificationNointo()
		}

	case MySqlParserLR_BRACKET:
		{
			p.SetState(4022)
			p.QueryExpressionNointo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralStatementContext is an interface to support dynamic dispatch.
type ILateralStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LATERAL() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLateralStatementContext differentiates from other interfaces.
	IsLateralStatementContext()
}

type LateralStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLateralStatementContext() *LateralStatementContext {
	var p = new(LateralStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lateralStatement
	return p
}

func InitEmptyLateralStatementContext(p *LateralStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lateralStatement
}

func (*LateralStatementContext) IsLateralStatementContext() {}

func NewLateralStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralStatementContext {
	var p = new(LateralStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lateralStatement

	return p
}

func (s *LateralStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralStatementContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *LateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *LateralStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *LateralStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LateralStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LateralStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LateralStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *LateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLateralStatement(s)
	}
}

func (s *LateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLateralStatement(s)
	}
}

func (s *LateralStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLateralStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LateralStatement() (localctx ILateralStatementContext) {
	localctx = NewLateralStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, MySqlParserRULE_lateralStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4025)
		p.Match(MySqlParserLATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 590, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4026)
			p.QuerySpecificationNointo()
		}

	case 2:
		{
			p.SetState(4027)
			p.QueryExpressionNointo()
		}

	case 3:
		{
			p.SetState(4028)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT:
			{
				p.SetState(4029)
				p.QuerySpecificationNointo()
			}

		case MySqlParserLR_BRACKET:
			{
				p.SetState(4030)
				p.QueryExpressionNointo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(4033)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4038)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 589, p.GetParserRuleContext()) == 1 {
			p.SetState(4035)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(4034)
					p.Match(MySqlParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4037)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonTableContext is an interface to support dynamic dispatch.
type IJsonTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_TABLE() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsJsonTableContext differentiates from other interfaces.
	IsJsonTableContext()
}

type JsonTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonTableContext() *JsonTableContext {
	var p = new(JsonTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonTable
	return p
}

func InitEmptyJsonTableContext(p *JsonTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonTable
}

func (*JsonTableContext) IsJsonTableContext() {}

func NewJsonTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonTableContext {
	var p = new(JsonTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonTable

	return p
}

func (s *JsonTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonTableContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TABLE, 0)
}

func (s *JsonTableContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *JsonTableContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *JsonTableContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *JsonTableContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *JsonTableContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *JsonTableContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *JsonTableContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonTableContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *JsonTableContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *JsonTableContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *JsonTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *JsonTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonTable(s)
	}
}

func (s *JsonTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonTable(s)
	}
}

func (s *JsonTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JsonTable() (localctx IJsonTableContext) {
	localctx = NewJsonTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, MySqlParserRULE_jsonTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4042)
		p.Match(MySqlParserJSON_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4043)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4044)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4045)
		p.Match(MySqlParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4046)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4047)
		p.Match(MySqlParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4048)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4049)
		p.JsonColumnList()
	}
	{
		p.SetState(4050)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4051)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 592, p.GetParserRuleContext()) == 1 {
		p.SetState(4053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(4052)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4055)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonColumnListContext is an interface to support dynamic dispatch.
type IJsonColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJsonColumn() []IJsonColumnContext
	JsonColumn(i int) IJsonColumnContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsJsonColumnListContext differentiates from other interfaces.
	IsJsonColumnListContext()
}

type JsonColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnListContext() *JsonColumnListContext {
	var p = new(JsonColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumnList
	return p
}

func InitEmptyJsonColumnListContext(p *JsonColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumnList
}

func (*JsonColumnListContext) IsJsonColumnListContext() {}

func NewJsonColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnListContext {
	var p = new(JsonColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonColumnList

	return p
}

func (s *JsonColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnListContext) AllJsonColumn() []IJsonColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonColumnContext); ok {
			len++
		}
	}

	tst := make([]IJsonColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonColumnContext); ok {
			tst[i] = t.(IJsonColumnContext)
			i++
		}
	}

	return tst
}

func (s *JsonColumnListContext) JsonColumn(i int) IJsonColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnContext)
}

func (s *JsonColumnListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *JsonColumnListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *JsonColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonColumnList(s)
	}
}

func (s *JsonColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonColumnList(s)
	}
}

func (s *JsonColumnListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonColumnList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JsonColumnList() (localctx IJsonColumnListContext) {
	localctx = NewJsonColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, MySqlParserRULE_jsonColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4058)
		p.JsonColumn()
	}
	p.SetState(4063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4059)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4060)
			p.JsonColumn()
		}

		p.SetState(4065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonColumnContext is an interface to support dynamic dispatch.
type IJsonColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	FOR() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	DataType() IDataTypeContext
	PATH() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	JsonOnEmpty() IJsonOnEmptyContext
	JsonOnError() IJsonOnErrorContext
	NESTED() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	RR_BRACKET() antlr.TerminalNode

	// IsJsonColumnContext differentiates from other interfaces.
	IsJsonColumnContext()
}

type JsonColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnContext() *JsonColumnContext {
	var p = new(JsonColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumn
	return p
}

func InitEmptyJsonColumnContext(p *JsonColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumn
}

func (*JsonColumnContext) IsJsonColumnContext() {}

func NewJsonColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnContext {
	var p = new(JsonColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonColumn

	return p
}

func (s *JsonColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *JsonColumnContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *JsonColumnContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDINALITY, 0)
}

func (s *JsonColumnContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *JsonColumnContext) PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserPATH, 0)
}

func (s *JsonColumnContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *JsonColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *JsonColumnContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonColumnContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}

func (s *JsonColumnContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserNESTED, 0)
}

func (s *JsonColumnContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *JsonColumnContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonColumnContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonColumnContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonColumn(s)
	}
}

func (s *JsonColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonColumn(s)
	}
}

func (s *JsonColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JsonColumn() (localctx IJsonColumnContext) {
	localctx = NewJsonColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, MySqlParserRULE_jsonColumn)
	var _la int

	p.SetState(4095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 599, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4066)
			p.FullColumnName()
		}
		p.SetState(4083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserFOR:
			{
				p.SetState(4067)
				p.Match(MySqlParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4068)
				p.Match(MySqlParserORDINALITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserCHARACTER, MySqlParserSET, MySqlParserTINYINT, MySqlParserSMALLINT, MySqlParserMEDIUMINT, MySqlParserMIDDLEINT, MySqlParserINT, MySqlParserINT1, MySqlParserINT2, MySqlParserINT3, MySqlParserINT4, MySqlParserINT8, MySqlParserINTEGER, MySqlParserBIGINT, MySqlParserREAL, MySqlParserDOUBLE, MySqlParserFLOAT, MySqlParserFLOAT4, MySqlParserFLOAT8, MySqlParserDECIMAL, MySqlParserDEC, MySqlParserNUMERIC, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserCHAR, MySqlParserVARCHAR, MySqlParserNVARCHAR, MySqlParserNATIONAL, MySqlParserBINARY, MySqlParserVARBINARY, MySqlParserTINYBLOB, MySqlParserBLOB, MySqlParserMEDIUMBLOB, MySqlParserLONG, MySqlParserLONGBLOB, MySqlParserTINYTEXT, MySqlParserTEXT, MySqlParserMEDIUMTEXT, MySqlParserLONGTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserBIT, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserFIXED, MySqlParserJSON, MySqlParserNCHAR, MySqlParserGEOMETRYCOLLECTION, MySqlParserGEOMCOLLECTION, MySqlParserGEOMETRY, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON:
			{
				p.SetState(4069)
				p.DataType()
			}
			p.SetState(4081)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserPATH:
				{
					p.SetState(4070)
					p.Match(MySqlParserPATH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4071)
					p.Match(MySqlParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(4073)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 594, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(4072)
						p.JsonOnEmpty()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				p.SetState(4076)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserDEFAULT || _la == MySqlParserNULL_LITERAL || _la == MySqlParserERROR {
					{
						p.SetState(4075)
						p.JsonOnError()
					}

				}

			case MySqlParserEXISTS:
				{
					p.SetState(4078)
					p.Match(MySqlParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4079)
					p.Match(MySqlParserPATH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4080)
					p.Match(MySqlParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4085)
			p.Match(MySqlParserNESTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPATH {
			{
				p.SetState(4086)
				p.Match(MySqlParserPATH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4089)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4090)
			p.Match(MySqlParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4091)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4092)
			p.JsonColumnList()
		}
		{
			p.SetState(4093)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOnEmptyContext is an interface to support dynamic dispatch.
type IJsonOnEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnEmptyContext differentiates from other interfaces.
	IsJsonOnEmptyContext()
}

type JsonOnEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnEmptyContext() *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty
	return p
}

func InitEmptyJsonOnEmptyContext(p *JsonOnEmptyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty
}

func (*JsonOnEmptyContext) IsJsonOnEmptyContext() {}

func NewJsonOnEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty

	return p
}

func (s *JsonOnEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnEmptyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JsonOnEmptyContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEMPTY, 0)
}

func (s *JsonOnEmptyContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *JsonOnEmptyContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *JsonOnEmptyContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *JsonOnEmptyContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOnEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOnEmpty(s)
	}
}

func (s *JsonOnEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOnEmpty(s)
	}
}

func (s *JsonOnEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonOnEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JsonOnEmpty() (localctx IJsonOnEmptyContext) {
	localctx = NewJsonOnEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, MySqlParserRULE_jsonOnEmpty)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNULL_LITERAL:
		{
			p.SetState(4097)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserERROR:
		{
			p.SetState(4098)
			p.Match(MySqlParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDEFAULT:
		{
			p.SetState(4099)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4100)
			p.DefaultValue()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4103)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4104)
		p.Match(MySqlParserEMPTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOnErrorContext is an interface to support dynamic dispatch.
type IJsonOnErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnErrorContext differentiates from other interfaces.
	IsJsonOnErrorContext()
}

type JsonOnErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnErrorContext() *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnError
	return p
}

func InitEmptyJsonOnErrorContext(p *JsonOnErrorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnError
}

func (*JsonOnErrorContext) IsJsonOnErrorContext() {}

func NewJsonOnErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOnError

	return p
}

func (s *JsonOnErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnErrorContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JsonOnErrorContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserERROR)
}

func (s *JsonOnErrorContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, i)
}

func (s *JsonOnErrorContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *JsonOnErrorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *JsonOnErrorContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOnErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOnError(s)
	}
}

func (s *JsonOnErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOnError(s)
	}
}

func (s *JsonOnErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonOnError(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JsonOnError() (localctx IJsonOnErrorContext) {
	localctx = NewJsonOnErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, MySqlParserRULE_jsonOnError)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNULL_LITERAL:
		{
			p.SetState(4106)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserERROR:
		{
			p.SetState(4107)
			p.Match(MySqlParserERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDEFAULT:
		{
			p.SetState(4108)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4109)
			p.DefaultValue()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4112)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4113)
		p.Match(MySqlParserERROR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectSpecContext is an interface to support dynamic dispatch.
type ISelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	DISTINCTROW() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	STRAIGHT_JOIN() antlr.TerminalNode
	SQL_SMALL_RESULT() antlr.TerminalNode
	SQL_BIG_RESULT() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_CALC_FOUND_ROWS() antlr.TerminalNode

	// IsSelectSpecContext differentiates from other interfaces.
	IsSelectSpecContext()
}

type SelectSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecContext() *SelectSpecContext {
	var p = new(SelectSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
	return p
}

func InitEmptySelectSpecContext(p *SelectSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
}

func (*SelectSpecContext) IsSelectSpecContext() {}

func NewSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecContext {
	var p = new(SelectSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectSpec

	return p
}

func (s *SelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SelectSpecContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *SelectSpecContext) DISTINCTROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCTROW, 0)
}

func (s *SelectSpecContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *SelectSpecContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *SelectSpecContext) SQL_SMALL_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_SMALL_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BIG_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BIG_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *SelectSpecContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *SelectSpecContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *SelectSpecContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *SelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectSpec(s)
	}
}

func (s *SelectSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectSpec(s)
	}
}

func (s *SelectSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectSpec() (localctx ISelectSpecContext) {
	localctx = NewSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, MySqlParserRULE_selectSpec)
	var _la int

	p.SetState(4123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL, MySqlParserDISTINCT, MySqlParserDISTINCTROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4115)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&844424930132000) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserHIGH_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4116)
			p.Match(MySqlParserHIGH_PRIORITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSTRAIGHT_JOIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4117)
			p.Match(MySqlParserSTRAIGHT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSQL_SMALL_RESULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4118)
			p.Match(MySqlParserSQL_SMALL_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSQL_BIG_RESULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4119)
			p.Match(MySqlParserSQL_BIG_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSQL_BUFFER_RESULT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4120)
			p.Match(MySqlParserSQL_BUFFER_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4121)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_CACHE || _la == MySqlParserSQL_NO_CACHE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserSQL_CALC_FOUND_ROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4122)
			p.Match(MySqlParserSQL_CALC_FOUND_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// Getter signatures
	AllSelectElement() []ISelectElementContext
	SelectElement(i int) ISelectElementContext
	STAR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
	return p
}

func InitEmptySelectElementsContext(p *SelectElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElements() (localctx ISelectElementsContext) {
	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, MySqlParserRULE_selectElements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 603, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4125)

			var _m = p.Match(MySqlParserSTAR)

			localctx.(*SelectElementsContext).star = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4126)
			p.SelectElement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 604, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4129)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4130)
				p.SelectElement()
			}

		}
		p.SetState(4135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 604, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
	return p
}

func InitEmptySelectElementContext(p *SelectElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyAll(ctx *SelectElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectExpressionElementContext struct {
	SelectElementContext
}

func NewSelectExpressionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectExpressionElementContext {
	var p = new(SelectExpressionElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectExpressionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExpressionElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectExpressionElementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *SelectExpressionElementContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *SelectExpressionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectExpressionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectExpressionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectExpressionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectFunctionElementContext struct {
	SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext {
	var p = new(SelectFunctionElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectFunctionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectFunctionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFunctionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectStarElementContext struct {
	SelectElementContext
}

func NewSelectStarElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectStarElementContext {
	var p = new(SelectStarElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectStarElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStarElementContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SelectStarElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *SelectStarElementContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectStarElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectStarElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectColumnElementContext struct {
	SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext {
	var p = new(SelectColumnElementContext)

	InitEmptySelectElementContext(&p.SelectElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectElementContext))

	return p
}

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *SelectColumnElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectColumnElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectColumnElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectColumnElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElement() (localctx ISelectElementContext) {
	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, MySqlParserRULE_selectElement)
	var _la int

	p.SetState(4165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectStarElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4136)
			p.FullId()
		}
		{
			p.SetState(4137)
			p.Match(MySqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4138)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSelectColumnElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4140)
			p.FullColumnName()
		}
		p.SetState(4145)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 606, p.GetParserRuleContext()) == 1 {
			p.SetState(4142)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(4141)
					p.Match(MySqlParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4144)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSelectFunctionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4147)
			p.FunctionCall()
		}
		p.SetState(4152)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 608, p.GetParserRuleContext()) == 1 {
			p.SetState(4149)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(4148)
					p.Match(MySqlParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4151)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewSelectExpressionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4156)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 609, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4154)
				p.Match(MySqlParserLOCAL_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4155)
				p.Match(MySqlParserVAR_ASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4158)
			p.expression(0)
		}
		p.SetState(4163)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) == 1 {
			p.SetState(4160)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(4159)
					p.Match(MySqlParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4162)
				p.Uid()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectIntoExpressionContext is an interface to support dynamic dispatch.
type ISelectIntoExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectIntoExpressionContext differentiates from other interfaces.
	IsSelectIntoExpressionContext()
}

type SelectIntoExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectIntoExpressionContext() *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectIntoExpression
	return p
}

func InitEmptySelectIntoExpressionContext(p *SelectIntoExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectIntoExpression
}

func (*SelectIntoExpressionContext) IsSelectIntoExpressionContext() {}

func NewSelectIntoExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectIntoExpression

	return p
}

func (s *SelectIntoExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectIntoExpressionContext) CopyAll(ctx *SelectIntoExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectIntoExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectIntoVariablesContext struct {
	SelectIntoExpressionContext
}

func NewSelectIntoVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoVariablesContext {
	var p = new(SelectIntoVariablesContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoVariablesContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoVariablesContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoVariablesContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *SelectIntoVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectIntoVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectIntoVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectIntoTextFileContext struct {
	SelectIntoExpressionContext
	filename     antlr.Token
	charset      ICharsetNameContext
	fieldsFormat antlr.Token
}

func NewSelectIntoTextFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoTextFileContext {
	var p = new(SelectIntoTextFileContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoTextFileContext) GetFilename() antlr.Token { return s.filename }

func (s *SelectIntoTextFileContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *SelectIntoTextFileContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *SelectIntoTextFileContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *SelectIntoTextFileContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *SelectIntoTextFileContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *SelectIntoTextFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoTextFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoTextFileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTFILE, 0)
}

func (s *SelectIntoTextFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectIntoTextFileContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *SelectIntoTextFileContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SelectIntoTextFileContext) LINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, 0)
}

func (s *SelectIntoTextFileContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SelectIntoTextFileContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *SelectIntoTextFileContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *SelectIntoTextFileContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *SelectIntoTextFileContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *SelectIntoTextFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoTextFile(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectIntoDumpFileContext struct {
	SelectIntoExpressionContext
}

func NewSelectIntoDumpFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoDumpFileContext {
	var p = new(SelectIntoDumpFileContext)

	InitEmptySelectIntoExpressionContext(&p.SelectIntoExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoDumpFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoDumpFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoDumpFileContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *SelectIntoDumpFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectIntoDumpFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoDumpFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectIntoExpression() (localctx ISelectIntoExpressionContext) {
	localctx = NewSelectIntoExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, MySqlParserRULE_selectIntoExpression)
	var _la int

	p.SetState(4203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 619, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectIntoVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4167)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4168)
			p.AssignmentField()
		}
		p.SetState(4173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4169)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4170)
				p.AssignmentField()
			}

			p.SetState(4175)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSelectIntoDumpFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4176)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4177)
			p.Match(MySqlParserDUMPFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4178)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSelectIntoTextFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4179)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4180)
			p.Match(MySqlParserOUTFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4181)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectIntoTextFileContext).filename = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER {
			{
				p.SetState(4182)
				p.Match(MySqlParserCHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4183)
				p.Match(MySqlParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4184)

				var _x = p.CharsetName()

				localctx.(*SelectIntoTextFileContext).charset = _x
			}

		}
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 616, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4187)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SelectIntoTextFileContext).fieldsFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SelectIntoTextFileContext).fieldsFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(4189)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MySqlParserENCLOSED || _la == MySqlParserESCAPED || _la == MySqlParserOPTIONALLY || _la == MySqlParserTERMINATED {
				{
					p.SetState(4188)
					p.SelectFieldsInto()
				}

				p.SetState(4191)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINES {
			{
				p.SetState(4195)
				p.Match(MySqlParserLINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4197)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MySqlParserSTARTING || _la == MySqlParserTERMINATED {
				{
					p.SetState(4196)
					p.SelectLinesInto()
				}

				p.SetState(4199)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectFieldsIntoContext is an interface to support dynamic dispatch.
type ISelectFieldsIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTerminationField returns the terminationField token.
	GetTerminationField() antlr.Token

	// GetEnclosion returns the enclosion token.
	GetEnclosion() antlr.Token

	// GetEscaping returns the escaping token.
	GetEscaping() antlr.Token

	// SetTerminationField sets the terminationField token.
	SetTerminationField(antlr.Token)

	// SetEnclosion sets the enclosion token.
	SetEnclosion(antlr.Token)

	// SetEscaping sets the escaping token.
	SetEscaping(antlr.Token)

	// Getter signatures
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENCLOSED() antlr.TerminalNode
	OPTIONALLY() antlr.TerminalNode
	ESCAPED() antlr.TerminalNode

	// IsSelectFieldsIntoContext differentiates from other interfaces.
	IsSelectFieldsIntoContext()
}

type SelectFieldsIntoContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	terminationField antlr.Token
	enclosion        antlr.Token
	escaping         antlr.Token
}

func NewEmptySelectFieldsIntoContext() *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectFieldsInto
	return p
}

func InitEmptySelectFieldsIntoContext(p *SelectFieldsIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectFieldsInto
}

func (*SelectFieldsIntoContext) IsSelectFieldsIntoContext() {}

func NewSelectFieldsIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectFieldsInto

	return p
}

func (s *SelectFieldsIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectFieldsIntoContext) GetTerminationField() antlr.Token { return s.terminationField }

func (s *SelectFieldsIntoContext) GetEnclosion() antlr.Token { return s.enclosion }

func (s *SelectFieldsIntoContext) GetEscaping() antlr.Token { return s.escaping }

func (s *SelectFieldsIntoContext) SetTerminationField(v antlr.Token) { s.terminationField = v }

func (s *SelectFieldsIntoContext) SetEnclosion(v antlr.Token) { s.enclosion = v }

func (s *SelectFieldsIntoContext) SetEscaping(v antlr.Token) { s.escaping = v }

func (s *SelectFieldsIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectFieldsIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectFieldsIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectFieldsIntoContext) ENCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCLOSED, 0)
}

func (s *SelectFieldsIntoContext) OPTIONALLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONALLY, 0)
}

func (s *SelectFieldsIntoContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPED, 0)
}

func (s *SelectFieldsIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFieldsIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectFieldsIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFieldsInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectFieldsInto() (localctx ISelectFieldsIntoContext) {
	localctx = NewSelectFieldsIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, MySqlParserRULE_selectFieldsInto)
	var _la int

	p.SetState(4217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4205)
			p.Match(MySqlParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4206)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4207)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).terminationField = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserENCLOSED, MySqlParserOPTIONALLY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserOPTIONALLY {
			{
				p.SetState(4208)
				p.Match(MySqlParserOPTIONALLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4211)
			p.Match(MySqlParserENCLOSED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4212)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4213)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).enclosion = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserESCAPED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4214)
			p.Match(MySqlParserESCAPED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4215)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4216)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).escaping = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectLinesIntoContext is an interface to support dynamic dispatch.
type ISelectLinesIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStarting returns the starting token.
	GetStarting() antlr.Token

	// GetTerminationLine returns the terminationLine token.
	GetTerminationLine() antlr.Token

	// SetStarting sets the starting token.
	SetStarting(antlr.Token)

	// SetTerminationLine sets the terminationLine token.
	SetTerminationLine(antlr.Token)

	// Getter signatures
	STARTING() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode

	// IsSelectLinesIntoContext differentiates from other interfaces.
	IsSelectLinesIntoContext()
}

type SelectLinesIntoContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	starting        antlr.Token
	terminationLine antlr.Token
}

func NewEmptySelectLinesIntoContext() *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectLinesInto
	return p
}

func InitEmptySelectLinesIntoContext(p *SelectLinesIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_selectLinesInto
}

func (*SelectLinesIntoContext) IsSelectLinesIntoContext() {}

func NewSelectLinesIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectLinesInto

	return p
}

func (s *SelectLinesIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectLinesIntoContext) GetStarting() antlr.Token { return s.starting }

func (s *SelectLinesIntoContext) GetTerminationLine() antlr.Token { return s.terminationLine }

func (s *SelectLinesIntoContext) SetStarting(v antlr.Token) { s.starting = v }

func (s *SelectLinesIntoContext) SetTerminationLine(v antlr.Token) { s.terminationLine = v }

func (s *SelectLinesIntoContext) STARTING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTING, 0)
}

func (s *SelectLinesIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectLinesIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectLinesIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectLinesIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectLinesIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectLinesIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectLinesInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectLinesInto() (localctx ISelectLinesIntoContext) {
	localctx = NewSelectLinesIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, MySqlParserRULE_selectLinesInto)
	p.SetState(4225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTARTING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4219)
			p.Match(MySqlParserSTARTING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4220)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4221)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).starting = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4222)
			p.Match(MySqlParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4223)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4224)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).terminationLine = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhereExpr returns the whereExpr rule contexts.
	GetWhereExpr() IExpressionContext

	// SetWhereExpr sets the whereExpr rule contexts.
	SetWhereExpr(IExpressionContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	whereExpr IExpressionContext
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) GetWhereExpr() IExpressionContext { return s.whereExpr }

func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) { s.whereExpr = v }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FromClauseContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *FromClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, MySqlParserRULE_fromClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFROM {
		{
			p.SetState(4227)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4228)
			p.TableSources()
		}

	}
	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(4231)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4232)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).whereExpr = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllGroupByItem() []IGroupByItemContext
	GroupByItem(i int) IGroupByItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *GroupByClauseContext) AllGroupByItem() []IGroupByItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByItemContext); ok {
			len++
		}
	}

	tst := make([]IGroupByItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByItemContext); ok {
			tst[i] = t.(IGroupByItemContext)
			i++
		}
	}

	return tst
}

func (s *GroupByClauseContext) GroupByItem(i int) IGroupByItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByItemContext)
}

func (s *GroupByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GroupByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GroupByClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, MySqlParserRULE_groupByClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4235)
		p.Match(MySqlParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4236)
		p.Match(MySqlParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4237)
		p.GroupByItem()
	}
	p.SetState(4242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 625, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4238)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4239)
				p.GroupByItem()
			}

		}
		p.SetState(4244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 625, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4247)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 626, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4245)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4246)
			p.Match(MySqlParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHavingExpr returns the havingExpr rule contexts.
	GetHavingExpr() IExpressionContext

	// SetHavingExpr sets the havingExpr rule contexts.
	SetHavingExpr(IExpressionContext)

	// Getter signatures
	HAVING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	havingExpr IExpressionContext
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) GetHavingExpr() IExpressionContext { return s.havingExpr }

func (s *HavingClauseContext) SetHavingExpr(v IExpressionContext) { s.havingExpr = v }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(MySqlParserHAVING, 0)
}

func (s *HavingClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, MySqlParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4249)
		p.Match(MySqlParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4250)

		var _x = p.expression(0)

		localctx.(*HavingClauseContext).havingExpr = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	AllWindowName() []IWindowNameContext
	WindowName(i int) IWindowNameContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllWindowSpec() []IWindowSpecContext
	WindowSpec(i int) IWindowSpecContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserWINDOW, 0)
}

func (s *WindowClauseContext) AllWindowName() []IWindowNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowNameContext); ok {
			len++
		}
	}

	tst := make([]IWindowNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowNameContext); ok {
			tst[i] = t.(IWindowNameContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowName(i int) IWindowNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowClauseContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAS)
}

func (s *WindowClauseContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, i)
}

func (s *WindowClauseContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *WindowClauseContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *WindowClauseContext) AllWindowSpec() []IWindowSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowSpecContext); ok {
			len++
		}
	}

	tst := make([]IWindowSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowSpecContext); ok {
			tst[i] = t.(IWindowSpecContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowSpec(i int) IWindowSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowClauseContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *WindowClauseContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *WindowClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WindowClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (s *WindowClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWindowClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, MySqlParserRULE_windowClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4252)
		p.Match(MySqlParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4253)
		p.WindowName()
	}
	{
		p.SetState(4254)
		p.Match(MySqlParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4255)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4256)
		p.WindowSpec()
	}
	{
		p.SetState(4257)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 627, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4258)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4259)
				p.WindowName()
			}
			{
				p.SetState(4260)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4261)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4262)
				p.WindowSpec()
			}
			{
				p.SetState(4263)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 627, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByItemContext is an interface to support dynamic dispatch.
type IGroupByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsGroupByItemContext differentiates from other interfaces.
	IsGroupByItemContext()
}

type GroupByItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyGroupByItemContext() *GroupByItemContext {
	var p = new(GroupByItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByItem
	return p
}

func InitEmptyGroupByItemContext(p *GroupByItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByItem
}

func (*GroupByItemContext) IsGroupByItemContext() {}

func NewGroupByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByItemContext {
	var p = new(GroupByItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_groupByItem

	return p
}

func (s *GroupByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByItemContext) GetOrder() antlr.Token { return s.order }

func (s *GroupByItemContext) SetOrder(v antlr.Token) { s.order = v }

func (s *GroupByItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *GroupByItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *GroupByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGroupByItem(s)
	}
}

func (s *GroupByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGroupByItem(s)
	}
}

func (s *GroupByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGroupByItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) GroupByItem() (localctx IGroupByItemContext) {
	localctx = NewGroupByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, MySqlParserRULE_groupByItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4270)
		p.expression(0)
	}
	p.SetState(4272)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4271)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GroupByItemContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GroupByItemContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitClauseAtomContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitClauseAtomContext

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitClauseAtomContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitClauseAtomContext)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	AllLimitClauseAtom() []ILimitClauseAtomContext
	LimitClauseAtom(i int) ILimitClauseAtomContext
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	offset ILimitClauseAtomContext
	limit  ILimitClauseAtomContext
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() ILimitClauseAtomContext { return s.offset }

func (s *LimitClauseContext) GetLimit() ILimitClauseAtomContext { return s.limit }

func (s *LimitClauseContext) SetOffset(v ILimitClauseAtomContext) { s.offset = v }

func (s *LimitClauseContext) SetLimit(v ILimitClauseAtomContext) { s.limit = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *LimitClauseContext) AllLimitClauseAtom() []ILimitClauseAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			len++
		}
	}

	tst := make([]ILimitClauseAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitClauseAtomContext); ok {
			tst[i] = t.(ILimitClauseAtomContext)
			i++
		}
	}

	return tst
}

func (s *LimitClauseContext) LimitClauseAtom(i int) ILimitClauseAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, MySqlParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4274)
		p.Match(MySqlParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4278)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 629, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4275)

				var _x = p.LimitClauseAtom()

				localctx.(*LimitClauseContext).offset = _x
			}
			{
				p.SetState(4276)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4280)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}

	case 2:
		{
			p.SetState(4281)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}
		{
			p.SetState(4282)
			p.Match(MySqlParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4283)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).offset = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseAtomContext is an interface to support dynamic dispatch.
type ILimitClauseAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsLimitClauseAtomContext differentiates from other interfaces.
	IsLimitClauseAtomContext()
}

type LimitClauseAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseAtomContext() *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
	return p
}

func InitEmptyLimitClauseAtomContext(p *LimitClauseAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
}

func (*LimitClauseAtomContext) IsLimitClauseAtomContext() {}

func NewLimitClauseAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClauseAtom

	return p
}

func (s *LimitClauseAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseAtomContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitClauseAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *LimitClauseAtomContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *LimitClauseAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClauseAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClauseAtom() (localctx ILimitClauseAtomContext) {
	localctx = NewLimitClauseAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, MySqlParserRULE_limitClauseAtom)
	p.SetState(4290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4287)
			p.DecimalLiteral()
		}

	case MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4288)
			p.MysqlVariable()
		}

	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4289)
			p.SimpleId()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartTransactionContext is an interface to support dynamic dispatch.
type IStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionMode() []ITransactionModeContext
	TransactionMode(i int) ITransactionModeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartTransactionContext differentiates from other interfaces.
	IsStartTransactionContext()
}

type StartTransactionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartTransactionContext() *StartTransactionContext {
	var p = new(StartTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startTransaction
	return p
}

func InitEmptyStartTransactionContext(p *StartTransactionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startTransaction
}

func (*StartTransactionContext) IsStartTransactionContext() {}

func NewStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartTransactionContext {
	var p = new(StartTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startTransaction

	return p
}

func (s *StartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StartTransactionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

func (s *StartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StartTransaction() (localctx IStartTransactionContext) {
	localctx = NewStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, MySqlParserRULE_startTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4292)
		p.Match(MySqlParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4293)
		p.Match(MySqlParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4302)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 633, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4294)
			p.TransactionMode()
		}
		p.SetState(4299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4295)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4296)
				p.TransactionMode()
			}

			p.SetState(4301)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginWorkContext is an interface to support dynamic dispatch.
type IBeginWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode
	ProxyHint() IProxyHintContext

	// IsBeginWorkContext differentiates from other interfaces.
	IsBeginWorkContext()
}

type BeginWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginWorkContext() *BeginWorkContext {
	var p = new(BeginWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_beginWork
	return p
}

func InitEmptyBeginWorkContext(p *BeginWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_beginWork
}

func (*BeginWorkContext) IsBeginWorkContext() {}

func NewBeginWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginWorkContext {
	var p = new(BeginWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_beginWork

	return p
}

func (s *BeginWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginWorkContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *BeginWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *BeginWorkContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *BeginWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBeginWork(s)
	}
}

func (s *BeginWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBeginWork(s)
	}
}

func (s *BeginWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBeginWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BeginWork() (localctx IBeginWorkContext) {
	localctx = NewBeginWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, MySqlParserRULE_beginWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4304)
		p.Match(MySqlParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4305)
			p.Match(MySqlParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(4308)
			p.ProxyHint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitWorkContext is an interface to support dynamic dispatch.
type ICommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token

	// SetNochain sets the nochain token.
	SetNochain(antlr.Token)

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token)

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitWorkContext differentiates from other interfaces.
	IsCommitWorkContext()
}

type CommitWorkContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	nochain   antlr.Token
	norelease antlr.Token
}

func NewEmptyCommitWorkContext() *CommitWorkContext {
	var p = new(CommitWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commitWork
	return p
}

func InitEmptyCommitWorkContext(p *CommitWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_commitWork
}

func (*CommitWorkContext) IsCommitWorkContext() {}

func NewCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitWorkContext {
	var p = new(CommitWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_commitWork

	return p
}

func (s *CommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *CommitWorkContext) GetNorelease() antlr.Token { return s.norelease }

func (s *CommitWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *CommitWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }

func (s *CommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *CommitWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *CommitWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *CommitWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *CommitWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *CommitWorkContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *CommitWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNO)
}

func (s *CommitWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, i)
}

func (s *CommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommitWork(s)
	}
}

func (s *CommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommitWork(s)
	}
}

func (s *CommitWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCommitWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CommitWork() (localctx ICommitWorkContext) {
	localctx = NewCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, MySqlParserRULE_commitWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4311)
		p.Match(MySqlParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4312)
			p.Match(MySqlParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAND {
		{
			p.SetState(4315)
			p.Match(MySqlParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4316)

				var _m = p.Match(MySqlParserNO)

				localctx.(*CommitWorkContext).nochain = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4319)
			p.Match(MySqlParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4326)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 640, p.GetParserRuleContext()) == 1 {
		p.SetState(4323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4322)

				var _m = p.Match(MySqlParserNO)

				localctx.(*CommitWorkContext).norelease = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4325)
			p.Match(MySqlParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(4328)
			p.ProxyHint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackWorkContext is an interface to support dynamic dispatch.
type IRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token

	// SetNochain sets the nochain token.
	SetNochain(antlr.Token)

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token)

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	ProxyHint() IProxyHintContext
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackWorkContext differentiates from other interfaces.
	IsRollbackWorkContext()
}

type RollbackWorkContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	nochain   antlr.Token
	norelease antlr.Token
}

func NewEmptyRollbackWorkContext() *RollbackWorkContext {
	var p = new(RollbackWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackWork
	return p
}

func InitEmptyRollbackWorkContext(p *RollbackWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackWork
}

func (*RollbackWorkContext) IsRollbackWorkContext() {}

func NewRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackWorkContext {
	var p = new(RollbackWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_rollbackWork

	return p
}

func (s *RollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *RollbackWorkContext) GetNorelease() antlr.Token { return s.norelease }

func (s *RollbackWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *RollbackWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }

func (s *RollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *RollbackWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *RollbackWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *RollbackWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *RollbackWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *RollbackWorkContext) ProxyHint() IProxyHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyHintContext)
}

func (s *RollbackWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNO)
}

func (s *RollbackWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, i)
}

func (s *RollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRollbackWork(s)
	}
}

func (s *RollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRollbackWork(s)
	}
}

func (s *RollbackWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRollbackWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RollbackWork() (localctx IRollbackWorkContext) {
	localctx = NewRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, MySqlParserRULE_rollbackWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4331)
		p.Match(MySqlParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4332)
			p.Match(MySqlParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAND {
		{
			p.SetState(4335)
			p.Match(MySqlParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4336)

				var _m = p.Match(MySqlParserNO)

				localctx.(*RollbackWorkContext).nochain = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4339)
			p.Match(MySqlParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4346)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 646, p.GetParserRuleContext()) == 1 {
		p.SetState(4343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4342)

				var _m = p.Match(MySqlParserNO)

				localctx.(*RollbackWorkContext).norelease = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4345)
			p.Match(MySqlParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPROXY_HINT {
		{
			p.SetState(4348)
			p.ProxyHint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISavepointStatementContext is an interface to support dynamic dispatch.
type ISavepointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsSavepointStatementContext differentiates from other interfaces.
	IsSavepointStatementContext()
}

type SavepointStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointStatementContext() *SavepointStatementContext {
	var p = new(SavepointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_savepointStatement
	return p
}

func InitEmptySavepointStatementContext(p *SavepointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_savepointStatement
}

func (*SavepointStatementContext) IsSavepointStatementContext() {}

func NewSavepointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointStatementContext {
	var p = new(SavepointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_savepointStatement

	return p
}

func (s *SavepointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *SavepointStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SavepointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSavepointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SavepointStatement() (localctx ISavepointStatementContext) {
	localctx = NewSavepointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, MySqlParserRULE_savepointStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4351)
		p.Match(MySqlParserSAVEPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4352)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	TO() antlr.TerminalNode
	Uid() IUidContext
	WORK() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *RollbackStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RollbackStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *RollbackStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRollbackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, MySqlParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4354)
		p.Match(MySqlParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4355)
			p.Match(MySqlParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4358)
		p.Match(MySqlParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4360)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 649, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4359)
			p.Match(MySqlParserSAVEPOINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4362)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReleaseStatementContext is an interface to support dynamic dispatch.
type IReleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELEASE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsReleaseStatementContext differentiates from other interfaces.
	IsReleaseStatementContext()
}

type ReleaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReleaseStatementContext() *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_releaseStatement
	return p
}

func InitEmptyReleaseStatementContext(p *ReleaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_releaseStatement
}

func (*ReleaseStatementContext) IsReleaseStatementContext() {}

func NewReleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_releaseStatement

	return p
}

func (s *ReleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReleaseStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *ReleaseStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *ReleaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ReleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReleaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReleaseStatement() (localctx IReleaseStatementContext) {
	localctx = NewReleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, MySqlParserRULE_releaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4364)
		p.Match(MySqlParserRELEASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4365)
		p.Match(MySqlParserSAVEPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4366)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockTablesContext is an interface to support dynamic dispatch.
type ILockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	AllLockTableElement() []ILockTableElementContext
	LockTableElement(i int) ILockTableElementContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext

	// IsLockTablesContext differentiates from other interfaces.
	IsLockTablesContext()
}

type LockTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTablesContext() *LockTablesContext {
	var p = new(LockTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTables
	return p
}

func InitEmptyLockTablesContext(p *LockTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTables
}

func (*LockTablesContext) IsLockTablesContext() {}

func NewLockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTablesContext {
	var p = new(LockTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockTables

	return p
}

func (s *LockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTablesContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockTablesContext) AllLockTableElement() []ILockTableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockTableElementContext); ok {
			len++
		}
	}

	tst := make([]ILockTableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockTableElementContext); ok {
			tst[i] = t.(ILockTableElementContext)
			i++
		}
	}

	return tst
}

func (s *LockTablesContext) LockTableElement(i int) ILockTableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTableElementContext)
}

func (s *LockTablesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *LockTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LockTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LockTablesContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *LockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockTables(s)
	}
}

func (s *LockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockTables(s)
	}
}

func (s *LockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LockTables() (localctx ILockTablesContext) {
	localctx = NewLockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, MySqlParserRULE_lockTables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4368)
		p.Match(MySqlParserLOCK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4369)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4370)
		p.LockTableElement()
	}
	p.SetState(4375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4371)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4372)
			p.LockTableElement()
		}

		p.SetState(4377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOWAIT || _la == MySqlParserWAIT {
		{
			p.SetState(4378)
			p.WaitNowaitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlockTablesContext is an interface to support dynamic dispatch.
type IUnlockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNLOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsUnlockTablesContext differentiates from other interfaces.
	IsUnlockTablesContext()
}

type UnlockTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlockTablesContext() *UnlockTablesContext {
	var p = new(UnlockTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unlockTables
	return p
}

func InitEmptyUnlockTablesContext(p *UnlockTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unlockTables
}

func (*UnlockTablesContext) IsUnlockTablesContext() {}

func NewUnlockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlockTablesContext {
	var p = new(UnlockTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unlockTables

	return p
}

func (s *UnlockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlockTablesContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNLOCK, 0)
}

func (s *UnlockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *UnlockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnlockTables(s)
	}
}

func (s *UnlockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnlockTables(s)
	}
}

func (s *UnlockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnlockTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnlockTables() (localctx IUnlockTablesContext) {
	localctx = NewUnlockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, MySqlParserRULE_unlockTables)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4381)
		p.Match(MySqlParserUNLOCK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4382)
		p.Match(MySqlParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetAutocommitStatementContext is an interface to support dynamic dispatch.
type ISetAutocommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutocommitValue returns the autocommitValue token.
	GetAutocommitValue() antlr.Token

	// SetAutocommitValue sets the autocommitValue token.
	SetAutocommitValue(antlr.Token)

	// Getter signatures
	SET() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsSetAutocommitStatementContext differentiates from other interfaces.
	IsSetAutocommitStatementContext()
}

type SetAutocommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	autocommitValue antlr.Token
}

func NewEmptySetAutocommitStatementContext() *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement
	return p
}

func InitEmptySetAutocommitStatementContext(p *SetAutocommitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement
}

func (*SetAutocommitStatementContext) IsSetAutocommitStatementContext() {}

func NewSetAutocommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement

	return p
}

func (s *SetAutocommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAutocommitStatementContext) GetAutocommitValue() antlr.Token { return s.autocommitValue }

func (s *SetAutocommitStatementContext) SetAutocommitValue(v antlr.Token) { s.autocommitValue = v }

func (s *SetAutocommitStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetAutocommitStatementContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOCOMMIT, 0)
}

func (s *SetAutocommitStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SetAutocommitStatementContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAutocommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetAutocommitStatement(s)
	}
}

func (s *SetAutocommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetAutocommitStatement(s)
	}
}

func (s *SetAutocommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetAutocommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SetAutocommitStatement() (localctx ISetAutocommitStatementContext) {
	localctx = NewSetAutocommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, MySqlParserRULE_setAutocommitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4384)
		p.Match(MySqlParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4385)
		p.Match(MySqlParserAUTOCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4386)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4387)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SetAutocommitStatementContext).autocommitValue = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SetAutocommitStatementContext).autocommitValue = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTransactionStatementContext is an interface to support dynamic dispatch.
type ISetTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTransactionContext returns the transactionContext token.
	GetTransactionContext() antlr.Token

	// SetTransactionContext sets the transactionContext token.
	SetTransactionContext(antlr.Token)

	// Getter signatures
	SET() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionOption() []ITransactionOptionContext
	TransactionOption(i int) ITransactionOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsSetTransactionStatementContext differentiates from other interfaces.
	IsSetTransactionStatementContext()
}

type SetTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	transactionContext antlr.Token
}

func NewEmptySetTransactionStatementContext() *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setTransactionStatement
	return p
}

func InitEmptySetTransactionStatementContext(p *SetTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setTransactionStatement
}

func (*SetTransactionStatementContext) IsSetTransactionStatementContext() {}

func NewSetTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setTransactionStatement

	return p
}

func (s *SetTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTransactionStatementContext) GetTransactionContext() antlr.Token {
	return s.transactionContext
}

func (s *SetTransactionStatementContext) SetTransactionContext(v antlr.Token) {
	s.transactionContext = v
}

func (s *SetTransactionStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *SetTransactionStatementContext) AllTransactionOption() []ITransactionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			len++
		}
	}

	tst := make([]ITransactionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionOptionContext); ok {
			tst[i] = t.(ITransactionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SetTransactionStatementContext) TransactionOption(i int) ITransactionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionOptionContext)
}

func (s *SetTransactionStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetTransactionStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetTransactionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *SetTransactionStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *SetTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetTransactionStatement(s)
	}
}

func (s *SetTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetTransactionStatement(s)
	}
}

func (s *SetTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SetTransactionStatement() (localctx ISetTransactionStatementContext) {
	localctx = NewSetTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, MySqlParserRULE_setTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4389)
		p.Match(MySqlParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserGLOBAL || _la == MySqlParserSESSION {
		{
			p.SetState(4390)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SetTransactionStatementContext).transactionContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserGLOBAL || _la == MySqlParserSESSION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SetTransactionStatementContext).transactionContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4393)
		p.Match(MySqlParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4394)
		p.TransactionOption()
	}
	p.SetState(4399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4395)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4396)
			p.TransactionOption()
		}

		p.SetState(4401)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionMode
	return p
}

func InitEmptyTransactionModeContext(p *TransactionModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionMode
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *TransactionModeContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSISTENT, 0)
}

func (s *TransactionModeContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSNAPSHOT, 0)
}

func (s *TransactionModeContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *TransactionModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionMode(s)
	}
}

func (s *TransactionModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionMode(s)
	}
}

func (s *TransactionModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionMode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, MySqlParserRULE_transactionMode)
	p.SetState(4409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 654, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4402)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4403)
			p.Match(MySqlParserCONSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4404)
			p.Match(MySqlParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4405)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4406)
			p.Match(MySqlParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4407)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4408)
			p.Match(MySqlParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockTableElementContext is an interface to support dynamic dispatch.
type ILockTableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	LockAction() ILockActionContext
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLockTableElementContext differentiates from other interfaces.
	IsLockTableElementContext()
}

type LockTableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTableElementContext() *LockTableElementContext {
	var p = new(LockTableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTableElement
	return p
}

func InitEmptyLockTableElementContext(p *LockTableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTableElement
}

func (*LockTableElementContext) IsLockTableElementContext() {}

func NewLockTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTableElementContext {
	var p = new(LockTableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockTableElement

	return p
}

func (s *LockTableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTableElementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LockTableElementContext) LockAction() ILockActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockActionContext)
}

func (s *LockTableElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LockTableElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *LockTableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockTableElement(s)
	}
}

func (s *LockTableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockTableElement(s)
	}
}

func (s *LockTableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LockTableElement() (localctx ILockTableElementContext) {
	localctx = NewLockTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, MySqlParserRULE_lockTableElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4411)
		p.TableName()
	}
	p.SetState(4416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256563200) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		p.SetState(4413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(4412)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4415)
			p.Uid()
		}

	}
	{
		p.SetState(4418)
		p.LockAction()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockActionContext is an interface to support dynamic dispatch.
type ILockActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLockActionContext differentiates from other interfaces.
	IsLockActionContext()
}

type LockActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockActionContext() *LockActionContext {
	var p = new(LockActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockAction
	return p
}

func InitEmptyLockActionContext(p *LockActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lockAction
}

func (*LockActionContext) IsLockActionContext() {}

func NewLockActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockActionContext {
	var p = new(LockActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockAction

	return p
}

func (s *LockActionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockActionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *LockActionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LockActionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *LockActionContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LockActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockAction(s)
	}
}

func (s *LockActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockAction(s)
	}
}

func (s *LockActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LockAction() (localctx ILockActionContext) {
	localctx = NewLockActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, MySqlParserRULE_lockAction)
	var _la int

	p.SetState(4428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4420)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLOCAL {
			{
				p.SetState(4421)
				p.Match(MySqlParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MySqlParserLOW_PRIORITY, MySqlParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLOW_PRIORITY {
			{
				p.SetState(4424)
				p.Match(MySqlParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4427)
			p.Match(MySqlParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionOptionContext is an interface to support dynamic dispatch.
type ITransactionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	TransactionLevel() ITransactionLevelContext
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionOptionContext differentiates from other interfaces.
	IsTransactionOptionContext()
}

type TransactionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionOptionContext() *TransactionOptionContext {
	var p = new(TransactionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionOption
	return p
}

func InitEmptyTransactionOptionContext(p *TransactionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionOption
}

func (*TransactionOptionContext) IsTransactionOptionContext() {}

func NewTransactionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionOptionContext {
	var p = new(TransactionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionOption

	return p
}

func (s *TransactionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionOptionContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserISOLATION, 0)
}

func (s *TransactionOptionContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *TransactionOptionContext) TransactionLevel() ITransactionLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelContext)
}

func (s *TransactionOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionOptionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *TransactionOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *TransactionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionOption(s)
	}
}

func (s *TransactionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionOption(s)
	}
}

func (s *TransactionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TransactionOption() (localctx ITransactionOptionContext) {
	localctx = NewTransactionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, MySqlParserRULE_transactionOption)
	p.SetState(4437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 660, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4430)
			p.Match(MySqlParserISOLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4431)
			p.Match(MySqlParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4432)
			p.TransactionLevel()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4433)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4434)
			p.Match(MySqlParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4435)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4436)
			p.Match(MySqlParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionLevelContext is an interface to support dynamic dispatch.
type ITransactionLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	READ() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelContext differentiates from other interfaces.
	IsTransactionLevelContext()
}

type TransactionLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelContext() *TransactionLevelContext {
	var p = new(TransactionLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevel
	return p
}

func InitEmptyTransactionLevelContext(p *TransactionLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevel
}

func (*TransactionLevelContext) IsTransactionLevelContext() {}

func NewTransactionLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelContext {
	var p = new(TransactionLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionLevel

	return p
}

func (s *TransactionLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEATABLE, 0)
}

func (s *TransactionLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMITTED, 0)
}

func (s *TransactionLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMMITTED, 0)
}

func (s *TransactionLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIALIZABLE, 0)
}

func (s *TransactionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionLevel(s)
	}
}

func (s *TransactionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionLevel(s)
	}
}

func (s *TransactionLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TransactionLevel() (localctx ITransactionLevelContext) {
	localctx = NewTransactionLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, MySqlParserRULE_transactionLevel)
	p.SetState(4446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 661, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4439)
			p.Match(MySqlParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4440)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4441)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4442)
			p.Match(MySqlParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4443)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4444)
			p.Match(MySqlParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4445)
			p.Match(MySqlParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeMasterContext is an interface to support dynamic dispatch.
type IChangeMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllMasterOption() []IMasterOptionContext
	MasterOption(i int) IMasterOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsChangeMasterContext differentiates from other interfaces.
	IsChangeMasterContext()
}

type ChangeMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterContext() *ChangeMasterContext {
	var p = new(ChangeMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeMaster
	return p
}

func InitEmptyChangeMasterContext(p *ChangeMasterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeMaster
}

func (*ChangeMasterContext) IsChangeMasterContext() {}

func NewChangeMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterContext {
	var p = new(ChangeMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_changeMaster

	return p
}

func (s *ChangeMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *ChangeMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ChangeMasterContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *ChangeMasterContext) AllMasterOption() []IMasterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterOptionContext); ok {
			len++
		}
	}

	tst := make([]IMasterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterOptionContext); ok {
			tst[i] = t.(IMasterOptionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeMasterContext) MasterOption(i int) IMasterOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterOptionContext)
}

func (s *ChangeMasterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ChangeMasterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ChangeMasterContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ChangeMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChangeMaster(s)
	}
}

func (s *ChangeMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChangeMaster(s)
	}
}

func (s *ChangeMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChangeMaster(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ChangeMaster() (localctx IChangeMasterContext) {
	localctx = NewChangeMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, MySqlParserRULE_changeMaster)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4448)
		p.Match(MySqlParserCHANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4449)
		p.Match(MySqlParserMASTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4450)
		p.Match(MySqlParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4451)
		p.MasterOption()
	}
	p.SetState(4456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4452)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4453)
			p.MasterOption()
		}

		p.SetState(4458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(4459)
			p.ChannelOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeReplicationFilterContext is an interface to support dynamic dispatch.
type IChangeReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	AllReplicationFilter() []IReplicationFilterContext
	ReplicationFilter(i int) IReplicationFilterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChangeReplicationFilterContext differentiates from other interfaces.
	IsChangeReplicationFilterContext()
}

type ChangeReplicationFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeReplicationFilterContext() *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter
	return p
}

func InitEmptyChangeReplicationFilterContext(p *ChangeReplicationFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter
}

func (*ChangeReplicationFilterContext) IsChangeReplicationFilterContext() {}

func NewChangeReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter

	return p
}

func (s *ChangeReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeReplicationFilterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *ChangeReplicationFilterContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *ChangeReplicationFilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILTER, 0)
}

func (s *ChangeReplicationFilterContext) AllReplicationFilter() []IReplicationFilterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			len++
		}
	}

	tst := make([]IReplicationFilterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplicationFilterContext); ok {
			tst[i] = t.(IReplicationFilterContext)
			i++
		}
	}

	return tst
}

func (s *ChangeReplicationFilterContext) ReplicationFilter(i int) IReplicationFilterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationFilterContext)
}

func (s *ChangeReplicationFilterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ChangeReplicationFilterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ChangeReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeReplicationFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChangeReplicationFilter(s)
	}
}

func (s *ChangeReplicationFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChangeReplicationFilter(s)
	}
}

func (s *ChangeReplicationFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChangeReplicationFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ChangeReplicationFilter() (localctx IChangeReplicationFilterContext) {
	localctx = NewChangeReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, MySqlParserRULE_changeReplicationFilter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4462)
		p.Match(MySqlParserCHANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4463)
		p.Match(MySqlParserREPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4464)
		p.Match(MySqlParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4465)
		p.ReplicationFilter()
	}
	p.SetState(4470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4466)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4467)
			p.ReplicationFilter()
		}

		p.SetState(4472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPurgeBinaryLogsContext is an interface to support dynamic dispatch.
type IPurgeBinaryLogsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPurgeFormat returns the purgeFormat token.
	GetPurgeFormat() antlr.Token

	// GetFileName returns the fileName token.
	GetFileName() antlr.Token

	// GetTimeValue returns the timeValue token.
	GetTimeValue() antlr.Token

	// SetPurgeFormat sets the purgeFormat token.
	SetPurgeFormat(antlr.Token)

	// SetFileName sets the fileName token.
	SetFileName(antlr.Token)

	// SetTimeValue sets the timeValue token.
	SetTimeValue(antlr.Token)

	// Getter signatures
	PURGE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsPurgeBinaryLogsContext differentiates from other interfaces.
	IsPurgeBinaryLogsContext()
}

type PurgeBinaryLogsContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	purgeFormat antlr.Token
	fileName    antlr.Token
	timeValue   antlr.Token
}

func NewEmptyPurgeBinaryLogsContext() *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs
	return p
}

func InitEmptyPurgeBinaryLogsContext(p *PurgeBinaryLogsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs
}

func (*PurgeBinaryLogsContext) IsPurgeBinaryLogsContext() {}

func NewPurgeBinaryLogsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs

	return p
}

func (s *PurgeBinaryLogsContext) GetParser() antlr.Parser { return s.parser }

func (s *PurgeBinaryLogsContext) GetPurgeFormat() antlr.Token { return s.purgeFormat }

func (s *PurgeBinaryLogsContext) GetFileName() antlr.Token { return s.fileName }

func (s *PurgeBinaryLogsContext) GetTimeValue() antlr.Token { return s.timeValue }

func (s *PurgeBinaryLogsContext) SetPurgeFormat(v antlr.Token) { s.purgeFormat = v }

func (s *PurgeBinaryLogsContext) SetFileName(v antlr.Token) { s.fileName = v }

func (s *PurgeBinaryLogsContext) SetTimeValue(v antlr.Token) { s.timeValue = v }

func (s *PurgeBinaryLogsContext) PURGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPURGE, 0)
}

func (s *PurgeBinaryLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *PurgeBinaryLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *PurgeBinaryLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *PurgeBinaryLogsContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *PurgeBinaryLogsContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEFORE, 0)
}

func (s *PurgeBinaryLogsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PurgeBinaryLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PurgeBinaryLogsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PurgeBinaryLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPurgeBinaryLogs(s)
	}
}

func (s *PurgeBinaryLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPurgeBinaryLogs(s)
	}
}

func (s *PurgeBinaryLogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPurgeBinaryLogs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PurgeBinaryLogs() (localctx IPurgeBinaryLogsContext) {
	localctx = NewPurgeBinaryLogsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, MySqlParserRULE_purgeBinaryLogs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4473)
		p.Match(MySqlParserPURGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4474)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PurgeBinaryLogsContext).purgeFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBINARY || _la == MySqlParserMASTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PurgeBinaryLogsContext).purgeFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4475)
		p.Match(MySqlParserLOGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserTO:
		{
			p.SetState(4476)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4477)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).fileName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBEFORE:
		{
			p.SetState(4478)
			p.Match(MySqlParserBEFORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4479)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).timeValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetMasterContext is an interface to support dynamic dispatch.
type IResetMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	MASTER() antlr.TerminalNode

	// IsResetMasterContext differentiates from other interfaces.
	IsResetMasterContext()
}

type ResetMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetMasterContext() *ResetMasterContext {
	var p = new(ResetMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetMaster
	return p
}

func InitEmptyResetMasterContext(p *ResetMasterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetMaster
}

func (*ResetMasterContext) IsResetMasterContext() {}

func NewResetMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetMasterContext {
	var p = new(ResetMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetMaster

	return p
}

func (s *ResetMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetMasterContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ResetMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetMaster(s)
	}
}

func (s *ResetMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetMaster(s)
	}
}

func (s *ResetMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResetMaster(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ResetMaster() (localctx IResetMasterContext) {
	localctx = NewResetMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, MySqlParserRULE_resetMaster)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4482)
		p.Match(MySqlParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4483)
		p.Match(MySqlParserMASTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetSlaveContext is an interface to support dynamic dispatch.
type IResetSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsResetSlaveContext differentiates from other interfaces.
	IsResetSlaveContext()
}

type ResetSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetSlaveContext() *ResetSlaveContext {
	var p = new(ResetSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetSlave
	return p
}

func InitEmptyResetSlaveContext(p *ResetSlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetSlave
}

func (*ResetSlaveContext) IsResetSlaveContext() {}

func NewResetSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetSlaveContext {
	var p = new(ResetSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetSlave

	return p
}

func (s *ResetSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetSlaveContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ResetSlaveContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ResetSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ResetSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetSlave(s)
	}
}

func (s *ResetSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetSlave(s)
	}
}

func (s *ResetSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResetSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ResetSlave() (localctx IResetSlaveContext) {
	localctx = NewResetSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, MySqlParserRULE_resetSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4485)
		p.Match(MySqlParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4486)
		p.Match(MySqlParserSLAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL {
		{
			p.SetState(4487)
			p.Match(MySqlParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(4490)
			p.ChannelOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartSlaveContext is an interface to support dynamic dispatch.
type IStartSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	UNTIL() antlr.TerminalNode
	UntilOption() IUntilOptionContext
	AllConnectionOption() []IConnectionOptionContext
	ConnectionOption(i int) IConnectionOptionContext
	ChannelOption() IChannelOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartSlaveContext differentiates from other interfaces.
	IsStartSlaveContext()
}

type StartSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartSlaveContext() *StartSlaveContext {
	var p = new(StartSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startSlave
	return p
}

func InitEmptyStartSlaveContext(p *StartSlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startSlave
}

func (*StartSlaveContext) IsStartSlaveContext() {}

func NewStartSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartSlaveContext {
	var p = new(StartSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startSlave

	return p
}

func (s *StartSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StartSlaveContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *StartSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StartSlaveContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *StartSlaveContext) UntilOption() IUntilOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUntilOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUntilOptionContext)
}

func (s *StartSlaveContext) AllConnectionOption() []IConnectionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			len++
		}
	}

	tst := make([]IConnectionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConnectionOptionContext); ok {
			tst[i] = t.(IConnectionOptionContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ConnectionOption(i int) IConnectionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectionOptionContext)
}

func (s *StartSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *StartSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StartSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StartSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartSlave(s)
	}
}

func (s *StartSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartSlave(s)
	}
}

func (s *StartSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStartSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StartSlave() (localctx IStartSlaveContext) {
	localctx = NewStartSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, MySqlParserRULE_startSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4493)
		p.Match(MySqlParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4494)
		p.Match(MySqlParserSLAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD {
		{
			p.SetState(4495)
			p.ThreadType()
		}
		p.SetState(4500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4496)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4497)
				p.ThreadType()
			}

			p.SetState(4502)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUNTIL {
		{
			p.SetState(4505)
			p.Match(MySqlParserUNTIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4506)
			p.UntilOption()
		}

	}
	p.SetState(4512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDEFAULT_AUTH || _la == MySqlParserPASSWORD || _la == MySqlParserPLUGIN_DIR || _la == MySqlParserUSER {
		{
			p.SetState(4509)
			p.ConnectionOption()
		}

		p.SetState(4514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(4515)
			p.ChannelOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopSlaveContext is an interface to support dynamic dispatch.
type IStopSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStopSlaveContext differentiates from other interfaces.
	IsStopSlaveContext()
}

type StopSlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopSlaveContext() *StopSlaveContext {
	var p = new(StopSlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopSlave
	return p
}

func InitEmptyStopSlaveContext(p *StopSlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopSlave
}

func (*StopSlaveContext) IsStopSlaveContext() {}

func NewStopSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopSlaveContext {
	var p = new(StopSlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stopSlave

	return p
}

func (s *StopSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StopSlaveContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *StopSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *StopSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StopSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StopSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StopSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StopSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStopSlave(s)
	}
}

func (s *StopSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStopSlave(s)
	}
}

func (s *StopSlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStopSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StopSlave() (localctx IStopSlaveContext) {
	localctx = NewStopSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, MySqlParserRULE_stopSlave)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4518)
		p.Match(MySqlParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4519)
		p.Match(MySqlParserSLAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD {
		{
			p.SetState(4520)
			p.ThreadType()
		}
		p.SetState(4525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4521)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4522)
				p.ThreadType()
			}

			p.SetState(4527)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartGroupReplicationContext is an interface to support dynamic dispatch.
type IStartGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStartGroupReplicationContext differentiates from other interfaces.
	IsStartGroupReplicationContext()
}

type StartGroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartGroupReplicationContext() *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startGroupReplication
	return p
}

func InitEmptyStartGroupReplicationContext(p *StartGroupReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_startGroupReplication
}

func (*StartGroupReplicationContext) IsStartGroupReplicationContext() {}

func NewStartGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startGroupReplication

	return p
}

func (s *StartGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StartGroupReplicationContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *StartGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartGroupReplication(s)
	}
}

func (s *StartGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartGroupReplication(s)
	}
}

func (s *StartGroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStartGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StartGroupReplication() (localctx IStartGroupReplicationContext) {
	localctx = NewStartGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, MySqlParserRULE_startGroupReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4530)
		p.Match(MySqlParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4531)
		p.Match(MySqlParserGROUP_REPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopGroupReplicationContext is an interface to support dynamic dispatch.
type IStopGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStopGroupReplicationContext differentiates from other interfaces.
	IsStopGroupReplicationContext()
}

type StopGroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopGroupReplicationContext() *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopGroupReplication
	return p
}

func InitEmptyStopGroupReplicationContext(p *StopGroupReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stopGroupReplication
}

func (*StopGroupReplicationContext) IsStopGroupReplicationContext() {}

func NewStopGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stopGroupReplication

	return p
}

func (s *StopGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StopGroupReplicationContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *StopGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *StopGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStopGroupReplication(s)
	}
}

func (s *StopGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStopGroupReplication(s)
	}
}

func (s *StopGroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStopGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StopGroupReplication() (localctx IStopGroupReplicationContext) {
	localctx = NewStopGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, MySqlParserRULE_stopGroupReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4533)
		p.Match(MySqlParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4534)
		p.Match(MySqlParserGROUP_REPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterOptionContext is an interface to support dynamic dispatch.
type IMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMasterOptionContext differentiates from other interfaces.
	IsMasterOptionContext()
}

type MasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterOptionContext() *MasterOptionContext {
	var p = new(MasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_masterOption
	return p
}

func InitEmptyMasterOptionContext(p *MasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_masterOption
}

func (*MasterOptionContext) IsMasterOptionContext() {}

func NewMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterOptionContext {
	var p = new(MasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_masterOption

	return p
}

func (s *MasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterOptionContext) CopyAll(ctx *MasterOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MasterStringOptionContext struct {
	MasterOptionContext
}

func NewMasterStringOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterStringOptionContext {
	var p = new(MasterStringOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterStringOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterStringOptionContext) StringMasterOption() IStringMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringMasterOptionContext)
}

func (s *MasterStringOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterStringOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *MasterStringOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterStringOption(s)
	}
}

func (s *MasterStringOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterStringOption(s)
	}
}

func (s *MasterStringOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterStringOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterRealOptionContext struct {
	MasterOptionContext
}

func NewMasterRealOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterRealOptionContext {
	var p = new(MasterRealOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterRealOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterRealOptionContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *MasterRealOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterRealOptionContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *MasterRealOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterRealOption(s)
	}
}

func (s *MasterRealOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterRealOption(s)
	}
}

func (s *MasterRealOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterRealOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterBoolOptionContext struct {
	MasterOptionContext
	boolVal antlr.Token
}

func NewMasterBoolOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterBoolOptionContext {
	var p = new(MasterBoolOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterBoolOptionContext) GetBoolVal() antlr.Token { return s.boolVal }

func (s *MasterBoolOptionContext) SetBoolVal(v antlr.Token) { s.boolVal = v }

func (s *MasterBoolOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterBoolOptionContext) BoolMasterOption() IBoolMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolMasterOptionContext)
}

func (s *MasterBoolOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterBoolOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *MasterBoolOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *MasterBoolOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterBoolOption(s)
	}
}

func (s *MasterBoolOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterBoolOption(s)
	}
}

func (s *MasterBoolOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterBoolOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterUidListOptionContext struct {
	MasterOptionContext
}

func NewMasterUidListOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterUidListOptionContext {
	var p = new(MasterUidListOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterUidListOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterUidListOptionContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE_SERVER_IDS, 0)
}

func (s *MasterUidListOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterUidListOptionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *MasterUidListOptionContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *MasterUidListOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MasterUidListOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MasterUidListOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterUidListOption(s)
	}
}

func (s *MasterUidListOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterUidListOption(s)
	}
}

func (s *MasterUidListOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterUidListOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterDecimalOptionContext struct {
	MasterOptionContext
}

func NewMasterDecimalOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterDecimalOptionContext {
	var p = new(MasterDecimalOptionContext)

	InitEmptyMasterOptionContext(&p.MasterOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterDecimalOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterDecimalOptionContext) DecimalMasterOption() IDecimalMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalMasterOptionContext)
}

func (s *MasterDecimalOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterDecimalOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *MasterDecimalOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterDecimalOption(s)
	}
}

func (s *MasterDecimalOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterDecimalOption(s)
	}
}

func (s *MasterDecimalOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterDecimalOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) MasterOption() (localctx IMasterOptionContext) {
	localctx = NewMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, MySqlParserRULE_masterOption)
	var _la int

	p.SetState(4565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserMASTER_BIND, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserRELAY_LOG_FILE:
		localctx = NewMasterStringOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4536)
			p.StringMasterOption()
		}
		{
			p.SetState(4537)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4538)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserRELAY_LOG_POS:
		localctx = NewMasterDecimalOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4540)
			p.DecimalMasterOption()
		}
		{
			p.SetState(4541)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4542)
			p.DecimalLiteral()
		}

	case MySqlParserMASTER_SSL_VERIFY_SERVER_CERT, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_SSL:
		localctx = NewMasterBoolOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4544)
			p.BoolMasterOption()
		}
		{
			p.SetState(4545)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4546)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*MasterBoolOptionContext).boolVal = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*MasterBoolOptionContext).boolVal = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserMASTER_HEARTBEAT_PERIOD:
		localctx = NewMasterRealOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4548)
			p.Match(MySqlParserMASTER_HEARTBEAT_PERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4549)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4550)
			p.Match(MySqlParserREAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserIGNORE_SERVER_IDS:
		localctx = NewMasterUidListOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4551)
			p.Match(MySqlParserIGNORE_SERVER_IDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4552)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4553)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
			{
				p.SetState(4554)
				p.Uid()
			}
			p.SetState(4559)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(4555)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4556)
					p.Uid()
				}

				p.SetState(4561)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4564)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringMasterOptionContext is an interface to support dynamic dispatch.
type IStringMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_BIND() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode

	// IsStringMasterOptionContext differentiates from other interfaces.
	IsStringMasterOptionContext()
}

type StringMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringMasterOptionContext() *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringMasterOption
	return p
}

func InitEmptyStringMasterOptionContext(p *StringMasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringMasterOption
}

func (*StringMasterOptionContext) IsStringMasterOptionContext() {}

func NewStringMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringMasterOption

	return p
}

func (s *StringMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringMasterOptionContext) MASTER_BIND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_BIND, 0)
}

func (s *StringMasterOptionContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HOST, 0)
}

func (s *StringMasterOptionContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_USER, 0)
}

func (s *StringMasterOptionContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PASSWORD, 0)
}

func (s *StringMasterOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CA, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CAPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CERT, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRL, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRLPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_KEY, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CIPHER, 0)
}

func (s *StringMasterOptionContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_TLS_VERSION, 0)
}

func (s *StringMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringMasterOption(s)
	}
}

func (s *StringMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringMasterOption(s)
	}
}

func (s *StringMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StringMasterOption() (localctx IStringMasterOptionContext) {
	localctx = NewStringMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, MySqlParserRULE_stringMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4567)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMASTER_BIND || ((int64((_la-481)) & ^0x3f) == 0 && ((int64(1)<<(_la-481))&65419) != 0) || _la == MySqlParserRELAY_LOG_FILE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalMasterOptionContext is an interface to support dynamic dispatch.
type IDecimalMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_PORT() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode

	// IsDecimalMasterOptionContext differentiates from other interfaces.
	IsDecimalMasterOptionContext()
}

type DecimalMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalMasterOptionContext() *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalMasterOption
	return p
}

func InitEmptyDecimalMasterOptionContext(p *DecimalMasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalMasterOption
}

func (*DecimalMasterOptionContext) IsDecimalMasterOptionContext() {}

func NewDecimalMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalMasterOption

	return p
}

func (s *DecimalMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalMasterOptionContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PORT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_CONNECT_RETRY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_RETRY_COUNT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_DELAY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDecimalMasterOption(s)
	}
}

func (s *DecimalMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDecimalMasterOption(s)
	}
}

func (s *DecimalMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDecimalMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DecimalMasterOption() (localctx IDecimalMasterOptionContext) {
	localctx = NewDecimalMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, MySqlParserRULE_decimalMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4569)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-478)) & ^0x3f) == 0 && ((int64(1)<<(_la-478))&419) != 0) || _la == MySqlParserRELAY_LOG_POS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolMasterOptionContext is an interface to support dynamic dispatch.
type IBoolMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode

	// IsBoolMasterOptionContext differentiates from other interfaces.
	IsBoolMasterOptionContext()
}

type BoolMasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolMasterOptionContext() *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_boolMasterOption
	return p
}

func InitEmptyBoolMasterOptionContext(p *BoolMasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_boolMasterOption
}

func (*BoolMasterOptionContext) IsBoolMasterOptionContext() {}

func NewBoolMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_boolMasterOption

	return p
}

func (s *BoolMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolMasterOptionContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_AUTO_POSITION, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_VERIFY_SERVER_CERT, 0)
}

func (s *BoolMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBoolMasterOption(s)
	}
}

func (s *BoolMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBoolMasterOption(s)
	}
}

func (s *BoolMasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBoolMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BoolMasterOption() (localctx IBoolMasterOptionContext) {
	localctx = NewBoolMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, MySqlParserRULE_boolMasterOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4571)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMASTER_SSL_VERIFY_SERVER_CERT || _la == MySqlParserMASTER_AUTO_POSITION || _la == MySqlParserMASTER_SSL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelOptionContext is an interface to support dynamic dispatch.
type IChannelOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsChannelOptionContext differentiates from other interfaces.
	IsChannelOptionContext()
}

type ChannelOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelOptionContext() *ChannelOptionContext {
	var p = new(ChannelOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_channelOption
	return p
}

func InitEmptyChannelOptionContext(p *ChannelOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_channelOption
}

func (*ChannelOptionContext) IsChannelOptionContext() {}

func NewChannelOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelOptionContext {
	var p = new(ChannelOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_channelOption

	return p
}

func (s *ChannelOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ChannelOptionContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *ChannelOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ChannelOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChannelOption(s)
	}
}

func (s *ChannelOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChannelOption(s)
	}
}

func (s *ChannelOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChannelOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ChannelOption() (localctx IChannelOptionContext) {
	localctx = NewChannelOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, MySqlParserRULE_channelOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4573)
		p.Match(MySqlParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4574)
		p.Match(MySqlParserCHANNEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4575)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationFilterContext is an interface to support dynamic dispatch.
type IReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReplicationFilterContext differentiates from other interfaces.
	IsReplicationFilterContext()
}

type ReplicationFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationFilterContext() *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationFilter
	return p
}

func InitEmptyReplicationFilterContext(p *ReplicationFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationFilter
}

func (*ReplicationFilterContext) IsReplicationFilterContext() {}

func NewReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replicationFilter

	return p
}

func (s *ReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationFilterContext) CopyAll(ctx *ReplicationFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WildIgnoreTableReplicationContext struct {
	ReplicationFilterContext
}

func NewWildIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildIgnoreTableReplicationContext {
	var p = new(WildIgnoreTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildIgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildIgnoreTableReplicationContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *WildIgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *WildIgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *WildIgnoreTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildIgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *WildIgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWildIgnoreTableReplication(s)
	}
}

func (s *WildIgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWildIgnoreTableReplication(s)
	}
}

func (s *WildIgnoreTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWildIgnoreTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoTableReplicationContext struct {
	ReplicationFilterContext
}

func NewDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoTableReplicationContext {
	var p = new(DoTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoTableReplicationContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_TABLE, 0)
}

func (s *DoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DoTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoTableReplication(s)
	}
}

func (s *DoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoTableReplication(s)
	}
}

func (s *DoTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDoTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type IgnoreTableReplicationContext struct {
	ReplicationFilterContext
}

func NewIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreTableReplicationContext {
	var p = new(IgnoreTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreTableReplicationContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *IgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IgnoreTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *IgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIgnoreTableReplication(s)
	}
}

func (s *IgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIgnoreTableReplication(s)
	}
}

func (s *IgnoreTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIgnoreTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type RewriteDbReplicationContext struct {
	ReplicationFilterContext
}

func NewRewriteDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RewriteDbReplicationContext {
	var p = new(RewriteDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *RewriteDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteDbReplicationContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_REWRITE_DB, 0)
}

func (s *RewriteDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *RewriteDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllTablePair() []ITablePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePairContext); ok {
			len++
		}
	}

	tst := make([]ITablePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePairContext); ok {
			tst[i] = t.(ITablePairContext)
			i++
		}
	}

	return tst
}

func (s *RewriteDbReplicationContext) TablePair(i int) ITablePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePairContext)
}

func (s *RewriteDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RewriteDbReplicationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RewriteDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRewriteDbReplication(s)
	}
}

func (s *RewriteDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRewriteDbReplication(s)
	}
}

func (s *RewriteDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRewriteDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoDbReplicationContext struct {
	ReplicationFilterContext
}

func NewDoDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoDbReplicationContext {
	var p = new(DoDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoDbReplicationContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_DB, 0)
}

func (s *DoDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DoDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DoDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DoDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DoDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoDbReplication(s)
	}
}

func (s *DoDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoDbReplication(s)
	}
}

func (s *DoDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDoDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type IgnoreDbReplicationContext struct {
	ReplicationFilterContext
}

func NewIgnoreDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreDbReplicationContext {
	var p = new(IgnoreDbReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreDbReplicationContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_DB, 0)
}

func (s *IgnoreDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IgnoreDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IgnoreDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IgnoreDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIgnoreDbReplication(s)
	}
}

func (s *IgnoreDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIgnoreDbReplication(s)
	}
}

func (s *IgnoreDbReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIgnoreDbReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

type WildDoTableReplicationContext struct {
	ReplicationFilterContext
}

func NewWildDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildDoTableReplicationContext {
	var p = new(WildDoTableReplicationContext)

	InitEmptyReplicationFilterContext(&p.ReplicationFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildDoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildDoTableReplicationContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *WildDoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *WildDoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *WildDoTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildDoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *WildDoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWildDoTableReplication(s)
	}
}

func (s *WildDoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWildDoTableReplication(s)
	}
}

func (s *WildDoTableReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWildDoTableReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReplicationFilter() (localctx IReplicationFilterContext) {
	localctx = NewReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, MySqlParserRULE_replicationFilter)
	var _la int

	p.SetState(4626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserREPLICATE_DO_DB:
		localctx = NewDoDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4577)
			p.Match(MySqlParserREPLICATE_DO_DB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4578)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4579)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4580)
			p.UidList()
		}
		{
			p.SetState(4581)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPLICATE_IGNORE_DB:
		localctx = NewIgnoreDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4583)
			p.Match(MySqlParserREPLICATE_IGNORE_DB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4584)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4585)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4586)
			p.UidList()
		}
		{
			p.SetState(4587)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPLICATE_DO_TABLE:
		localctx = NewDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4589)
			p.Match(MySqlParserREPLICATE_DO_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4590)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4591)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4592)
			p.Tables()
		}
		{
			p.SetState(4593)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPLICATE_IGNORE_TABLE:
		localctx = NewIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4595)
			p.Match(MySqlParserREPLICATE_IGNORE_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4596)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4597)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4598)
			p.Tables()
		}
		{
			p.SetState(4599)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPLICATE_WILD_DO_TABLE:
		localctx = NewWildDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4601)
			p.Match(MySqlParserREPLICATE_WILD_DO_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4602)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4603)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4604)
			p.SimpleStrings()
		}
		{
			p.SetState(4605)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPLICATE_WILD_IGNORE_TABLE:
		localctx = NewWildIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4607)
			p.Match(MySqlParserREPLICATE_WILD_IGNORE_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4608)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4609)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4610)
			p.SimpleStrings()
		}
		{
			p.SetState(4611)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPLICATE_REWRITE_DB:
		localctx = NewRewriteDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4613)
			p.Match(MySqlParserREPLICATE_REWRITE_DB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4614)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4615)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4616)
			p.TablePair()
		}
		p.SetState(4621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4617)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4618)
				p.TablePair()
			}

			p.SetState(4623)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4624)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePairContext is an interface to support dynamic dispatch.
type ITablePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirstTable returns the firstTable rule contexts.
	GetFirstTable() ITableNameContext

	// GetSecondTable returns the secondTable rule contexts.
	GetSecondTable() ITableNameContext

	// SetFirstTable sets the firstTable rule contexts.
	SetFirstTable(ITableNameContext)

	// SetSecondTable sets the secondTable rule contexts.
	SetSecondTable(ITableNameContext)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext

	// IsTablePairContext differentiates from other interfaces.
	IsTablePairContext()
}

type TablePairContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	firstTable  ITableNameContext
	secondTable ITableNameContext
}

func NewEmptyTablePairContext() *TablePairContext {
	var p = new(TablePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablePair
	return p
}

func InitEmptyTablePairContext(p *TablePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tablePair
}

func (*TablePairContext) IsTablePairContext() {}

func NewTablePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePairContext {
	var p = new(TablePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tablePair

	return p
}

func (s *TablePairContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePairContext) GetFirstTable() ITableNameContext { return s.firstTable }

func (s *TablePairContext) GetSecondTable() ITableNameContext { return s.secondTable }

func (s *TablePairContext) SetFirstTable(v ITableNameContext) { s.firstTable = v }

func (s *TablePairContext) SetSecondTable(v ITableNameContext) { s.secondTable = v }

func (s *TablePairContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TablePairContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *TablePairContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TablePairContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablePairContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTablePair(s)
	}
}

func (s *TablePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTablePair(s)
	}
}

func (s *TablePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTablePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TablePair() (localctx ITablePairContext) {
	localctx = NewTablePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, MySqlParserRULE_tablePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4628)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4629)

		var _x = p.TableName()

		localctx.(*TablePairContext).firstTable = _x
	}
	{
		p.SetState(4630)
		p.Match(MySqlParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4631)

		var _x = p.TableName()

		localctx.(*TablePairContext).secondTable = _x
	}
	{
		p.SetState(4632)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThreadTypeContext is an interface to support dynamic dispatch.
type IThreadTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IO_THREAD() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode

	// IsThreadTypeContext differentiates from other interfaces.
	IsThreadTypeContext()
}

type ThreadTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThreadTypeContext() *ThreadTypeContext {
	var p = new(ThreadTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_threadType
	return p
}

func InitEmptyThreadTypeContext(p *ThreadTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_threadType
}

func (*ThreadTypeContext) IsThreadTypeContext() {}

func NewThreadTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThreadTypeContext {
	var p = new(ThreadTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_threadType

	return p
}

func (s *ThreadTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ThreadTypeContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO_THREAD, 0)
}

func (s *ThreadTypeContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD, 0)
}

func (s *ThreadTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThreadTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThreadTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterThreadType(s)
	}
}

func (s *ThreadTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitThreadType(s)
	}
}

func (s *ThreadTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitThreadType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ThreadType() (localctx IThreadTypeContext) {
	localctx = NewThreadTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, MySqlParserRULE_threadType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4634)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUntilOptionContext is an interface to support dynamic dispatch.
type IUntilOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUntilOptionContext differentiates from other interfaces.
	IsUntilOptionContext()
}

type UntilOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntilOptionContext() *UntilOptionContext {
	var p = new(UntilOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_untilOption
	return p
}

func InitEmptyUntilOptionContext(p *UntilOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_untilOption
}

func (*UntilOptionContext) IsUntilOptionContext() {}

func NewUntilOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UntilOptionContext {
	var p = new(UntilOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_untilOption

	return p
}

func (s *UntilOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UntilOptionContext) CopyAll(ctx *UntilOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UntilOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GtidsUntilOptionContext struct {
	UntilOptionContext
	gtids antlr.Token
}

func NewGtidsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GtidsUntilOptionContext {
	var p = new(GtidsUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *GtidsUntilOptionContext) GetGtids() antlr.Token { return s.gtids }

func (s *GtidsUntilOptionContext) SetGtids(v antlr.Token) { s.gtids = v }

func (s *GtidsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtidsUntilOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *GtidsUntilOptionContext) GtuidSet() IGtuidSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGtuidSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGtuidSetContext)
}

func (s *GtidsUntilOptionContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BEFORE_GTIDS, 0)
}

func (s *GtidsUntilOptionContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_GTIDS, 0)
}

func (s *GtidsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGtidsUntilOption(s)
	}
}

func (s *GtidsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGtidsUntilOption(s)
	}
}

func (s *GtidsUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGtidsUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type SqlGapsUntilOptionContext struct {
	UntilOptionContext
}

func NewSqlGapsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SqlGapsUntilOptionContext {
	var p = new(SqlGapsUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *SqlGapsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlGapsUntilOptionContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *SqlGapsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlGapsUntilOption(s)
	}
}

func (s *SqlGapsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlGapsUntilOption(s)
	}
}

func (s *SqlGapsUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlGapsUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type MasterLogUntilOptionContext struct {
	UntilOptionContext
}

func NewMasterLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterLogUntilOptionContext {
	var p = new(MasterLogUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *MasterLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *MasterLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *MasterLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *MasterLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *MasterLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *MasterLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *MasterLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterLogUntilOption(s)
	}
}

func (s *MasterLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterLogUntilOption(s)
	}
}

func (s *MasterLogUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMasterLogUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelayLogUntilOptionContext struct {
	UntilOptionContext
}

func NewRelayLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelayLogUntilOptionContext {
	var p = new(RelayLogUntilOptionContext)

	InitEmptyUntilOptionContext(&p.UntilOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UntilOptionContext))

	return p
}

func (s *RelayLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *RelayLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *RelayLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *RelayLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *RelayLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *RelayLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *RelayLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRelayLogUntilOption(s)
	}
}

func (s *RelayLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRelayLogUntilOption(s)
	}
}

func (s *RelayLogUntilOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRelayLogUntilOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UntilOption() (localctx IUntilOptionContext) {
	localctx = NewUntilOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, MySqlParserRULE_untilOption)
	var _la int

	p.SetState(4654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_BEFORE_GTIDS:
		localctx = NewGtidsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4636)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GtidsUntilOptionContext).gtids = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_AFTER_GTIDS || _la == MySqlParserSQL_BEFORE_GTIDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GtidsUntilOptionContext).gtids = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4637)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4638)
			p.GtuidSet()
		}

	case MySqlParserMASTER_LOG_FILE:
		localctx = NewMasterLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4639)
			p.Match(MySqlParserMASTER_LOG_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4640)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4641)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4642)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4643)
			p.Match(MySqlParserMASTER_LOG_POS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4644)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4645)
			p.DecimalLiteral()
		}

	case MySqlParserRELAY_LOG_FILE:
		localctx = NewRelayLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4646)
			p.Match(MySqlParserRELAY_LOG_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4647)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4648)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4649)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4650)
			p.Match(MySqlParserRELAY_LOG_POS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4651)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4652)
			p.DecimalLiteral()
		}

	case MySqlParserSQL_AFTER_MTS_GAPS:
		localctx = NewSqlGapsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4653)
			p.Match(MySqlParserSQL_AFTER_MTS_GAPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConnectionOptionContext is an interface to support dynamic dispatch.
type IConnectionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConnectionOptionContext differentiates from other interfaces.
	IsConnectionOptionContext()
}

type ConnectionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectionOptionContext() *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_connectionOption
	return p
}

func InitEmptyConnectionOptionContext(p *ConnectionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_connectionOption
}

func (*ConnectionOptionContext) IsConnectionOptionContext() {}

func NewConnectionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_connectionOption

	return p
}

func (s *ConnectionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectionOptionContext) CopyAll(ctx *ConnectionOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PluginDirConnectionOptionContext struct {
	ConnectionOptionContext
	conOptPluginDir antlr.Token
}

func NewPluginDirConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PluginDirConnectionOptionContext {
	var p = new(PluginDirConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *PluginDirConnectionOptionContext) GetConOptPluginDir() antlr.Token { return s.conOptPluginDir }

func (s *PluginDirConnectionOptionContext) SetConOptPluginDir(v antlr.Token) { s.conOptPluginDir = v }

func (s *PluginDirConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluginDirConnectionOptionContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN_DIR, 0)
}

func (s *PluginDirConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PluginDirConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PluginDirConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPluginDirConnectionOption(s)
	}
}

func (s *PluginDirConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPluginDirConnectionOption(s)
	}
}

func (s *PluginDirConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPluginDirConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserConnectionOptionContext struct {
	ConnectionOptionContext
	conOptUser antlr.Token
}

func NewUserConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserConnectionOptionContext {
	var p = new(UserConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *UserConnectionOptionContext) GetConOptUser() antlr.Token { return s.conOptUser }

func (s *UserConnectionOptionContext) SetConOptUser(v antlr.Token) { s.conOptUser = v }

func (s *UserConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserConnectionOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *UserConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *UserConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *UserConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserConnectionOption(s)
	}
}

func (s *UserConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserConnectionOption(s)
	}
}

func (s *UserConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefaultAuthConnectionOptionContext struct {
	ConnectionOptionContext
	conOptDefAuth antlr.Token
}

func NewDefaultAuthConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultAuthConnectionOptionContext {
	var p = new(DefaultAuthConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *DefaultAuthConnectionOptionContext) GetConOptDefAuth() antlr.Token { return s.conOptDefAuth }

func (s *DefaultAuthConnectionOptionContext) SetConOptDefAuth(v antlr.Token) { s.conOptDefAuth = v }

func (s *DefaultAuthConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultAuthConnectionOptionContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT_AUTH, 0)
}

func (s *DefaultAuthConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DefaultAuthConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *DefaultAuthConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultAuthConnectionOption(s)
	}
}

func (s *DefaultAuthConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultAuthConnectionOption(s)
	}
}

func (s *DefaultAuthConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefaultAuthConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type PasswordConnectionOptionContext struct {
	ConnectionOptionContext
	conOptPassword antlr.Token
}

func NewPasswordConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordConnectionOptionContext {
	var p = new(PasswordConnectionOptionContext)

	InitEmptyConnectionOptionContext(&p.ConnectionOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConnectionOptionContext))

	return p
}

func (s *PasswordConnectionOptionContext) GetConOptPassword() antlr.Token { return s.conOptPassword }

func (s *PasswordConnectionOptionContext) SetConOptPassword(v antlr.Token) { s.conOptPassword = v }

func (s *PasswordConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordConnectionOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *PasswordConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PasswordConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PasswordConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordConnectionOption(s)
	}
}

func (s *PasswordConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordConnectionOption(s)
	}
}

func (s *PasswordConnectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordConnectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ConnectionOption() (localctx IConnectionOptionContext) {
	localctx = NewConnectionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, MySqlParserRULE_connectionOption)
	p.SetState(4668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserUSER:
		localctx = NewUserConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4656)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4657)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4658)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*UserConnectionOptionContext).conOptUser = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPASSWORD:
		localctx = NewPasswordConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4659)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4660)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4661)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PasswordConnectionOptionContext).conOptPassword = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDEFAULT_AUTH:
		localctx = NewDefaultAuthConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4662)
			p.Match(MySqlParserDEFAULT_AUTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4663)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4664)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*DefaultAuthConnectionOptionContext).conOptDefAuth = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPLUGIN_DIR:
		localctx = NewPluginDirConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4665)
			p.Match(MySqlParserPLUGIN_DIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4666)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4667)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PluginDirConnectionOptionContext).conOptPluginDir = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGtuidSetContext is an interface to support dynamic dispatch.
type IGtuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUuidSet() []IUuidSetContext
	UuidSet(i int) IUuidSetContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsGtuidSetContext differentiates from other interfaces.
	IsGtuidSetContext()
}

type GtuidSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGtuidSetContext() *GtuidSetContext {
	var p = new(GtuidSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_gtuidSet
	return p
}

func InitEmptyGtuidSetContext(p *GtuidSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_gtuidSet
}

func (*GtuidSetContext) IsGtuidSetContext() {}

func NewGtuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GtuidSetContext {
	var p = new(GtuidSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_gtuidSet

	return p
}

func (s *GtuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GtuidSetContext) AllUuidSet() []IUuidSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUuidSetContext); ok {
			len++
		}
	}

	tst := make([]IUuidSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUuidSetContext); ok {
			tst[i] = t.(IUuidSetContext)
			i++
		}
	}

	return tst
}

func (s *GtuidSetContext) UuidSet(i int) IUuidSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidSetContext)
}

func (s *GtuidSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GtuidSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GtuidSetContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *GtuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GtuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGtuidSet(s)
	}
}

func (s *GtuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGtuidSet(s)
	}
}

func (s *GtuidSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGtuidSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) GtuidSet() (localctx IGtuidSetContext) {
	localctx = NewGtuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, MySqlParserRULE_gtuidSet)
	var _la int

	p.SetState(4679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4670)
			p.UuidSet()
		}
		p.SetState(4675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4671)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4672)
				p.UuidSet()
			}

			p.SetState(4677)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4678)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaStartTransactionContext is an interface to support dynamic dispatch.
type IXaStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetXaStart returns the xaStart token.
	GetXaStart() antlr.Token

	// GetXaAction returns the xaAction token.
	GetXaAction() antlr.Token

	// SetXaStart sets the xaStart token.
	SetXaStart(antlr.Token)

	// SetXaAction sets the xaAction token.
	SetXaAction(antlr.Token)

	// Getter signatures
	XA() antlr.TerminalNode
	Xid() IXidContext
	START() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RESUME() antlr.TerminalNode

	// IsXaStartTransactionContext differentiates from other interfaces.
	IsXaStartTransactionContext()
}

type XaStartTransactionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	xaStart  antlr.Token
	xaAction antlr.Token
}

func NewEmptyXaStartTransactionContext() *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaStartTransaction
	return p
}

func InitEmptyXaStartTransactionContext(p *XaStartTransactionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaStartTransaction
}

func (*XaStartTransactionContext) IsXaStartTransactionContext() {}

func NewXaStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaStartTransaction

	return p
}

func (s *XaStartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaStartTransactionContext) GetXaStart() antlr.Token { return s.xaStart }

func (s *XaStartTransactionContext) GetXaAction() antlr.Token { return s.xaAction }

func (s *XaStartTransactionContext) SetXaStart(v antlr.Token) { s.xaStart = v }

func (s *XaStartTransactionContext) SetXaAction(v antlr.Token) { s.xaAction = v }

func (s *XaStartTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaStartTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *XaStartTransactionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *XaStartTransactionContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *XaStartTransactionContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESUME, 0)
}

func (s *XaStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaStartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaStartTransaction(s)
	}
}

func (s *XaStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaStartTransaction(s)
	}
}

func (s *XaStartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) XaStartTransaction() (localctx IXaStartTransactionContext) {
	localctx = NewXaStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, MySqlParserRULE_xaStartTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4681)
		p.Match(MySqlParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4682)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*XaStartTransactionContext).xaStart = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBEGIN || _la == MySqlParserSTART) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*XaStartTransactionContext).xaStart = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4683)
		p.Xid()
	}
	p.SetState(4685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserJOIN || _la == MySqlParserRESUME {
		{
			p.SetState(4684)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*XaStartTransactionContext).xaAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJOIN || _la == MySqlParserRESUME) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*XaStartTransactionContext).xaAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaEndTransactionContext is an interface to support dynamic dispatch.
type IXaEndTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	END() antlr.TerminalNode
	Xid() IXidContext
	SUSPEND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode

	// IsXaEndTransactionContext differentiates from other interfaces.
	IsXaEndTransactionContext()
}

type XaEndTransactionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaEndTransactionContext() *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaEndTransaction
	return p
}

func InitEmptyXaEndTransactionContext(p *XaEndTransactionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaEndTransaction
}

func (*XaEndTransactionContext) IsXaEndTransactionContext() {}

func NewXaEndTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaEndTransaction

	return p
}

func (s *XaEndTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaEndTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaEndTransactionContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *XaEndTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaEndTransactionContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUSPEND, 0)
}

func (s *XaEndTransactionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *XaEndTransactionContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIGRATE, 0)
}

func (s *XaEndTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaEndTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaEndTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaEndTransaction(s)
	}
}

func (s *XaEndTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaEndTransaction(s)
	}
}

func (s *XaEndTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaEndTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) XaEndTransaction() (localctx IXaEndTransactionContext) {
	localctx = NewXaEndTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, MySqlParserRULE_xaEndTransaction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4687)
		p.Match(MySqlParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4688)
		p.Match(MySqlParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4689)
		p.Xid()
	}
	p.SetState(4695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSUSPEND {
		{
			p.SetState(4690)
			p.Match(MySqlParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(4691)
				p.Match(MySqlParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4692)
				p.Match(MySqlParserMIGRATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaPrepareStatementContext is an interface to support dynamic dispatch.
type IXaPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	Xid() IXidContext

	// IsXaPrepareStatementContext differentiates from other interfaces.
	IsXaPrepareStatementContext()
}

type XaPrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaPrepareStatementContext() *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement
	return p
}

func InitEmptyXaPrepareStatementContext(p *XaPrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement
}

func (*XaPrepareStatementContext) IsXaPrepareStatementContext() {}

func NewXaPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement

	return p
}

func (s *XaPrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *XaPrepareStatementContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaPrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *XaPrepareStatementContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaPrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaPrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaPrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaPrepareStatement(s)
	}
}

func (s *XaPrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaPrepareStatement(s)
	}
}

func (s *XaPrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) XaPrepareStatement() (localctx IXaPrepareStatementContext) {
	localctx = NewXaPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, MySqlParserRULE_xaPrepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4697)
		p.Match(MySqlParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4698)
		p.Match(MySqlParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4699)
		p.Xid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaCommitWorkContext is an interface to support dynamic dispatch.
type IXaCommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	Xid() IXidContext
	ONE() antlr.TerminalNode
	PHASE() antlr.TerminalNode

	// IsXaCommitWorkContext differentiates from other interfaces.
	IsXaCommitWorkContext()
}

type XaCommitWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaCommitWorkContext() *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaCommitWork
	return p
}

func InitEmptyXaCommitWorkContext(p *XaCommitWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaCommitWork
}

func (*XaCommitWorkContext) IsXaCommitWorkContext() {}

func NewXaCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaCommitWork

	return p
}

func (s *XaCommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaCommitWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaCommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *XaCommitWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaCommitWorkContext) ONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE, 0)
}

func (s *XaCommitWorkContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPHASE, 0)
}

func (s *XaCommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaCommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaCommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaCommitWork(s)
	}
}

func (s *XaCommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaCommitWork(s)
	}
}

func (s *XaCommitWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaCommitWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) XaCommitWork() (localctx IXaCommitWorkContext) {
	localctx = NewXaCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, MySqlParserRULE_xaCommitWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4701)
		p.Match(MySqlParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4702)
		p.Match(MySqlParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4703)
		p.Xid()
	}
	p.SetState(4706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserONE {
		{
			p.SetState(4704)
			p.Match(MySqlParserONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4705)
			p.Match(MySqlParserPHASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaRollbackWorkContext is an interface to support dynamic dispatch.
type IXaRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRollbackWorkContext differentiates from other interfaces.
	IsXaRollbackWorkContext()
}

type XaRollbackWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRollbackWorkContext() *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRollbackWork
	return p
}

func InitEmptyXaRollbackWorkContext(p *XaRollbackWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRollbackWork
}

func (*XaRollbackWorkContext) IsXaRollbackWorkContext() {}

func NewXaRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaRollbackWork

	return p
}

func (s *XaRollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRollbackWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaRollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *XaRollbackWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaRollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaRollbackWork(s)
	}
}

func (s *XaRollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaRollbackWork(s)
	}
}

func (s *XaRollbackWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaRollbackWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) XaRollbackWork() (localctx IXaRollbackWorkContext) {
	localctx = NewXaRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, MySqlParserRULE_xaRollbackWork)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4708)
		p.Match(MySqlParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4709)
		p.Match(MySqlParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4710)
		p.Xid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaRecoverWorkContext is an interface to support dynamic dispatch.
type IXaRecoverWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRecoverWorkContext differentiates from other interfaces.
	IsXaRecoverWorkContext()
}

type XaRecoverWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRecoverWorkContext() *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRecoverWork
	return p
}

func InitEmptyXaRecoverWorkContext(p *XaRecoverWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRecoverWork
}

func (*XaRecoverWorkContext) IsXaRecoverWorkContext() {}

func NewXaRecoverWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaRecoverWork

	return p
}

func (s *XaRecoverWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRecoverWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaRecoverWorkContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECOVER, 0)
}

func (s *XaRecoverWorkContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *XaRecoverWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRecoverWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRecoverWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaRecoverWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaRecoverWork(s)
	}
}

func (s *XaRecoverWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaRecoverWork(s)
	}
}

func (s *XaRecoverWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXaRecoverWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) XaRecoverWork() (localctx IXaRecoverWorkContext) {
	localctx = NewXaRecoverWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, MySqlParserRULE_xaRecoverWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4712)
		p.Match(MySqlParserXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4713)
		p.Match(MySqlParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCONVERT {
		{
			p.SetState(4714)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4715)
			p.Xid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetQuery returns the query token.
	GetQuery() antlr.Token

	// GetVariable returns the variable token.
	GetVariable() antlr.Token

	// SetQuery sets the query token.
	SetQuery(antlr.Token)

	// SetVariable sets the variable token.
	SetVariable(antlr.Token)

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	FROM() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	LOCAL_ID() antlr.TerminalNode

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	query    antlr.Token
	variable antlr.Token
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) GetQuery() antlr.Token { return s.query }

func (s *PrepareStatementContext) GetVariable() antlr.Token { return s.variable }

func (s *PrepareStatementContext) SetQuery(v antlr.Token) { s.query = v }

func (s *PrepareStatementContext) SetVariable(v antlr.Token) { s.variable = v }

func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *PrepareStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *PrepareStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PrepareStatementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, MySqlParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4718)
		p.Match(MySqlParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4719)
		p.Uid()
	}
	{
		p.SetState(4720)
		p.Match(MySqlParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTRING_LITERAL:
		{
			p.SetState(4721)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PrepareStatementContext).query = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserLOCAL_ID:
		{
			p.SetState(4722)

			var _m = p.Match(MySqlParserLOCAL_ID)

			localctx.(*PrepareStatementContext).variable = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Uid() IUidContext
	USING() antlr.TerminalNode
	UserVariables() IUserVariablesContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *ExecuteStatementContext) UserVariables() IUserVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariablesContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, MySqlParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4725)
		p.Match(MySqlParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4726)
		p.Uid()
	}
	p.SetState(4729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUSING {
		{
			p.SetState(4727)
			p.Match(MySqlParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4728)
			p.UserVariables()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocatePrepareContext is an interface to support dynamic dispatch.
type IDeallocatePrepareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropFormat returns the dropFormat token.
	GetDropFormat() antlr.Token

	// SetDropFormat sets the dropFormat token.
	SetDropFormat(antlr.Token)

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocatePrepareContext differentiates from other interfaces.
	IsDeallocatePrepareContext()
}

type DeallocatePrepareContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	dropFormat antlr.Token
}

func NewEmptyDeallocatePrepareContext() *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deallocatePrepare
	return p
}

func InitEmptyDeallocatePrepareContext(p *DeallocatePrepareContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_deallocatePrepare
}

func (*DeallocatePrepareContext) IsDeallocatePrepareContext() {}

func NewDeallocatePrepareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_deallocatePrepare

	return p
}

func (s *DeallocatePrepareContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocatePrepareContext) GetDropFormat() antlr.Token { return s.dropFormat }

func (s *DeallocatePrepareContext) SetDropFormat(v antlr.Token) { s.dropFormat = v }

func (s *DeallocatePrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *DeallocatePrepareContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeallocatePrepareContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEALLOCATE, 0)
}

func (s *DeallocatePrepareContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DeallocatePrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocatePrepareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeallocatePrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeallocatePrepare(s)
	}
}

func (s *DeallocatePrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeallocatePrepare(s)
	}
}

func (s *DeallocatePrepareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeallocatePrepare(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DeallocatePrepare() (localctx IDeallocatePrepareContext) {
	localctx = NewDeallocatePrepareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, MySqlParserRULE_deallocatePrepare)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4731)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeallocatePrepareContext).dropFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDROP || _la == MySqlParserDEALLOCATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeallocatePrepareContext).dropFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4732)
		p.Match(MySqlParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4733)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	SqlStatement() ISqlStatementContext

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineBody
	return p
}

func InitEmptyRoutineBodyContext(p *RoutineBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_routineBody
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *RoutineBodyContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (s *RoutineBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoutineBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RoutineBody() (localctx IRoutineBodyContext) {
	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, MySqlParserRULE_routineBody)
	p.SetState(4737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 691, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4735)
			p.BlockStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4736)
			p.SqlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllDeclareVariable() []IDeclareVariableContext
	DeclareVariable(i int) IDeclareVariableContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllDeclareCondition() []IDeclareConditionContext
	DeclareCondition(i int) IDeclareConditionContext
	AllDeclareCursor() []IDeclareCursorContext
	DeclareCursor(i int) IDeclareCursorContext
	AllDeclareHandler() []IDeclareHandlerContext
	DeclareHandler(i int) IDeclareHandlerContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_blockStatement
	return p
}

func InitEmptyBlockStatementContext(p *BlockStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_blockStatement
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *BlockStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *BlockStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *BlockStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *BlockStatementContext) AllDeclareVariable() []IDeclareVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			len++
		}
	}

	tst := make([]IDeclareVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareVariableContext); ok {
			tst[i] = t.(IDeclareVariableContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareVariable(i int) IDeclareVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareVariableContext)
}

func (s *BlockStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *BlockStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *BlockStatementContext) AllDeclareCondition() []IDeclareConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			len++
		}
	}

	tst := make([]IDeclareConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareConditionContext); ok {
			tst[i] = t.(IDeclareConditionContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCondition(i int) IDeclareConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareConditionContext)
}

func (s *BlockStatementContext) AllDeclareCursor() []IDeclareCursorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			len++
		}
	}

	tst := make([]IDeclareCursorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareCursorContext); ok {
			tst[i] = t.(IDeclareCursorContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCursor(i int) IDeclareCursorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareCursorContext)
}

func (s *BlockStatementContext) AllDeclareHandler() []IDeclareHandlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			len++
		}
	}

	tst := make([]IDeclareHandlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareHandlerContext); ok {
			tst[i] = t.(IDeclareHandlerContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareHandler(i int) IDeclareHandlerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareHandlerContext)
}

func (s *BlockStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, MySqlParserRULE_blockStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4742)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 692, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4739)
			p.Uid()
		}
		{
			p.SetState(4740)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4744)
		p.Match(MySqlParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4745)
				p.DeclareVariable()
			}
			{
				p.SetState(4746)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4753)
				p.DeclareCondition()
			}
			{
				p.SetState(4754)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4761)
				p.DeclareCursor()
			}
			{
				p.SetState(4762)
				p.Match(MySqlParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDECLARE {
		{
			p.SetState(4769)
			p.DeclareHandler()
		}
		{
			p.SetState(4770)
			p.Match(MySqlParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(4776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4777)
				p.ProcedureSqlStatement()
			}

		}
		p.SetState(4782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4783)
		p.Match(MySqlParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4785)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4784)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCASE() []antlr.TerminalNode
	CASE(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	Uid() IUidContext
	Expression() IExpressionContext
	AllCaseAlternative() []ICaseAlternativeContext
	CaseAlternative(i int) ICaseAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCASE)
}

func (s *CaseStatementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, i)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) AllCaseAlternative() []ICaseAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseAlternativeContext); ok {
			tst[i] = t.(ICaseAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseAlternative(i int) ICaseAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseAlternativeContext)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, MySqlParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4787)
		p.Match(MySqlParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4790)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 699, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4788)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 699, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4789)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySqlParserWHEN {
		{
			p.SetState(4792)
			p.CaseAlternative()
		}

		p.SetState(4795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserELSE {
		{
			p.SetState(4797)
			p.Match(MySqlParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4798)
					p.ProcedureSqlStatement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4801)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	{
		p.SetState(4805)
		p.Match(MySqlParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4806)
		p.Match(MySqlParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_procedureSqlStatement returns the _procedureSqlStatement rule contexts.
	Get_procedureSqlStatement() IProcedureSqlStatementContext

	// Set_procedureSqlStatement sets the _procedureSqlStatement rule contexts.
	Set_procedureSqlStatement(IProcedureSqlStatementContext)

	// GetThenStatements returns the thenStatements rule context list.
	GetThenStatements() []IProcedureSqlStatementContext

	// GetElseStatements returns the elseStatements rule context list.
	GetElseStatements() []IProcedureSqlStatementContext

	// SetThenStatements sets the thenStatements rule context list.
	SetThenStatements([]IProcedureSqlStatementContext)

	// SetElseStatements sets the elseStatements rule context list.
	SetElseStatements([]IProcedureSqlStatementContext)

	// Getter signatures
	AllIF() []antlr.TerminalNode
	IF(i int) antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllElifAlternative() []IElifAlternativeContext
	ElifAlternative(i int) IElifAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	_procedureSqlStatement IProcedureSqlStatementContext
	thenStatements         []IProcedureSqlStatementContext
	elseStatements         []IProcedureSqlStatementContext
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Get_procedureSqlStatement() IProcedureSqlStatementContext {
	return s._procedureSqlStatement
}

func (s *IfStatementContext) Set_procedureSqlStatement(v IProcedureSqlStatementContext) {
	s._procedureSqlStatement = v
}

func (s *IfStatementContext) GetThenStatements() []IProcedureSqlStatementContext {
	return s.thenStatements
}

func (s *IfStatementContext) GetElseStatements() []IProcedureSqlStatementContext {
	return s.elseStatements
}

func (s *IfStatementContext) SetThenStatements(v []IProcedureSqlStatementContext) {
	s.thenStatements = v
}

func (s *IfStatementContext) SetElseStatements(v []IProcedureSqlStatementContext) {
	s.elseStatements = v
}

func (s *IfStatementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIF)
}

func (s *IfStatementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, i)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *IfStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *IfStatementContext) AllElifAlternative() []IElifAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			len++
		}
	}

	tst := make([]IElifAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElifAlternativeContext); ok {
			tst[i] = t.(IElifAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElifAlternative(i int) IElifAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElifAlternativeContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *IfStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, MySqlParserRULE_ifStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4808)
		p.Match(MySqlParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4809)
		p.expression(0)
	}
	{
		p.SetState(4810)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4811)

				var _x = p.ProcedureSqlStatement()

				localctx.(*IfStatementContext)._procedureSqlStatement = _x
			}
			localctx.(*IfStatementContext).thenStatements = append(localctx.(*IfStatementContext).thenStatements, localctx.(*IfStatementContext)._procedureSqlStatement)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4814)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 703, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserELSEIF {
		{
			p.SetState(4816)
			p.ElifAlternative()
		}

		p.SetState(4821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserELSE {
		{
			p.SetState(4822)
			p.Match(MySqlParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4823)

					var _x = p.ProcedureSqlStatement()

					localctx.(*IfStatementContext)._procedureSqlStatement = _x
				}
				localctx.(*IfStatementContext).elseStatements = append(localctx.(*IfStatementContext).elseStatements, localctx.(*IfStatementContext)._procedureSqlStatement)

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4826)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 705, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	{
		p.SetState(4830)
		p.Match(MySqlParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4831)
		p.Match(MySqlParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterateStatementContext is an interface to support dynamic dispatch.
type IIterateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ITERATE() antlr.TerminalNode
	Uid() IUidContext

	// IsIterateStatementContext differentiates from other interfaces.
	IsIterateStatementContext()
}

type IterateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterateStatementContext() *IterateStatementContext {
	var p = new(IterateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_iterateStatement
	return p
}

func InitEmptyIterateStatementContext(p *IterateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_iterateStatement
}

func (*IterateStatementContext) IsIterateStatementContext() {}

func NewIterateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterateStatementContext {
	var p = new(IterateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_iterateStatement

	return p
}

func (s *IterateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterateStatementContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserITERATE, 0)
}

func (s *IterateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IterateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIterateStatement(s)
	}
}

func (s *IterateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIterateStatement(s)
	}
}

func (s *IterateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIterateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IterateStatement() (localctx IIterateStatementContext) {
	localctx = NewIterateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, MySqlParserRULE_iterateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4833)
		p.Match(MySqlParserITERATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4834)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeaveStatementContext is an interface to support dynamic dispatch.
type ILeaveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEAVE() antlr.TerminalNode
	Uid() IUidContext

	// IsLeaveStatementContext differentiates from other interfaces.
	IsLeaveStatementContext()
}

type LeaveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeaveStatementContext() *LeaveStatementContext {
	var p = new(LeaveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_leaveStatement
	return p
}

func InitEmptyLeaveStatementContext(p *LeaveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_leaveStatement
}

func (*LeaveStatementContext) IsLeaveStatementContext() {}

func NewLeaveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeaveStatementContext {
	var p = new(LeaveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_leaveStatement

	return p
}

func (s *LeaveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LeaveStatementContext) LEAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVE, 0)
}

func (s *LeaveStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LeaveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeaveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeaveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLeaveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LeaveStatement() (localctx ILeaveStatementContext) {
	localctx = NewLeaveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, MySqlParserRULE_leaveStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4836)
		p.Match(MySqlParserLEAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4837)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOOP() []antlr.TerminalNode
	LOOP(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOOP)
}

func (s *LoopStatementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOOP, i)
}

func (s *LoopStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *LoopStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LoopStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *LoopStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, MySqlParserRULE_loopStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		{
			p.SetState(4839)
			p.Uid()
		}
		{
			p.SetState(4840)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4844)
		p.Match(MySqlParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4845)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4848)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4850)
		p.Match(MySqlParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4851)
		p.Match(MySqlParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		{
			p.SetState(4852)
			p.Uid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllREPEAT() []antlr.TerminalNode
	REPEAT(i int) antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) AllREPEAT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserREPEAT)
}

func (s *RepeatStatementContext) REPEAT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEAT, i)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *RepeatStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RepeatStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *RepeatStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, MySqlParserRULE_repeatStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4858)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4855)
			p.Uid()
		}
		{
			p.SetState(4856)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4860)
		p.Match(MySqlParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4861)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4864)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4866)
		p.Match(MySqlParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4867)
		p.expression(0)
	}
	{
		p.SetState(4868)
		p.Match(MySqlParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4869)
		p.Match(MySqlParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		{
			p.SetState(4870)
			p.Uid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, MySqlParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4873)
		p.Match(MySqlParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4874)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWHILE() []antlr.TerminalNode
	WHILE(i int) antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) AllWHILE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWHILE)
}

func (s *WhileStatementContext) WHILE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWHILE, i)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *WhileStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *WhileStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WhileStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *WhileStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, MySqlParserRULE_whileStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		{
			p.SetState(4876)
			p.Uid()
		}
		{
			p.SetState(4877)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4881)
		p.Match(MySqlParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4882)
		p.expression(0)
	}
	{
		p.SetState(4883)
		p.Match(MySqlParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4884)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4887)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 714, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4889)
		p.Match(MySqlParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4890)
		p.Match(MySqlParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445666256561152) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055071174737) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&268698883) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17174494689) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&-1099511627777) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&-2882305960540372993) != 0) || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&-4398063288321) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&-16325548649218049) != 0) || ((int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&-9007199258936065) != 0) || ((int64((_la-600)) & ^0x3f) == 0 && ((int64(1)<<(_la-600))&-68719476801) != 0) || ((int64((_la-664)) & ^0x3f) == 0 && ((int64(1)<<(_la-664))&-22236531750340609) != 0) || ((int64((_la-728)) & ^0x3f) == 0 && ((int64(1)<<(_la-728))&-65) != 0) || ((int64((_la-792)) & ^0x3f) == 0 && ((int64(1)<<(_la-792))&-6145) != 0) || ((int64((_la-856)) & ^0x3f) == 0 && ((int64(1)<<(_la-856))&-1) != 0) || ((int64((_la-920)) & ^0x3f) == 0 && ((int64(1)<<(_la-920))&-1) != 0) || ((int64((_la-984)) & ^0x3f) == 0 && ((int64(1)<<(_la-984))&-1) != 0) || ((int64((_la-1048)) & ^0x3f) == 0 && ((int64(1)<<(_la-1048))&576460752303423487) != 0) || ((int64((_la-1122)) & ^0x3f) == 0 && ((int64(1)<<(_la-1122))&8627683329) != 0) {
		{
			p.SetState(4891)
			p.Uid()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursorStatementContext is an interface to support dynamic dispatch.
type ICursorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCursorStatementContext differentiates from other interfaces.
	IsCursorStatementContext()
}

type CursorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorStatementContext() *CursorStatementContext {
	var p = new(CursorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cursorStatement
	return p
}

func InitEmptyCursorStatementContext(p *CursorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cursorStatement
}

func (*CursorStatementContext) IsCursorStatementContext() {}

func NewCursorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorStatementContext {
	var p = new(CursorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cursorStatement

	return p
}

func (s *CursorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorStatementContext) CopyAll(ctx *CursorStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CursorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CloseCursorContext struct {
	CursorStatementContext
}

func NewCloseCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CloseCursorContext {
	var p = new(CloseCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *CloseCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseCursorContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *CloseCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CloseCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCloseCursor(s)
	}
}

func (s *CloseCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCloseCursor(s)
	}
}

func (s *CloseCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCloseCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

type OpenCursorContext struct {
	CursorStatementContext
}

func NewOpenCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OpenCursorContext {
	var p = new(OpenCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *OpenCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenCursorContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *OpenCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *OpenCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOpenCursor(s)
	}
}

func (s *OpenCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOpenCursor(s)
	}
}

func (s *OpenCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOpenCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

type FetchCursorContext struct {
	CursorStatementContext
}

func NewFetchCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FetchCursorContext {
	var p = new(FetchCursorContext)

	InitEmptyCursorStatementContext(&p.CursorStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*CursorStatementContext))

	return p
}

func (s *FetchCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FetchCursorContext) FETCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFETCH, 0)
}

func (s *FetchCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FetchCursorContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *FetchCursorContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *FetchCursorContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FetchCursorContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *FetchCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFetchCursor(s)
	}
}

func (s *FetchCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFetchCursor(s)
	}
}

func (s *FetchCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFetchCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CursorStatement() (localctx ICursorStatementContext) {
	localctx = NewCursorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, MySqlParserRULE_cursorStatement)
	var _la int

	p.SetState(4909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCLOSE:
		localctx = NewCloseCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4894)
			p.Match(MySqlParserCLOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4895)
			p.Uid()
		}

	case MySqlParserFETCH:
		localctx = NewFetchCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4896)
			p.Match(MySqlParserFETCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4901)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
			p.SetState(4898)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserNEXT {
				{
					p.SetState(4897)
					p.Match(MySqlParserNEXT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4900)
				p.Match(MySqlParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4903)
			p.Uid()
		}
		{
			p.SetState(4904)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4905)
			p.UidList()
		}

	case MySqlParserOPEN:
		localctx = NewOpenCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4907)
			p.Match(MySqlParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4908)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareVariableContext is an interface to support dynamic dispatch.
type IDeclareVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	UidList() IUidListContext
	DataType() IDataTypeContext
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeclareVariableContext differentiates from other interfaces.
	IsDeclareVariableContext()
}

type DeclareVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareVariableContext() *DeclareVariableContext {
	var p = new(DeclareVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareVariable
	return p
}

func InitEmptyDeclareVariableContext(p *DeclareVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareVariable
}

func (*DeclareVariableContext) IsDeclareVariableContext() {}

func NewDeclareVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareVariableContext {
	var p = new(DeclareVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareVariable

	return p
}

func (s *DeclareVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareVariableContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareVariableContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DeclareVariableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DeclareVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *DeclareVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeclareVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DeclareVariable() (localctx IDeclareVariableContext) {
	localctx = NewDeclareVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, MySqlParserRULE_declareVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4911)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4912)
		p.UidList()
	}
	{
		p.SetState(4913)
		p.DataType()
	}
	p.SetState(4916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFAULT {
		{
			p.SetState(4914)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4915)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareConditionContext is an interface to support dynamic dispatch.
type IDeclareConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CONDITION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	SQLSTATE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDeclareConditionContext differentiates from other interfaces.
	IsDeclareConditionContext()
}

type DeclareConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareConditionContext() *DeclareConditionContext {
	var p = new(DeclareConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCondition
	return p
}

func InitEmptyDeclareConditionContext(p *DeclareConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCondition
}

func (*DeclareConditionContext) IsDeclareConditionContext() {}

func NewDeclareConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareConditionContext {
	var p = new(DeclareConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareCondition

	return p
}

func (s *DeclareConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareConditionContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareConditionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareConditionContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *DeclareConditionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareConditionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DeclareConditionContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *DeclareConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *DeclareConditionContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *DeclareConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareCondition(s)
	}
}

func (s *DeclareConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareCondition(s)
	}
}

func (s *DeclareConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DeclareCondition() (localctx IDeclareConditionContext) {
	localctx = NewDeclareConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, MySqlParserRULE_declareCondition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4918)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4919)
		p.Uid()
	}
	{
		p.SetState(4920)
		p.Match(MySqlParserCONDITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4921)
		p.Match(MySqlParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		{
			p.SetState(4922)
			p.DecimalLiteral()
		}

	case MySqlParserSQLSTATE:
		{
			p.SetState(4923)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(4924)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4927)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareCursorContext is an interface to support dynamic dispatch.
type IDeclareCursorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CURSOR() antlr.TerminalNode
	FOR() antlr.TerminalNode
	SelectStatement() ISelectStatementContext

	// IsDeclareCursorContext differentiates from other interfaces.
	IsDeclareCursorContext()
}

type DeclareCursorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareCursorContext() *DeclareCursorContext {
	var p = new(DeclareCursorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCursor
	return p
}

func InitEmptyDeclareCursorContext(p *DeclareCursorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCursor
}

func (*DeclareCursorContext) IsDeclareCursorContext() {}

func NewDeclareCursorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareCursorContext {
	var p = new(DeclareCursorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareCursor

	return p
}

func (s *DeclareCursorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareCursorContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareCursorContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR, 0)
}

func (s *DeclareCursorContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareCursorContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DeclareCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareCursorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareCursor(s)
	}
}

func (s *DeclareCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareCursor(s)
	}
}

func (s *DeclareCursorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareCursor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DeclareCursor() (localctx IDeclareCursorContext) {
	localctx = NewDeclareCursorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, MySqlParserRULE_declareCursor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4930)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4931)
		p.Uid()
	}
	{
		p.SetState(4932)
		p.Match(MySqlParserCURSOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4933)
		p.Match(MySqlParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4934)
		p.SelectStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareHandlerContext is an interface to support dynamic dispatch.
type IDeclareHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHandlerAction returns the handlerAction token.
	GetHandlerAction() antlr.Token

	// SetHandlerAction sets the handlerAction token.
	SetHandlerAction(antlr.Token)

	// Getter signatures
	DECLARE() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllHandlerConditionValue() []IHandlerConditionValueContext
	HandlerConditionValue(i int) IHandlerConditionValueContext
	RoutineBody() IRoutineBodyContext
	CONTINUE() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	UNDO() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDeclareHandlerContext differentiates from other interfaces.
	IsDeclareHandlerContext()
}

type DeclareHandlerContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	handlerAction antlr.Token
}

func NewEmptyDeclareHandlerContext() *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareHandler
	return p
}

func InitEmptyDeclareHandlerContext(p *DeclareHandlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_declareHandler
}

func (*DeclareHandlerContext) IsDeclareHandlerContext() {}

func NewDeclareHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareHandler

	return p
}

func (s *DeclareHandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareHandlerContext) GetHandlerAction() antlr.Token { return s.handlerAction }

func (s *DeclareHandlerContext) SetHandlerAction(v antlr.Token) { s.handlerAction = v }

func (s *DeclareHandlerContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareHandlerContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *DeclareHandlerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareHandlerContext) AllHandlerConditionValue() []IHandlerConditionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			len++
		}
	}

	tst := make([]IHandlerConditionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHandlerConditionValueContext); ok {
			tst[i] = t.(IHandlerConditionValueContext)
			i++
		}
	}

	return tst
}

func (s *DeclareHandlerContext) HandlerConditionValue(i int) IHandlerConditionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerConditionValueContext)
}

func (s *DeclareHandlerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *DeclareHandlerContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTINUE, 0)
}

func (s *DeclareHandlerContext) EXIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXIT, 0)
}

func (s *DeclareHandlerContext) UNDO() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO, 0)
}

func (s *DeclareHandlerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DeclareHandlerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DeclareHandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareHandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareHandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareHandler(s)
	}
}

func (s *DeclareHandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareHandler(s)
	}
}

func (s *DeclareHandlerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDeclareHandler(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DeclareHandler() (localctx IDeclareHandlerContext) {
	localctx = NewDeclareHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, MySqlParserRULE_declareHandler)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4936)
		p.Match(MySqlParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4937)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeclareHandlerContext).handlerAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserCONTINUE || _la == MySqlParserEXIT || _la == MySqlParserUNDO) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeclareHandlerContext).handlerAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4938)
		p.Match(MySqlParserHANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4939)
		p.Match(MySqlParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4940)
		p.HandlerConditionValue()
	}
	p.SetState(4945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4941)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4942)
			p.HandlerConditionValue()
		}

		p.SetState(4947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4948)
		p.RoutineBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerConditionValueContext is an interface to support dynamic dispatch.
type IHandlerConditionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsHandlerConditionValueContext differentiates from other interfaces.
	IsHandlerConditionValueContext()
}

type HandlerConditionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerConditionValueContext() *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerConditionValue
	return p
}

func InitEmptyHandlerConditionValueContext(p *HandlerConditionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerConditionValue
}

func (*HandlerConditionValueContext) IsHandlerConditionValueContext() {}

func NewHandlerConditionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerConditionValue

	return p
}

func (s *HandlerConditionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerConditionValueContext) CopyAll(ctx *HandlerConditionValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *HandlerConditionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type HandlerConditionWarningContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionWarningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionWarningContext {
	var p = new(HandlerConditionWarningContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionWarningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionWarningContext) SQLWARNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLWARNING, 0)
}

func (s *HandlerConditionWarningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionWarning(s)
	}
}

func (s *HandlerConditionWarningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionWarning(s)
	}
}

func (s *HandlerConditionWarningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionWarning(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionCodeContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionCodeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionCodeContext {
	var p = new(HandlerConditionCodeContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionCodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionCodeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *HandlerConditionCodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionCode(s)
	}
}

func (s *HandlerConditionCodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionCode(s)
	}
}

func (s *HandlerConditionCodeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionCode(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionNotfoundContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionNotfoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNotfoundContext {
	var p = new(HandlerConditionNotfoundContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNotfoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNotfoundContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *HandlerConditionNotfoundContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND, 0)
}

func (s *HandlerConditionNotfoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionNotfound(s)
	}
}

func (s *HandlerConditionNotfoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionNotfound(s)
	}
}

func (s *HandlerConditionNotfoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionNotfound(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionStateContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionStateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionStateContext {
	var p = new(HandlerConditionStateContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionStateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionStateContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *HandlerConditionStateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HandlerConditionStateContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *HandlerConditionStateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionState(s)
	}
}

func (s *HandlerConditionStateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionState(s)
	}
}

func (s *HandlerConditionStateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionState(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionExceptionContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionExceptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionExceptionContext {
	var p = new(HandlerConditionExceptionContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionExceptionContext) SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLEXCEPTION, 0)
}

func (s *HandlerConditionExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionException(s)
	}
}

func (s *HandlerConditionExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionException(s)
	}
}

func (s *HandlerConditionExceptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionException(s)

	default:
		return t.VisitChildren(s)
	}
}

type HandlerConditionNameContext struct {
	HandlerConditionValueContext
}

func NewHandlerConditionNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNameContext {
	var p = new(HandlerConditionNameContext)

	InitEmptyHandlerConditionValueContext(&p.HandlerConditionValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerConditionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionName(s)
	}
}

func (s *HandlerConditionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionName(s)
	}
}

func (s *HandlerConditionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHandlerConditionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HandlerConditionValue() (localctx IHandlerConditionValueContext) {
	localctx = NewHandlerConditionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, MySqlParserRULE_handlerConditionValue)
	var _la int

	p.SetState(4961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		localctx = NewHandlerConditionCodeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4950)
			p.DecimalLiteral()
		}

	case MySqlParserSQLSTATE:
		localctx = NewHandlerConditionStateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4951)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(4952)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4955)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		localctx = NewHandlerConditionNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4956)
			p.Uid()
		}

	case MySqlParserSQLWARNING:
		localctx = NewHandlerConditionWarningContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4957)
			p.Match(MySqlParserSQLWARNING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserNOT:
		localctx = NewHandlerConditionNotfoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4958)
			p.Match(MySqlParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4959)
			p.Match(MySqlParserFOUND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSQLEXCEPTION:
		localctx = NewHandlerConditionExceptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4960)
			p.Match(MySqlParserSQLEXCEPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureSqlStatementContext is an interface to support dynamic dispatch.
type IProcedureSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	SqlStatement() ISqlStatementContext

	// IsProcedureSqlStatementContext differentiates from other interfaces.
	IsProcedureSqlStatementContext()
}

type ProcedureSqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSqlStatementContext() *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement
	return p
}

func InitEmptyProcedureSqlStatementContext(p *ProcedureSqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement
}

func (*ProcedureSqlStatementContext) IsProcedureSqlStatementContext() {}

func NewProcedureSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement

	return p
}

func (s *ProcedureSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSqlStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *ProcedureSqlStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureSqlStatementContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *ProcedureSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProcedureSqlStatement(s)
	}
}

func (s *ProcedureSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProcedureSqlStatement(s)
	}
}

func (s *ProcedureSqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitProcedureSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ProcedureSqlStatement() (localctx IProcedureSqlStatementContext) {
	localctx = NewProcedureSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, MySqlParserRULE_procedureSqlStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4963)
			p.CompoundStatement()
		}

	case 2:
		{
			p.SetState(4964)
			p.SqlStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4967)
		p.Match(MySqlParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseAlternativeContext is an interface to support dynamic dispatch.
type ICaseAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	Constant() IConstantContext
	Expression() IExpressionContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseAlternativeContext differentiates from other interfaces.
	IsCaseAlternativeContext()
}

type CaseAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAlternativeContext() *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseAlternative
	return p
}

func InitEmptyCaseAlternativeContext(p *CaseAlternativeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseAlternative
}

func (*CaseAlternativeContext) IsCaseAlternativeContext() {}

func NewCaseAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseAlternative

	return p
}

func (s *CaseAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHEN, 0)
}

func (s *CaseAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *CaseAlternativeContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *CaseAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseAlternative(s)
	}
}

func (s *CaseAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseAlternative(s)
	}
}

func (s *CaseAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CaseAlternative() (localctx ICaseAlternativeContext) {
	localctx = NewCaseAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, MySqlParserRULE_caseAlternative)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4969)
		p.Match(MySqlParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 726, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4970)
			p.Constant()
		}

	case 2:
		{
			p.SetState(4971)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4974)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4975)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4978)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 727, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElifAlternativeContext is an interface to support dynamic dispatch.
type IElifAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSEIF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsElifAlternativeContext differentiates from other interfaces.
	IsElifAlternativeContext()
}

type ElifAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElifAlternativeContext() *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_elifAlternative
	return p
}

func InitEmptyElifAlternativeContext(p *ElifAlternativeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_elifAlternative
}

func (*ElifAlternativeContext) IsElifAlternativeContext() {}

func NewElifAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_elifAlternative

	return p
}

func (s *ElifAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ElifAlternativeContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSEIF, 0)
}

func (s *ElifAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElifAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *ElifAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *ElifAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *ElifAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElifAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElifAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterElifAlternative(s)
	}
}

func (s *ElifAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitElifAlternative(s)
	}
}

func (s *ElifAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitElifAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ElifAlternative() (localctx IElifAlternativeContext) {
	localctx = NewElifAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, MySqlParserRULE_elifAlternative)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4980)
		p.Match(MySqlParserELSEIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4981)
		p.expression(0)
	}
	{
		p.SetState(4982)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4983)
				p.ProcedureSqlStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4986)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterUser
	return p
}

func InitEmptyAlterUserContext(p *AlterUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_alterUser
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) CopyAll(ctx *AlterUserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterUserMysqlV80Context struct {
	AlterUserContext
	tlsNone antlr.Token
}

func NewAlterUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV80Context {
	var p = new(AlterUserMysqlV80Context)

	InitEmptyAlterUserContext(&p.AlterUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterUserContext))

	return p
}

func (s *AlterUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *AlterUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *AlterUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV80Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *AlterUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *AlterUserMysqlV80Context) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *AlterUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *AlterUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *AlterUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *AlterUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *AlterUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *AlterUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *AlterUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *AlterUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *AlterUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *AlterUserMysqlV80Context) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterUserMysqlV80Context) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *AlterUserMysqlV80Context) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *AlterUserMysqlV80Context) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *AlterUserMysqlV80Context) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUserMysqlV80(s)
	}
}

func (s *AlterUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUserMysqlV80(s)
	}
}

func (s *AlterUserMysqlV80Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterUserMysqlV80(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterUserMysqlV56Context struct {
	AlterUserContext
}

func NewAlterUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV56Context {
	var p = new(AlterUserMysqlV56Context)

	InitEmptyAlterUserContext(&p.AlterUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterUserContext))

	return p
}

func (s *AlterUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV56Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *AlterUserMysqlV56Context) AllUserSpecification() []IUserSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IUserSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserSpecificationContext); ok {
			tst[i] = t.(IUserSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV56Context) UserSpecification(i int) IUserSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserSpecificationContext)
}

func (s *AlterUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUserMysqlV56(s)
	}
}

func (s *AlterUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUserMysqlV56(s)
	}
}

func (s *AlterUserMysqlV56Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAlterUserMysqlV56(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AlterUser() (localctx IAlterUserContext) {
	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, MySqlParserRULE_alterUser)
	var _la int

	p.SetState(5061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 743, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4988)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4989)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4990)
			p.UserSpecification()
		}
		p.SetState(4995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4991)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4992)
				p.UserSpecification()
			}

			p.SetState(4997)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAlterUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4998)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4999)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIF {
			{
				p.SetState(5000)
				p.IfExists()
			}

		}
		{
			p.SetState(5003)
			p.UserAuthOption()
		}
		p.SetState(5008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5004)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5005)
				p.UserAuthOption()
			}

			p.SetState(5010)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5011)
				p.Match(MySqlParserREQUIRE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5023)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5012)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*AlterUserMysqlV80Context).tlsNone = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5013)
					p.TlsOption()
				}
				p.SetState(5020)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5015)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserAND {
						{
							p.SetState(5014)
							p.Match(MySqlParserAND)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(5017)
						p.TlsOption()
					}

					p.SetState(5022)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5033)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 737, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5027)
				p.Match(MySqlParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5029)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-497)) & ^0x3f) == 0 && ((int64(1)<<(_la-497))&51) != 0) {
				{
					p.SetState(5028)
					p.UserResourceOption()
				}

				p.SetState(5031)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserACCOUNT || _la == MySqlParserFAILED_LOGIN_ATTEMPTS || _la == MySqlParserPASSWORD || _la == MySqlParserPASSWORD_LOCK_TIME {
			p.SetState(5037)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME:
				{
					p.SetState(5035)
					p.UserPasswordOption()
				}

			case MySqlParserACCOUNT:
				{
					p.SetState(5036)
					p.UserLockOption()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(5041)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserCOMMENT:
			{
				p.SetState(5042)
				p.Match(MySqlParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5043)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserATTRIBUTE:
			{
				p.SetState(5044)
				p.Match(MySqlParserATTRIBUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5045)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:

		default:
		}

	case 3:
		localctx = NewAlterUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5048)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5049)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5051)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5050)
				p.IfExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 742, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5053)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5054)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(5057)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5058)
			p.Match(MySqlParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5059)
			p.RoleOption()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUser
	return p
}

func InitEmptyCreateUserContext(p *CreateUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUser
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CopyAll(ctx *CreateUserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateUserMysqlV56Context struct {
	CreateUserContext
}

func NewCreateUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV56Context {
	var p = new(CreateUserMysqlV56Context)

	InitEmptyCreateUserContext(&p.CreateUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateUserContext))

	return p
}

func (s *CreateUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV56Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *CreateUserMysqlV56Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV56Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUserMysqlV56(s)
	}
}

func (s *CreateUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUserMysqlV56(s)
	}
}

func (s *CreateUserMysqlV56Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateUserMysqlV56(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateUserMysqlV80Context struct {
	CreateUserContext
	tlsNone antlr.Token
}

func NewCreateUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV80Context {
	var p = new(CreateUserMysqlV80Context)

	InitEmptyCreateUserContext(&p.CreateUserContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateUserContext))

	return p
}

func (s *CreateUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *CreateUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *CreateUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV80Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *CreateUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV80Context) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateUserMysqlV80Context) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *CreateUserMysqlV80Context) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *CreateUserMysqlV80Context) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *CreateUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *CreateUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *CreateUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *CreateUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *CreateUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *CreateUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *CreateUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *CreateUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *CreateUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *CreateUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *CreateUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUserMysqlV80(s)
	}
}

func (s *CreateUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUserMysqlV80(s)
	}
}

func (s *CreateUserMysqlV80Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateUserMysqlV80(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateUser() (localctx ICreateUserContext) {
	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, MySqlParserRULE_createUser)
	var _la int

	p.SetState(5128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 757, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5063)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5064)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5065)
			p.UserAuthOption()
		}
		p.SetState(5070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5066)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5067)
				p.UserAuthOption()
			}

			p.SetState(5072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewCreateUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5073)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5074)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIF {
			{
				p.SetState(5075)
				p.IfNotExists()
			}

		}
		{
			p.SetState(5078)
			p.UserAuthOption()
		}
		p.SetState(5083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5079)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5080)
				p.UserAuthOption()
			}

			p.SetState(5085)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(5086)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5087)
				p.Match(MySqlParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5088)
				p.RoleOption()
			}

		}
		p.SetState(5105)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5091)
				p.Match(MySqlParserREQUIRE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5103)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5092)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*CreateUserMysqlV80Context).tlsNone = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5093)
					p.TlsOption()
				}
				p.SetState(5100)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5095)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserAND {
						{
							p.SetState(5094)
							p.Match(MySqlParserAND)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(5097)
						p.TlsOption()
					}

					p.SetState(5102)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5113)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5107)
				p.Match(MySqlParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5109)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-497)) & ^0x3f) == 0 && ((int64(1)<<(_la-497))&51) != 0) {
				{
					p.SetState(5108)
					p.UserResourceOption()
				}

				p.SetState(5111)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserACCOUNT || _la == MySqlParserFAILED_LOGIN_ATTEMPTS || _la == MySqlParserPASSWORD || _la == MySqlParserPASSWORD_LOCK_TIME {
			p.SetState(5117)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME:
				{
					p.SetState(5115)
					p.UserPasswordOption()
				}

			case MySqlParserACCOUNT:
				{
					p.SetState(5116)
					p.UserLockOption()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(5121)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserCOMMENT:
			{
				p.SetState(5122)
				p.Match(MySqlParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5123)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserATTRIBUTE:
			{
				p.SetState(5124)
				p.Match(MySqlParserATTRIBUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5125)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:

		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropUser
	return p
}

func InitEmptyDropUserContext(p *DropUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dropUser
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *DropUserContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DropUserContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DropUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (s *DropUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDropUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DropUser() (localctx IDropUserContext) {
	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, MySqlParserRULE_dropUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5130)
		p.Match(MySqlParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5131)
		p.Match(MySqlParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIF {
		{
			p.SetState(5132)
			p.IfExists()
		}

	}
	{
		p.SetState(5135)
		p.UserName()
	}
	p.SetState(5140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5136)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5137)
			p.UserName()
		}

		p.SetState(5142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantStatementContext is an interface to support dynamic dispatch.
type IGrantStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrivilegeObject returns the privilegeObject token.
	GetPrivilegeObject() antlr.Token

	// GetTlsNone returns the tlsNone token.
	GetTlsNone() antlr.Token

	// SetPrivilegeObject sets the privilegeObject token.
	SetPrivilegeObject(antlr.Token)

	// SetTlsNone sets the tlsNone token.
	SetTlsNone(antlr.Token)

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	AllPrivelegeClause() []IPrivelegeClauseContext
	PrivelegeClause(i int) IPrivelegeClauseContext
	ON() antlr.TerminalNode
	PrivilegeLevel() IPrivilegeLevelContext
	TO() antlr.TerminalNode
	AllUserAuthOption() []IUserAuthOptionContext
	UserAuthOption(i int) IUserAuthOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	ROLE() antlr.TerminalNode
	RoleOption() IRoleOptionContext
	TABLE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	AllTlsOption() []ITlsOptionContext
	TlsOption(i int) ITlsOptionContext
	NONE() antlr.TerminalNode
	AllOPTION() []antlr.TerminalNode
	OPTION(i int) antlr.TerminalNode
	AllUserResourceOption() []IUserResourceOptionContext
	UserResourceOption(i int) IUserResourceOptionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADMIN() antlr.TerminalNode

	// IsGrantStatementContext differentiates from other interfaces.
	IsGrantStatementContext()
}

type GrantStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	privilegeObject antlr.Token
	tlsNone         antlr.Token
}

func NewEmptyGrantStatementContext() *GrantStatementContext {
	var p = new(GrantStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantStatement
	return p
}

func InitEmptyGrantStatementContext(p *GrantStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantStatement
}

func (*GrantStatementContext) IsGrantStatementContext() {}

func NewGrantStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantStatementContext {
	var p = new(GrantStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_grantStatement

	return p
}

func (s *GrantStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantStatementContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }

func (s *GrantStatementContext) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *GrantStatementContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *GrantStatementContext) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *GrantStatementContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGRANT)
}

func (s *GrantStatementContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, i)
}

func (s *GrantStatementContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *GrantStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *GrantStatementContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *GrantStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *GrantStatementContext) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *GrantStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GrantStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GrantStatementContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *GrantStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWITH)
}

func (s *GrantStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, i)
}

func (s *GrantStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *GrantStatementContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *GrantStatementContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *GrantStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *GrantStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *GrantStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *GrantStatementContext) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *GrantStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *GrantStatementContext) AllOPTION() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserOPTION)
}

func (s *GrantStatementContext) OPTION(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, i)
}

func (s *GrantStatementContext) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *GrantStatementContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *GrantStatementContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *GrantStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *GrantStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *GrantStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGrantStatement(s)
	}
}

func (s *GrantStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGrantStatement(s)
	}
}

func (s *GrantStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGrantStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) GrantStatement() (localctx IGrantStatementContext) {
	localctx = NewGrantStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, MySqlParserRULE_grantStatement)
	var _la int

	var _alt int

	p.SetState(5236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 778, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5143)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5144)
			p.PrivelegeClause()
		}
		p.SetState(5149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5145)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5146)
				p.PrivelegeClause()
			}

			p.SetState(5151)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5152)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5154)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 761, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5153)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*GrantStatementContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserPROCEDURE || _la == MySqlParserTABLE || _la == MySqlParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*GrantStatementContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5156)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5157)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5158)
			p.UserAuthOption()
		}
		p.SetState(5163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5159)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5160)
				p.UserAuthOption()
			}

			p.SetState(5165)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5166)
				p.Match(MySqlParserREQUIRE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5178)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5167)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*GrantStatementContext).tlsNone = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5168)
					p.TlsOption()
				}
				p.SetState(5175)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5170)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserAND {
						{
							p.SetState(5169)
							p.Match(MySqlParserAND)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(5172)
						p.TlsOption()
					}

					p.SetState(5177)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(5191)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 769, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5182)
				p.Match(MySqlParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5188)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 768, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(5186)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case MySqlParserGRANT:
						{
							p.SetState(5183)
							p.Match(MySqlParserGRANT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(5184)
							p.Match(MySqlParserOPTION)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					case MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS:
						{
							p.SetState(5185)
							p.UserResourceOption()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

				}
				p.SetState(5190)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 768, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(5193)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5194)
				p.UserName()
			}
			{
				p.SetState(5195)
				p.Match(MySqlParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5196)
				p.Match(MySqlParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5197)
				p.RoleOption()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5201)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 771, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5202)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5203)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5206)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5207)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5208)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5215)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5216)
			p.Match(MySqlParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5217)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5218)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5221)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5224)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 775, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5222)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5223)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5230)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5234)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5231)
				p.Match(MySqlParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5232)
				p.Match(MySqlParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5233)
				p.Match(MySqlParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOptionContext is an interface to support dynamic dispatch.
type IRoleOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRoleOptionContext differentiates from other interfaces.
	IsRoleOptionContext()
}

type RoleOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOptionContext() *RoleOptionContext {
	var p = new(RoleOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleOption
	return p
}

func InitEmptyRoleOptionContext(p *RoleOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleOption
}

func (*RoleOptionContext) IsRoleOptionContext() {}

func NewRoleOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOptionContext {
	var p = new(RoleOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_roleOption

	return p
}

func (s *RoleOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *RoleOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *RoleOptionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *RoleOptionContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCEPT, 0)
}

func (s *RoleOptionContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleOptionContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RoleOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RoleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleOption(s)
	}
}

func (s *RoleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleOption(s)
	}
}

func (s *RoleOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoleOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RoleOption() (localctx IRoleOptionContext) {
	localctx = NewRoleOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, MySqlParserRULE_roleOption)
	var _la int

	p.SetState(5260)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 782, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5238)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5239)
			p.Match(MySqlParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5240)
			p.Match(MySqlParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEXCEPT {
			{
				p.SetState(5241)
				p.Match(MySqlParserEXCEPT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5242)
				p.UserName()
			}
			p.SetState(5247)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(5243)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5244)
					p.UserName()
				}

				p.SetState(5249)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5252)
			p.UserName()
		}
		p.SetState(5257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5253)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5254)
				p.UserName()
			}

			p.SetState(5259)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantProxyContext is an interface to support dynamic dispatch.
type IGrantProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)

	// GetToOther returns the toOther rule context list.
	GetToOther() []IUserNameContext

	// SetToOther sets the toOther rule context list.
	SetToOther([]IUserNameContext)

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	OPTION() antlr.TerminalNode

	// IsGrantProxyContext differentiates from other interfaces.
	IsGrantProxyContext()
}

type GrantProxyContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	fromFirst IUserNameContext
	toFirst   IUserNameContext
	_userName IUserNameContext
	toOther   []IUserNameContext
}

func NewEmptyGrantProxyContext() *GrantProxyContext {
	var p = new(GrantProxyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantProxy
	return p
}

func InitEmptyGrantProxyContext(p *GrantProxyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_grantProxy
}

func (*GrantProxyContext) IsGrantProxyContext() {}

func NewGrantProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantProxyContext {
	var p = new(GrantProxyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_grantProxy

	return p
}

func (s *GrantProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *GrantProxyContext) GetToFirst() IUserNameContext { return s.toFirst }

func (s *GrantProxyContext) Get_userName() IUserNameContext { return s._userName }

func (s *GrantProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *GrantProxyContext) SetToFirst(v IUserNameContext) { s.toFirst = v }

func (s *GrantProxyContext) Set_userName(v IUserNameContext) { s._userName = v }

func (s *GrantProxyContext) GetToOther() []IUserNameContext { return s.toOther }

func (s *GrantProxyContext) SetToOther(v []IUserNameContext) { s.toOther = v }

func (s *GrantProxyContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGRANT)
}

func (s *GrantProxyContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, i)
}

func (s *GrantProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *GrantProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *GrantProxyContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *GrantProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GrantProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GrantProxyContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *GrantProxyContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *GrantProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGrantProxy(s)
	}
}

func (s *GrantProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGrantProxy(s)
	}
}

func (s *GrantProxyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGrantProxy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) GrantProxy() (localctx IGrantProxyContext) {
	localctx = NewGrantProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, MySqlParserRULE_grantProxy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5262)
		p.Match(MySqlParserGRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5263)
		p.Match(MySqlParserPROXY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5264)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5265)

		var _x = p.UserName()

		localctx.(*GrantProxyContext).fromFirst = _x
	}
	{
		p.SetState(5266)
		p.Match(MySqlParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5267)

		var _x = p.UserName()

		localctx.(*GrantProxyContext).toFirst = _x
	}
	p.SetState(5272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5268)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5269)

			var _x = p.UserName()

			localctx.(*GrantProxyContext)._userName = _x
		}
		localctx.(*GrantProxyContext).toOther = append(localctx.(*GrantProxyContext).toOther, localctx.(*GrantProxyContext)._userName)

		p.SetState(5274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5278)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 784, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5275)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5276)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5277)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameUserContext is an interface to support dynamic dispatch.
type IRenameUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllRenameUserClause() []IRenameUserClauseContext
	RenameUserClause(i int) IRenameUserClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameUserContext differentiates from other interfaces.
	IsRenameUserContext()
}

type RenameUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameUserContext() *RenameUserContext {
	var p = new(RenameUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUser
	return p
}

func InitEmptyRenameUserContext(p *RenameUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUser
}

func (*RenameUserContext) IsRenameUserContext() {}

func NewRenameUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserContext {
	var p = new(RenameUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameUser

	return p
}

func (s *RenameUserContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *RenameUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *RenameUserContext) AllRenameUserClause() []IRenameUserClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameUserClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameUserClauseContext); ok {
			tst[i] = t.(IRenameUserClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserContext) RenameUserClause(i int) IRenameUserClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserClauseContext)
}

func (s *RenameUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RenameUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RenameUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameUser(s)
	}
}

func (s *RenameUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameUser(s)
	}
}

func (s *RenameUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RenameUser() (localctx IRenameUserContext) {
	localctx = NewRenameUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, MySqlParserRULE_renameUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5280)
		p.Match(MySqlParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5281)
		p.Match(MySqlParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5282)
		p.RenameUserClause()
	}
	p.SetState(5287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5283)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5284)
			p.RenameUserClause()
		}

		p.SetState(5289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeStatementContext is an interface to support dynamic dispatch.
type IRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeStatementContext differentiates from other interfaces.
	IsRevokeStatementContext()
}

type RevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeStatementContext() *RevokeStatementContext {
	var p = new(RevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeStatement
	return p
}

func InitEmptyRevokeStatementContext(p *RevokeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeStatement
}

func (*RevokeStatementContext) IsRevokeStatementContext() {}

func NewRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeStatementContext {
	var p = new(RevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_revokeStatement

	return p
}

func (s *RevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeStatementContext) CopyAll(ctx *RevokeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DetailRevokeContext struct {
	RevokeStatementContext
	privilegeObject antlr.Token
}

func NewDetailRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DetailRevokeContext {
	var p = new(DetailRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *DetailRevokeContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }

func (s *DetailRevokeContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *DetailRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DetailRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *DetailRevokeContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *DetailRevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DetailRevokeContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *DetailRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *DetailRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DetailRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DetailRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DetailRevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *DetailRevokeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *DetailRevokeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *DetailRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDetailRevoke(s)
	}
}

func (s *DetailRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDetailRevoke(s)
	}
}

func (s *DetailRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDetailRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

type RoleRevokeContext struct {
	RevokeStatementContext
}

func NewRoleRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoleRevokeContext {
	var p = new(RoleRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *RoleRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *RoleRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *RoleRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleRevokeContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RoleRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RoleRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleRevoke(s)
	}
}

func (s *RoleRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleRevoke(s)
	}
}

func (s *RoleRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoleRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShortRevokeContext struct {
	RevokeStatementContext
}

func NewShortRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShortRevokeContext {
	var p = new(ShortRevokeContext)

	InitEmptyRevokeStatementContext(&p.RevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeStatementContext))

	return p
}

func (s *ShortRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *ShortRevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ShortRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ShortRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ShortRevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, 0)
}

func (s *ShortRevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *ShortRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShortRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *ShortRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShortRevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *ShortRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShortRevoke(s)
	}
}

func (s *ShortRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShortRevoke(s)
	}
}

func (s *ShortRevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShortRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RevokeStatement() (localctx IRevokeStatementContext) {
	localctx = NewRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, MySqlParserRULE_revokeStatement)
	var _la int

	p.SetState(5360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 797, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDetailRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5290)
			p.Match(MySqlParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5291)
			p.PrivelegeClause()
		}
		p.SetState(5296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5292)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5293)
				p.PrivelegeClause()
			}

			p.SetState(5298)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5299)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5301)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 787, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5300)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*DetailRevokeContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserPROCEDURE || _la == MySqlParserTABLE || _la == MySqlParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*DetailRevokeContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5303)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5304)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5305)
			p.UserName()
		}
		p.SetState(5310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5306)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5307)
				p.UserName()
			}

			p.SetState(5312)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewShortRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5313)
			p.Match(MySqlParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5314)
			p.Match(MySqlParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRIVILEGES {
			{
				p.SetState(5315)
				p.Match(MySqlParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5318)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5319)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5320)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5321)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5322)
			p.UserName()
		}
		p.SetState(5327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5323)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5324)
				p.UserName()
			}

			p.SetState(5329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewRoleRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5330)
			p.Match(MySqlParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 791, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5331)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5332)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5335)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5338)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 792, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5336)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5337)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5344)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5345)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 794, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5346)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5347)
				p.Uid()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5350)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5353)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 795, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5351)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5352)
					p.Uid()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5359)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeProxyContext is an interface to support dynamic dispatch.
type IRevokeProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnUser returns the onUser rule contexts.
	GetOnUser() IUserNameContext

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext

	// SetOnUser sets the onUser rule contexts.
	SetOnUser(IUserNameContext)

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)

	// GetFromOther returns the fromOther rule context list.
	GetFromOther() []IUserNameContext

	// SetFromOther sets the fromOther rule context list.
	SetFromOther([]IUserNameContext)

	// Getter signatures
	REVOKE() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRevokeProxyContext differentiates from other interfaces.
	IsRevokeProxyContext()
}

type RevokeProxyContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	onUser    IUserNameContext
	fromFirst IUserNameContext
	_userName IUserNameContext
	fromOther []IUserNameContext
}

func NewEmptyRevokeProxyContext() *RevokeProxyContext {
	var p = new(RevokeProxyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeProxy
	return p
}

func InitEmptyRevokeProxyContext(p *RevokeProxyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeProxy
}

func (*RevokeProxyContext) IsRevokeProxyContext() {}

func NewRevokeProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeProxyContext {
	var p = new(RevokeProxyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_revokeProxy

	return p
}

func (s *RevokeProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeProxyContext) GetOnUser() IUserNameContext { return s.onUser }

func (s *RevokeProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RevokeProxyContext) Get_userName() IUserNameContext { return s._userName }

func (s *RevokeProxyContext) SetOnUser(v IUserNameContext) { s.onUser = v }

func (s *RevokeProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RevokeProxyContext) Set_userName(v IUserNameContext) { s._userName = v }

func (s *RevokeProxyContext) GetFromOther() []IUserNameContext { return s.fromOther }

func (s *RevokeProxyContext) SetFromOther(v []IUserNameContext) { s.fromOther = v }

func (s *RevokeProxyContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *RevokeProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *RevokeProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *RevokeProxyContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *RevokeProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RevokeProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RevokeProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RevokeProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RevokeProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRevokeProxy(s)
	}
}

func (s *RevokeProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRevokeProxy(s)
	}
}

func (s *RevokeProxyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRevokeProxy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RevokeProxy() (localctx IRevokeProxyContext) {
	localctx = NewRevokeProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, MySqlParserRULE_revokeProxy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5362)
		p.Match(MySqlParserREVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5363)
		p.Match(MySqlParserPROXY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5364)
		p.Match(MySqlParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5365)

		var _x = p.UserName()

		localctx.(*RevokeProxyContext).onUser = _x
	}
	{
		p.SetState(5366)
		p.Match(MySqlParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5367)

		var _x = p.UserName()

		localctx.(*RevokeProxyContext).fromFirst = _x
	}
	p.SetState(5372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5368)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5369)

			var _x = p.UserName()

			localctx.(*RevokeProxyContext)._userName = _x
		}
		localctx.(*RevokeProxyContext).fromOther = append(localctx.(*RevokeProxyContext).fromOther, localctx.(*RevokeProxyContext)._userName)

		p.SetState(5374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetPasswordStatementContext is an interface to support dynamic dispatch.
type ISetPasswordStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	PasswordFunctionClause() IPasswordFunctionClauseContext
	STRING_LITERAL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	UserName() IUserNameContext

	// IsSetPasswordStatementContext differentiates from other interfaces.
	IsSetPasswordStatementContext()
}

type SetPasswordStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetPasswordStatementContext() *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setPasswordStatement
	return p
}

func InitEmptySetPasswordStatementContext(p *SetPasswordStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setPasswordStatement
}

func (*SetPasswordStatementContext) IsSetPasswordStatementContext() {}

func NewSetPasswordStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setPasswordStatement

	return p
}

func (s *SetPasswordStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetPasswordStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetPasswordStatementContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *SetPasswordStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SetPasswordStatementContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *SetPasswordStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SetPasswordStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *SetPasswordStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetPasswordStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetPasswordStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetPasswordStatement(s)
	}
}

func (s *SetPasswordStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetPasswordStatement(s)
	}
}

func (s *SetPasswordStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetPasswordStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SetPasswordStatement() (localctx ISetPasswordStatementContext) {
	localctx = NewSetPasswordStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, MySqlParserRULE_setPasswordStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5375)
		p.Match(MySqlParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5376)
		p.Match(MySqlParserPASSWORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(5377)
			p.Match(MySqlParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5378)
			p.UserName()
		}

	}
	{
		p.SetState(5381)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserOLD_PASSWORD, MySqlParserPASSWORD:
		{
			p.SetState(5382)
			p.PasswordFunctionClause()
		}

	case MySqlParserSTRING_LITERAL:
		{
			p.SetState(5383)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserSpecificationContext is an interface to support dynamic dispatch.
type IUserSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	UserPasswordOption() IUserPasswordOptionContext

	// IsUserSpecificationContext differentiates from other interfaces.
	IsUserSpecificationContext()
}

type UserSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserSpecificationContext() *UserSpecificationContext {
	var p = new(UserSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userSpecification
	return p
}

func InitEmptyUserSpecificationContext(p *UserSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userSpecification
}

func (*UserSpecificationContext) IsUserSpecificationContext() {}

func NewUserSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserSpecificationContext {
	var p = new(UserSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userSpecification

	return p
}

func (s *UserSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *UserSpecificationContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *UserSpecificationContext) UserPasswordOption() IUserPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *UserSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserSpecification(s)
	}
}

func (s *UserSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserSpecification(s)
	}
}

func (s *UserSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UserSpecification() (localctx IUserSpecificationContext) {
	localctx = NewUserSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, MySqlParserRULE_userSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5386)
		p.UserName()
	}
	{
		p.SetState(5387)
		p.UserPasswordOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserAuthOptionContext is an interface to support dynamic dispatch.
type IUserAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserAuthOptionContext differentiates from other interfaces.
	IsUserAuthOptionContext()
}

type UserAuthOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserAuthOptionContext() *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userAuthOption
	return p
}

func InitEmptyUserAuthOptionContext(p *UserAuthOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userAuthOption
}

func (*UserAuthOptionContext) IsUserAuthOptionContext() {}

func NewUserAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userAuthOption

	return p
}

func (s *UserAuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserAuthOptionContext) CopyAll(ctx *UserAuthOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UserAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserAuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleAuthOptionContext struct {
	UserAuthOptionContext
}

func NewSimpleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleAuthOptionContext {
	var p = new(SimpleAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *SimpleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SimpleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleAuthOption(s)
	}
}

func (s *SimpleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleAuthOption(s)
	}
}

func (s *SimpleAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModuleAuthOptionContext struct {
	UserAuthOptionContext
}

func NewModuleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleAuthOptionContext {
	var p = new(ModuleAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *ModuleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ModuleAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *ModuleAuthOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *ModuleAuthOptionContext) AuthenticationRule() IAuthenticationRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthenticationRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthenticationRuleContext)
}

func (s *ModuleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterModuleAuthOption(s)
	}
}

func (s *ModuleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitModuleAuthOption(s)
	}
}

func (s *ModuleAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitModuleAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type RandomAuthOptionContext struct {
	UserAuthOptionContext
}

func NewRandomAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RandomAuthOptionContext {
	var p = new(RandomAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *RandomAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RandomAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RandomAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *RandomAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *RandomAuthOptionContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM, 0)
}

func (s *RandomAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *RandomAuthOptionContext) AuthOptionClause() IAuthOptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionClauseContext)
}

func (s *RandomAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRandomAuthOption(s)
	}
}

func (s *RandomAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRandomAuthOption(s)
	}
}

func (s *RandomAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRandomAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringAuthOptionContext struct {
	UserAuthOptionContext
}

func NewStringAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringAuthOptionContext {
	var p = new(StringAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *StringAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *StringAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *StringAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *StringAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *StringAuthOptionContext) AuthOptionClause() IAuthOptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionClauseContext)
}

func (s *StringAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringAuthOption(s)
	}
}

func (s *StringAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringAuthOption(s)
	}
}

func (s *StringAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type HashAuthOptionContext struct {
	UserAuthOptionContext
	hashed antlr.Token
}

func NewHashAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HashAuthOptionContext {
	var p = new(HashAuthOptionContext)

	InitEmptyUserAuthOptionContext(&p.UserAuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserAuthOptionContext))

	return p
}

func (s *HashAuthOptionContext) GetHashed() antlr.Token { return s.hashed }

func (s *HashAuthOptionContext) SetHashed(v antlr.Token) { s.hashed = v }

func (s *HashAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HashAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *HashAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *HashAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *HashAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *HashAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HashAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHashAuthOption(s)
	}
}

func (s *HashAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHashAuthOption(s)
	}
}

func (s *HashAuthOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHashAuthOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UserAuthOption() (localctx IUserAuthOptionContext) {
	localctx = NewUserAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, MySqlParserRULE_userAuthOption)
	p.SetState(5414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 801, p.GetParserRuleContext()) {
	case 1:
		localctx = NewHashAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5389)
			p.UserName()
		}
		{
			p.SetState(5390)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5391)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5392)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5393)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*HashAuthOptionContext).hashed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewRandomAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5395)
			p.UserName()
		}
		{
			p.SetState(5396)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5397)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5398)
			p.Match(MySqlParserRANDOM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5399)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5400)
			p.AuthOptionClause()
		}

	case 3:
		localctx = NewStringAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5402)
			p.UserName()
		}
		{
			p.SetState(5403)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5404)
			p.Match(MySqlParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5405)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5406)
			p.AuthOptionClause()
		}

	case 4:
		localctx = NewModuleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5408)
			p.UserName()
		}
		{
			p.SetState(5409)
			p.Match(MySqlParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5410)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5411)
			p.AuthenticationRule()
		}

	case 5:
		localctx = NewSimpleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5413)
			p.UserName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthOptionClauseContext is an interface to support dynamic dispatch.
type IAuthOptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode

	// IsAuthOptionClauseContext differentiates from other interfaces.
	IsAuthOptionClauseContext()
}

type AuthOptionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthOptionClauseContext() *AuthOptionClauseContext {
	var p = new(AuthOptionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authOptionClause
	return p
}

func InitEmptyAuthOptionClauseContext(p *AuthOptionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authOptionClause
}

func (*AuthOptionClauseContext) IsAuthOptionClauseContext() {}

func NewAuthOptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthOptionClauseContext {
	var p = new(AuthOptionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authOptionClause

	return p
}

func (s *AuthOptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthOptionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *AuthOptionClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AuthOptionClauseContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETAIN, 0)
}

func (s *AuthOptionClauseContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *AuthOptionClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *AuthOptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthOptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuthOptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAuthOptionClause(s)
	}
}

func (s *AuthOptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAuthOptionClause(s)
	}
}

func (s *AuthOptionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAuthOptionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AuthOptionClause() (localctx IAuthOptionClauseContext) {
	localctx = NewAuthOptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, MySqlParserRULE_authOptionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5418)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 802, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5416)
			p.Match(MySqlParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5417)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserRETAIN {
		{
			p.SetState(5420)
			p.Match(MySqlParserRETAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5421)
			p.Match(MySqlParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5422)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthenticationRuleContext is an interface to support dynamic dispatch.
type IAuthenticationRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthenticationRuleContext differentiates from other interfaces.
	IsAuthenticationRuleContext()
}

type AuthenticationRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthenticationRuleContext() *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authenticationRule
	return p
}

func InitEmptyAuthenticationRuleContext(p *AuthenticationRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authenticationRule
}

func (*AuthenticationRuleContext) IsAuthenticationRuleContext() {}

func NewAuthenticationRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authenticationRule

	return p
}

func (s *AuthenticationRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthenticationRuleContext) CopyAll(ctx *AuthenticationRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthenticationRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthenticationRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PasswordModuleOptionContext struct {
	AuthenticationRuleContext
}

func NewPasswordModuleOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordModuleOptionContext {
	var p = new(PasswordModuleOptionContext)

	InitEmptyAuthenticationRuleContext(&p.AuthenticationRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *PasswordModuleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordModuleOptionContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *PasswordModuleOptionContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *PasswordModuleOptionContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *PasswordModuleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordModuleOption(s)
	}
}

func (s *PasswordModuleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordModuleOption(s)
	}
}

func (s *PasswordModuleOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordModuleOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModuleContext struct {
	AuthenticationRuleContext
}

func NewModuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleContext {
	var p = new(ModuleContext)

	InitEmptyAuthenticationRuleContext(&p.AuthenticationRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *ModuleContext) AuthOptionClause() IAuthOptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionClauseContext)
}

func (s *ModuleContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *ModuleContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *ModuleContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *ModuleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ModuleContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM, 0)
}

func (s *ModuleContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitModule(s)
	}
}

func (s *ModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AuthenticationRule() (localctx IAuthenticationRuleContext) {
	localctx = NewAuthenticationRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, MySqlParserRULE_authenticationRule)
	var _la int

	p.SetState(5439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext()) {
	case 1:
		localctx = NewModuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5425)
			p.AuthPlugin()
		}
		p.SetState(5433)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 805, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5426)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserAS || _la == MySqlParserBY || _la == MySqlParserUSING) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(5430)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSTRING_LITERAL:
				{
					p.SetState(5427)
					p.Match(MySqlParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySqlParserRANDOM:
				{
					p.SetState(5428)
					p.Match(MySqlParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5429)
					p.Match(MySqlParserPASSWORD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(5432)
				p.AuthOptionClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewPasswordModuleOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5435)
			p.AuthPlugin()
		}
		{
			p.SetState(5436)
			p.Match(MySqlParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5437)
			p.PasswordFunctionClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITlsOptionContext is an interface to support dynamic dispatch.
type ITlsOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SSL() antlr.TerminalNode
	X509() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode

	// IsTlsOptionContext differentiates from other interfaces.
	IsTlsOptionContext()
}

type TlsOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTlsOptionContext() *TlsOptionContext {
	var p = new(TlsOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tlsOption
	return p
}

func InitEmptyTlsOptionContext(p *TlsOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tlsOption
}

func (*TlsOptionContext) IsTlsOptionContext() {}

func NewTlsOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TlsOptionContext {
	var p = new(TlsOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tlsOption

	return p
}

func (s *TlsOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TlsOptionContext) SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSSL, 0)
}

func (s *TlsOptionContext) X509() antlr.TerminalNode {
	return s.GetToken(MySqlParserX509, 0)
}

func (s *TlsOptionContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCIPHER, 0)
}

func (s *TlsOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TlsOptionContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSUER, 0)
}

func (s *TlsOptionContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBJECT, 0)
}

func (s *TlsOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TlsOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TlsOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTlsOption(s)
	}
}

func (s *TlsOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTlsOption(s)
	}
}

func (s *TlsOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTlsOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TlsOption() (localctx ITlsOptionContext) {
	localctx = NewTlsOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, MySqlParserRULE_tlsOption)
	p.SetState(5449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSSL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5441)
			p.Match(MySqlParserSSL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserX509:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5442)
			p.Match(MySqlParserX509)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCIPHER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5443)
			p.Match(MySqlParserCIPHER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5444)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserISSUER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5445)
			p.Match(MySqlParserISSUER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5446)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSUBJECT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5447)
			p.Match(MySqlParserSUBJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5448)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserResourceOptionContext is an interface to support dynamic dispatch.
type IUserResourceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode

	// IsUserResourceOptionContext differentiates from other interfaces.
	IsUserResourceOptionContext()
}

type UserResourceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserResourceOptionContext() *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userResourceOption
	return p
}

func InitEmptyUserResourceOptionContext(p *UserResourceOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userResourceOption
}

func (*UserResourceOptionContext) IsUserResourceOptionContext() {}

func NewUserResourceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userResourceOption

	return p
}

func (s *UserResourceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserResourceOptionContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserResourceOptionContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_USER_CONNECTIONS, 0)
}

func (s *UserResourceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserResourceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserResourceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserResourceOption(s)
	}
}

func (s *UserResourceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserResourceOption(s)
	}
}

func (s *UserResourceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserResourceOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UserResourceOption() (localctx IUserResourceOptionContext) {
	localctx = NewUserResourceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, MySqlParserRULE_userResourceOption)
	p.SetState(5459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserMAX_QUERIES_PER_HOUR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5451)
			p.Match(MySqlParserMAX_QUERIES_PER_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5452)
			p.DecimalLiteral()
		}

	case MySqlParserMAX_UPDATES_PER_HOUR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5453)
			p.Match(MySqlParserMAX_UPDATES_PER_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5454)
			p.DecimalLiteral()
		}

	case MySqlParserMAX_CONNECTIONS_PER_HOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5455)
			p.Match(MySqlParserMAX_CONNECTIONS_PER_HOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5456)
			p.DecimalLiteral()
		}

	case MySqlParserMAX_USER_CONNECTIONS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5457)
			p.Match(MySqlParserMAX_USER_CONNECTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5458)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPasswordOptionContext is an interface to support dynamic dispatch.
type IUserPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExpireType returns the expireType token.
	GetExpireType() antlr.Token

	// SetExpireType sets the expireType token.
	SetExpireType(antlr.Token)

	// Getter signatures
	PASSWORD() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	DAY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode

	// IsUserPasswordOptionContext differentiates from other interfaces.
	IsUserPasswordOptionContext()
}

type UserPasswordOptionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	expireType antlr.Token
}

func NewEmptyUserPasswordOptionContext() *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userPasswordOption
	return p
}

func InitEmptyUserPasswordOptionContext(p *UserPasswordOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userPasswordOption
}

func (*UserPasswordOptionContext) IsUserPasswordOptionContext() {}

func NewUserPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userPasswordOption

	return p
}

func (s *UserPasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPasswordOptionContext) GetExpireType() antlr.Token { return s.expireType }

func (s *UserPasswordOptionContext) SetExpireType(v antlr.Token) { s.expireType = v }

func (s *UserPasswordOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *UserPasswordOptionContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPIRE, 0)
}

func (s *UserPasswordOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserPasswordOptionContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *UserPasswordOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *UserPasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEVER, 0)
}

func (s *UserPasswordOptionContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *UserPasswordOptionContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTORY, 0)
}

func (s *UserPasswordOptionContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREUSE, 0)
}

func (s *UserPasswordOptionContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *UserPasswordOptionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *UserPasswordOptionContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONAL, 0)
}

func (s *UserPasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *UserPasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD_LOCK_TIME, 0)
}

func (s *UserPasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *UserPasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPasswordOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserPasswordOption(s)
	}
}

func (s *UserPasswordOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserPasswordOption(s)
	}
}

func (s *UserPasswordOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserPasswordOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UserPasswordOption() (localctx IUserPasswordOptionContext) {
	localctx = NewUserPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, MySqlParserRULE_userPasswordOption)
	var _la int

	p.SetState(5499)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 814, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5461)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5462)
			p.Match(MySqlParserEXPIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5463)

				var _m = p.Match(MySqlParserDEFAULT)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserNEVER:
			{
				p.SetState(5464)

				var _m = p.Match(MySqlParserNEVER)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserINTERVAL:
			{
				p.SetState(5465)

				var _m = p.Match(MySqlParserINTERVAL)

				localctx.(*UserPasswordOptionContext).expireType = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5466)
				p.DecimalLiteral()
			}
			{
				p.SetState(5467)
				p.Match(MySqlParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserATTRIBUTE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserACCOUNT, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5471)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5472)
			p.Match(MySqlParserHISTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5473)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5474)
				p.DecimalLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5477)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5478)
			p.Match(MySqlParserREUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5479)
			p.Match(MySqlParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5480)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5481)
				p.DecimalLiteral()
			}
			{
				p.SetState(5482)
				p.Match(MySqlParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5486)
			p.Match(MySqlParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5487)
			p.Match(MySqlParserREQUIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5488)
			p.Match(MySqlParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT || _la == MySqlParserOPTIONAL {
			{
				p.SetState(5489)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserDEFAULT || _la == MySqlParserOPTIONAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5492)
			p.Match(MySqlParserFAILED_LOGIN_ATTEMPTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5493)
			p.DecimalLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5494)
			p.Match(MySqlParserPASSWORD_LOCK_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5495)
				p.DecimalLiteral()
			}

		case MySqlParserUNBOUNDED:
			{
				p.SetState(5496)
				p.Match(MySqlParserUNBOUNDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserLockOptionContext is an interface to support dynamic dispatch.
type IUserLockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode

	// IsUserLockOptionContext differentiates from other interfaces.
	IsUserLockOptionContext()
}

type UserLockOptionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	lockType antlr.Token
}

func NewEmptyUserLockOptionContext() *UserLockOptionContext {
	var p = new(UserLockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userLockOption
	return p
}

func InitEmptyUserLockOptionContext(p *UserLockOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userLockOption
}

func (*UserLockOptionContext) IsUserLockOptionContext() {}

func NewUserLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserLockOptionContext {
	var p = new(UserLockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userLockOption

	return p
}

func (s *UserLockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserLockOptionContext) GetLockType() antlr.Token { return s.lockType }

func (s *UserLockOptionContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *UserLockOptionContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserACCOUNT, 0)
}

func (s *UserLockOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *UserLockOptionContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNLOCK, 0)
}

func (s *UserLockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserLockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserLockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserLockOption(s)
	}
}

func (s *UserLockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserLockOption(s)
	}
}

func (s *UserLockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UserLockOption() (localctx IUserLockOptionContext) {
	localctx = NewUserLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, MySqlParserRULE_userLockOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5501)
		p.Match(MySqlParserACCOUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5502)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*UserLockOptionContext).lockType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserLOCK || _la == MySqlParserUNLOCK) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*UserLockOptionContext).lockType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivelegeClauseContext is an interface to support dynamic dispatch.
type IPrivelegeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Privilege() IPrivilegeContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode

	// IsPrivelegeClauseContext differentiates from other interfaces.
	IsPrivelegeClauseContext()
}

type PrivelegeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivelegeClauseContext() *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privelegeClause
	return p
}

func InitEmptyPrivelegeClauseContext(p *PrivelegeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privelegeClause
}

func (*PrivelegeClauseContext) IsPrivelegeClauseContext() {}

func NewPrivelegeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privelegeClause

	return p
}

func (s *PrivelegeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivelegeClauseContext) Privilege() IPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivelegeClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PrivelegeClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivelegeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivelegeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivelegeClause(s)
	}
}

func (s *PrivelegeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivelegeClause(s)
	}
}

func (s *PrivelegeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrivelegeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PrivelegeClause() (localctx IPrivelegeClauseContext) {
	localctx = NewPrivelegeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, MySqlParserRULE_privelegeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5504)
		p.Privilege()
	}
	p.SetState(5509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(5505)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5506)
			p.UidList()
		}
		{
			p.SetState(5507)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	USER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode
	AUDIT_ABORT_EXEMPT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_EXEMPT() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode
	FLUSH_STATUS() antlr.TerminalNode
	FLUSH_TABLES() antlr.TerminalNode
	FLUSH_USER_RESOURCES() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INNODB_REDO_LOG_ENABLE() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	SERVICE_CONNECTION_ADMIN() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SKIP_QUERY_REWRITE() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TP_CONNECTION_ADMIN() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	S3() antlr.TerminalNode
	INTO() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *PrivilegeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *PrivilegeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *PrivilegeContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUTINE, 0)
}

func (s *PrivilegeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *PrivilegeContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *PrivilegeContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *PrivilegeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *PrivilegeContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *PrivilegeContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *PrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *PrivilegeContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *PrivilegeContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *PrivilegeContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *PrivilegeContext) FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE, 0)
}

func (s *PrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, 0)
}

func (s *PrivilegeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *PrivilegeContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *PrivilegeContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *PrivilegeContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESS, 0)
}

func (s *PrivilegeContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *PrivilegeContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserREFERENCES, 0)
}

func (s *PrivilegeContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELOAD, 0)
}

func (s *PrivilegeContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *PrivilegeContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLIENT, 0)
}

func (s *PrivilegeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *PrivilegeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *PrivilegeContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASES, 0)
}

func (s *PrivilegeContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *PrivilegeContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUPER, 0)
}

func (s *PrivilegeContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *PrivilegeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *PrivilegeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSAGE, 0)
}

func (s *PrivilegeContext) APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAPPLICATION_PASSWORD_ADMIN, 0)
}

func (s *PrivilegeContext) AUDIT_ABORT_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ABORT_EXEMPT, 0)
}

func (s *PrivilegeContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ADMIN, 0)
}

func (s *PrivilegeContext) AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHENTICATION_POLICY_ADMIN, 0)
}

func (s *PrivilegeContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBACKUP_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLONE_ADMIN, 0)
}

func (s *PrivilegeContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_EXEMPT, 0)
}

func (s *PrivilegeContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_USER, 0)
}

func (s *PrivilegeContext) FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_OPTIMIZER_COSTS, 0)
}

func (s *PrivilegeContext) FLUSH_STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_STATUS, 0)
}

func (s *PrivilegeContext) FLUSH_TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_TABLES, 0)
}

func (s *PrivilegeContext) FLUSH_USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_USER_RESOURCES, 0)
}

func (s *PrivilegeContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ENABLE, 0)
}

func (s *PrivilegeContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB_STORED_USER, 0)
}

func (s *PrivilegeContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *PrivilegeContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_APPLIER, 0)
}

func (s *PrivilegeContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_USER, 0)
}

func (s *PrivilegeContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE_ADMIN, 0)
}

func (s *PrivilegeContext) SERVICE_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVICE_CONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET_USER_ID, 0)
}

func (s *PrivilegeContext) SKIP_QUERY_REWRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSKIP_QUERY_REWRITE, 0)
}

func (s *PrivilegeContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW_ROUTINE, 0)
}

func (s *PrivilegeContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_USER, 0)
}

func (s *PrivilegeContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) TP_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTP_CONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION_TOKEN_ADMIN, 0)
}

func (s *PrivilegeContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA_RECOVER_ADMIN, 0)
}

func (s *PrivilegeContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *PrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *PrivilegeContext) S3() antlr.TerminalNode {
	return s.GetToken(MySqlParserS3, 0)
}

func (s *PrivilegeContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *PrivilegeContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKE, 0)
}

func (s *PrivilegeContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAMBDA, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, MySqlParserRULE_privilege)
	var _la int

	p.SetState(5604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 820, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5511)
			p.Match(MySqlParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRIVILEGES {
			{
				p.SetState(5512)
				p.Match(MySqlParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5515)
			p.Match(MySqlParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserROUTINE {
			{
				p.SetState(5516)
				p.Match(MySqlParserROUTINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5519)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySqlParserTEMPORARY:
			{
				p.SetState(5520)
				p.Match(MySqlParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5521)
				p.Match(MySqlParserTABLES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserROUTINE:
			{
				p.SetState(5522)
				p.Match(MySqlParserROUTINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserVIEW:
			{
				p.SetState(5523)
				p.Match(MySqlParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserUSER:
			{
				p.SetState(5524)
				p.Match(MySqlParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserTABLESPACE:
			{
				p.SetState(5525)
				p.Match(MySqlParserTABLESPACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserROLE:
			{
				p.SetState(5526)
				p.Match(MySqlParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserON, MySqlParserLR_BRACKET, MySqlParserCOMMA:

		default:
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5529)
			p.Match(MySqlParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5530)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserROLE {
			{
				p.SetState(5531)
				p.Match(MySqlParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5534)
			p.Match(MySqlParserEVENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5535)
			p.Match(MySqlParserEXECUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5536)
			p.Match(MySqlParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5537)
			p.Match(MySqlParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5538)
			p.Match(MySqlParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5539)
			p.Match(MySqlParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5540)
			p.Match(MySqlParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5541)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5542)
			p.Match(MySqlParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5543)
			p.Match(MySqlParserPROCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5544)
			p.Match(MySqlParserPROXY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5545)
			p.Match(MySqlParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5546)
			p.Match(MySqlParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5547)
			p.Match(MySqlParserREPLICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5548)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCLIENT || _la == MySqlParserSLAVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5549)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5550)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5551)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASES || _la == MySqlParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5552)
			p.Match(MySqlParserSHUTDOWN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5553)
			p.Match(MySqlParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(5554)
			p.Match(MySqlParserTRIGGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(5555)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(5556)
			p.Match(MySqlParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(5557)
			p.Match(MySqlParserAPPLICATION_PASSWORD_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(5558)
			p.Match(MySqlParserAUDIT_ABORT_EXEMPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(5559)
			p.Match(MySqlParserAUDIT_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(5560)
			p.Match(MySqlParserAUTHENTICATION_POLICY_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(5561)
			p.Match(MySqlParserBACKUP_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(5562)
			p.Match(MySqlParserBINLOG_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(5563)
			p.Match(MySqlParserBINLOG_ENCRYPTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(5564)
			p.Match(MySqlParserCLONE_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(5565)
			p.Match(MySqlParserCONNECTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(5566)
			p.Match(MySqlParserENCRYPTION_KEY_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(5567)
			p.Match(MySqlParserFIREWALL_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(5568)
			p.Match(MySqlParserFIREWALL_EXEMPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(5569)
			p.Match(MySqlParserFIREWALL_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(5570)
			p.Match(MySqlParserFLUSH_OPTIMIZER_COSTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(5571)
			p.Match(MySqlParserFLUSH_STATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(5572)
			p.Match(MySqlParserFLUSH_TABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(5573)
			p.Match(MySqlParserFLUSH_USER_RESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(5574)
			p.Match(MySqlParserGROUP_REPLICATION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(5575)
			p.Match(MySqlParserINNODB_REDO_LOG_ARCHIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(5576)
			p.Match(MySqlParserINNODB_REDO_LOG_ENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(5577)
			p.Match(MySqlParserNDB_STORED_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(5578)
			p.Match(MySqlParserPASSWORDLESS_USER_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(5579)
			p.Match(MySqlParserPERSIST_RO_VARIABLES_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(5580)
			p.Match(MySqlParserREPLICATION_APPLIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(5581)
			p.Match(MySqlParserREPLICATION_SLAVE_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(5582)
			p.Match(MySqlParserRESOURCE_GROUP_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(5583)
			p.Match(MySqlParserRESOURCE_GROUP_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(5584)
			p.Match(MySqlParserROLE_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(5585)
			p.Match(MySqlParserSERVICE_CONNECTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(5586)
			p.Match(MySqlParserSESSION_VARIABLES_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(5587)
			p.Match(MySqlParserSET_USER_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(5588)
			p.Match(MySqlParserSKIP_QUERY_REWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(5589)
			p.Match(MySqlParserSHOW_ROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(5590)
			p.Match(MySqlParserSYSTEM_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(5591)
			p.Match(MySqlParserSYSTEM_VARIABLES_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(5592)
			p.Match(MySqlParserTABLE_ENCRYPTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(5593)
			p.Match(MySqlParserTP_CONNECTION_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(5594)
			p.Match(MySqlParserVERSION_TOKEN_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(5595)
			p.Match(MySqlParserXA_RECOVER_ADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(5596)
			p.Match(MySqlParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5597)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5598)
			p.Match(MySqlParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(5599)
			p.Match(MySqlParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5600)
			p.Match(MySqlParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5601)
			p.Match(MySqlParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(5602)
			p.Match(MySqlParserINVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5603)
			p.Match(MySqlParserLAMBDA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeLevelContext is an interface to support dynamic dispatch.
type IPrivilegeLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrivilegeLevelContext differentiates from other interfaces.
	IsPrivilegeLevelContext()
}

type PrivilegeLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeLevelContext() *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegeLevel
	return p
}

func InitEmptyPrivilegeLevelContext(p *PrivilegeLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegeLevel
}

func (*PrivilegeLevelContext) IsPrivilegeLevelContext() {}

func NewPrivilegeLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilegeLevel

	return p
}

func (s *PrivilegeLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeLevelContext) CopyAll(ctx *PrivilegeLevelContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrivilegeLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DefiniteSchemaPrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteSchemaPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteSchemaPrivLevelContext {
	var p = new(DefiniteSchemaPrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteSchemaPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteSchemaPrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteSchemaPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DefiniteSchemaPrivLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *DefiniteSchemaPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteSchemaPrivLevel(s)
	}
}

func (s *DefiniteSchemaPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteSchemaPrivLevel(s)
	}
}

func (s *DefiniteSchemaPrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteSchemaPrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefiniteFullTablePrivLevel2Context struct {
	PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevel2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevel2Context {
	var p = new(DefiniteFullTablePrivLevel2Context)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevel2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevel2Context) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevel2Context) DottedId() IDottedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *DefiniteFullTablePrivLevel2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel2(s)
	}
}

func (s *DefiniteFullTablePrivLevel2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel2(s)
	}
}

func (s *DefiniteFullTablePrivLevel2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteFullTablePrivLevel2(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefiniteFullTablePrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevelContext {
	var p = new(DefiniteFullTablePrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevelContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *DefiniteFullTablePrivLevelContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DefiniteFullTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel(s)
	}
}

func (s *DefiniteFullTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel(s)
	}
}

func (s *DefiniteFullTablePrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteFullTablePrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type GlobalPrivLevelContext struct {
	PrivilegeLevelContext
}

func NewGlobalPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GlobalPrivLevelContext {
	var p = new(GlobalPrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *GlobalPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalPrivLevelContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTAR)
}

func (s *GlobalPrivLevelContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, i)
}

func (s *GlobalPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *GlobalPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGlobalPrivLevel(s)
	}
}

func (s *GlobalPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGlobalPrivLevel(s)
	}
}

func (s *GlobalPrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGlobalPrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type DefiniteTablePrivLevelContext struct {
	PrivilegeLevelContext
}

func NewDefiniteTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteTablePrivLevelContext {
	var p = new(DefiniteTablePrivLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteTablePrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteTablePrivLevel(s)
	}
}

func (s *DefiniteTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteTablePrivLevel(s)
	}
}

func (s *DefiniteTablePrivLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefiniteTablePrivLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentSchemaPriviLevelContext struct {
	PrivilegeLevelContext
}

func NewCurrentSchemaPriviLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentSchemaPriviLevelContext {
	var p = new(CurrentSchemaPriviLevelContext)

	InitEmptyPrivilegeLevelContext(&p.PrivilegeLevelContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *CurrentSchemaPriviLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentSchemaPriviLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *CurrentSchemaPriviLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentSchemaPriviLevel(s)
	}
}

func (s *CurrentSchemaPriviLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentSchemaPriviLevel(s)
	}
}

func (s *CurrentSchemaPriviLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentSchemaPriviLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PrivilegeLevel() (localctx IPrivilegeLevelContext) {
	localctx = NewPrivilegeLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, MySqlParserRULE_privilegeLevel)
	p.SetState(5622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 821, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentSchemaPriviLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5606)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewGlobalPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5607)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5608)
			p.Match(MySqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5609)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDefiniteSchemaPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5610)
			p.Uid()
		}
		{
			p.SetState(5611)
			p.Match(MySqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5612)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewDefiniteFullTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5614)
			p.Uid()
		}
		{
			p.SetState(5615)
			p.Match(MySqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5616)
			p.Uid()
		}

	case 5:
		localctx = NewDefiniteFullTablePrivLevel2Context(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5618)
			p.Uid()
		}
		{
			p.SetState(5619)
			p.DottedId()
		}

	case 6:
		localctx = NewDefiniteTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5621)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameUserClauseContext is an interface to support dynamic dispatch.
type IRenameUserClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)

	// Getter signatures
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext

	// IsRenameUserClauseContext differentiates from other interfaces.
	IsRenameUserClauseContext()
}

type RenameUserClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	fromFirst IUserNameContext
	toFirst   IUserNameContext
}

func NewEmptyRenameUserClauseContext() *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUserClause
	return p
}

func InitEmptyRenameUserClauseContext(p *RenameUserClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUserClause
}

func (*RenameUserClauseContext) IsRenameUserClauseContext() {}

func NewRenameUserClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameUserClause

	return p
}

func (s *RenameUserClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserClauseContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RenameUserClauseContext) GetToFirst() IUserNameContext { return s.toFirst }

func (s *RenameUserClauseContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RenameUserClauseContext) SetToFirst(v IUserNameContext) { s.toFirst = v }

func (s *RenameUserClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RenameUserClauseContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserClauseContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RenameUserClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameUserClause(s)
	}
}

func (s *RenameUserClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameUserClause(s)
	}
}

func (s *RenameUserClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRenameUserClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RenameUserClause() (localctx IRenameUserClauseContext) {
	localctx = NewRenameUserClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, MySqlParserRULE_renameUserClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5624)

		var _x = p.UserName()

		localctx.(*RenameUserClauseContext).fromFirst = _x
	}
	{
		p.SetState(5625)
		p.Match(MySqlParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5626)

		var _x = p.UserName()

		localctx.(*RenameUserClauseContext).toFirst = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeTableContext is an interface to support dynamic dispatch.
type IAnalyzeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllHISTOGRAM() []antlr.TerminalNode
	HISTOGRAM(i int) antlr.TerminalNode
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	DROP() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	BUCKETS() antlr.TerminalNode

	// IsAnalyzeTableContext differentiates from other interfaces.
	IsAnalyzeTableContext()
}

type AnalyzeTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyAnalyzeTableContext() *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_analyzeTable
	return p
}

func InitEmptyAnalyzeTableContext(p *AnalyzeTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_analyzeTable
}

func (*AnalyzeTableContext) IsAnalyzeTableContext() {}

func NewAnalyzeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_analyzeTable

	return p
}

func (s *AnalyzeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *AnalyzeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *AnalyzeTableContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserANALYZE, 0)
}

func (s *AnalyzeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *AnalyzeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AnalyzeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *AnalyzeTableContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *AnalyzeTableContext) AllHISTOGRAM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserHISTOGRAM)
}

func (s *AnalyzeTableContext) HISTOGRAM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTOGRAM, i)
}

func (s *AnalyzeTableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *AnalyzeTableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *AnalyzeTableContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeTableContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *AnalyzeTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AnalyzeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *AnalyzeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *AnalyzeTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AnalyzeTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AnalyzeTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AnalyzeTableContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AnalyzeTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUCKETS, 0)
}

func (s *AnalyzeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAnalyzeTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AnalyzeTable() (localctx IAnalyzeTableContext) {
	localctx = NewAnalyzeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, MySqlParserRULE_analyzeTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5628)
		p.Match(MySqlParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5629)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AnalyzeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AnalyzeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5632)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5633)
		p.Tables()
	}
	p.SetState(5651)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 825, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5634)
			p.Match(MySqlParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5635)
			p.Match(MySqlParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5636)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5637)
			p.FullColumnName()
		}
		p.SetState(5642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5638)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5639)
				p.FullColumnName()
			}

			p.SetState(5644)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5649)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 824, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5645)
				p.Match(MySqlParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5646)
				p.DecimalLiteral()
			}
			{
				p.SetState(5647)
				p.Match(MySqlParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5664)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 827, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5653)
			p.Match(MySqlParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5654)
			p.Match(MySqlParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5655)
			p.Match(MySqlParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5656)
			p.FullColumnName()
		}
		p.SetState(5661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5657)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5658)
				p.FullColumnName()
			}

			p.SetState(5663)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckTableContext is an interface to support dynamic dispatch.
type ICheckTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	AllCheckTableOption() []ICheckTableOptionContext
	CheckTableOption(i int) ICheckTableOptionContext

	// IsCheckTableContext differentiates from other interfaces.
	IsCheckTableContext()
}

type CheckTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableContext() *CheckTableContext {
	var p = new(CheckTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTable
	return p
}

func InitEmptyCheckTableContext(p *CheckTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTable
}

func (*CheckTableContext) IsCheckTableContext() {}

func NewCheckTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableContext {
	var p = new(CheckTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checkTable

	return p
}

func (s *CheckTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *CheckTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *CheckTableContext) AllCheckTableOption() []ICheckTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICheckTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckTableOptionContext); ok {
			tst[i] = t.(ICheckTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CheckTableContext) CheckTableOption(i int) ICheckTableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableOptionContext)
}

func (s *CheckTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTable(s)
	}
}

func (s *CheckTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTable(s)
	}
}

func (s *CheckTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CheckTable() (localctx ICheckTableContext) {
	localctx = NewCheckTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, MySqlParserRULE_checkTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5666)
		p.Match(MySqlParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5667)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5668)
		p.Tables()
	}
	p.SetState(5672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserFOR || _la == MySqlParserCHANGED || _la == MySqlParserEXTENDED || _la == MySqlParserFAST || _la == MySqlParserMEDIUM || _la == MySqlParserQUICK {
		{
			p.SetState(5669)
			p.CheckTableOption()
		}

		p.SetState(5674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChecksumTableContext is an interface to support dynamic dispatch.
type IChecksumTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	CHECKSUM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode

	// IsChecksumTableContext differentiates from other interfaces.
	IsChecksumTableContext()
}

type ChecksumTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyChecksumTableContext() *ChecksumTableContext {
	var p = new(ChecksumTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checksumTable
	return p
}

func InitEmptyChecksumTableContext(p *ChecksumTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checksumTable
}

func (*ChecksumTableContext) IsChecksumTableContext() {}

func NewChecksumTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChecksumTableContext {
	var p = new(ChecksumTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checksumTable

	return p
}

func (s *ChecksumTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ChecksumTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *ChecksumTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *ChecksumTableContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *ChecksumTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ChecksumTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *ChecksumTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *ChecksumTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *ChecksumTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChecksumTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChecksumTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChecksumTable(s)
	}
}

func (s *ChecksumTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChecksumTable(s)
	}
}

func (s *ChecksumTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChecksumTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ChecksumTable() (localctx IChecksumTableContext) {
	localctx = NewChecksumTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, MySqlParserRULE_checksumTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5675)
		p.Match(MySqlParserCHECKSUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5676)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5677)
		p.Tables()
	}
	p.SetState(5679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENDED || _la == MySqlParserQUICK {
		{
			p.SetState(5678)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ChecksumTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserEXTENDED || _la == MySqlParserQUICK) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ChecksumTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeTableContext is an interface to support dynamic dispatch.
type IOptimizeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	OPTIMIZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsOptimizeTableContext differentiates from other interfaces.
	IsOptimizeTableContext()
}

type OptimizeTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyOptimizeTableContext() *OptimizeTableContext {
	var p = new(OptimizeTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_optimizeTable
	return p
}

func InitEmptyOptimizeTableContext(p *OptimizeTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_optimizeTable
}

func (*OptimizeTableContext) IsOptimizeTableContext() {}

func NewOptimizeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeTableContext {
	var p = new(OptimizeTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_optimizeTable

	return p
}

func (s *OptimizeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *OptimizeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *OptimizeTableContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZE, 0)
}

func (s *OptimizeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *OptimizeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *OptimizeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *OptimizeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *OptimizeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *OptimizeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOptimizeTable(s)
	}
}

func (s *OptimizeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOptimizeTable(s)
	}
}

func (s *OptimizeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOptimizeTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OptimizeTable() (localctx IOptimizeTableContext) {
	localctx = NewOptimizeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, MySqlParserRULE_optimizeTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5681)
		p.Match(MySqlParserOPTIMIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5682)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OptimizeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OptimizeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5685)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5686)
		p.Tables()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepairTableContext is an interface to support dynamic dispatch.
type IRepairTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsRepairTableContext differentiates from other interfaces.
	IsRepairTableContext()
}

type RepairTableContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyRepairTableContext() *RepairTableContext {
	var p = new(RepairTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repairTable
	return p
}

func InitEmptyRepairTableContext(p *RepairTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_repairTable
}

func (*RepairTableContext) IsRepairTableContext() {}

func NewRepairTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepairTableContext {
	var p = new(RepairTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_repairTable

	return p
}

func (s *RepairTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RepairTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *RepairTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *RepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *RepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *RepairTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *RepairTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *RepairTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *RepairTableContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE_FRM, 0)
}

func (s *RepairTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *RepairTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *RepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepairTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRepairTable(s)
	}
}

func (s *RepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRepairTable(s)
	}
}

func (s *RepairTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRepairTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RepairTable() (localctx IRepairTableContext) {
	localctx = NewRepairTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, MySqlParserRULE_repairTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5688)
		p.Match(MySqlParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5689)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RepairTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RepairTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5692)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5693)
		p.Tables()
	}
	p.SetState(5695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserQUICK {
		{
			p.SetState(5694)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENDED {
		{
			p.SetState(5697)
			p.Match(MySqlParserEXTENDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUSE_FRM {
		{
			p.SetState(5700)
			p.Match(MySqlParserUSE_FRM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckTableOptionContext is an interface to support dynamic dispatch.
type ICheckTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	FAST() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	CHANGED() antlr.TerminalNode

	// IsCheckTableOptionContext differentiates from other interfaces.
	IsCheckTableOptionContext()
}

type CheckTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableOptionContext() *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTableOption
	return p
}

func InitEmptyCheckTableOptionContext(p *CheckTableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTableOption
}

func (*CheckTableOptionContext) IsCheckTableOptionContext() {}

func NewCheckTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checkTableOption

	return p
}

func (s *CheckTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *CheckTableOptionContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *CheckTableOptionContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *CheckTableOptionContext) FAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAST, 0)
}

func (s *CheckTableOptionContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUM, 0)
}

func (s *CheckTableOptionContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *CheckTableOptionContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGED, 0)
}

func (s *CheckTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTableOption(s)
	}
}

func (s *CheckTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTableOption(s)
	}
}

func (s *CheckTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCheckTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CheckTableOption() (localctx ICheckTableOptionContext) {
	localctx = NewCheckTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, MySqlParserRULE_checkTableOption)
	p.SetState(5710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5703)
			p.Match(MySqlParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5704)
			p.Match(MySqlParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserQUICK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5705)
			p.Match(MySqlParserQUICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserFAST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5706)
			p.Match(MySqlParserFAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMEDIUM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5707)
			p.Match(MySqlParserMEDIUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserEXTENDED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5708)
			p.Match(MySqlParserEXTENDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCHANGED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5709)
			p.Match(MySqlParserCHANGED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUdfunctionContext is an interface to support dynamic dispatch.
type ICreateUdfunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnType returns the returnType token.
	GetReturnType() antlr.Token

	// SetReturnType sets the returnType token.
	SetReturnType(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	Uid() IUidContext
	RETURNS() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext

	// IsCreateUdfunctionContext differentiates from other interfaces.
	IsCreateUdfunctionContext()
}

type CreateUdfunctionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	returnType antlr.Token
}

func NewEmptyCreateUdfunctionContext() *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUdfunction
	return p
}

func InitEmptyCreateUdfunctionContext(p *CreateUdfunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_createUdfunction
}

func (*CreateUdfunctionContext) IsCreateUdfunctionContext() {}

func NewCreateUdfunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createUdfunction

	return p
}

func (s *CreateUdfunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUdfunctionContext) GetReturnType() antlr.Token { return s.returnType }

func (s *CreateUdfunctionContext) SetReturnType(v antlr.Token) { s.returnType = v }

func (s *CreateUdfunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUdfunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *CreateUdfunctionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateUdfunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *CreateUdfunctionContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *CreateUdfunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateUdfunctionContext) STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING, 0)
}

func (s *CreateUdfunctionContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *CreateUdfunctionContext) REAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL, 0)
}

func (s *CreateUdfunctionContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *CreateUdfunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *CreateUdfunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUdfunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUdfunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUdfunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUdfunction(s)
	}
}

func (s *CreateUdfunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUdfunction(s)
	}
}

func (s *CreateUdfunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCreateUdfunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CreateUdfunction() (localctx ICreateUdfunctionContext) {
	localctx = NewCreateUdfunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, MySqlParserRULE_createUdfunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5712)
		p.Match(MySqlParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAGGREGATE {
		{
			p.SetState(5713)
			p.Match(MySqlParserAGGREGATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5716)
		p.Match(MySqlParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5718)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 837, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5717)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5720)
		p.Uid()
	}
	{
		p.SetState(5721)
		p.Match(MySqlParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5722)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateUdfunctionContext).returnType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&261) != 0) || _la == MySqlParserSTRING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateUdfunctionContext).returnType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5723)
		p.Match(MySqlParserSONAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5724)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallPluginContext is an interface to support dynamic dispatch.
type IInstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsInstallPluginContext differentiates from other interfaces.
	IsInstallPluginContext()
}

type InstallPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginContext() *InstallPluginContext {
	var p = new(InstallPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_installPlugin
	return p
}

func InitEmptyInstallPluginContext(p *InstallPluginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_installPlugin
}

func (*InstallPluginContext) IsInstallPluginContext() {}

func NewInstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginContext {
	var p = new(InstallPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_installPlugin

	return p
}

func (s *InstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTALL, 0)
}

func (s *InstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *InstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *InstallPluginContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *InstallPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *InstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInstallPlugin(s)
	}
}

func (s *InstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInstallPlugin(s)
	}
}

func (s *InstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) InstallPlugin() (localctx IInstallPluginContext) {
	localctx = NewInstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, MySqlParserRULE_installPlugin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5726)
		p.Match(MySqlParserINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5727)
		p.Match(MySqlParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5728)
		p.Uid()
	}
	{
		p.SetState(5729)
		p.Match(MySqlParserSONAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5730)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUninstallPluginContext is an interface to support dynamic dispatch.
type IUninstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext

	// IsUninstallPluginContext differentiates from other interfaces.
	IsUninstallPluginContext()
}

type UninstallPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginContext() *UninstallPluginContext {
	var p = new(UninstallPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uninstallPlugin
	return p
}

func InitEmptyUninstallPluginContext(p *UninstallPluginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uninstallPlugin
}

func (*UninstallPluginContext) IsUninstallPluginContext() {}

func NewUninstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginContext {
	var p = new(UninstallPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uninstallPlugin

	return p
}

func (s *UninstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNINSTALL, 0)
}

func (s *UninstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *UninstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UninstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UninstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUninstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UninstallPlugin() (localctx IUninstallPluginContext) {
	localctx = NewUninstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, MySqlParserRULE_uninstallPlugin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5732)
		p.Match(MySqlParserUNINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5733)
		p.Match(MySqlParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5734)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) CopyAll(ctx *SetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SetTransactionStatement() ISetTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTransactionStatementContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetCharsetContext struct {
	SetStatementContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *SetCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetCharset(s)
	}
}

func (s *SetCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetCharset(s)
	}
}

func (s *SetCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetNamesContext struct {
	SetStatementContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAMES, 0)
}

func (s *SetNamesContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetNamesContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *SetNamesContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

func (s *SetNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetNames(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetPasswordContext struct {
	SetStatementContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) SetPasswordStatement() ISetPasswordStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetPasswordStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetPasswordStatementContext)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

func (s *SetPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetAutocommitContext struct {
	SetStatementContext
}

func NewSetAutocommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetAutocommitContext {
	var p = new(SetAutocommitContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetAutocommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitContext) SetAutocommitStatement() ISetAutocommitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAutocommitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAutocommitStatementContext)
}

func (s *SetAutocommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetAutocommit(s)
	}
}

func (s *SetAutocommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetAutocommit(s)
	}
}

func (s *SetAutocommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetAutocommit(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetNewValueInsideTriggerContext struct {
	SetStatementContext
}

func NewSetNewValueInsideTriggerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNewValueInsideTriggerContext {
	var p = new(SetNewValueInsideTriggerContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetNewValueInsideTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNewValueInsideTriggerContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetNewValueInsideTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SetNewValueInsideTriggerContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNewValueInsideTriggerContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *SetNewValueInsideTriggerContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *SetNewValueInsideTriggerContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserVAR_ASSIGN)
}

func (s *SetNewValueInsideTriggerContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, i)
}

func (s *SetNewValueInsideTriggerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetNewValueInsideTriggerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetNewValueInsideTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetNewValueInsideTrigger(s)
	}
}

func (s *SetNewValueInsideTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetNewValueInsideTrigger(s)
	}
}

func (s *SetNewValueInsideTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetNewValueInsideTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetVariableContext struct {
	SetStatementContext
}

func NewSetVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableContext {
	var p = new(SetVariableContext)

	InitEmptySetStatementContext(&p.SetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetStatementContext))

	return p
}

func (s *SetVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetVariableContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *SetVariableContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *SetVariableContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *SetVariableContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserVAR_ASSIGN)
}

func (s *SetVariableContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, i)
}

func (s *SetVariableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetVariableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *SetVariableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *SetVariableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetVariableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetVariable(s)
	}
}

func (s *SetVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetVariable(s)
	}
}

func (s *SetVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSetVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, MySqlParserRULE_setStatement)
	var _la int

	p.SetState(5788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5736)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5737)
			p.VariableClause()
		}
		{
			p.SetState(5738)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5739)
				p.expression(0)
			}

		case 2:
			{
				p.SetState(5740)
				p.Match(MySqlParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(5752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5743)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5744)
				p.VariableClause()
			}
			{
				p.SetState(5745)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(5748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5746)
					p.expression(0)
				}

			case 2:
				{
					p.SetState(5747)
					p.Match(MySqlParserON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(5754)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5755)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5756)
			p.CharSet()
		}
		p.SetState(5759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(5757)
				p.CharsetName()
			}

		case MySqlParserDEFAULT:
			{
				p.SetState(5758)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5761)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5762)
			p.Match(MySqlParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(5763)
				p.CharsetName()
			}
			p.SetState(5766)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserCOLLATE {
				{
					p.SetState(5764)
					p.Match(MySqlParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5765)
					p.CollationName()
				}

			}

		case MySqlParserDEFAULT:
			{
				p.SetState(5768)
				p.Match(MySqlParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5771)
			p.SetPasswordStatement()
		}

	case 5:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5772)
			p.SetTransactionStatement()
		}

	case 6:
		localctx = NewSetAutocommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5773)
			p.SetAutocommitStatement()
		}

	case 7:
		localctx = NewSetNewValueInsideTriggerContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5774)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5775)
			p.FullId()
		}
		{
			p.SetState(5776)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5777)
			p.expression(0)
		}
		p.SetState(5785)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5778)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5779)
				p.FullId()
			}
			{
				p.SetState(5780)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5781)
				p.expression(0)
			}

			p.SetState(5787)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showStatement
	return p
}

func InitEmptyShowStatementContext(p *ShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showStatement
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) CopyAll(ctx *ShowStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowOpenTablesContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowOpenTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowOpenTablesContext {
	var p = new(ShowOpenTablesContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowOpenTablesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowOpenTablesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowOpenTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowOpenTablesContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *ShowOpenTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *ShowOpenTablesContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowOpenTablesContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowOpenTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowOpenTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ShowOpenTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowOpenTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGlobalInfoContext struct {
	ShowStatementContext
}

func NewShowGlobalInfoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGlobalInfoContext {
	var p = new(ShowGlobalInfoContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGlobalInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowGlobalInfoContext) ShowGlobalInfoClause() IShowGlobalInfoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGlobalInfoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGlobalInfoClauseContext)
}

func (s *ShowGlobalInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGlobalInfo(s)
	}
}

func (s *ShowGlobalInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGlobalInfo(s)
	}
}

func (s *ShowGlobalInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowGlobalInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateFullIdObjectContext struct {
	ShowStatementContext
	namedEntity antlr.Token
}

func NewShowCreateFullIdObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFullIdObjectContext {
	var p = new(ShowCreateFullIdObjectContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateFullIdObjectContext) GetNamedEntity() antlr.Token { return s.namedEntity }

func (s *ShowCreateFullIdObjectContext) SetNamedEntity(v antlr.Token) { s.namedEntity = v }

func (s *ShowCreateFullIdObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFullIdObjectContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateFullIdObjectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateFullIdObjectContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowCreateFullIdObjectContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *ShowCreateFullIdObjectContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowCreateFullIdObjectContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowCreateFullIdObjectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ShowCreateFullIdObjectContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *ShowCreateFullIdObjectContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *ShowCreateFullIdObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateFullIdObject(s)
	}
}

func (s *ShowCreateFullIdObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateFullIdObject(s)
	}
}

func (s *ShowCreateFullIdObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCreateFullIdObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateUserContext struct {
	ShowStatementContext
}

func NewShowCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateUserContext {
	var p = new(ShowCreateUserContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *ShowCreateUserContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShowCreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateUser(s)
	}
}

func (s *ShowCreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateUser(s)
	}
}

func (s *ShowCreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowErrorsContext struct {
	ShowStatementContext
	errorFormat antlr.Token
	offset      IDecimalLiteralContext
	rowCount    IDecimalLiteralContext
}

func NewShowErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowErrorsContext {
	var p = new(ShowErrorsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }

func (s *ShowErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }

func (s *ShowErrorsContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowErrorsContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }

func (s *ShowErrorsContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowErrorsContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *ShowErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *ShowErrorsContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowErrorsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowErrorsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowErrorsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *ShowErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowErrors(s)
	}
}

func (s *ShowErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowErrors(s)
	}
}

func (s *ShowErrorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowErrors(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCountErrorsContext struct {
	ShowStatementContext
	errorFormat antlr.Token
}

func NewShowCountErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCountErrorsContext {
	var p = new(ShowCountErrorsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCountErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }

func (s *ShowCountErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }

func (s *ShowCountErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCountErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCountErrorsContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *ShowCountErrorsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *ShowCountErrorsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *ShowCountErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *ShowCountErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCountErrors(s)
	}
}

func (s *ShowCountErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCountErrors(s)
	}
}

func (s *ShowCountErrorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCountErrors(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowObjectFilterContext struct {
	ShowStatementContext
}

func NewShowObjectFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowObjectFilterContext {
	var p = new(ShowObjectFilterContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowObjectFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowObjectFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowObjectFilterContext) ShowCommonEntity() IShowCommonEntityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCommonEntityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCommonEntityContext)
}

func (s *ShowObjectFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowObjectFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowObjectFilter(s)
	}
}

func (s *ShowObjectFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowObjectFilter(s)
	}
}

func (s *ShowObjectFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowObjectFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateDbContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowCreateDbContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDbContext {
	var p = new(ShowCreateDbContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateDbContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowCreateDbContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowCreateDbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateDbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateDbContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowCreateDbContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *ShowCreateDbContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *ShowCreateDbContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ShowCreateDbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateDb(s)
	}
}

func (s *ShowCreateDbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateDb(s)
	}
}

func (s *ShowCreateDbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCreateDb(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowEngineContext struct {
	ShowStatementContext
	engineOption antlr.Token
}

func NewShowEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEngineContext {
	var p = new(ShowEngineContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowEngineContext) GetEngineOption() antlr.Token { return s.engineOption }

func (s *ShowEngineContext) SetEngineOption(v antlr.Token) { s.engineOption = v }

func (s *ShowEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEngineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *ShowEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *ShowEngineContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowEngineContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMUTEX, 0)
}

func (s *ShowEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowEngine(s)
	}
}

func (s *ShowEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowEngine(s)
	}
}

func (s *ShowEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowEngine(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSchemaFilterContext struct {
	ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowSchemaFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemaFilterContext {
	var p = new(ShowSchemaFilterContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowSchemaFilterContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowSchemaFilterContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowSchemaFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowSchemaFilterContext) ShowSchemaEntity() IShowSchemaEntityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSchemaEntityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSchemaEntityContext)
}

func (s *ShowSchemaFilterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowSchemaFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowSchemaFilterContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowSchemaFilterContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ShowSchemaFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSchemaFilter(s)
	}
}

func (s *ShowSchemaFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSchemaFilter(s)
	}
}

func (s *ShowSchemaFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowSchemaFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowIndexesContext struct {
	ShowStatementContext
	indexFormat  antlr.Token
	tableFormat  antlr.Token
	schemaFormat antlr.Token
}

func NewShowIndexesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexesContext {
	var p = new(ShowIndexesContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *ShowIndexesContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowIndexesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *ShowIndexesContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowIndexesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *ShowIndexesContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEXES, 0)
}

func (s *ShowIndexesContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}

func (s *ShowIndexesContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserFROM)
}

func (s *ShowIndexesContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, i)
}

func (s *ShowIndexesContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIN)
}

func (s *ShowIndexesContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, i)
}

func (s *ShowIndexesContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowIndexesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *ShowIndexesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowIndexes(s)
	}
}

func (s *ShowIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowIndexes(s)
	}
}

func (s *ShowIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowLogEventsContext struct {
	ShowStatementContext
	logFormat    antlr.Token
	filename     antlr.Token
	fromPosition IDecimalLiteralContext
	offset       IDecimalLiteralContext
	rowCount     IDecimalLiteralContext
}

func NewShowLogEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLogEventsContext {
	var p = new(ShowLogEventsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowLogEventsContext) GetLogFormat() antlr.Token { return s.logFormat }

func (s *ShowLogEventsContext) GetFilename() antlr.Token { return s.filename }

func (s *ShowLogEventsContext) SetLogFormat(v antlr.Token) { s.logFormat = v }

func (s *ShowLogEventsContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *ShowLogEventsContext) GetFromPosition() IDecimalLiteralContext { return s.fromPosition }

func (s *ShowLogEventsContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowLogEventsContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }

func (s *ShowLogEventsContext) SetFromPosition(v IDecimalLiteralContext) { s.fromPosition = v }

func (s *ShowLogEventsContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowLogEventsContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowLogEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLogEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowLogEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *ShowLogEventsContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *ShowLogEventsContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAYLOG, 0)
}

func (s *ShowLogEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ShowLogEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowLogEventsContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowLogEventsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowLogEventsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowLogEventsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowLogEventsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *ShowLogEventsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowLogEvents(s)
	}
}

func (s *ShowLogEventsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowLogEvents(s)
	}
}

func (s *ShowLogEventsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowLogEvents(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowMasterLogsContext struct {
	ShowStatementContext
	logFormat antlr.Token
}

func NewShowMasterLogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowMasterLogsContext {
	var p = new(ShowMasterLogsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowMasterLogsContext) GetLogFormat() antlr.Token { return s.logFormat }

func (s *ShowMasterLogsContext) SetLogFormat(v antlr.Token) { s.logFormat = v }

func (s *ShowMasterLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMasterLogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowMasterLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *ShowMasterLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *ShowMasterLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ShowMasterLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowMasterLogs(s)
	}
}

func (s *ShowMasterLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowMasterLogs(s)
	}
}

func (s *ShowMasterLogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowMasterLogs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGrantsContext struct {
	ShowStatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANTS, 0)
}

func (s *ShowGrantsContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowGrantsContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

func (s *ShowGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowGrants(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSlaveStatusContext struct {
	ShowStatementContext
}

func NewShowSlaveStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSlaveStatusContext {
	var p = new(ShowSlaveStatusContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowSlaveStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSlaveStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowSlaveStatusContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ShowSlaveStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowSlaveStatusContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowSlaveStatusContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *ShowSlaveStatusContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowSlaveStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSlaveStatus(s)
	}
}

func (s *ShowSlaveStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSlaveStatus(s)
	}
}

func (s *ShowSlaveStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowSlaveStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRoutineContext struct {
	ShowStatementContext
	routine antlr.Token
}

func NewShowRoutineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineContext {
	var p = new(ShowRoutineContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowRoutineContext) GetRoutine() antlr.Token { return s.routine }

func (s *ShowRoutineContext) SetRoutine(v antlr.Token) { s.routine = v }

func (s *ShowRoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowRoutineContext) CODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCODE, 0)
}

func (s *ShowRoutineContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowRoutineContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowRoutineContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowRoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowRoutine(s)
	}
}

func (s *ShowRoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowRoutine(s)
	}
}

func (s *ShowRoutineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowRoutine(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowProfileContext struct {
	ShowStatementContext
	queryCount IDecimalLiteralContext
	offset     IDecimalLiteralContext
	rowCount   IDecimalLiteralContext
}

func NewShowProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProfileContext {
	var p = new(ShowProfileContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowProfileContext) GetQueryCount() IDecimalLiteralContext { return s.queryCount }

func (s *ShowProfileContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowProfileContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }

func (s *ShowProfileContext) SetQueryCount(v IDecimalLiteralContext) { s.queryCount = v }

func (s *ShowProfileContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowProfileContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILE, 0)
}

func (s *ShowProfileContext) AllShowProfileType() []IShowProfileTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			len++
		}
	}

	tst := make([]IShowProfileTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShowProfileTypeContext); ok {
			tst[i] = t.(IShowProfileTypeContext)
			i++
		}
	}

	return tst
}

func (s *ShowProfileContext) ShowProfileType(i int) IShowProfileTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfileTypeContext)
}

func (s *ShowProfileContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowProfileContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ShowProfileContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ShowProfileContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowProfileContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *ShowProfileContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowProfileContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowProfile(s)
	}
}

func (s *ShowProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowProfile(s)
	}
}

func (s *ShowProfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowProfile(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowColumnsContext struct {
	ShowStatementContext
	columnsFormat antlr.Token
	tableFormat   antlr.Token
	schemaFormat  antlr.Token
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyShowStatementContext(&p.ShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowColumnsContext) GetColumnsFormat() antlr.Token { return s.columnsFormat }

func (s *ShowColumnsContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowColumnsContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowColumnsContext) SetColumnsFormat(v antlr.Token) { s.columnsFormat = v }

func (s *ShowColumnsContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowColumnsContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowColumnsContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, i)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowColumnsContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowColumnsContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

func (s *ShowColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ShowStatement() (localctx IShowStatementContext) {
	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, MySqlParserRULE_showStatement)
	var _la int

	p.SetState(5943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 868, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowMasterLogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5790)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5791)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowMasterLogsContext).logFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINARY || _la == MySqlParserMASTER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowMasterLogsContext).logFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5792)
			p.Match(MySqlParserLOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewShowLogEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5793)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5794)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowLogEventsContext).logFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINLOG || _la == MySqlParserRELAYLOG) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowLogEventsContext).logFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5795)
			p.Match(MySqlParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIN {
			{
				p.SetState(5796)
				p.Match(MySqlParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5797)

				var _m = p.Match(MySqlParserSTRING_LITERAL)

				localctx.(*ShowLogEventsContext).filename = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(5802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM {
			{
				p.SetState(5800)
				p.Match(MySqlParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5801)

				var _x = p.DecimalLiteral()

				localctx.(*ShowLogEventsContext).fromPosition = _x
			}

		}
		p.SetState(5811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(5804)
				p.Match(MySqlParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5808)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 848, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5805)

					var _x = p.DecimalLiteral()

					localctx.(*ShowLogEventsContext).offset = _x
				}
				{
					p.SetState(5806)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(5810)

				var _x = p.DecimalLiteral()

				localctx.(*ShowLogEventsContext).rowCount = _x
			}

		}

	case 3:
		localctx = NewShowObjectFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5813)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5814)
			p.ShowCommonEntity()
		}
		p.SetState(5816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5815)
				p.ShowFilter()
			}

		}

	case 4:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5818)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5820)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFULL {
			{
				p.SetState(5819)
				p.Match(MySqlParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5822)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).columnsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).columnsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5823)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5824)
			p.TableName()
		}
		p.SetState(5827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5825)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowColumnsContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowColumnsContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5826)
				p.Uid()
			}

		}
		p.SetState(5830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5829)
				p.ShowFilter()
			}

		}

	case 5:
		localctx = NewShowCreateDbContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5832)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5833)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5834)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateDbContext).schemaFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateDbContext).schemaFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5836)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 854, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5835)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5838)
			p.Uid()
		}

	case 6:
		localctx = NewShowCreateFullIdObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5839)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5840)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5841)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateFullIdObjectContext).namedEntity = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&72567767433217) != 0) || _la == MySqlParserEVENT || _la == MySqlParserFUNCTION || _la == MySqlParserVIEW) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateFullIdObjectContext).namedEntity = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5842)
			p.FullId()
		}

	case 7:
		localctx = NewShowCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5843)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5844)
			p.Match(MySqlParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5845)
			p.Match(MySqlParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5846)
			p.UserName()
		}

	case 8:
		localctx = NewShowEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5847)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5848)
			p.Match(MySqlParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5849)
			p.EngineName()
		}
		{
			p.SetState(5850)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowEngineContext).engineOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMUTEX || _la == MySqlParserSTATUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowEngineContext).engineOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		localctx = NewShowGlobalInfoContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5852)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5853)
			p.ShowGlobalInfoClause()
		}

	case 10:
		localctx = NewShowErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5854)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5855)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserERRORS || _la == MySqlParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(5856)
				p.Match(MySqlParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5860)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 855, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5857)

					var _x = p.DecimalLiteral()

					localctx.(*ShowErrorsContext).offset = _x
				}
				{
					p.SetState(5858)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(5862)

				var _x = p.DecimalLiteral()

				localctx.(*ShowErrorsContext).rowCount = _x
			}

		}

	case 11:
		localctx = NewShowCountErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5865)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5866)
			p.Match(MySqlParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5867)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5868)
			p.Match(MySqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5869)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5870)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCountErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserERRORS || _la == MySqlParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCountErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 12:
		localctx = NewShowSchemaFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5871)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5872)
			p.ShowSchemaEntity()
		}
		p.SetState(5875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5873)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowSchemaFilterContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowSchemaFilterContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5874)
				p.Uid()
			}

		}
		p.SetState(5878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5877)
				p.ShowFilter()
			}

		}

	case 13:
		localctx = NewShowRoutineContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5880)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5881)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowRoutineContext).routine = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPROCEDURE || _la == MySqlParserFUNCTION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowRoutineContext).routine = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5882)
			p.Match(MySqlParserCODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5883)
			p.FullId()
		}

	case 14:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5884)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5885)
			p.Match(MySqlParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(5886)
				p.Match(MySqlParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5887)
				p.UserName()
			}

		}

	case 15:
		localctx = NewShowIndexesContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5890)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5891)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEYS || _la == MySqlParserINDEXES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5892)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5893)
			p.TableName()
		}
		p.SetState(5896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5894)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowIndexesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowIndexesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5895)
				p.Uid()
			}

		}
		p.SetState(5900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWHERE {
			{
				p.SetState(5898)
				p.Match(MySqlParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5899)
				p.expression(0)
			}

		}

	case 16:
		localctx = NewShowOpenTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5902)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5903)
			p.Match(MySqlParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5904)
			p.Match(MySqlParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5905)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowOpenTablesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowOpenTablesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5906)
				p.Uid()
			}

		}
		p.SetState(5910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5909)
				p.ShowFilter()
			}

		}

	case 17:
		localctx = NewShowProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5912)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5913)
			p.Match(MySqlParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5914)
			p.ShowProfileType()
		}
		p.SetState(5919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5915)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5916)
				p.ShowProfileType()
			}

			p.SetState(5921)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(5922)
				p.Match(MySqlParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5923)
				p.Match(MySqlParserQUERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5924)

				var _x = p.DecimalLiteral()

				localctx.(*ShowProfileContext).queryCount = _x
			}

		}

		{
			p.SetState(5927)
			p.Match(MySqlParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5931)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 866, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5928)

				var _x = p.DecimalLiteral()

				localctx.(*ShowProfileContext).offset = _x
			}
			{
				p.SetState(5929)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5933)

			var _x = p.DecimalLiteral()

			localctx.(*ShowProfileContext).rowCount = _x
		}

	case 18:
		localctx = NewShowSlaveStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5935)
			p.Match(MySqlParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5936)
			p.Match(MySqlParserSLAVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5937)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5941)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(5938)
				p.Match(MySqlParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5939)
				p.Match(MySqlParserCHANNEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5940)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableClauseContext is an interface to support dynamic dispatch.
type IVariableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode
	Uid() IUidContext
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllAT_SIGN() []antlr.TerminalNode
	AT_SIGN(i int) antlr.TerminalNode

	// IsVariableClauseContext differentiates from other interfaces.
	IsVariableClauseContext()
}

type VariableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableClauseContext() *VariableClauseContext {
	var p = new(VariableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_variableClause
	return p
}

func InitEmptyVariableClauseContext(p *VariableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_variableClause
}

func (*VariableClauseContext) IsVariableClauseContext() {}

func NewVariableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableClauseContext {
	var p = new(VariableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_variableClause

	return p
}

func (s *VariableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableClauseContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *VariableClauseContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL_ID, 0)
}

func (s *VariableClauseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *VariableClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *VariableClauseContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *VariableClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *VariableClauseContext) AllAT_SIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAT_SIGN)
}

func (s *VariableClauseContext) AT_SIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAT_SIGN, i)
}

func (s *VariableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVariableClause(s)
	}
}

func (s *VariableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVariableClause(s)
	}
}

func (s *VariableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitVariableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) VariableClause() (localctx IVariableClauseContext) {
	localctx = NewVariableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, MySqlParserRULE_variableClause)
	var _la int

	p.SetState(5955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5945)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5946)
			p.Match(MySqlParserGLOBAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserAT_SIGN, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5952)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 870, p.GetParserRuleContext()) == 1 {
			p.SetState(5949)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAT_SIGN {
				{
					p.SetState(5947)
					p.Match(MySqlParserAT_SIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5948)
					p.Match(MySqlParserAT_SIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5951)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserGLOBAL || _la == MySqlParserLOCAL || _la == MySqlParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5954)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCommonEntityContext is an interface to support dynamic dispatch.
type IShowCommonEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsShowCommonEntityContext differentiates from other interfaces.
	IsShowCommonEntityContext()
}

type ShowCommonEntityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCommonEntityContext() *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showCommonEntity
	return p
}

func InitEmptyShowCommonEntityContext(p *ShowCommonEntityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showCommonEntity
}

func (*ShowCommonEntityContext) IsShowCommonEntityContext() {}

func NewShowCommonEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showCommonEntity

	return p
}

func (s *ShowCommonEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCommonEntityContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *ShowCommonEntityContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ShowCommonEntityContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATION, 0)
}

func (s *ShowCommonEntityContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASES, 0)
}

func (s *ShowCommonEntityContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMAS, 0)
}

func (s *ShowCommonEntityContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowCommonEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowCommonEntityContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowCommonEntityContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIABLES, 0)
}

func (s *ShowCommonEntityContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *ShowCommonEntityContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *ShowCommonEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCommonEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCommonEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCommonEntity(s)
	}
}

func (s *ShowCommonEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCommonEntity(s)
	}
}

func (s *ShowCommonEntityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowCommonEntity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ShowCommonEntity() (localctx IShowCommonEntityContext) {
	localctx = NewShowCommonEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, MySqlParserRULE_showCommonEntity)
	var _la int

	p.SetState(5970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5957)
			p.Match(MySqlParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5958)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCOLLATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5959)
			p.Match(MySqlParserCOLLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDATABASES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5960)
			p.Match(MySqlParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSCHEMAS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5961)
			p.Match(MySqlParserSCHEMAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserFUNCTION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5962)
			p.Match(MySqlParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5963)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPROCEDURE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5964)
			p.Match(MySqlParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5965)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserGLOBAL, MySqlParserSESSION, MySqlParserSTATUS, MySqlParserVARIABLES:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(5967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserGLOBAL || _la == MySqlParserSESSION {
			{
				p.SetState(5966)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserGLOBAL || _la == MySqlParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5969)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSTATUS || _la == MySqlParserVARIABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFilterContext is an interface to support dynamic dispatch.
type IShowFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowFilterContext differentiates from other interfaces.
	IsShowFilterContext()
}

type ShowFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFilterContext() *ShowFilterContext {
	var p = new(ShowFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showFilter
	return p
}

func InitEmptyShowFilterContext(p *ShowFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showFilter
}

func (*ShowFilterContext) IsShowFilterContext() {}

func NewShowFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFilterContext {
	var p = new(ShowFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showFilter

	return p
}

func (s *ShowFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFilterContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *ShowFilterContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowFilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *ShowFilterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowFilter(s)
	}
}

func (s *ShowFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowFilter(s)
	}
}

func (s *ShowFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ShowFilter() (localctx IShowFilterContext) {
	localctx = NewShowFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, MySqlParserRULE_showFilter)
	p.SetState(5976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5972)
			p.Match(MySqlParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5973)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5974)
			p.Match(MySqlParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5975)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGlobalInfoClauseContext is an interface to support dynamic dispatch.
type IShowGlobalInfoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINES() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode

	// IsShowGlobalInfoClauseContext differentiates from other interfaces.
	IsShowGlobalInfoClauseContext()
}

type ShowGlobalInfoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGlobalInfoClauseContext() *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause
	return p
}

func InitEmptyShowGlobalInfoClauseContext(p *ShowGlobalInfoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause
}

func (*ShowGlobalInfoClauseContext) IsShowGlobalInfoClauseContext() {}

func NewShowGlobalInfoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause

	return p
}

func (s *ShowGlobalInfoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGlobalInfoClauseContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINES, 0)
}

func (s *ShowGlobalInfoClauseContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *ShowGlobalInfoClauseContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ShowGlobalInfoClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowGlobalInfoClauseContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGINS, 0)
}

func (s *ShowGlobalInfoClauseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *ShowGlobalInfoClauseContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESSLIST, 0)
}

func (s *ShowGlobalInfoClauseContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowGlobalInfoClauseContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILES, 0)
}

func (s *ShowGlobalInfoClauseContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ShowGlobalInfoClauseContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *ShowGlobalInfoClauseContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHORS, 0)
}

func (s *ShowGlobalInfoClauseContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTRIBUTORS, 0)
}

func (s *ShowGlobalInfoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGlobalInfoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGlobalInfoClause(s)
	}
}

func (s *ShowGlobalInfoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGlobalInfoClause(s)
	}
}

func (s *ShowGlobalInfoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowGlobalInfoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ShowGlobalInfoClause() (localctx IShowGlobalInfoClauseContext) {
	localctx = NewShowGlobalInfoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, MySqlParserRULE_showGlobalInfoClause)
	var _la int

	p.SetState(5995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserENGINES, MySqlParserSTORAGE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTORAGE {
			{
				p.SetState(5978)
				p.Match(MySqlParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5981)
			p.Match(MySqlParserENGINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMASTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5982)
			p.Match(MySqlParserMASTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5983)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPLUGINS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5984)
			p.Match(MySqlParserPLUGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPRIVILEGES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5985)
			p.Match(MySqlParserPRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserFULL, MySqlParserPROCESSLIST:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFULL {
			{
				p.SetState(5986)
				p.Match(MySqlParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5989)
			p.Match(MySqlParserPROCESSLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPROFILES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5990)
			p.Match(MySqlParserPROFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSLAVE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5991)
			p.Match(MySqlParserSLAVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5992)
			p.Match(MySqlParserHOSTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserAUTHORS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5993)
			p.Match(MySqlParserAUTHORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCONTRIBUTORS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5994)
			p.Match(MySqlParserCONTRIBUTORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSchemaEntityContext is an interface to support dynamic dispatch.
type IShowSchemaEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENTS() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode

	// IsShowSchemaEntityContext differentiates from other interfaces.
	IsShowSchemaEntityContext()
}

type ShowSchemaEntityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSchemaEntityContext() *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showSchemaEntity
	return p
}

func InitEmptyShowSchemaEntityContext(p *ShowSchemaEntityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showSchemaEntity
}

func (*ShowSchemaEntityContext) IsShowSchemaEntityContext() {}

func NewShowSchemaEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showSchemaEntity

	return p
}

func (s *ShowSchemaEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSchemaEntityContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *ShowSchemaEntityContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ShowSchemaEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowSchemaEntityContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *ShowSchemaEntityContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowSchemaEntityContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGERS, 0)
}

func (s *ShowSchemaEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSchemaEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSchemaEntity(s)
	}
}

func (s *ShowSchemaEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSchemaEntity(s)
	}
}

func (s *ShowSchemaEntityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowSchemaEntity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ShowSchemaEntity() (localctx IShowSchemaEntityContext) {
	localctx = NewShowSchemaEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, MySqlParserRULE_showSchemaEntity)
	var _la int

	p.SetState(6005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserEVENTS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5997)
			p.Match(MySqlParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5998)
			p.Match(MySqlParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5999)
			p.Match(MySqlParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserFULL, MySqlParserTABLES:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFULL {
			{
				p.SetState(6000)
				p.Match(MySqlParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6003)
			p.Match(MySqlParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserTRIGGERS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6004)
			p.Match(MySqlParserTRIGGERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProfileTypeContext is an interface to support dynamic dispatch.
type IShowProfileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	IO() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	CPU() antlr.TerminalNode
	IPC() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SWAPS() antlr.TerminalNode

	// IsShowProfileTypeContext differentiates from other interfaces.
	IsShowProfileTypeContext()
}

type ShowProfileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProfileTypeContext() *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showProfileType
	return p
}

func InitEmptyShowProfileTypeContext(p *ShowProfileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_showProfileType
}

func (*ShowProfileTypeContext) IsShowProfileTypeContext() {}

func NewShowProfileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showProfileType

	return p
}

func (s *ShowProfileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfileTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ShowProfileTypeContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOCK, 0)
}

func (s *ShowProfileTypeContext) IO() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO, 0)
}

func (s *ShowProfileTypeContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTEXT, 0)
}

func (s *ShowProfileTypeContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWITCHES, 0)
}

func (s *ShowProfileTypeContext) CPU() antlr.TerminalNode {
	return s.GetToken(MySqlParserCPU, 0)
}

func (s *ShowProfileTypeContext) IPC() antlr.TerminalNode {
	return s.GetToken(MySqlParserIPC, 0)
}

func (s *ShowProfileTypeContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *ShowProfileTypeContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE, 0)
}

func (s *ShowProfileTypeContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAULTS, 0)
}

func (s *ShowProfileTypeContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOURCE, 0)
}

func (s *ShowProfileTypeContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWAPS, 0)
}

func (s *ShowProfileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProfileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowProfileType(s)
	}
}

func (s *ShowProfileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowProfileType(s)
	}
}

func (s *ShowProfileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShowProfileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ShowProfileType() (localctx IShowProfileTypeContext) {
	localctx = NewShowProfileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, MySqlParserRULE_showProfileType)
	p.SetState(6019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6007)
			p.Match(MySqlParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6008)
			p.Match(MySqlParserBLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6009)
			p.Match(MySqlParserIO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCONTEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6010)
			p.Match(MySqlParserCONTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6011)
			p.Match(MySqlParserSWITCHES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCPU:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6012)
			p.Match(MySqlParserCPU)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserIPC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6013)
			p.Match(MySqlParserIPC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMEMORY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6014)
			p.Match(MySqlParserMEMORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserPAGE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6015)
			p.Match(MySqlParserPAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6016)
			p.Match(MySqlParserFAULTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6017)
			p.Match(MySqlParserSOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSWAPS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6018)
			p.Match(MySqlParserSWAPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinlogStatementContext is an interface to support dynamic dispatch.
type IBinlogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINLOG() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsBinlogStatementContext differentiates from other interfaces.
	IsBinlogStatementContext()
}

type BinlogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinlogStatementContext() *BinlogStatementContext {
	var p = new(BinlogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_binlogStatement
	return p
}

func InitEmptyBinlogStatementContext(p *BinlogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_binlogStatement
}

func (*BinlogStatementContext) IsBinlogStatementContext() {}

func NewBinlogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinlogStatementContext {
	var p = new(BinlogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_binlogStatement

	return p
}

func (s *BinlogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BinlogStatementContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *BinlogStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *BinlogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinlogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinlogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinlogStatement(s)
	}
}

func (s *BinlogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinlogStatement(s)
	}
}

func (s *BinlogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinlogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BinlogStatement() (localctx IBinlogStatementContext) {
	localctx = NewBinlogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, MySqlParserRULE_binlogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6021)
		p.Match(MySqlParserBINLOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6022)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICacheIndexStatementContext is an interface to support dynamic dispatch.
type ICacheIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSchema returns the schema rule contexts.
	GetSchema() IUidContext

	// SetSchema sets the schema rule contexts.
	SetSchema(IUidContext)

	// Getter signatures
	CACHE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	AllTableIndexes() []ITableIndexesContext
	TableIndexes(i int) ITableIndexesContext
	IN() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	ALL() antlr.TerminalNode

	// IsCacheIndexStatementContext differentiates from other interfaces.
	IsCacheIndexStatementContext()
}

type CacheIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	schema IUidContext
}

func NewEmptyCacheIndexStatementContext() *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement
	return p
}

func InitEmptyCacheIndexStatementContext(p *CacheIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement
}

func (*CacheIndexStatementContext) IsCacheIndexStatementContext() {}

func NewCacheIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement

	return p
}

func (s *CacheIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CacheIndexStatementContext) GetSchema() IUidContext { return s.schema }

func (s *CacheIndexStatementContext) SetSchema(v IUidContext) { s.schema = v }

func (s *CacheIndexStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *CacheIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *CacheIndexStatementContext) AllTableIndexes() []ITableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ITableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableIndexesContext); ok {
			tst[i] = t.(ITableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *CacheIndexStatementContext) TableIndexes(i int) ITableIndexesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIndexesContext)
}

func (s *CacheIndexStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *CacheIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CacheIndexStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CacheIndexStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CacheIndexStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *CacheIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CacheIndexStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *CacheIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CacheIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CacheIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCacheIndexStatement(s)
	}
}

func (s *CacheIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCacheIndexStatement(s)
	}
}

func (s *CacheIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCacheIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CacheIndexStatement() (localctx ICacheIndexStatementContext) {
	localctx = NewCacheIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, MySqlParserRULE_cacheIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6024)
		p.Match(MySqlParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6025)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6026)
		p.TableIndexes()
	}
	p.SetState(6031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6027)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6028)
			p.TableIndexes()
		}

		p.SetState(6033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(6041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(6034)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6035)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(6036)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(6037)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6040)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6043)
		p.Match(MySqlParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6044)

		var _x = p.Uid()

		localctx.(*CacheIndexStatementContext).schema = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushStatementContext is an interface to support dynamic dispatch.
type IFlushStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFlushFormat returns the flushFormat token.
	GetFlushFormat() antlr.Token

	// SetFlushFormat sets the flushFormat token.
	SetFlushFormat(antlr.Token)

	// Getter signatures
	FLUSH() antlr.TerminalNode
	AllFlushOption() []IFlushOptionContext
	FlushOption(i int) IFlushOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsFlushStatementContext differentiates from other interfaces.
	IsFlushStatementContext()
}

type FlushStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	flushFormat antlr.Token
}

func NewEmptyFlushStatementContext() *FlushStatementContext {
	var p = new(FlushStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushStatement
	return p
}

func InitEmptyFlushStatementContext(p *FlushStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushStatement
}

func (*FlushStatementContext) IsFlushStatementContext() {}

func NewFlushStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushStatementContext {
	var p = new(FlushStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushStatement

	return p
}

func (s *FlushStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushStatementContext) GetFlushFormat() antlr.Token { return s.flushFormat }

func (s *FlushStatementContext) SetFlushFormat(v antlr.Token) { s.flushFormat = v }

func (s *FlushStatementContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH, 0)
}

func (s *FlushStatementContext) AllFlushOption() []IFlushOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlushOptionContext); ok {
			len++
		}
	}

	tst := make([]IFlushOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlushOptionContext); ok {
			tst[i] = t.(IFlushOptionContext)
			i++
		}
	}

	return tst
}

func (s *FlushStatementContext) FlushOption(i int) IFlushOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushOptionContext)
}

func (s *FlushStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FlushStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FlushStatementContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *FlushStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *FlushStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFlushStatement(s)
	}
}

func (s *FlushStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFlushStatement(s)
	}
}

func (s *FlushStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFlushStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FlushStatement() (localctx IFlushStatementContext) {
	localctx = NewFlushStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, MySqlParserRULE_flushStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6046)
		p.Match(MySqlParserFLUSH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(6047)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FlushStatementContext).flushFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FlushStatementContext).flushFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6050)
		p.FlushOption()
	}
	p.SetState(6055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6051)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6052)
			p.FlushOption()
		}

		p.SetState(6057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnectionFormat returns the connectionFormat token.
	GetConnectionFormat() antlr.Token

	// SetConnectionFormat sets the connectionFormat token.
	SetConnectionFormat(antlr.Token)

	// Getter signatures
	KILL() antlr.TerminalNode
	Expression() IExpressionContext
	CONNECTION() antlr.TerminalNode
	QUERY() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	connectionFormat antlr.Token
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_killStatement
	return p
}

func InitEmptyKillStatementContext(p *KillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_killStatement
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnectionFormat() antlr.Token { return s.connectionFormat }

func (s *KillStatementContext) SetConnectionFormat(v antlr.Token) { s.connectionFormat = v }

func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(MySqlParserKILL, 0)
}

func (s *KillStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (s *KillStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitKillStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) KillStatement() (localctx IKillStatementContext) {
	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, MySqlParserRULE_killStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6058)
		p.Match(MySqlParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6060)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 886, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6059)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*KillStatementContext).connectionFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCONNECTION || _la == MySqlParserQUERY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*KillStatementContext).connectionFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6062)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadIndexIntoCacheContext is an interface to support dynamic dispatch.
type ILoadIndexIntoCacheContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INTO() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	AllLoadedTableIndexes() []ILoadedTableIndexesContext
	LoadedTableIndexes(i int) ILoadedTableIndexesContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadIndexIntoCacheContext differentiates from other interfaces.
	IsLoadIndexIntoCacheContext()
}

type LoadIndexIntoCacheContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadIndexIntoCacheContext() *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache
	return p
}

func InitEmptyLoadIndexIntoCacheContext(p *LoadIndexIntoCacheContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache
}

func (*LoadIndexIntoCacheContext) IsLoadIndexIntoCacheContext() {}

func NewLoadIndexIntoCacheContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache

	return p
}

func (s *LoadIndexIntoCacheContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadIndexIntoCacheContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadIndexIntoCacheContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *LoadIndexIntoCacheContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadIndexIntoCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *LoadIndexIntoCacheContext) AllLoadedTableIndexes() []ILoadedTableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ILoadedTableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadedTableIndexesContext); ok {
			tst[i] = t.(ILoadedTableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *LoadIndexIntoCacheContext) LoadedTableIndexes(i int) ILoadedTableIndexesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadedTableIndexesContext)
}

func (s *LoadIndexIntoCacheContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadIndexIntoCacheContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadIndexIntoCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadIndexIntoCacheContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadIndexIntoCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadIndexIntoCache(s)
	}
}

func (s *LoadIndexIntoCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadIndexIntoCache(s)
	}
}

func (s *LoadIndexIntoCacheContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadIndexIntoCache(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LoadIndexIntoCache() (localctx ILoadIndexIntoCacheContext) {
	localctx = NewLoadIndexIntoCacheContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, MySqlParserRULE_loadIndexIntoCache)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6064)
		p.Match(MySqlParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6065)
		p.Match(MySqlParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6066)
		p.Match(MySqlParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6067)
		p.Match(MySqlParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6068)
		p.LoadedTableIndexes()
	}
	p.SetState(6073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6069)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6070)
			p.LoadedTableIndexes()
		}

		p.SetState(6075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetStatementContext is an interface to support dynamic dispatch.
type IResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	CACHE() antlr.TerminalNode

	// IsResetStatementContext differentiates from other interfaces.
	IsResetStatementContext()
}

type ResetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStatementContext() *ResetStatementContext {
	var p = new(ResetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetStatement
	return p
}

func InitEmptyResetStatementContext(p *ResetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resetStatement
}

func (*ResetStatementContext) IsResetStatementContext() {}

func NewResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStatementContext {
	var p = new(ResetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetStatement

	return p
}

func (s *ResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStatementContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *ResetStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *ResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetStatement(s)
	}
}

func (s *ResetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetStatement(s)
	}
}

func (s *ResetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ResetStatement() (localctx IResetStatementContext) {
	localctx = NewResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, MySqlParserRULE_resetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6076)
		p.Match(MySqlParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6077)
		p.Match(MySqlParserQUERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6078)
		p.Match(MySqlParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShutdownStatementContext is an interface to support dynamic dispatch.
type IShutdownStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHUTDOWN() antlr.TerminalNode

	// IsShutdownStatementContext differentiates from other interfaces.
	IsShutdownStatementContext()
}

type ShutdownStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShutdownStatementContext() *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_shutdownStatement
	return p
}

func InitEmptyShutdownStatementContext(p *ShutdownStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_shutdownStatement
}

func (*ShutdownStatementContext) IsShutdownStatementContext() {}

func NewShutdownStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_shutdownStatement

	return p
}

func (s *ShutdownStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShutdownStatementContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *ShutdownStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShutdownStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShutdownStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShutdownStatement(s)
	}
}

func (s *ShutdownStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShutdownStatement(s)
	}
}

func (s *ShutdownStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitShutdownStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ShutdownStatement() (localctx IShutdownStatementContext) {
	localctx = NewShutdownStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, MySqlParserRULE_shutdownStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6080)
		p.Match(MySqlParserSHUTDOWN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableIndexesContext is an interface to support dynamic dispatch.
type ITableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token

	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token)

	// Getter signatures
	TableName() ITableNameContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsTableIndexesContext differentiates from other interfaces.
	IsTableIndexesContext()
}

type TableIndexesContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	indexFormat antlr.Token
}

func NewEmptyTableIndexesContext() *TableIndexesContext {
	var p = new(TableIndexesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableIndexes
	return p
}

func InitEmptyTableIndexesContext(p *TableIndexesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableIndexes
}

func (*TableIndexesContext) IsTableIndexesContext() {}

func NewTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIndexesContext {
	var p = new(TableIndexesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableIndexes

	return p
}

func (s *TableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *TableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *TableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableIndexesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableIndexesContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *TableIndexesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *TableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableIndexes(s)
	}
}

func (s *TableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableIndexes(s)
	}
}

func (s *TableIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableIndexes() (localctx ITableIndexesContext) {
	localctx = NewTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, MySqlParserRULE_tableIndexes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6082)
		p.TableName()
	}
	p.SetState(6090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINDEX || _la == MySqlParserKEY || _la == MySqlParserLR_BRACKET {
		p.SetState(6084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(6083)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*TableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*TableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6086)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6087)
			p.UidList()
		}
		{
			p.SetState(6088)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushOptionContext is an interface to support dynamic dispatch.
type IFlushOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFlushOptionContext differentiates from other interfaces.
	IsFlushOptionContext()
}

type FlushOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushOptionContext() *FlushOptionContext {
	var p = new(FlushOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushOption
	return p
}

func InitEmptyFlushOptionContext(p *FlushOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushOption
}

func (*FlushOptionContext) IsFlushOptionContext() {}

func NewFlushOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushOptionContext {
	var p = new(FlushOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushOption

	return p
}

func (s *FlushOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushOptionContext) CopyAll(ctx *FlushOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableFlushOptionContext struct {
	FlushOptionContext
}

func NewTableFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFlushOptionContext {
	var p = new(TableFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *TableFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFlushOptionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TableFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *TableFlushOptionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableFlushOptionContext) FlushTableOption() IFlushTableOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushTableOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushTableOptionContext)
}

func (s *TableFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableFlushOption(s)
	}
}

func (s *TableFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableFlushOption(s)
	}
}

func (s *TableFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type ChannelFlushOptionContext struct {
	FlushOptionContext
}

func NewChannelFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ChannelFlushOptionContext {
	var p = new(ChannelFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *ChannelFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *ChannelFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *ChannelFlushOptionContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ChannelFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChannelFlushOption(s)
	}
}

func (s *ChannelFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChannelFlushOption(s)
	}
}

func (s *ChannelFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitChannelFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFlushOptionContext struct {
	FlushOptionContext
}

func NewSimpleFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFlushOptionContext {
	var p = new(SimpleFlushOptionContext)

	InitEmptyFlushOptionContext(&p.FlushOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*FlushOptionContext))

	return p
}

func (s *SimpleFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFlushOptionContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_KEY_FILE, 0)
}

func (s *SimpleFlushOptionContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *SimpleFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *SimpleFlushOptionContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZER_COSTS, 0)
}

func (s *SimpleFlushOptionContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *SimpleFlushOptionContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *SimpleFlushOptionContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *SimpleFlushOptionContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *SimpleFlushOptionContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER_RESOURCES, 0)
}

func (s *SimpleFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *SimpleFlushOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *SimpleFlushOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *SimpleFlushOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *SimpleFlushOptionContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *SimpleFlushOptionContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *SimpleFlushOptionContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *SimpleFlushOptionContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERAL, 0)
}

func (s *SimpleFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *SimpleFlushOptionContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLOW, 0)
}

func (s *SimpleFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleFlushOption(s)
	}
}

func (s *SimpleFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleFlushOption(s)
	}
}

func (s *SimpleFlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FlushOption() (localctx IFlushOptionContext) {
	localctx = NewFlushOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, MySqlParserRULE_flushOption)
	var _la int

	p.SetState(6124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 896, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDES_KEY_FILE:
			{
				p.SetState(6092)
				p.Match(MySqlParserDES_KEY_FILE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserHOSTS:
			{
				p.SetState(6093)
				p.Match(MySqlParserHOSTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserBINARY, MySqlParserENGINE, MySqlParserERROR, MySqlParserGENERAL, MySqlParserLOGS, MySqlParserRELAY, MySqlParserSLOW:
			p.SetState(6095)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserBINARY || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&536870917) != 0) || _la == MySqlParserRELAY || _la == MySqlParserSLOW {
				{
					p.SetState(6094)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserBINARY || ((int64((_la-408)) & ^0x3f) == 0 && ((int64(1)<<(_la-408))&536870917) != 0) || _la == MySqlParserRELAY || _la == MySqlParserSLOW) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(6097)
				p.Match(MySqlParserLOGS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserOPTIMIZER_COSTS:
			{
				p.SetState(6098)
				p.Match(MySqlParserOPTIMIZER_COSTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserPRIVILEGES:
			{
				p.SetState(6099)
				p.Match(MySqlParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserQUERY:
			{
				p.SetState(6100)
				p.Match(MySqlParserQUERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6101)
				p.Match(MySqlParserCACHE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserSTATUS:
			{
				p.SetState(6102)
				p.Match(MySqlParserSTATUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserUSER_RESOURCES:
			{
				p.SetState(6103)
				p.Match(MySqlParserUSER_RESOURCES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserTABLES:
			{
				p.SetState(6104)
				p.Match(MySqlParserTABLES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6108)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 891, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6105)
					p.Match(MySqlParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6106)
					p.Match(MySqlParserREAD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6107)
					p.Match(MySqlParserLOCK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewChannelFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6112)
			p.Match(MySqlParserRELAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6113)
			p.Match(MySqlParserLOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(6114)
				p.ChannelOption()
			}

		}

	case 3:
		localctx = NewTableFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6117)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6119)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 894, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6118)
				p.Tables()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6122)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 895, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6121)
				p.FlushTableOption()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushTableOptionContext is an interface to support dynamic dispatch.
type IFlushTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	READ() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	FOR() antlr.TerminalNode
	EXPORT() antlr.TerminalNode

	// IsFlushTableOptionContext differentiates from other interfaces.
	IsFlushTableOptionContext()
}

type FlushTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushTableOptionContext() *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushTableOption
	return p
}

func InitEmptyFlushTableOptionContext(p *FlushTableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_flushTableOption
}

func (*FlushTableOptionContext) IsFlushTableOptionContext() {}

func NewFlushTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushTableOption

	return p
}

func (s *FlushTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushTableOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *FlushTableOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *FlushTableOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *FlushTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *FlushTableOptionContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT, 0)
}

func (s *FlushTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFlushTableOption(s)
	}
}

func (s *FlushTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFlushTableOption(s)
	}
}

func (s *FlushTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFlushTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FlushTableOption() (localctx IFlushTableOptionContext) {
	localctx = NewFlushTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, MySqlParserRULE_flushTableOption)
	p.SetState(6131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6126)
			p.Match(MySqlParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6127)
			p.Match(MySqlParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6128)
			p.Match(MySqlParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6129)
			p.Match(MySqlParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6130)
			p.Match(MySqlParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadedTableIndexesContext is an interface to support dynamic dispatch.
type ILoadedTableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token

	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token)

	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IUidListContext

	// GetIndexList returns the indexList rule contexts.
	GetIndexList() IUidListContext

	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IUidListContext)

	// SetIndexList sets the indexList rule contexts.
	SetIndexList(IUidListContext)

	// Getter signatures
	TableName() ITableNameContext
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	ALL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsLoadedTableIndexesContext differentiates from other interfaces.
	IsLoadedTableIndexesContext()
}

type LoadedTableIndexesContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionList IUidListContext
	indexFormat   antlr.Token
	indexList     IUidListContext
}

func NewEmptyLoadedTableIndexesContext() *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes
	return p
}

func InitEmptyLoadedTableIndexesContext(p *LoadedTableIndexesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes
}

func (*LoadedTableIndexesContext) IsLoadedTableIndexesContext() {}

func NewLoadedTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes

	return p
}

func (s *LoadedTableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadedTableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *LoadedTableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *LoadedTableIndexesContext) GetPartitionList() IUidListContext { return s.partitionList }

func (s *LoadedTableIndexesContext) GetIndexList() IUidListContext { return s.indexList }

func (s *LoadedTableIndexesContext) SetPartitionList(v IUidListContext) { s.partitionList = v }

func (s *LoadedTableIndexesContext) SetIndexList(v IUidListContext) { s.indexList = v }

func (s *LoadedTableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadedTableIndexesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *LoadedTableIndexesContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *LoadedTableIndexesContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *LoadedTableIndexesContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *LoadedTableIndexesContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVES, 0)
}

func (s *LoadedTableIndexesContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *LoadedTableIndexesContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadedTableIndexesContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *LoadedTableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *LoadedTableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *LoadedTableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadedTableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadedTableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadedTableIndexes(s)
	}
}

func (s *LoadedTableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadedTableIndexes(s)
	}
}

func (s *LoadedTableIndexesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLoadedTableIndexes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LoadedTableIndexes() (localctx ILoadedTableIndexesContext) {
	localctx = NewLoadedTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, MySqlParserRULE_loadedTableIndexes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6133)
		p.TableName()
	}
	p.SetState(6141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(6134)
			p.Match(MySqlParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6135)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
			{
				p.SetState(6136)

				var _x = p.UidList()

				localctx.(*LoadedTableIndexesContext).partitionList = _x
			}

		case MySqlParserALL:
			{
				p.SetState(6137)
				p.Match(MySqlParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6140)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(6150)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 901, p.GetParserRuleContext()) == 1 {
		p.SetState(6144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(6143)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*LoadedTableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*LoadedTableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6146)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6147)

			var _x = p.UidList()

			localctx.(*LoadedTableIndexesContext).indexList = _x
		}
		{
			p.SetState(6148)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(6152)
			p.Match(MySqlParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6153)
			p.Match(MySqlParserLEAVES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleDescribeStatementContext is an interface to support dynamic dispatch.
type ISimpleDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token

	// GetPattern returns the pattern token.
	GetPattern() antlr.Token

	// SetCommand sets the command token.
	SetCommand(antlr.Token)

	// SetPattern sets the pattern token.
	SetPattern(antlr.Token)

	// GetColumn returns the column rule contexts.
	GetColumn() IUidContext

	// SetColumn sets the column rule contexts.
	SetColumn(IUidContext)

	// Getter signatures
	TableName() ITableNameContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleDescribeStatementContext differentiates from other interfaces.
	IsSimpleDescribeStatementContext()
}

type SimpleDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	command antlr.Token
	column  IUidContext
	pattern antlr.Token
}

func NewEmptySimpleDescribeStatementContext() *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement
	return p
}

func InitEmptySimpleDescribeStatementContext(p *SimpleDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement
}

func (*SimpleDescribeStatementContext) IsSimpleDescribeStatementContext() {}

func NewSimpleDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement

	return p
}

func (s *SimpleDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *SimpleDescribeStatementContext) GetPattern() antlr.Token { return s.pattern }

func (s *SimpleDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *SimpleDescribeStatementContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *SimpleDescribeStatementContext) GetColumn() IUidContext { return s.column }

func (s *SimpleDescribeStatementContext) SetColumn(v IUidContext) { s.column = v }

func (s *SimpleDescribeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SimpleDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPLAIN, 0)
}

func (s *SimpleDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESCRIBE, 0)
}

func (s *SimpleDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *SimpleDescribeStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleDescribeStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SimpleDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleDescribeStatement(s)
	}
}

func (s *SimpleDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleDescribeStatement(s)
	}
}

func (s *SimpleDescribeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleDescribeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SimpleDescribeStatement() (localctx ISimpleDescribeStatementContext) {
	localctx = NewSimpleDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, MySqlParserRULE_simpleDescribeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6156)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SimpleDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2305895785771827200) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SimpleDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6157)
		p.TableName()
	}
	p.SetState(6160)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 903, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6158)

			var _x = p.Uid()

			localctx.(*SimpleDescribeStatementContext).column = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 903, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6159)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SimpleDescribeStatementContext).pattern = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullDescribeStatementContext is an interface to support dynamic dispatch.
type IFullDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token

	// GetFormatType returns the formatType token.
	GetFormatType() antlr.Token

	// GetFormatValue returns the formatValue token.
	GetFormatValue() antlr.Token

	// SetCommand sets the command token.
	SetCommand(antlr.Token)

	// SetFormatType sets the formatType token.
	SetFormatType(antlr.Token)

	// SetFormatValue sets the formatValue token.
	SetFormatValue(antlr.Token)

	// Getter signatures
	DescribeObjectClause() IDescribeObjectClauseContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	JSON() antlr.TerminalNode

	// IsFullDescribeStatementContext differentiates from other interfaces.
	IsFullDescribeStatementContext()
}

type FullDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	command     antlr.Token
	formatType  antlr.Token
	formatValue antlr.Token
}

func NewEmptyFullDescribeStatementContext() *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement
	return p
}

func InitEmptyFullDescribeStatementContext(p *FullDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement
}

func (*FullDescribeStatementContext) IsFullDescribeStatementContext() {}

func NewFullDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement

	return p
}

func (s *FullDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FullDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *FullDescribeStatementContext) GetFormatType() antlr.Token { return s.formatType }

func (s *FullDescribeStatementContext) GetFormatValue() antlr.Token { return s.formatValue }

func (s *FullDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *FullDescribeStatementContext) SetFormatType(v antlr.Token) { s.formatType = v }

func (s *FullDescribeStatementContext) SetFormatValue(v antlr.Token) { s.formatValue = v }

func (s *FullDescribeStatementContext) DescribeObjectClause() IDescribeObjectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeObjectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeObjectClauseContext)
}

func (s *FullDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPLAIN, 0)
}

func (s *FullDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESCRIBE, 0)
}

func (s *FullDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *FullDescribeStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *FullDescribeStatementContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *FullDescribeStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *FullDescribeStatementContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORMAT, 0)
}

func (s *FullDescribeStatementContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRADITIONAL, 0)
}

func (s *FullDescribeStatementContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *FullDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullDescribeStatement(s)
	}
}

func (s *FullDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullDescribeStatement(s)
	}
}

func (s *FullDescribeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullDescribeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullDescribeStatement() (localctx IFullDescribeStatementContext) {
	localctx = NewFullDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, MySqlParserRULE_fullDescribeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6162)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*FullDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2305895785771827200) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*FullDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(6166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENDED || _la == MySqlParserPARTITIONS || _la == MySqlParserFORMAT {
		{
			p.SetState(6163)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserEXTENDED || _la == MySqlParserPARTITIONS || _la == MySqlParserFORMAT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6164)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6165)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJSON || _la == MySqlParserTRADITIONAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6168)
		p.DescribeObjectClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_helpStatement
	return p
}

func InitEmptyHelpStatementContext(p *HelpStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_helpStatement
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(MySqlParserHELP, 0)
}

func (s *HelpStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (s *HelpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHelpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HelpStatement() (localctx IHelpStatementContext) {
	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, MySqlParserRULE_helpStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6170)
		p.Match(MySqlParserHELP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6171)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Uid() IUidContext

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_useStatement
	return p
}

func InitEmptyUseStatementContext(p *UseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_useStatement
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *UseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (s *UseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UseStatement() (localctx IUseStatementContext) {
	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, MySqlParserRULE_useStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6173)
		p.Match(MySqlParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6174)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalStatementContext is an interface to support dynamic dispatch.
type ISignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsSignalStatementContext differentiates from other interfaces.
	IsSignalStatementContext()
}

type SignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalStatementContext() *SignalStatementContext {
	var p = new(SignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalStatement
	return p
}

func InitEmptySignalStatementContext(p *SignalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalStatement
}

func (*SignalStatementContext) IsSignalStatementContext() {}

func NewSignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalStatementContext {
	var p = new(SignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_signalStatement

	return p
}

func (s *SignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalStatementContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNAL, 0)
}

func (s *SignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *SignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *SignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *SignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *SignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *SignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSignalStatement(s)
	}
}

func (s *SignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSignalStatement(s)
	}
}

func (s *SignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SignalStatement() (localctx ISignalStatementContext) {
	localctx = NewSignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, MySqlParserRULE_signalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6176)
		p.Match(MySqlParserSIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQLSTATE:
		{
			p.SetState(6177)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(6178)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6181)
			p.StringLiteral()
		}

	case MySqlParserID:
		{
			p.SetState(6182)
			p.Match(MySqlParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(6183)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6195)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 908, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6186)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6187)
			p.SignalConditionInformation()
		}
		p.SetState(6192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6188)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6189)
				p.SignalConditionInformation()
			}

			p.SetState(6194)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResignalStatementContext is an interface to support dynamic dispatch.
type IResignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsResignalStatementContext differentiates from other interfaces.
	IsResignalStatementContext()
}

type ResignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignalStatementContext() *ResignalStatementContext {
	var p = new(ResignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resignalStatement
	return p
}

func InitEmptyResignalStatementContext(p *ResignalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_resignalStatement
}

func (*ResignalStatementContext) IsResignalStatementContext() {}

func NewResignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResignalStatementContext {
	var p = new(ResignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resignalStatement

	return p
}

func (s *ResignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResignalStatementContext) RESIGNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESIGNAL, 0)
}

func (s *ResignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *ResignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *ResignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ResignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *ResignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *ResignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *ResignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ResignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ResignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ResignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *ResignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResignalStatement(s)
	}
}

func (s *ResignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResignalStatement(s)
	}
}

func (s *ResignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitResignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ResignalStatement() (localctx IResignalStatementContext) {
	localctx = NewResignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, MySqlParserRULE_resignalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6197)
		p.Match(MySqlParserRESIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQLSTATE:
		{
			p.SetState(6198)
			p.Match(MySqlParserSQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(6199)
				p.Match(MySqlParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6202)
			p.StringLiteral()
		}

	case MySqlParserID:
		{
			p.SetState(6203)
			p.Match(MySqlParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(6204)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserTABLE, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:

	default:
	}
	p.SetState(6216)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 912, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6207)
			p.Match(MySqlParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6208)
			p.SignalConditionInformation()
		}
		p.SetState(6213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6209)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6210)
				p.SignalConditionInformation()
			}

			p.SetState(6215)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalConditionInformationContext is an interface to support dynamic dispatch.
type ISignalConditionInformationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DECIMAL_LITERAL() antlr.TerminalNode
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsSignalConditionInformationContext differentiates from other interfaces.
	IsSignalConditionInformationContext()
}

type SignalConditionInformationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalConditionInformationContext() *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalConditionInformation
	return p
}

func InitEmptySignalConditionInformationContext(p *SignalConditionInformationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_signalConditionInformation
}

func (*SignalConditionInformationContext) IsSignalConditionInformationContext() {}

func NewSignalConditionInformationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_signalConditionInformation

	return p
}

func (s *SignalConditionInformationContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalConditionInformationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SignalConditionInformationContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *SignalConditionInformationContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *SignalConditionInformationContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *SignalConditionInformationContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *SignalConditionInformationContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *SignalConditionInformationContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *SignalConditionInformationContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *SignalConditionInformationContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalConditionInformationContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *SignalConditionInformationContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *SignalConditionInformationContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *SignalConditionInformationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalConditionInformationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalConditionInformationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSignalConditionInformation(s)
	}
}

func (s *SignalConditionInformationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSignalConditionInformation(s)
	}
}

func (s *SignalConditionInformationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSignalConditionInformation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SignalConditionInformation() (localctx ISignalConditionInformationContext) {
	localctx = NewSignalConditionInformationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, MySqlParserRULE_signalConditionInformation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6218)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-358)) & ^0x3f) == 0 && ((int64(1)<<(_la-358))&272105729) != 0) || _la == MySqlParserMESSAGE_TEXT || _la == MySqlParserMYSQL_ERRNO || _la == MySqlParserSUBCLASS_ORIGIN || _la == MySqlParserTABLE_NAME || _la == MySqlParserCATALOG_NAME || _la == MySqlParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6219)
		p.Match(MySqlParserEQUAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTART_NATIONAL_STRING_LITERAL, MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
		{
			p.SetState(6220)
			p.StringLiteral()
		}

	case MySqlParserDECIMAL_LITERAL:
		{
			p.SetState(6221)
			p.Match(MySqlParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
		{
			p.SetState(6222)
			p.MysqlVariable()
		}

	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserID:
		{
			p.SetState(6223)
			p.SimpleId()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCommonTableExpressions() []ICommonTableExpressionsContext
	CommonTableExpressions(i int) ICommonTableExpressionsContext
	RECURSIVE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *WithStatementContext) AllCommonTableExpressions() []ICommonTableExpressionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionsContext); ok {
			tst[i] = t.(ICommonTableExpressionsContext)
			i++
		}
	}

	return tst
}

func (s *WithStatementContext) CommonTableExpressions(i int) ICommonTableExpressionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *WithStatementContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *WithStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WithStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, MySqlParserRULE_withStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6226)
		p.Match(MySqlParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6228)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 914, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6227)
			p.Match(MySqlParserRECURSIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6230)
		p.CommonTableExpressions()
	}
	p.SetState(6235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6231)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6232)
			p.CommonTableExpressions()
		}

		p.SetState(6237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableStatementContext is an interface to support dynamic dispatch.
type ITableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsTableStatementContext differentiates from other interfaces.
	IsTableStatementContext()
}

type TableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableStatementContext() *TableStatementContext {
	var p = new(TableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableStatement
	return p
}

func InitEmptyTableStatementContext(p *TableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableStatement
}

func (*TableStatementContext) IsTableStatementContext() {}

func NewTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableStatementContext {
	var p = new(TableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableStatement

	return p
}

func (s *TableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TableStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *TableStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *TableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableStatement(s)
	}
}

func (s *TableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableStatement(s)
	}
}

func (s *TableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableStatement() (localctx ITableStatementContext) {
	localctx = NewTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, MySqlParserRULE_tableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6238)
		p.Match(MySqlParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6239)
		p.TableName()
	}
	p.SetState(6241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserORDER {
		{
			p.SetState(6240)
			p.OrderByClause()
		}

	}
	p.SetState(6244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(6243)
			p.LimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDiagnosticsStatementContext is an interface to support dynamic dispatch.
type IDiagnosticsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	AllVariableClause() []IVariableClauseContext
	VariableClause(i int) IVariableClauseContext
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext
	DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	AllROW_COUNT() []antlr.TerminalNode
	ROW_COUNT(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDiagnosticsStatementContext differentiates from other interfaces.
	IsDiagnosticsStatementContext()
}

type DiagnosticsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsStatementContext() *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement
	return p
}

func InitEmptyDiagnosticsStatementContext(p *DiagnosticsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement
}

func (*DiagnosticsStatementContext) IsDiagnosticsStatementContext() {}

func NewDiagnosticsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement

	return p
}

func (s *DiagnosticsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsStatementContext) GET() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET, 0)
}

func (s *DiagnosticsStatementContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIAGNOSTICS, 0)
}

func (s *DiagnosticsStatementContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *DiagnosticsStatementContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTACKED, 0)
}

func (s *DiagnosticsStatementContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *DiagnosticsStatementContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *DiagnosticsStatementContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *DiagnosticsStatementContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *DiagnosticsStatementContext) AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			len++
		}
	}

	tst := make([]IDiagnosticsConditionInformationNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			tst[i] = t.(IDiagnosticsConditionInformationNameContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsConditionInformationNameContext)
}

func (s *DiagnosticsStatementContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNUMBER)
}

func (s *DiagnosticsStatementContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMBER, i)
}

func (s *DiagnosticsStatementContext) AllROW_COUNT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserROW_COUNT)
}

func (s *DiagnosticsStatementContext) ROW_COUNT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_COUNT, i)
}

func (s *DiagnosticsStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DiagnosticsStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DiagnosticsStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DiagnosticsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiagnosticsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDiagnosticsStatement(s)
	}
}

func (s *DiagnosticsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDiagnosticsStatement(s)
	}
}

func (s *DiagnosticsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDiagnosticsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DiagnosticsStatement() (localctx IDiagnosticsStatementContext) {
	localctx = NewDiagnosticsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, MySqlParserRULE_diagnosticsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6246)
		p.Match(MySqlParserGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCURRENT || _la == MySqlParserSTACKED {
		{
			p.SetState(6247)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCURRENT || _la == MySqlParserSTACKED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6250)
		p.Match(MySqlParserDIAGNOSTICS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 922, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6251)
			p.VariableClause()
		}
		{
			p.SetState(6252)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6253)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNUMBER || _la == MySqlParserROW_COUNT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6254)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6255)
				p.VariableClause()
			}
			{
				p.SetState(6256)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6257)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserNUMBER || _la == MySqlParserROW_COUNT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(6263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(6264)
			p.Match(MySqlParserCONDITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(6265)
				p.DecimalLiteral()
			}

		case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserAT_SIGN, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
			{
				p.SetState(6266)
				p.VariableClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6269)
			p.VariableClause()
		}
		{
			p.SetState(6270)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6271)
			p.DiagnosticsConditionInformationName()
		}
		p.SetState(6279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6272)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6273)
				p.VariableClause()
			}
			{
				p.SetState(6274)
				p.Match(MySqlParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6275)
				p.DiagnosticsConditionInformationName()
			}

			p.SetState(6281)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDiagnosticsConditionInformationNameContext is an interface to support dynamic dispatch.
type IDiagnosticsConditionInformationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode

	// IsDiagnosticsConditionInformationNameContext differentiates from other interfaces.
	IsDiagnosticsConditionInformationNameContext()
}

type DiagnosticsConditionInformationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsConditionInformationNameContext() *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName
	return p
}

func InitEmptyDiagnosticsConditionInformationNameContext(p *DiagnosticsConditionInformationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName
}

func (*DiagnosticsConditionInformationNameContext) IsDiagnosticsConditionInformationNameContext() {}

func NewDiagnosticsConditionInformationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName

	return p
}

func (s *DiagnosticsConditionInformationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsConditionInformationNameContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNED_SQLSTATE, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsConditionInformationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiagnosticsConditionInformationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDiagnosticsConditionInformationName(s)
	}
}

func (s *DiagnosticsConditionInformationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDiagnosticsConditionInformationName(s)
	}
}

func (s *DiagnosticsConditionInformationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDiagnosticsConditionInformationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DiagnosticsConditionInformationName() (localctx IDiagnosticsConditionInformationNameContext) {
	localctx = NewDiagnosticsConditionInformationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, MySqlParserRULE_diagnosticsConditionInformationName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6284)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-358)) & ^0x3f) == 0 && ((int64(1)<<(_la-358))&272105729) != 0) || _la == MySqlParserMESSAGE_TEXT || _la == MySqlParserMYSQL_ERRNO || ((int64((_la-591)) & ^0x3f) == 0 && ((int64(1)<<(_la-591))&18155135997837313) != 0) || _la == MySqlParserCATALOG_NAME || _la == MySqlParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeObjectClauseContext is an interface to support dynamic dispatch.
type IDescribeObjectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDescribeObjectClauseContext differentiates from other interfaces.
	IsDescribeObjectClauseContext()
}

type DescribeObjectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeObjectClauseContext() *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_describeObjectClause
	return p
}

func InitEmptyDescribeObjectClauseContext(p *DescribeObjectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_describeObjectClause
}

func (*DescribeObjectClauseContext) IsDescribeObjectClauseContext() {}

func NewDescribeObjectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_describeObjectClause

	return p
}

func (s *DescribeObjectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeObjectClauseContext) CopyAll(ctx *DescribeObjectClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DescribeObjectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeObjectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DescribeStatementsContext struct {
	DescribeObjectClauseContext
}

func NewDescribeStatementsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStatementsContext {
	var p = new(DescribeStatementsContext)

	InitEmptyDescribeObjectClauseContext(&p.DescribeObjectClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStatementsContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DescribeStatementsContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DescribeStatementsContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DescribeStatementsContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DescribeStatementsContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DescribeStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDescribeStatements(s)
	}
}

func (s *DescribeStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDescribeStatements(s)
	}
}

func (s *DescribeStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDescribeStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeConnectionContext struct {
	DescribeObjectClauseContext
}

func NewDescribeConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectionContext {
	var p = new(DescribeConnectionContext)

	InitEmptyDescribeObjectClauseContext(&p.DescribeObjectClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DescribeConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *DescribeConnectionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DescribeConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDescribeConnection(s)
	}
}

func (s *DescribeConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDescribeConnection(s)
	}
}

func (s *DescribeConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDescribeConnection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DescribeObjectClause() (localctx IDescribeObjectClauseContext) {
	localctx = NewDescribeObjectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, MySqlParserRULE_describeObjectClause)
	p.SetState(6296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDELETE, MySqlParserINSERT, MySqlParserREPLACE, MySqlParserSELECT, MySqlParserUPDATE, MySqlParserLR_BRACKET:
		localctx = NewDescribeStatementsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT, MySqlParserLR_BRACKET:
			{
				p.SetState(6286)
				p.SelectStatement()
			}

		case MySqlParserDELETE:
			{
				p.SetState(6287)
				p.DeleteStatement()
			}

		case MySqlParserINSERT:
			{
				p.SetState(6288)
				p.InsertStatement()
			}

		case MySqlParserREPLACE:
			{
				p.SetState(6289)
				p.ReplaceStatement()
			}

		case MySqlParserUPDATE:
			{
				p.SetState(6290)
				p.UpdateStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySqlParserFOR:
		localctx = NewDescribeConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6293)
			p.Match(MySqlParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6294)
			p.Match(MySqlParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6295)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
	return p
}

func InitEmptyFullIdContext(p *FullIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullId(s)
	}
}

func (s *FullIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullId(s)
	}
}

func (s *FullIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullId() (localctx IFullIdContext) {
	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, MySqlParserRULE_fullId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6298)
		p.Uid()
	}
	p.SetState(6302)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 925, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6299)
			p.Match(MySqlParserDOT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 925, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6300)
			p.Match(MySqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6301)
			p.Uid()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullId() IFullIdContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, MySqlParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6304)
		p.FullId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleNameContext is an interface to support dynamic dispatch.
type IRoleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	Uid() IUidContext

	// IsRoleNameContext differentiates from other interfaces.
	IsRoleNameContext()
}

type RoleNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleNameContext() *RoleNameContext {
	var p = new(RoleNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleName
	return p
}

func InitEmptyRoleNameContext(p *RoleNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_roleName
}

func (*RoleNameContext) IsRoleNameContext() {}

func NewRoleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleNameContext {
	var p = new(RoleNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_roleName

	return p
}

func (s *RoleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleNameContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleName(s)
	}
}

func (s *RoleNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleName(s)
	}
}

func (s *RoleNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoleName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) RoleName() (localctx IRoleNameContext) {
	localctx = NewRoleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, MySqlParserRULE_roleName)
	p.SetState(6308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 926, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6306)
			p.UserName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6307)
			p.Uid()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	AllDottedId() []IDottedIdContext
	DottedId(i int) IDottedIdContext

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
	return p
}

func InitEmptyFullColumnNameContext(p *FullColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnName(s)
	}
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnName(s)
	}
}

func (s *FullColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullColumnName() (localctx IFullColumnNameContext) {
	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, MySqlParserRULE_fullColumnName)
	p.SetState(6324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6310)
			p.Uid()
		}
		p.SetState(6315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 928, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6311)
				p.DottedId()
			}
			p.SetState(6313)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 927, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6312)
					p.DottedId()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6318)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 929, p.GetParserRuleContext()) == 1 {
			p.SetState(6317)
			p.MatchWildcard()

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6320)
			p.DottedId()
		}
		p.SetState(6322)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 930, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6321)
				p.DottedId()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnNameContext is an interface to support dynamic dispatch.
type IIndexColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSortType returns the sortType token.
	GetSortType() antlr.Token

	// SetSortType sets the sortType token.
	SetSortType(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsIndexColumnNameContext differentiates from other interfaces.
	IsIndexColumnNameContext()
}

type IndexColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	sortType antlr.Token
}

func NewEmptyIndexColumnNameContext() *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnName
	return p
}

func InitEmptyIndexColumnNameContext(p *IndexColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnName
}

func (*IndexColumnNameContext) IsIndexColumnNameContext() {}

func NewIndexColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnName

	return p
}

func (s *IndexColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNameContext) GetSortType() antlr.Token { return s.sortType }

func (s *IndexColumnNameContext) SetSortType(v antlr.Token) { s.sortType = v }

func (s *IndexColumnNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexColumnNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *IndexColumnNameContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexColumnNameContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IndexColumnNameContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexColumnNameContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *IndexColumnNameContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *IndexColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexColumnName() (localctx IIndexColumnNameContext) {
	localctx = NewIndexColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, MySqlParserRULE_indexColumnName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 934, p.GetParserRuleContext()) {
	case 1:
		p.SetState(6328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 932, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6326)
				p.Uid()
			}

		case 2:
			{
				p.SetState(6327)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(6334)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6330)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6331)
				p.DecimalLiteral()
			}
			{
				p.SetState(6332)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		{
			p.SetState(6336)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(6340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserASC || _la == MySqlParserDESC {
		{
			p.SetState(6339)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexColumnNameContext).sortType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexColumnNameContext).sortType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleUserNameContext is an interface to support dynamic dispatch.
type ISimpleUserNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	KeywordsCanBeId() IKeywordsCanBeIdContext

	// IsSimpleUserNameContext differentiates from other interfaces.
	IsSimpleUserNameContext()
}

type SimpleUserNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleUserNameContext() *SimpleUserNameContext {
	var p = new(SimpleUserNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleUserName
	return p
}

func InitEmptySimpleUserNameContext(p *SimpleUserNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleUserName
}

func (*SimpleUserNameContext) IsSimpleUserNameContext() {}

func NewSimpleUserNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleUserNameContext {
	var p = new(SimpleUserNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleUserName

	return p
}

func (s *SimpleUserNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleUserNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SimpleUserNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleUserNameContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *SimpleUserNameContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleUserNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleUserNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleUserNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleUserName(s)
	}
}

func (s *SimpleUserNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleUserName(s)
	}
}

func (s *SimpleUserNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleUserName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SimpleUserName() (localctx ISimpleUserNameContext) {
	localctx = NewSimpleUserNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, MySqlParserRULE_simpleUserName)
	p.SetState(6346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 936, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6342)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6343)
			p.Match(MySqlParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6344)
			p.Match(MySqlParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6345)
			p.KeywordsCanBeId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHostNameContext is an interface to support dynamic dispatch.
type IHostNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	HOST_IP_ADDRESS() antlr.TerminalNode
	AT_SIGN() antlr.TerminalNode

	// IsHostNameContext differentiates from other interfaces.
	IsHostNameContext()
}

type HostNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostNameContext() *HostNameContext {
	var p = new(HostNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hostName
	return p
}

func InitEmptyHostNameContext(p *HostNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hostName
}

func (*HostNameContext) IsHostNameContext() {}

func NewHostNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostNameContext {
	var p = new(HostNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hostName

	return p
}

func (s *HostNameContext) GetParser() antlr.Parser { return s.parser }

func (s *HostNameContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *HostNameContext) HOST_IP_ADDRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST_IP_ADDRESS, 0)
}

func (s *HostNameContext) AT_SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT_SIGN, 0)
}

func (s *HostNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HostNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHostName(s)
	}
}

func (s *HostNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHostName(s)
	}
}

func (s *HostNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHostName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HostName() (localctx IHostNameContext) {
	localctx = NewHostNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, MySqlParserRULE_hostName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6348)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1136)) & ^0x3f) == 0 && ((int64(1)<<(_la-1136))&6291457) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserNameContext is an interface to support dynamic dispatch.
type IUserNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleUserName() ISimpleUserNameContext
	HostName() IHostNameContext
	CurrentUserExpression() ICurrentUserExpressionContext

	// IsUserNameContext differentiates from other interfaces.
	IsUserNameContext()
}

type UserNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserNameContext() *UserNameContext {
	var p = new(UserNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userName
	return p
}

func InitEmptyUserNameContext(p *UserNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userName
}

func (*UserNameContext) IsUserNameContext() {}

func NewUserNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserNameContext {
	var p = new(UserNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userName

	return p
}

func (s *UserNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserNameContext) SimpleUserName() ISimpleUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleUserNameContext)
}

func (s *UserNameContext) HostName() IHostNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostNameContext)
}

func (s *UserNameContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}

func (s *UserNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserName(s)
	}
}

func (s *UserNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserName(s)
	}
}

func (s *UserNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UserName() (localctx IUserNameContext) {
	localctx = NewUserNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, MySqlParserRULE_userName)
	p.SetState(6355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 937, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6350)
			p.SimpleUserName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6351)
			p.SimpleUserName()
		}
		{
			p.SetState(6352)
			p.HostName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6354)
			p.CurrentUserExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMysqlVariableContext is an interface to support dynamic dispatch.
type IMysqlVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode

	// IsMysqlVariableContext differentiates from other interfaces.
	IsMysqlVariableContext()
}

type MysqlVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMysqlVariableContext() *MysqlVariableContext {
	var p = new(MysqlVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_mysqlVariable
	return p
}

func InitEmptyMysqlVariableContext(p *MysqlVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_mysqlVariable
}

func (*MysqlVariableContext) IsMysqlVariableContext() {}

func NewMysqlVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlVariableContext {
	var p = new(MysqlVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_mysqlVariable

	return p
}

func (s *MysqlVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlVariableContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *MysqlVariableContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL_ID, 0)
}

func (s *MysqlVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMysqlVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) MysqlVariable() (localctx IMysqlVariableContext) {
	localctx = NewMysqlVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, MySqlParserRULE_mysqlVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6357)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserLOCAL_ID || _la == MySqlParserGLOBAL_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	STRING_LITERAL() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CharsetNameContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *CharsetNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CharsetNameContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, MySqlParserRULE_charsetName)
	p.SetState(6363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 938, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6359)
			p.Match(MySqlParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6360)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6361)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6362)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
	return p
}

func InitEmptyCollationNameContext(p *CollationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CollationName() (localctx ICollationNameContext) {
	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, MySqlParserRULE_collationName)
	p.SetState(6367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 939, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6365)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6366)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineNameContext is an interface to support dynamic dispatch.
type IEngineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EngineNameBase() IEngineNameBaseContext
	ID() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsEngineNameContext differentiates from other interfaces.
	IsEngineNameContext()
}

type EngineNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameContext() *EngineNameContext {
	var p = new(EngineNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineName
	return p
}

func InitEmptyEngineNameContext(p *EngineNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineName
}

func (*EngineNameContext) IsEngineNameContext() {}

func NewEngineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameContext {
	var p = new(EngineNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_engineName

	return p
}

func (s *EngineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameContext) EngineNameBase() IEngineNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameBaseContext)
}

func (s *EngineNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *EngineNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *EngineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEngineName(s)
	}
}

func (s *EngineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEngineName(s)
	}
}

func (s *EngineNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEngineName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) EngineName() (localctx IEngineNameContext) {
	localctx = NewEngineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, MySqlParserRULE_engineName)
	p.SetState(6372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCONNECT, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6369)
			p.EngineNameBase()
		}

	case MySqlParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6370)
			p.Match(MySqlParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6371)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineNameBaseContext is an interface to support dynamic dispatch.
type IEngineNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARCHIVE() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CSV() antlr.TerminalNode
	FEDERATED() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MRG_MYISAM() antlr.TerminalNode
	MYISAM() antlr.TerminalNode
	NDB() antlr.TerminalNode
	NDBCLUSTER() antlr.TerminalNode
	PERFORMANCE_SCHEMA() antlr.TerminalNode
	TOKUDB() antlr.TerminalNode

	// IsEngineNameBaseContext differentiates from other interfaces.
	IsEngineNameBaseContext()
}

type EngineNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameBaseContext() *EngineNameBaseContext {
	var p = new(EngineNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineNameBase
	return p
}

func InitEmptyEngineNameBaseContext(p *EngineNameBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_engineNameBase
}

func (*EngineNameBaseContext) IsEngineNameBaseContext() {}

func NewEngineNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameBaseContext {
	var p = new(EngineNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_engineNameBase

	return p
}

func (s *EngineNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameBaseContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserARCHIVE, 0)
}

func (s *EngineNameBaseContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLACKHOLE, 0)
}

func (s *EngineNameBaseContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECT, 0)
}

func (s *EngineNameBaseContext) CSV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCSV, 0)
}

func (s *EngineNameBaseContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFEDERATED, 0)
}

func (s *EngineNameBaseContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB, 0)
}

func (s *EngineNameBaseContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *EngineNameBaseContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMRG_MYISAM, 0)
}

func (s *EngineNameBaseContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYISAM, 0)
}

func (s *EngineNameBaseContext) NDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB, 0)
}

func (s *EngineNameBaseContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDBCLUSTER, 0)
}

func (s *EngineNameBaseContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERFORMANCE_SCHEMA, 0)
}

func (s *EngineNameBaseContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOKUDB, 0)
}

func (s *EngineNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEngineNameBase(s)
	}
}

func (s *EngineNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEngineNameBase(s)
	}
}

func (s *EngineNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEngineNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) EngineNameBase() (localctx IEngineNameBaseContext) {
	localctx = NewEngineNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, MySqlParserRULE_engineNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6374)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserCONNECT || ((int64((_la-786)) & ^0x3f) == 0 && ((int64(1)<<(_la-786))&4095) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUuidSetContext is an interface to support dynamic dispatch.
type IUuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	AllCOLON_SYMB() []antlr.TerminalNode
	COLON_SYMB(i int) antlr.TerminalNode

	// IsUuidSetContext differentiates from other interfaces.
	IsUuidSetContext()
}

type UuidSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUuidSetContext() *UuidSetContext {
	var p = new(UuidSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uuidSet
	return p
}

func InitEmptyUuidSetContext(p *UuidSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uuidSet
}

func (*UuidSetContext) IsUuidSetContext() {}

func NewUuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UuidSetContext {
	var p = new(UuidSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uuidSet

	return p
}

func (s *UuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *UuidSetContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *UuidSetContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UuidSetContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *UuidSetContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *UuidSetContext) AllCOLON_SYMB() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOLON_SYMB)
}

func (s *UuidSetContext) COLON_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, i)
}

func (s *UuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUuidSet(s)
	}
}

func (s *UuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUuidSet(s)
	}
}

func (s *UuidSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUuidSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UuidSet() (localctx IUuidSetContext) {
	localctx = NewUuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, MySqlParserRULE_uuidSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6376)
		p.DecimalLiteral()
	}
	{
		p.SetState(6377)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6378)
		p.DecimalLiteral()
	}
	{
		p.SetState(6379)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6380)
		p.DecimalLiteral()
	}
	{
		p.SetState(6381)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6382)
		p.DecimalLiteral()
	}
	{
		p.SetState(6383)
		p.Match(MySqlParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6384)
		p.DecimalLiteral()
	}
	p.SetState(6390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySqlParserCOLON_SYMB {
		{
			p.SetState(6385)
			p.Match(MySqlParserCOLON_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6386)
			p.DecimalLiteral()
		}
		{
			p.SetState(6387)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6388)
			p.DecimalLiteral()
		}

		p.SetState(6392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXidContext is an interface to support dynamic dispatch.
type IXidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetGlobalTableUid returns the globalTableUid rule contexts.
	GetGlobalTableUid() IXuidStringIdContext

	// GetQualifier returns the qualifier rule contexts.
	GetQualifier() IXuidStringIdContext

	// GetIdFormat returns the idFormat rule contexts.
	GetIdFormat() IDecimalLiteralContext

	// SetGlobalTableUid sets the globalTableUid rule contexts.
	SetGlobalTableUid(IXuidStringIdContext)

	// SetQualifier sets the qualifier rule contexts.
	SetQualifier(IXuidStringIdContext)

	// SetIdFormat sets the idFormat rule contexts.
	SetIdFormat(IDecimalLiteralContext)

	// Getter signatures
	AllXuidStringId() []IXuidStringIdContext
	XuidStringId(i int) IXuidStringIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsXidContext differentiates from other interfaces.
	IsXidContext()
}

type XidContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	globalTableUid IXuidStringIdContext
	qualifier      IXuidStringIdContext
	idFormat       IDecimalLiteralContext
}

func NewEmptyXidContext() *XidContext {
	var p = new(XidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xid
	return p
}

func InitEmptyXidContext(p *XidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xid
}

func (*XidContext) IsXidContext() {}

func NewXidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XidContext {
	var p = new(XidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xid

	return p
}

func (s *XidContext) GetParser() antlr.Parser { return s.parser }

func (s *XidContext) GetGlobalTableUid() IXuidStringIdContext { return s.globalTableUid }

func (s *XidContext) GetQualifier() IXuidStringIdContext { return s.qualifier }

func (s *XidContext) GetIdFormat() IDecimalLiteralContext { return s.idFormat }

func (s *XidContext) SetGlobalTableUid(v IXuidStringIdContext) { s.globalTableUid = v }

func (s *XidContext) SetQualifier(v IXuidStringIdContext) { s.qualifier = v }

func (s *XidContext) SetIdFormat(v IDecimalLiteralContext) { s.idFormat = v }

func (s *XidContext) AllXuidStringId() []IXuidStringIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			len++
		}
	}

	tst := make([]IXuidStringIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXuidStringIdContext); ok {
			tst[i] = t.(IXuidStringIdContext)
			i++
		}
	}

	return tst
}

func (s *XidContext) XuidStringId(i int) IXuidStringIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXuidStringIdContext)
}

func (s *XidContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *XidContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *XidContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *XidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXid(s)
	}
}

func (s *XidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXid(s)
	}
}

func (s *XidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Xid() (localctx IXidContext) {
	localctx = NewXidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, MySqlParserRULE_xid)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6394)

		var _x = p.XuidStringId()

		localctx.(*XidContext).globalTableUid = _x
	}
	p.SetState(6401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMA {
		{
			p.SetState(6395)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6396)

			var _x = p.XuidStringId()

			localctx.(*XidContext).qualifier = _x
		}
		p.SetState(6399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOMMA {
			{
				p.SetState(6397)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6398)

				var _x = p.DecimalLiteral()

				localctx.(*XidContext).idFormat = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXuidStringIdContext is an interface to support dynamic dispatch.
type IXuidStringIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	AllHEXADECIMAL_LITERAL() []antlr.TerminalNode
	HEXADECIMAL_LITERAL(i int) antlr.TerminalNode

	// IsXuidStringIdContext differentiates from other interfaces.
	IsXuidStringIdContext()
}

type XuidStringIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXuidStringIdContext() *XuidStringIdContext {
	var p = new(XuidStringIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xuidStringId
	return p
}

func InitEmptyXuidStringIdContext(p *XuidStringIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_xuidStringId
}

func (*XuidStringIdContext) IsXuidStringIdContext() {}

func NewXuidStringIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XuidStringIdContext {
	var p = new(XuidStringIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xuidStringId

	return p
}

func (s *XuidStringIdContext) GetParser() antlr.Parser { return s.parser }

func (s *XuidStringIdContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *XuidStringIdContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *XuidStringIdContext) AllHEXADECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserHEXADECIMAL_LITERAL)
}

func (s *XuidStringIdContext) HEXADECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, i)
}

func (s *XuidStringIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XuidStringIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XuidStringIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXuidStringId(s)
	}
}

func (s *XuidStringIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXuidStringId(s)
	}
}

func (s *XuidStringIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitXuidStringId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) XuidStringId() (localctx IXuidStringIdContext) {
	localctx = NewXuidStringIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, MySqlParserRULE_xuidStringId)
	var _la int

	p.SetState(6410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6403)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBIT_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6404)
			p.Match(MySqlParserBIT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserHEXADECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserHEXADECIMAL_LITERAL {
			{
				p.SetState(6405)
				p.Match(MySqlParserHEXADECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(6408)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthPluginContext is an interface to support dynamic dispatch.
type IAuthPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsAuthPluginContext differentiates from other interfaces.
	IsAuthPluginContext()
}

type AuthPluginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthPluginContext() *AuthPluginContext {
	var p = new(AuthPluginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authPlugin
	return p
}

func InitEmptyAuthPluginContext(p *AuthPluginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_authPlugin
}

func (*AuthPluginContext) IsAuthPluginContext() {}

func NewAuthPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthPluginContext {
	var p = new(AuthPluginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authPlugin

	return p
}

func (s *AuthPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AuthPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AuthPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuthPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAuthPlugin(s)
	}
}

func (s *AuthPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAuthPlugin(s)
	}
}

func (s *AuthPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAuthPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AuthPlugin() (localctx IAuthPluginContext) {
	localctx = NewAuthPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, MySqlParserRULE_authPlugin)
	p.SetState(6414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 946, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6412)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6413)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleId() ISimpleIdContext
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
	return p
}

func InitEmptyUidContext(p *UidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (s *UidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Uid() (localctx IUidContext) {
	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, MySqlParserRULE_uid)
	p.SetState(6419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6416)
			p.SimpleId()
		}

	case MySqlParserCHARSET_REVERSE_QOUTE_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6417)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6418)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	TransactionLevelBase() ITransactionLevelBaseContext
	EngineNameBase() IEngineNameBaseContext
	PrivilegesBase() IPrivilegesBaseContext
	IntervalTypeBase() IIntervalTypeBaseContext
	DataTypeBase() IDataTypeBaseContext
	KeywordsCanBeId() IKeywordsCanBeIdContext
	ScalarFunctionName() IScalarFunctionNameContext

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
	return p
}

func InitEmptySimpleIdContext(p *SimpleIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleIdContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *SimpleIdContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *SimpleIdContext) EngineNameBase() IEngineNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameBaseContext)
}

func (s *SimpleIdContext) PrivilegesBase() IPrivilegesBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegesBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *SimpleIdContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *SimpleIdContext) DataTypeBase() IDataTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *SimpleIdContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleIdContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (s *SimpleIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SimpleId() (localctx ISimpleIdContext) {
	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, MySqlParserRULE_simpleId)
	p.SetState(6430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 948, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6421)
			p.Match(MySqlParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6422)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6423)
			p.TransactionLevelBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6424)
			p.EngineNameBase()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6425)
			p.PrivilegesBase()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6426)
			p.IntervalTypeBase()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6427)
			p.DataTypeBase()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6428)
			p.KeywordsCanBeId()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6429)
			p.ScalarFunctionName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode
	Uid() IUidContext

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
	return p
}

func InitEmptyDottedIdContext(p *DottedIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDottedId(s)
	}
}

func (s *DottedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDottedId(s)
	}
}

func (s *DottedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDottedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DottedId() (localctx IDottedIdContext) {
	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, MySqlParserRULE_dottedId)
	p.SetState(6435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6432)
			p.Match(MySqlParserDOT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6433)
			p.Match(MySqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6434)
			p.Uid()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode
	TWO_DECIMAL() antlr.TerminalNode
	REAL_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
	return p
}

func InitEmptyDecimalLiteralContext(p *DecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, MySqlParserRULE_decimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6437)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1137)) & ^0x3f) == 0 && ((int64(1)<<(_la-1137))&10247) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileSizeLiteralContext is an interface to support dynamic dispatch.
type IFileSizeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILESIZE_LITERAL() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsFileSizeLiteralContext differentiates from other interfaces.
	IsFileSizeLiteralContext()
}

type FileSizeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSizeLiteralContext() *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral
	return p
}

func InitEmptyFileSizeLiteralContext(p *FileSizeLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral
}

func (*FileSizeLiteralContext) IsFileSizeLiteralContext() {}

func NewFileSizeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral

	return p
}

func (s *FileSizeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSizeLiteralContext) FILESIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILESIZE_LITERAL, 0)
}

func (s *FileSizeLiteralContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *FileSizeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSizeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSizeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFileSizeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FileSizeLiteral() (localctx IFileSizeLiteralContext) {
	localctx = NewFileSizeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, MySqlParserRULE_fileSizeLiteral)
	p.SetState(6441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFILESIZE_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6439)
			p.Match(MySqlParserFILESIZE_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6440)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	START_NATIONAL_STRING_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, MySqlParserRULE_stringLiteral)
	var _la int

	var _alt int

	p.SetState(6466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 957, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(6444)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(6443)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6446)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6447)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(6451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6450)
					p.Match(MySqlParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(6453)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 953, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(6456)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(6455)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6458)
				p.Match(MySqlParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6459)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(6464)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 956, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6462)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6463)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, MySqlParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6468)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
	return p
}

func InitEmptyHexadecimalLiteralContext(p *HexadecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHexadecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, MySqlParserRULE_hexadecimalLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSTRING_CHARSET_NAME {
		{
			p.SetState(6470)
			p.Match(MySqlParserSTRING_CHARSET_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6473)
		p.Match(MySqlParserHEXADECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNullNotnullContext differentiates from other interfaces.
	IsNullNotnullContext()
}

type NullNotnullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext {
	var p = new(NullNotnullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nullNotnull
	return p
}

func InitEmptyNullNotnullContext(p *NullNotnullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nullNotnull
}

func (*NullNotnullContext) IsNullNotnullContext() {}

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext {
	var p = new(NullNotnullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_nullNotnull

	return p
}

func (s *NullNotnullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}

func (s *NullNotnullContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNullNotnull(s)
	}
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNullNotnull(s)
	}
}

func (s *NullNotnullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNullNotnull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) NullNotnull() (localctx INullNotnullContext) {
	localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, MySqlParserRULE_nullNotnull)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOT {
		{
			p.SetState(6475)
			p.Match(MySqlParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6478)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullLiteral returns the nullLiteral token.
	GetNullLiteral() antlr.Token

	// SetNullLiteral sets the nullLiteral token.
	SetNullLiteral(antlr.Token)

	// Getter signatures
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	MINUS() antlr.TerminalNode
	HexadecimalLiteral() IHexadecimalLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	REAL_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	nullLiteral antlr.Token
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) GetNullLiteral() antlr.Token { return s.nullLiteral }

func (s *ConstantContext) SetNullLiteral(v antlr.Token) { s.nullLiteral = v }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *ConstantContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *ConstantContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}

func (s *ConstantContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, MySqlParserRULE_constant)
	var _la int

	p.SetState(6492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 961, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6480)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6481)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6482)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6483)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6484)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6485)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6486)
			p.Match(MySqlParserREAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6487)
			p.Match(MySqlParserBIT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(6489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(6488)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6491)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConstantContext).nullLiteral = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConstantContext).nullLiteral = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpatialDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSpatialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpatialDataTypeContext {
	var p = new(SpatialDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *SpatialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpatialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpatialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialDataTypeContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) GEOMCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *SpatialDataTypeContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *SpatialDataTypeContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *SpatialDataTypeContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *SpatialDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *SpatialDataTypeContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRY, 0)
}

func (s *SpatialDataTypeContext) SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSRID, 0)
}

func (s *SpatialDataTypeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SpatialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpatialDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LongVarbinaryDataTypeContext struct {
	DataTypeContext
}

func NewLongVarbinaryDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarbinaryDataTypeContext {
	var p = new(LongVarbinaryDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarbinaryDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarbinaryDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarbinaryDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}

func (s *LongVarbinaryDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLongVarbinaryDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollectionDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewCollectionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionDataTypeContext {
	var p = new(CollectionDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *CollectionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *CollectionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *CollectionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionDataTypeContext) CollectionOptions() ICollectionOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionOptionsContext)
}

func (s *CollectionDataTypeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *CollectionDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *CollectionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CollectionDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CollectionDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CollectionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollectionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type NationalVaryingStringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewNationalVaryingStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalVaryingStringDataTypeContext {
	var p = new(NationalVaryingStringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *NationalVaryingStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalVaryingStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalVaryingStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalVaryingStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalVaryingStringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARYING, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalVaryingStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalVaryingStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *NationalVaryingStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNationalVaryingStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DimensionDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewDimensionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DimensionDataTypeContext {
	var p = new(DimensionDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *DimensionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *DimensionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *DimensionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionDataTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYINT, 0)
}

func (s *DimensionDataTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSMALLINT, 0)
}

func (s *DimensionDataTypeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMINT, 0)
}

func (s *DimensionDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT, 0)
}

func (s *DimensionDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *DimensionDataTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIGINT, 0)
}

func (s *DimensionDataTypeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIDDLEINT, 0)
}

func (s *DimensionDataTypeContext) INT1() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT1, 0)
}

func (s *DimensionDataTypeContext) INT2() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT2, 0)
}

func (s *DimensionDataTypeContext) INT3() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT3, 0)
}

func (s *DimensionDataTypeContext) INT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT4, 0)
}

func (s *DimensionDataTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT8, 0)
}

func (s *DimensionDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *DimensionDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSIGNED)
}

func (s *DimensionDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, i)
}

func (s *DimensionDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserUNSIGNED)
}

func (s *DimensionDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, i)
}

func (s *DimensionDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserZEROFILL)
}

func (s *DimensionDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserZEROFILL, i)
}

func (s *DimensionDataTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL, 0)
}

func (s *DimensionDataTypeContext) LengthTwoDimension() ILengthTwoDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *DimensionDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOUBLE, 0)
}

func (s *DimensionDataTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECISION, 0)
}

func (s *DimensionDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *DimensionDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC, 0)
}

func (s *DimensionDataTypeContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *DimensionDataTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMERIC, 0)
}

func (s *DimensionDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT, 0)
}

func (s *DimensionDataTypeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT4, 0)
}

func (s *DimensionDataTypeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT8, 0)
}

func (s *DimensionDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *DimensionDataTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *DimensionDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DimensionDataTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DimensionDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DimensionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *DimensionDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}

func (s *DimensionDataTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOB, 0)
}

func (s *DimensionDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *DimensionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDimensionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringDataTypeContext {
	var p = new(StringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *StringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *StringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *StringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *StringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *StringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *StringDataTypeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYTEXT, 0)
}

func (s *StringDataTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *StringDataTypeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMTEXT, 0)
}

func (s *StringDataTypeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGTEXT, 0)
}

func (s *StringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *StringDataTypeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNVARCHAR, 0)
}

func (s *StringDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *StringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARYING, 0)
}

func (s *StringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *StringDataTypeContext) AllBINARY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBINARY)
}

func (s *StringDataTypeContext) BINARY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, i)
}

func (s *StringDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *StringDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *StringDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringDataType(s)
	}
}

func (s *StringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringDataType(s)
	}
}

func (s *StringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LongVarcharDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewLongVarcharDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarcharDataTypeContext {
	var p = new(LongVarcharDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarcharDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *LongVarcharDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *LongVarcharDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarcharDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarcharDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *LongVarcharDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *LongVarcharDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *LongVarcharDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LongVarcharDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *LongVarcharDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *LongVarcharDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLongVarcharDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type NationalStringDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewNationalStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalStringDataTypeContext {
	var p = new(NationalStringDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *NationalStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalStringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *NationalStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *NationalStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *NationalStringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *NationalStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNationalStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleDataTypeContext struct {
	DataTypeContext
	typeName antlr.Token
}

func NewSimpleDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleDataTypeContext {
	var p = new(SimpleDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *SimpleDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SimpleDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SimpleDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *SimpleDataTypeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYBLOB, 0)
}

func (s *SimpleDataTypeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMBLOB, 0)
}

func (s *SimpleDataTypeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGBLOB, 0)
}

func (s *SimpleDataTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *SimpleDataTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *SimpleDataTypeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *SimpleDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, MySqlParserRULE_dataType)
	var _la int

	var _alt int

	p.SetState(6620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 990, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6494)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || ((int64((_la-221)) & ^0x3f) == 0 && ((int64(1)<<(_la-221))&31239) != 0) || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVARYING {
			{
				p.SetState(6495)
				p.Match(MySqlParserVARYING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6499)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6498)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6502)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 964, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6501)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6507)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 965, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6504)
				p.CharSet()
			}
			{
				p.SetState(6505)
				p.CharsetName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6512)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 966, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6509)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6510)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 966, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6511)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewNationalVaryingStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6514)
			p.Match(MySqlParserNATIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6515)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalVaryingStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalVaryingStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6516)
			p.Match(MySqlParserVARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6518)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 967, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6517)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6521)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 968, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6520)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6523)
			p.Match(MySqlParserNATIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6524)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserCHAR || _la == MySqlParserVARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6526)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 969, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6525)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6529)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 970, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6528)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6531)
			p.Match(MySqlParserNCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6532)

			var _m = p.Match(MySqlParserVARCHAR)

			localctx.(*NationalStringDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6534)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 971, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6533)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6537)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 972, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6536)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6539)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&4095) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6541)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 973, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6540)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 974, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6543)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6548)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 974, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 6:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6549)

			var _m = p.Match(MySqlParserREAL)

			localctx.(*DimensionDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6551)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 975, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6550)
				p.LengthTwoDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 976, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6553)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6558)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 976, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 7:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6559)

			var _m = p.Match(MySqlParserDOUBLE)

			localctx.(*DimensionDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRECISION {
			{
				p.SetState(6560)
				p.Match(MySqlParserPRECISION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6564)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 978, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6563)
				p.LengthTwoDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 979, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6566)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6571)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 979, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 8:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6572)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-210)) & ^0x3f) == 0 && ((int64(1)<<(_la-210))&63) != 0) || _la == MySqlParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6574)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 980, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6573)
				p.LengthTwoOptionalDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 981, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6576)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6581)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 981, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 9:
		localctx = NewSimpleDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6582)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&4237313) != 0) || _la == MySqlParserBOOL || _la == MySqlParserBOOLEAN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6583)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&2831) != 0) || _la == MySqlParserBIT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6585)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 982, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6584)
				p.LengthOneDimension()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		localctx = NewCollectionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6587)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CollectionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSET || _la == MySqlParserENUM) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CollectionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6588)
			p.CollectionOptions()
		}
		p.SetState(6590)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 983, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6589)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6595)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 984, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6592)
				p.CharSet()
			}
			{
				p.SetState(6593)
				p.CharsetName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		localctx = NewSpatialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6597)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpatialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJSON || ((int64((_la-802)) & ^0x3f) == 0 && ((int64(1)<<(_la-802))&511) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpatialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6600)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 985, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6598)
				p.Match(MySqlParserSRID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6599)
				p.DecimalLiteral()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 13:
		localctx = NewLongVarcharDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6602)

			var _m = p.Match(MySqlParserLONG)

			localctx.(*LongVarcharDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVARCHAR {
			{
				p.SetState(6603)
				p.Match(MySqlParserVARCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6607)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 987, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6606)
				p.Match(MySqlParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6612)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 988, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6609)
				p.CharSet()
			}
			{
				p.SetState(6610)
				p.CharsetName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6616)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 989, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6614)
				p.Match(MySqlParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6615)
				p.CollationName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		localctx = NewLongVarbinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6618)
			p.Match(MySqlParserLONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6619)
			p.Match(MySqlParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollectionOptionsContext is an interface to support dynamic dispatch.
type ICollectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCollectionOptionsContext differentiates from other interfaces.
	IsCollectionOptionsContext()
}

type CollectionOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOptionsContext() *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collectionOptions
	return p
}

func InitEmptyCollectionOptionsContext(p *CollectionOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_collectionOptions
}

func (*CollectionOptionsContext) IsCollectionOptionsContext() {}

func NewCollectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collectionOptions

	return p
}

func (s *CollectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOptionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CollectionOptionsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CollectionOptionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CollectionOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CollectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollectionOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CollectionOptions() (localctx ICollectionOptionsContext) {
	localctx = NewCollectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, MySqlParserRULE_collectionOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6622)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6623)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6624)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6625)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6631)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConvertedDataTypeContext is an interface to support dynamic dispatch.
type IConvertedDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTypeName returns the typeName token.
	GetTypeName() antlr.Token

	// SetTypeName sets the typeName token.
	SetTypeName(antlr.Token)

	// Getter signatures
	CHAR() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	JSON() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DEC() antlr.TerminalNode
	LengthOneDimension() ILengthOneDimensionContext
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext

	// IsConvertedDataTypeContext differentiates from other interfaces.
	IsConvertedDataTypeContext()
}

type ConvertedDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	typeName antlr.Token
}

func NewEmptyConvertedDataTypeContext() *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_convertedDataType
	return p
}

func InitEmptyConvertedDataTypeContext(p *ConvertedDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_convertedDataType
}

func (*ConvertedDataTypeContext) IsConvertedDataTypeContext() {}

func NewConvertedDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_convertedDataType

	return p
}

func (s *ConvertedDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertedDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *ConvertedDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *ConvertedDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, 0)
}

func (s *ConvertedDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserARRAY, 0)
}

func (s *ConvertedDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *ConvertedDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *ConvertedDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT, 0)
}

func (s *ConvertedDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *ConvertedDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *ConvertedDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *ConvertedDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *ConvertedDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *ConvertedDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT, 0)
}

func (s *ConvertedDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *ConvertedDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOUBLE, 0)
}

func (s *ConvertedDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *ConvertedDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC, 0)
}

func (s *ConvertedDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *ConvertedDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ConvertedDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *ConvertedDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertedDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConvertedDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ConvertedDataType() (localctx IConvertedDataTypeContext) {
	localctx = NewConvertedDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, MySqlParserRULE_convertedDataType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFLOAT, MySqlParserBINARY, MySqlParserNCHAR:
		{
			p.SetState(6633)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFLOAT || _la == MySqlParserBINARY || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6634)
				p.LengthOneDimension()
			}

		}

	case MySqlParserCHAR:
		{
			p.SetState(6637)

			var _m = p.Match(MySqlParserCHAR)

			localctx.(*ConvertedDataTypeContext).typeName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6638)
				p.LengthOneDimension()
			}

		}
		p.SetState(6644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER || _la == MySqlParserCHAR || _la == MySqlParserCHARSET {
			{
				p.SetState(6641)
				p.CharSet()
			}
			{
				p.SetState(6642)
				p.CharsetName()
			}

		}

	case MySqlParserINT, MySqlParserINTEGER, MySqlParserDOUBLE, MySqlParserDATE, MySqlParserTIME, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserJSON:
		{
			p.SetState(6646)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-199)) & ^0x3f) == 0 && ((int64(1)<<(_la-199))&3539521) != 0) || _la == MySqlParserJSON) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserDECIMAL, MySqlParserDEC:
		{
			p.SetState(6647)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDECIMAL || _la == MySqlParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6648)
				p.LengthTwoOptionalDimension()
			}

		}

	case MySqlParserUNSIGNED, MySqlParserSIGNED:
		{
			p.SetState(6651)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINT || _la == MySqlParserINTEGER {
			{
				p.SetState(6652)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINT || _la == MySqlParserINTEGER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserARRAY {
		{
			p.SetState(6657)
			p.Match(MySqlParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthOneDimension
	return p
}

func InitEmptyLengthOneDimensionContext(p *LengthOneDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthOneDimension
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthOneDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, MySqlParserRULE_lengthOneDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6660)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6661)
		p.DecimalLiteral()
	}
	{
		p.SetState(6662)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsLengthTwoDimensionContext differentiates from other interfaces.
	IsLengthTwoDimensionContext()
}

type LengthTwoDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoDimensionContext() *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension
	return p
}

func InitEmptyLengthTwoDimensionContext(p *LengthTwoDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension
}

func (*LengthTwoDimensionContext) IsLengthTwoDimensionContext() {}

func NewLengthTwoDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension

	return p
}

func (s *LengthTwoDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthTwoDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LengthTwoDimension() (localctx ILengthTwoDimensionContext) {
	localctx = NewLengthTwoDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, MySqlParserRULE_lengthTwoDimension)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6664)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6665)
		p.DecimalLiteral()
	}
	{
		p.SetState(6666)
		p.Match(MySqlParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6667)
		p.DecimalLiteral()
	}
	{
		p.SetState(6668)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension
	return p
}

func InitEmptyLengthTwoOptionalDimensionContext(p *LengthTwoOptionalDimensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthTwoOptionalDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, MySqlParserRULE_lengthTwoOptionalDimension)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6670)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6671)
		p.DecimalLiteral()
	}
	p.SetState(6674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMA {
		{
			p.SetState(6672)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6673)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(6676)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUidListContext differentiates from other interfaces.
	IsUidListContext()
}

type UidListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext {
	var p = new(UidListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uidList
	return p
}

func InitEmptyUidListContext(p *UidListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_uidList
}

func (*UidListContext) IsUidListContext() {}

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext {
	var p = new(UidListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uidList

	return p
}

func (s *UidListContext) GetParser() antlr.Parser { return s.parser }

func (s *UidListContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UidListContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *UidListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *UidListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUidList(s)
	}
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUidList(s)
	}
}

func (s *UidListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUidList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UidList() (localctx IUidListContext) {
	localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, MySqlParserRULE_uidList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6678)
		p.Uid()
	}
	p.SetState(6683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1000, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6679)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6680)
				p.Uid()
			}

		}
		p.SetState(6685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1000, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullColumnNameListContext is an interface to support dynamic dispatch.
type IFullColumnNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFullColumnNameListContext differentiates from other interfaces.
	IsFullColumnNameListContext()
}

type FullColumnNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameListContext() *FullColumnNameListContext {
	var p = new(FullColumnNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnNameList
	return p
}

func InitEmptyFullColumnNameListContext(p *FullColumnNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnNameList
}

func (*FullColumnNameListContext) IsFullColumnNameListContext() {}

func NewFullColumnNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameListContext {
	var p = new(FullColumnNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnNameList

	return p
}

func (s *FullColumnNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameListContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameListContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FullColumnNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FullColumnNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnNameList(s)
	}
}

func (s *FullColumnNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnNameList(s)
	}
}

func (s *FullColumnNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullColumnNameList() (localctx IFullColumnNameListContext) {
	localctx = NewFullColumnNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, MySqlParserRULE_fullColumnNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6686)
		p.FullColumnName()
	}
	p.SetState(6691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6687)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6688)
			p.FullColumnName()
		}

		p.SetState(6693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablesContext is an interface to support dynamic dispatch.
type ITablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTablesContext differentiates from other interfaces.
	IsTablesContext()
}

type TablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesContext() *TablesContext {
	var p = new(TablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tables
	return p
}

func InitEmptyTablesContext(p *TablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_tables
}

func (*TablesContext) IsTablesContext() {}

func NewTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablesContext {
	var p = new(TablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tables

	return p
}

func (s *TablesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablesContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablesContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTables(s)
	}
}

func (s *TablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTables(s)
	}
}

func (s *TablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Tables() (localctx ITablesContext) {
	localctx = NewTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, MySqlParserRULE_tables)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6694)
		p.TableName()
	}
	p.SetState(6699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1002, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6695)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6696)
				p.TableName()
			}

		}
		p.SetState(6701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1002, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnNamesContext is an interface to support dynamic dispatch.
type IIndexColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllIndexColumnName() []IIndexColumnNameContext
	IndexColumnName(i int) IIndexColumnNameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexColumnNamesContext differentiates from other interfaces.
	IsIndexColumnNamesContext()
}

type IndexColumnNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnNamesContext() *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnNames
	return p
}

func InitEmptyIndexColumnNamesContext(p *IndexColumnNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnNames
}

func (*IndexColumnNamesContext) IsIndexColumnNamesContext() {}

func NewIndexColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnNames

	return p
}

func (s *IndexColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNamesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllIndexColumnName() []IIndexColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexColumnNameContext); ok {
			tst[i] = t.(IIndexColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *IndexColumnNamesContext) IndexColumnName(i int) IIndexColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNameContext)
}

func (s *IndexColumnNamesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *IndexColumnNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *IndexColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexColumnNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexColumnNames() (localctx IIndexColumnNamesContext) {
	localctx = NewIndexColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, MySqlParserRULE_indexColumnNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6702)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6703)
		p.IndexColumnName()
	}
	p.SetState(6708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6704)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6705)
			p.IndexColumnName()
		}

		p.SetState(6710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6711)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
	return p
}

func InitEmptyExpressionsContext(p *ExpressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expressions() (localctx IExpressionsContext) {
	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, MySqlParserRULE_expressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6713)
		p.expression(0)
	}
	p.SetState(6718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6714)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6715)
			p.expression(0)
		}

		p.SetState(6720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsWithDefaultsContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsWithDefaultsContext differentiates from other interfaces.
	IsExpressionsWithDefaultsContext()
}

type ExpressionsWithDefaultsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultsContext() *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults
	return p
}

func InitEmptyExpressionsWithDefaultsContext(p *ExpressionsWithDefaultsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults
}

func (*ExpressionsWithDefaultsContext) IsExpressionsWithDefaultsContext() {}

func NewExpressionsWithDefaultsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults

	return p
}

func (s *ExpressionsWithDefaultsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultsContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultsContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsWithDefaultsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsWithDefaultsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsWithDefaultsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionsWithDefaults(s)
	}
}

func (s *ExpressionsWithDefaultsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionsWithDefaults(s)
	}
}

func (s *ExpressionsWithDefaultsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionsWithDefaults(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ExpressionsWithDefaults() (localctx IExpressionsWithDefaultsContext) {
	localctx = NewExpressionsWithDefaultsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, MySqlParserRULE_expressionsWithDefaults)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6721)
		p.ExpressionOrDefault()
	}
	p.SetState(6726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6722)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6723)
			p.ExpressionOrDefault()
		}

		p.SetState(6728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantsContext is an interface to support dynamic dispatch.
type IConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstantsContext differentiates from other interfaces.
	IsConstantsContext()
}

type ConstantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantsContext() *ConstantsContext {
	var p = new(ConstantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constants
	return p
}

func InitEmptyConstantsContext(p *ConstantsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_constants
}

func (*ConstantsContext) IsConstantsContext() {}

func NewConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantsContext {
	var p = new(ConstantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constants

	return p
}

func (s *ConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstants(s)
	}
}

func (s *ConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstants(s)
	}
}

func (s *ConstantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Constants() (localctx IConstantsContext) {
	localctx = NewConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, MySqlParserRULE_constants)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6729)
		p.Constant()
	}
	p.SetState(6734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6730)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6731)
			p.Constant()
		}

		p.SetState(6736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStringsContext is an interface to support dynamic dispatch.
type ISimpleStringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleStringsContext differentiates from other interfaces.
	IsSimpleStringsContext()
}

type SimpleStringsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStringsContext() *SimpleStringsContext {
	var p = new(SimpleStringsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleStrings
	return p
}

func InitEmptySimpleStringsContext(p *SimpleStringsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleStrings
}

func (*SimpleStringsContext) IsSimpleStringsContext() {}

func NewSimpleStringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStringsContext {
	var p = new(SimpleStringsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleStrings

	return p
}

func (s *SimpleStringsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStringsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *SimpleStringsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *SimpleStringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SimpleStringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SimpleStringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleStrings(s)
	}
}

func (s *SimpleStringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleStrings(s)
	}
}

func (s *SimpleStringsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleStrings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SimpleStrings() (localctx ISimpleStringsContext) {
	localctx = NewSimpleStringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, MySqlParserRULE_simpleStrings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6737)
		p.Match(MySqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6738)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6739)
			p.Match(MySqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariablesContext is an interface to support dynamic dispatch.
type IUserVariablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOCAL_ID() []antlr.TerminalNode
	LOCAL_ID(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUserVariablesContext differentiates from other interfaces.
	IsUserVariablesContext()
}

type UserVariablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariablesContext() *UserVariablesContext {
	var p = new(UserVariablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userVariables
	return p
}

func InitEmptyUserVariablesContext(p *UserVariablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_userVariables
}

func (*UserVariablesContext) IsUserVariablesContext() {}

func NewUserVariablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariablesContext {
	var p = new(UserVariablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userVariables

	return p
}

func (s *UserVariablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariablesContext) AllLOCAL_ID() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCAL_ID)
}

func (s *UserVariablesContext) LOCAL_ID(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, i)
}

func (s *UserVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *UserVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *UserVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserVariables(s)
	}
}

func (s *UserVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserVariables(s)
	}
}

func (s *UserVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUserVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UserVariables() (localctx IUserVariablesContext) {
	localctx = NewUserVariablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, MySqlParserRULE_userVariables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6745)
		p.Match(MySqlParserLOCAL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6746)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6747)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	CAST() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	ConvertedDataType() IConvertedDataTypeContext
	RR_BRACKET() antlr.TerminalNode
	Constant() IConstantContext
	UnaryOperator() IUnaryOperatorContext
	AllCurrentTimestamp() []ICurrentTimestampContext
	CurrentTimestamp(i int) ICurrentTimestampContext
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	FullId() IFullIdContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *DefaultValueContext) CAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCAST, 0)
}

func (s *DefaultValueContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *DefaultValueContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DefaultValueContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DefaultValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *DefaultValueContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *DefaultValueContext) AllCurrentTimestamp() []ICurrentTimestampContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			len++
		}
	}

	tst := make([]ICurrentTimestampContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICurrentTimestampContext); ok {
			tst[i] = t.(ICurrentTimestampContext)
			i++
		}
	}

	return tst
}

func (s *DefaultValueContext) CurrentTimestamp(i int) ICurrentTimestampContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *DefaultValueContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DefaultValueContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *DefaultValueContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, MySqlParserRULE_defaultValue)
	p.SetState(6779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1011, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6753)
			p.Match(MySqlParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6754)
			p.Match(MySqlParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6755)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6756)
			p.expression(0)
		}
		{
			p.SetState(6757)
			p.Match(MySqlParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6758)
			p.ConvertedDataType()
		}
		{
			p.SetState(6759)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6762)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1009, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6761)
				p.UnaryOperator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6764)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6765)
			p.CurrentTimestamp()
		}
		p.SetState(6769)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1010, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6766)
				p.Match(MySqlParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6767)
				p.Match(MySqlParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6768)
				p.CurrentTimestamp()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6771)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6772)
			p.expression(0)
		}
		{
			p.SetState(6773)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6775)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6776)
			p.FullId()
		}
		{
			p.SetState(6777)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICurrentTimestampContext is an interface to support dynamic dispatch.
type ICurrentTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOW() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsCurrentTimestampContext differentiates from other interfaces.
	IsCurrentTimestampContext()
}

type CurrentTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentTimestampContext() *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentTimestamp
	return p
}

func InitEmptyCurrentTimestampContext(p *CurrentTimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_currentTimestamp
}

func (*CurrentTimestampContext) IsCurrentTimestampContext() {}

func NewCurrentTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_currentTimestamp

	return p
}

func (s *CurrentTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentTimestampContext) NOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOW, 0)
}

func (s *CurrentTimestampContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CurrentTimestampContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *CurrentTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIMESTAMP, 0)
}

func (s *CurrentTimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentTimestamp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CurrentTimestamp() (localctx ICurrentTimestampContext) {
	localctx = NewCurrentTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, MySqlParserRULE_currentTimestamp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserLOCALTIMESTAMP:
		{
			p.SetState(6781)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&131) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6787)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1013, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6782)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6784)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-1137)) & ^0x3f) == 0 && ((int64(1)<<(_la-1137))&10247) != 0 {
				{
					p.SetState(6783)
					p.DecimalLiteral()
				}

			}
			{
				p.SetState(6786)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserNOW:
		{
			p.SetState(6789)
			p.Match(MySqlParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6790)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-1137)) & ^0x3f) == 0 && ((int64(1)<<(_la-1137))&10247) != 0 {
			{
				p.SetState(6791)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(6794)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, MySqlParserRULE_expressionOrDefault)
	p.SetState(6799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1016, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6797)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6798)
			p.Match(MySqlParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *IfExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (s *IfExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIfExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, MySqlParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6801)
		p.Match(MySqlParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6802)
		p.Match(MySqlParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, MySqlParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6804)
		p.Match(MySqlParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6805)
		p.Match(MySqlParserNOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6806)
		p.Match(MySqlParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (s *OrReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrReplace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, MySqlParserRULE_orReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6808)
		p.Match(MySqlParserOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6809)
		p.Match(MySqlParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWaitNowaitClauseContext is an interface to support dynamic dispatch.
type IWaitNowaitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WAIT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	NOWAIT() antlr.TerminalNode

	// IsWaitNowaitClauseContext differentiates from other interfaces.
	IsWaitNowaitClauseContext()
}

type WaitNowaitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitNowaitClauseContext() *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_waitNowaitClause
	return p
}

func InitEmptyWaitNowaitClauseContext(p *WaitNowaitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_waitNowaitClause
}

func (*WaitNowaitClauseContext) IsWaitNowaitClauseContext() {}

func NewWaitNowaitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_waitNowaitClause

	return p
}

func (s *WaitNowaitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitNowaitClauseContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *WaitNowaitClauseContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WaitNowaitClauseContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOWAIT, 0)
}

func (s *WaitNowaitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitNowaitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaitNowaitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWaitNowaitClause(s)
	}
}

func (s *WaitNowaitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWaitNowaitClause(s)
	}
}

func (s *WaitNowaitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWaitNowaitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) WaitNowaitClause() (localctx IWaitNowaitClauseContext) {
	localctx = NewWaitNowaitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, MySqlParserRULE_waitNowaitClause)
	p.SetState(6814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserWAIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6811)
			p.Match(MySqlParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6812)
			p.DecimalLiteral()
		}

	case MySqlParserNOWAIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6813)
			p.Match(MySqlParserNOWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyAll(ctx *FunctionCallContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecificFunctionCallContext struct {
	FunctionCallContext
}

func NewSpecificFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecificFunctionCallContext {
	var p = new(SpecificFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecificFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionCallContext) SpecificFunction() ISpecificFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecificFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecificFunctionContext)
}

func (s *SpecificFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpecificFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type PasswordFunctionCallContext struct {
	FunctionCallContext
}

func NewPasswordFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordFunctionCallContext {
	var p = new(PasswordFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *PasswordFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionCallContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *PasswordFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type UdfFunctionCallContext struct {
	FunctionCallContext
}

func NewUdfFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UdfFunctionCallContext {
	var p = new(UdfFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *UdfFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfFunctionCallContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *UdfFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *UdfFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUdfFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type NonAggregateFunctionCallContext struct {
	FunctionCallContext
}

func NewNonAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonAggregateFunctionCallContext {
	var p = new(NonAggregateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *NonAggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateFunctionCallContext) NonAggregateWindowedFunction() INonAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonAggregateWindowedFunctionContext)
}

func (s *NonAggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNonAggregateFunctionCall(s)
	}
}

func (s *NonAggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNonAggregateFunctionCall(s)
	}
}

func (s *NonAggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNonAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggregateFunctionCallContext struct {
	FunctionCallContext
}

func NewAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateFunctionCallContext {
	var p = new(AggregateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionCallContext) AggregateWindowedFunction() IAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateWindowedFunctionContext)
}

func (s *AggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarFunctionCallContext struct {
	FunctionCallContext
}

func NewScalarFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarFunctionCallContext {
	var p = new(ScalarFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *ScalarFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionCallContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *ScalarFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *ScalarFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitScalarFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, MySqlParserRULE_functionCall)
	p.SetState(6834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1020, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSpecificFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6816)
			p.SpecificFunction()
		}

	case 2:
		localctx = NewAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6817)
			p.AggregateWindowedFunction()
		}

	case 3:
		localctx = NewNonAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6818)
			p.NonAggregateWindowedFunction()
		}

	case 4:
		localctx = NewScalarFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6819)
			p.ScalarFunctionName()
		}
		{
			p.SetState(6820)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6822)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1018, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6821)
				p.FunctionArgs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6824)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewUdfFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6826)
			p.FullId()
		}
		{
			p.SetState(6827)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6829)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1019, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6828)
				p.FunctionArgs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6831)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewPasswordFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6833)
			p.PasswordFunctionClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecificFunctionContext is an interface to support dynamic dispatch.
type ISpecificFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSpecificFunctionContext differentiates from other interfaces.
	IsSpecificFunctionContext()
}

type SpecificFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecificFunctionContext() *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_specificFunction
	return p
}

func InitEmptySpecificFunctionContext(p *SpecificFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_specificFunction
}

func (*SpecificFunctionContext) IsSpecificFunctionContext() {}

func NewSpecificFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_specificFunction

	return p
}

func (s *SpecificFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificFunctionContext) CopyAll(ctx *SpecificFunctionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SpecificFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionFunctionCallContext struct {
	SpecificFunctionContext
	positionString     IStringLiteralContext
	positionExpression IExpressionContext
	inString           IStringLiteralContext
	inExpression       IExpressionContext
}

func NewPositionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionFunctionCallContext {
	var p = new(PositionFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *PositionFunctionCallContext) GetPositionString() IStringLiteralContext {
	return s.positionString
}

func (s *PositionFunctionCallContext) GetPositionExpression() IExpressionContext {
	return s.positionExpression
}

func (s *PositionFunctionCallContext) GetInString() IStringLiteralContext { return s.inString }

func (s *PositionFunctionCallContext) GetInExpression() IExpressionContext { return s.inExpression }

func (s *PositionFunctionCallContext) SetPositionString(v IStringLiteralContext) {
	s.positionString = v
}

func (s *PositionFunctionCallContext) SetPositionExpression(v IExpressionContext) {
	s.positionExpression = v
}

func (s *PositionFunctionCallContext) SetInString(v IStringLiteralContext) { s.inString = v }

func (s *PositionFunctionCallContext) SetInExpression(v IExpressionContext) { s.inExpression = v }

func (s *PositionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionFunctionCallContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *PositionFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PositionFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PositionFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPositionFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type TrimFunctionCallContext struct {
	SpecificFunctionContext
	positioinForm    antlr.Token
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromString       IStringLiteralContext
	fromExpression   IExpressionContext
}

func NewTrimFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TrimFunctionCallContext {
	var p = new(TrimFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *TrimFunctionCallContext) GetPositioinForm() antlr.Token { return s.positioinForm }

func (s *TrimFunctionCallContext) SetPositioinForm(v antlr.Token) { s.positioinForm = v }

func (s *TrimFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *TrimFunctionCallContext) GetSourceExpression() IExpressionContext { return s.sourceExpression }

func (s *TrimFunctionCallContext) GetFromString() IStringLiteralContext { return s.fromString }

func (s *TrimFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *TrimFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *TrimFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *TrimFunctionCallContext) SetFromString(v IStringLiteralContext) { s.fromString = v }

func (s *TrimFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *TrimFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionCallContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *TrimFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *TrimFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) BOTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOTH, 0)
}

func (s *TrimFunctionCallContext) LEADING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEADING, 0)
}

func (s *TrimFunctionCallContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRAILING, 0)
}

func (s *TrimFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TrimFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TrimFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTrimFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonValueFunctionCallContext struct {
	SpecificFunctionContext
}

func NewJsonValueFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonValueFunctionCallContext {
	var p = new(JsonValueFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *JsonValueFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueFunctionCallContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALUE, 0)
}

func (s *JsonValueFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *JsonValueFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JsonValueFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *JsonValueFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNING, 0)
}

func (s *JsonValueFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *JsonValueFunctionCallContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonValueFunctionCallContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}

func (s *JsonValueFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonValueFunctionCall(s)
	}
}

func (s *JsonValueFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonValueFunctionCall(s)
	}
}

func (s *JsonValueFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonValueFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CaseFunctionCallContext struct {
	SpecificFunctionContext
	elseArg IFunctionArgContext
}

func NewCaseFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseFunctionCallContext {
	var p = new(CaseFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CaseFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }

func (s *CaseFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, 0)
}

func (s *CaseFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractFunctionCallContext struct {
	SpecificFunctionContext
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
}

func NewExtractFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractFunctionCallContext {
	var p = new(ExtractFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ExtractFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *ExtractFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *ExtractFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *ExtractFunctionCallContext) SetSourceExpression(v IExpressionContext) {
	s.sourceExpression = v
}

func (s *ExtractFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionCallContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACT, 0)
}

func (s *ExtractFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *ExtractFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ExtractFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ExtractFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtractFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExtractFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type DataTypeFunctionCallContext struct {
	SpecificFunctionContext
	separator antlr.Token
}

func NewDataTypeFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataTypeFunctionCallContext {
	var p = new(DataTypeFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *DataTypeFunctionCallContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataTypeFunctionCallContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataTypeFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeFunctionCallContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *DataTypeFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataTypeFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DataTypeFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *DataTypeFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *DataTypeFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *DataTypeFunctionCallContext) CAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCAST, 0)
}

func (s *DataTypeFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *DataTypeFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDataTypeFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ValuesFunctionCallContext struct {
	SpecificFunctionContext
}

func NewValuesFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesFunctionCallContext {
	var p = new(ValuesFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ValuesFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesFunctionCallContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *ValuesFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ValuesFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitValuesFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CaseExpressionFunctionCallContext struct {
	SpecificFunctionContext
	elseArg IFunctionArgContext
}

func NewCaseExpressionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExpressionFunctionCallContext {
	var p = new(CaseExpressionFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CaseExpressionFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }

func (s *CaseExpressionFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseExpressionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, 0)
}

func (s *CaseExpressionFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseExpressionFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseExpressionFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseExpressionFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseExpressionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseExpressionFunctionCall(s)
	}
}

func (s *CaseExpressionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseExpressionFunctionCall(s)
	}
}

func (s *CaseExpressionFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseExpressionFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentUserContext struct {
	SpecificFunctionContext
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CurrentUserExpression() ICurrentUserExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentUserExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentUserExpressionContext)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

func (s *CurrentUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCurrentUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFunctionCallContext struct {
	SpecificFunctionContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *SimpleFunctionCallContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *SimpleFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SimpleFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CharFunctionCallContext struct {
	SpecificFunctionContext
}

func NewCharFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionCallContext {
	var p = new(CharFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CharFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *CharFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CharFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *CharFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CharFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *CharFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type WeightFunctionCallContext struct {
	SpecificFunctionContext
	stringFormat antlr.Token
}

func NewWeightFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WeightFunctionCallContext {
	var p = new(WeightFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *WeightFunctionCallContext) GetStringFormat() antlr.Token { return s.stringFormat }

func (s *WeightFunctionCallContext) SetStringFormat(v antlr.Token) { s.stringFormat = v }

func (s *WeightFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightFunctionCallContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *WeightFunctionCallContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *WeightFunctionCallContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *WeightFunctionCallContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *WeightFunctionCallContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *WeightFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *WeightFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WeightFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *WeightFunctionCallContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WeightFunctionCallContext) LevelsInWeightString() ILevelsInWeightStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelsInWeightStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelsInWeightStringContext)
}

func (s *WeightFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *WeightFunctionCallContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *WeightFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWeightFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type GetFormatFunctionCallContext struct {
	SpecificFunctionContext
	datetimeFormat antlr.Token
}

func NewGetFormatFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GetFormatFunctionCallContext {
	var p = new(GetFormatFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *GetFormatFunctionCallContext) GetDatetimeFormat() antlr.Token { return s.datetimeFormat }

func (s *GetFormatFunctionCallContext) SetDatetimeFormat(v antlr.Token) { s.datetimeFormat = v }

func (s *GetFormatFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetFormatFunctionCallContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *GetFormatFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *GetFormatFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *GetFormatFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *GetFormatFunctionCallContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *GetFormatFunctionCallContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *GetFormatFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGetFormatFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubstrFunctionCallContext struct {
	SpecificFunctionContext
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromDecimal      IDecimalLiteralContext
	fromExpression   IExpressionContext
	forDecimal       IDecimalLiteralContext
	forExpression    IExpressionContext
}

func NewSubstrFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstrFunctionCallContext {
	var p = new(SubstrFunctionCallContext)

	InitEmptySpecificFunctionContext(&p.SpecificFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SubstrFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *SubstrFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *SubstrFunctionCallContext) GetFromDecimal() IDecimalLiteralContext { return s.fromDecimal }

func (s *SubstrFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *SubstrFunctionCallContext) GetForDecimal() IDecimalLiteralContext { return s.forDecimal }

func (s *SubstrFunctionCallContext) GetForExpression() IExpressionContext { return s.forExpression }

func (s *SubstrFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *SubstrFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *SubstrFunctionCallContext) SetFromDecimal(v IDecimalLiteralContext) { s.fromDecimal = v }

func (s *SubstrFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *SubstrFunctionCallContext) SetForDecimal(v IDecimalLiteralContext) { s.forDecimal = v }

func (s *SubstrFunctionCallContext) SetForExpression(v IExpressionContext) { s.forExpression = v }

func (s *SubstrFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstrFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *SubstrFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *SubstrFunctionCallContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *SubstrFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SubstrFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubstrFunctionCallContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SubstrFunctionCallContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *SubstrFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubstrFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SpecificFunction() (localctx ISpecificFunctionContext) {
	localctx = NewSpecificFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, MySqlParserRULE_specificFunction)
	var _la int

	p.SetState(7015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1044, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6836)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSCHEMA || ((int64((_la-312)) & ^0x3f) == 0 && ((int64(1)<<(_la-312))&262159) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6839)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1021, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6837)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6838)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewCurrentUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6841)
			p.CurrentUserExpression()
		}

	case 3:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6842)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6843)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6844)
			p.expression(0)
		}
		{
			p.SetState(6845)

			var _m = p.Match(MySqlParserCOMMA)

			localctx.(*DataTypeFunctionCallContext).separator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6846)
			p.ConvertedDataType()
		}
		{
			p.SetState(6847)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6849)
			p.Match(MySqlParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6850)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6851)
			p.expression(0)
		}
		{
			p.SetState(6852)
			p.Match(MySqlParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6853)
			p.CharsetName()
		}
		{
			p.SetState(6854)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6856)
			p.Match(MySqlParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6857)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6858)
			p.expression(0)
		}
		{
			p.SetState(6859)
			p.Match(MySqlParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6860)
			p.ConvertedDataType()
		}
		{
			p.SetState(6861)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewValuesFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6863)
			p.Match(MySqlParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6864)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6865)
			p.FullColumnName()
		}
		{
			p.SetState(6866)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewCaseExpressionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6868)
			p.Match(MySqlParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6869)
			p.expression(0)
		}
		p.SetState(6871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(6870)
				p.CaseFuncAlternative()
			}

			p.SetState(6873)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserELSE {
			{
				p.SetState(6875)
				p.Match(MySqlParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6876)

				var _x = p.FunctionArg()

				localctx.(*CaseExpressionFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6879)
			p.Match(MySqlParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewCaseFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6881)
			p.Match(MySqlParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(6882)
				p.CaseFuncAlternative()
			}

			p.SetState(6885)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserELSE {
			{
				p.SetState(6887)
				p.Match(MySqlParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6888)

				var _x = p.FunctionArg()

				localctx.(*CaseFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6891)
			p.Match(MySqlParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewCharFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6893)
			p.Match(MySqlParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6894)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6895)
			p.FunctionArgs()
		}
		p.SetState(6898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(6896)
				p.Match(MySqlParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6897)
				p.CharsetName()
			}

		}
		{
			p.SetState(6900)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewPositionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6902)
			p.Match(MySqlParserPOSITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6903)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1027, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6904)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).positionString = _x
			}

		case 2:
			{
				p.SetState(6905)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).positionExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6908)
			p.Match(MySqlParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1028, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6909)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).inString = _x
			}

		case 2:
			{
				p.SetState(6910)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).inExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6913)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewSubstrFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6915)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSUBSTR || _la == MySqlParserSUBSTRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6916)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1029, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6917)

				var _x = p.StringLiteral()

				localctx.(*SubstrFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(6918)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6921)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1030, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6922)

				var _x = p.DecimalLiteral()

				localctx.(*SubstrFunctionCallContext).fromDecimal = _x
			}

		case 2:
			{
				p.SetState(6923)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(6931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(6926)
				p.Match(MySqlParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6929)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1031, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(6927)

					var _x = p.DecimalLiteral()

					localctx.(*SubstrFunctionCallContext).forDecimal = _x
				}

			case 2:
				{
					p.SetState(6928)

					var _x = p.expression(0)

					localctx.(*SubstrFunctionCallContext).forExpression = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		{
			p.SetState(6933)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6935)
			p.Match(MySqlParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6936)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6937)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TrimFunctionCallContext).positioinForm = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBOTH || _la == MySqlParserLEADING || _la == MySqlParserTRAILING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TrimFunctionCallContext).positioinForm = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6940)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1033, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6938)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1033, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6939)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6942)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1034, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6943)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(6944)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6947)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6949)
			p.Match(MySqlParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6950)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1035, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6951)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(6952)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6955)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1036, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6956)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(6957)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6960)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewWeightFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6962)
			p.Match(MySqlParserWEIGHT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6963)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1037, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6964)
				p.StringLiteral()
			}

		case 2:
			{
				p.SetState(6965)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(6974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(6968)
				p.Match(MySqlParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6969)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*WeightFunctionCallContext).stringFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCHAR || _la == MySqlParserBINARY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*WeightFunctionCallContext).stringFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(6970)
				p.Match(MySqlParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6971)
				p.DecimalLiteral()
			}
			{
				p.SetState(6972)
				p.Match(MySqlParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLEVEL {
			{
				p.SetState(6976)
				p.LevelsInWeightString()
			}

		}
		{
			p.SetState(6979)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewExtractFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6981)
			p.Match(MySqlParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6982)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6983)
			p.IntervalType()
		}
		{
			p.SetState(6984)
			p.Match(MySqlParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1040, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6985)

				var _x = p.StringLiteral()

				localctx.(*ExtractFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(6986)

				var _x = p.expression(0)

				localctx.(*ExtractFunctionCallContext).sourceExpression = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6989)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewGetFormatFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6991)
			p.Match(MySqlParserGET_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6992)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6993)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GetFormatFunctionCallContext).datetimeFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&11) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GetFormatFunctionCallContext).datetimeFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6994)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6995)
			p.StringLiteral()
		}
		{
			p.SetState(6996)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewJsonValueFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6998)
			p.Match(MySqlParserJSON_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6999)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7000)
			p.expression(0)
		}
		{
			p.SetState(7001)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7002)
			p.expression(0)
		}
		p.SetState(7005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserRETURNING {
			{
				p.SetState(7003)
				p.Match(MySqlParserRETURNING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7004)
				p.ConvertedDataType()
			}

		}
		p.SetState(7008)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1042, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7007)
				p.JsonOnEmpty()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT || _la == MySqlParserNULL_LITERAL || _la == MySqlParserERROR {
			{
				p.SetState(7010)
				p.JsonOnError()
			}

		}
		{
			p.SetState(7013)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseFuncAlternativeContext is an interface to support dynamic dispatch.
type ICaseFuncAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IFunctionArgContext

	// GetConsequent returns the consequent rule contexts.
	GetConsequent() IFunctionArgContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IFunctionArgContext)

	// SetConsequent sets the consequent rule contexts.
	SetConsequent(IFunctionArgContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllFunctionArg() []IFunctionArgContext
	FunctionArg(i int) IFunctionArgContext

	// IsCaseFuncAlternativeContext differentiates from other interfaces.
	IsCaseFuncAlternativeContext()
}

type CaseFuncAlternativeContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	condition  IFunctionArgContext
	consequent IFunctionArgContext
}

func NewEmptyCaseFuncAlternativeContext() *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative
	return p
}

func InitEmptyCaseFuncAlternativeContext(p *CaseFuncAlternativeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative
}

func (*CaseFuncAlternativeContext) IsCaseFuncAlternativeContext() {}

func NewCaseFuncAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative

	return p
}

func (s *CaseFuncAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseFuncAlternativeContext) GetCondition() IFunctionArgContext { return s.condition }

func (s *CaseFuncAlternativeContext) GetConsequent() IFunctionArgContext { return s.consequent }

func (s *CaseFuncAlternativeContext) SetCondition(v IFunctionArgContext) { s.condition = v }

func (s *CaseFuncAlternativeContext) SetConsequent(v IFunctionArgContext) { s.consequent = v }

func (s *CaseFuncAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHEN, 0)
}

func (s *CaseFuncAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *CaseFuncAlternativeContext) AllFunctionArg() []IFunctionArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgContext); ok {
			tst[i] = t.(IFunctionArgContext)
			i++
		}
	}

	return tst
}

func (s *CaseFuncAlternativeContext) FunctionArg(i int) IFunctionArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFuncAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFuncAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseFuncAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseFuncAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CaseFuncAlternative() (localctx ICaseFuncAlternativeContext) {
	localctx = NewCaseFuncAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, MySqlParserRULE_caseFuncAlternative)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7017)
		p.Match(MySqlParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7018)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).condition = _x
	}
	{
		p.SetState(7019)
		p.Match(MySqlParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7020)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).consequent = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelsInWeightStringContext is an interface to support dynamic dispatch.
type ILevelsInWeightStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLevelsInWeightStringContext differentiates from other interfaces.
	IsLevelsInWeightStringContext()
}

type LevelsInWeightStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelsInWeightStringContext() *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelsInWeightString
	return p
}

func InitEmptyLevelsInWeightStringContext(p *LevelsInWeightStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelsInWeightString
}

func (*LevelsInWeightStringContext) IsLevelsInWeightStringContext() {}

func NewLevelsInWeightStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelsInWeightString

	return p
}

func (s *LevelsInWeightStringContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelsInWeightStringContext) CopyAll(ctx *LevelsInWeightStringContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LevelsInWeightStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelsInWeightStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LevelWeightRangeContext struct {
	LevelsInWeightStringContext
	firstLevel IDecimalLiteralContext
	lastLevel  IDecimalLiteralContext
}

func NewLevelWeightRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightRangeContext {
	var p = new(LevelWeightRangeContext)

	InitEmptyLevelsInWeightStringContext(&p.LevelsInWeightStringContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightRangeContext) GetFirstLevel() IDecimalLiteralContext { return s.firstLevel }

func (s *LevelWeightRangeContext) GetLastLevel() IDecimalLiteralContext { return s.lastLevel }

func (s *LevelWeightRangeContext) SetFirstLevel(v IDecimalLiteralContext) { s.firstLevel = v }

func (s *LevelWeightRangeContext) SetLastLevel(v IDecimalLiteralContext) { s.lastLevel = v }

func (s *LevelWeightRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightRangeContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightRangeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *LevelWeightRangeContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightRangeContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelWeightRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelWeightRange(s)

	default:
		return t.VisitChildren(s)
	}
}

type LevelWeightListContext struct {
	LevelsInWeightStringContext
}

func NewLevelWeightListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightListContext {
	var p = new(LevelWeightListContext)

	InitEmptyLevelsInWeightStringContext(&p.LevelsInWeightStringContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightListContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightListContext) AllLevelInWeightListElement() []ILevelInWeightListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			len++
		}
	}

	tst := make([]ILevelInWeightListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILevelInWeightListElementContext); ok {
			tst[i] = t.(ILevelInWeightListElementContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightListContext) LevelInWeightListElement(i int) ILevelInWeightListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelInWeightListElementContext)
}

func (s *LevelWeightListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LevelWeightListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LevelWeightListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelWeightList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LevelsInWeightString() (localctx ILevelsInWeightStringContext) {
	localctx = NewLevelsInWeightStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, MySqlParserRULE_levelsInWeightString)
	var _la int

	p.SetState(7036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1046, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLevelWeightListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7022)
			p.Match(MySqlParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7023)
			p.LevelInWeightListElement()
		}
		p.SetState(7028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(7024)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7025)
				p.LevelInWeightListElement()
			}

			p.SetState(7030)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewLevelWeightRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7031)
			p.Match(MySqlParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7032)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).firstLevel = _x
		}
		{
			p.SetState(7033)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7034)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).lastLevel = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelInWeightListElementContext is an interface to support dynamic dispatch.
type ILevelInWeightListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrderType returns the orderType token.
	GetOrderType() antlr.Token

	// SetOrderType sets the orderType token.
	SetOrderType(antlr.Token)

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	REVERSE() antlr.TerminalNode

	// IsLevelInWeightListElementContext differentiates from other interfaces.
	IsLevelInWeightListElementContext()
}

type LevelInWeightListElementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	orderType antlr.Token
}

func NewEmptyLevelInWeightListElementContext() *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement
	return p
}

func InitEmptyLevelInWeightListElementContext(p *LevelInWeightListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement
}

func (*LevelInWeightListElementContext) IsLevelInWeightListElementContext() {}

func NewLevelInWeightListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement

	return p
}

func (s *LevelInWeightListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelInWeightListElementContext) GetOrderType() antlr.Token { return s.orderType }

func (s *LevelInWeightListElementContext) SetOrderType(v antlr.Token) { s.orderType = v }

func (s *LevelInWeightListElementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelInWeightListElementContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *LevelInWeightListElementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *LevelInWeightListElementContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *LevelInWeightListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelInWeightListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelInWeightListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelInWeightListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LevelInWeightListElement() (localctx ILevelInWeightListElementContext) {
	localctx = NewLevelInWeightListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, MySqlParserRULE_levelInWeightListElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7038)
		p.DecimalLiteral()
	}
	p.SetState(7040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE {
		{
			p.SetState(7039)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LevelInWeightListElementContext).orderType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LevelInWeightListElementContext).orderType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type IAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAggregator returns the aggregator token.
	GetAggregator() antlr.Token

	// GetStarArg returns the starArg token.
	GetStarArg() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// SetAggregator sets the aggregator token.
	SetAggregator(antlr.Token)

	// SetStarArg sets the starArg token.
	SetStarArg(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	AVG() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	OverClause() IOverClauseContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	STAR() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	SEPARATOR() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAggregateWindowedFunctionContext differentiates from other interfaces.
	IsAggregateWindowedFunctionContext()
}

type AggregateWindowedFunctionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	aggregator antlr.Token
	starArg    antlr.Token
	separator  antlr.Token
}

func NewEmptyAggregateWindowedFunctionContext() *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
	return p
}

func InitEmptyAggregateWindowedFunctionContext(p *AggregateWindowedFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
}

func (*AggregateWindowedFunctionContext) IsAggregateWindowedFunctionContext() {}

func NewAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction

	return p
}

func (s *AggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateWindowedFunctionContext) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunctionContext) GetStarArg() antlr.Token { return s.starArg }

func (s *AggregateWindowedFunctionContext) GetSeparator() antlr.Token { return s.separator }

func (s *AggregateWindowedFunctionContext) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunctionContext) SetStarArg(v antlr.Token) { s.starArg = v }

func (s *AggregateWindowedFunctionContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *AggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *AggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG, 0)
}

func (s *AggregateWindowedFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX, 0)
}

func (s *AggregateWindowedFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN, 0)
}

func (s *AggregateWindowedFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUM, 0)
}

func (s *AggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *AggregateWindowedFunctionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AggregateWindowedFunctionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *AggregateWindowedFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *AggregateWindowedFunctionContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR, 0)
}

func (s *AggregateWindowedFunctionContext) STD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTD, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_POP, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_POP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIANCE, 0)
}

func (s *AggregateWindowedFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_CONCAT, 0)
}

func (s *AggregateWindowedFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *AggregateWindowedFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AggregateWindowedFunctionContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregateWindowedFunctionContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *AggregateWindowedFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEPARATOR, 0)
}

func (s *AggregateWindowedFunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction(s)
	}
}

func (s *AggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction(s)
	}
}

func (s *AggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AggregateWindowedFunction() (localctx IAggregateWindowedFunctionContext) {
	localctx = NewAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, MySqlParserRULE_aggregateWindowedFunction)
	var _la int

	p.SetState(7101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAVG, MySqlParserMAX, MySqlParserMIN, MySqlParserSUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7042)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-285)) & ^0x3f) == 0 && ((int64(1)<<(_la-285))&8400897) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7043)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7045)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1048, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7044)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7047)
			p.FunctionArg()
		}
		{
			p.SetState(7048)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7050)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1049, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7049)
				p.OverClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserCOUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7052)
			p.Match(MySqlParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7053)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1051, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7054)

				var _m = p.Match(MySqlParserSTAR)

				localctx.(*AggregateWindowedFunctionContext).starArg = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			p.SetState(7056)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1050, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7055)

					var _m = p.Match(MySqlParserALL)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(7058)
				p.FunctionArg()
			}

		case 3:
			{
				p.SetState(7059)

				var _m = p.Match(MySqlParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7060)
				p.FunctionArgs()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7063)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7065)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1052, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7064)
				p.OverClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7067)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-286)) & ^0x3f) == 0 && ((int64(1)<<(_la-286))&62652423) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7068)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7070)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1053, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7069)

				var _m = p.Match(MySqlParserALL)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7072)
			p.FunctionArg()
		}
		{
			p.SetState(7073)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7075)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1054, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7074)
				p.OverClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySqlParserGROUP_CONCAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7077)
			p.Match(MySqlParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7078)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7080)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1055, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7079)

				var _m = p.Match(MySqlParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7082)
			p.FunctionArgs()
		}
		p.SetState(7093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserORDER {
			{
				p.SetState(7083)
				p.Match(MySqlParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7084)
				p.Match(MySqlParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7085)
				p.OrderByExpression()
			}
			p.SetState(7090)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(7086)
					p.Match(MySqlParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7087)
					p.OrderByExpression()
				}

				p.SetState(7092)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(7097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSEPARATOR {
			{
				p.SetState(7095)
				p.Match(MySqlParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7096)

				var _m = p.Match(MySqlParserSTRING_LITERAL)

				localctx.(*AggregateWindowedFunctionContext).separator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7099)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type INonAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	RR_BRACKET() antlr.TerminalNode
	OverClause() IOverClauseContext
	LAG() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	RANK() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode

	// IsNonAggregateWindowedFunctionContext differentiates from other interfaces.
	IsNonAggregateWindowedFunctionContext()
}

type NonAggregateWindowedFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonAggregateWindowedFunctionContext() *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction
	return p
}

func InitEmptyNonAggregateWindowedFunctionContext(p *NonAggregateWindowedFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction
}

func (*NonAggregateWindowedFunctionContext) IsNonAggregateWindowedFunctionContext() {}

func NewNonAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction

	return p
}

func (s *NonAggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *NonAggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NonAggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *NonAggregateWindowedFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAG, 0)
}

func (s *NonAggregateWindowedFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAD, 0)
}

func (s *NonAggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NonAggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NonAggregateWindowedFunctionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *NonAggregateWindowedFunctionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *NonAggregateWindowedFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCUME_DIST, 0)
}

func (s *NonAggregateWindowedFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDENSE_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERCENT_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_NUMBER, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTH_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTILE, 0)
}

func (s *NonAggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonAggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNonAggregateWindowedFunction(s)
	}
}

func (s *NonAggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNonAggregateWindowedFunction(s)
	}
}

func (s *NonAggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNonAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) NonAggregateWindowedFunction() (localctx INonAggregateWindowedFunctionContext) {
	localctx = NewNonAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, MySqlParserRULE_nonAggregateWindowedFunction)
	var _la int

	p.SetState(7141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLAG, MySqlParserLEAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7103)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLAG || _la == MySqlParserLEAD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7104)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7105)
			p.expression(0)
		}
		p.SetState(7108)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1060, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7106)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7107)
				p.DecimalLiteral()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOMMA {
			{
				p.SetState(7110)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7111)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(7114)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7115)
			p.OverClause()
		}

	case MySqlParserFIRST_VALUE, MySqlParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7117)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST_VALUE || _la == MySqlParserLAST_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7118)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7119)
			p.expression(0)
		}
		{
			p.SetState(7120)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7121)
			p.OverClause()
		}

	case MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7123)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-290)) & ^0x3f) == 0 && ((int64(1)<<(_la-290))&14339) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7124)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7125)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7126)
			p.OverClause()
		}

	case MySqlParserNTH_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7127)
			p.Match(MySqlParserNTH_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7128)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7129)
			p.expression(0)
		}
		{
			p.SetState(7130)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7131)
			p.DecimalLiteral()
		}
		{
			p.SetState(7132)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7133)
			p.OverClause()
		}

	case MySqlParserNTILE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7135)
			p.Match(MySqlParserNTILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7136)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7137)
			p.DecimalLiteral()
		}
		{
			p.SetState(7138)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7139)
			p.OverClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverClauseContext is an interface to support dynamic dispatch.
type IOverClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	RR_BRACKET() antlr.TerminalNode
	WindowName() IWindowNameContext

	// IsOverClauseContext differentiates from other interfaces.
	IsOverClauseContext()
}

type OverClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverClauseContext() *OverClauseContext {
	var p = new(OverClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_overClause
	return p
}

func InitEmptyOverClauseContext(p *OverClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_overClause
}

func (*OverClauseContext) IsOverClauseContext() {}

func NewOverClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverClauseContext {
	var p = new(OverClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_overClause

	return p
}

func (s *OverClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OverClauseContext) OVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOVER, 0)
}

func (s *OverClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *OverClauseContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *OverClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *OverClauseContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *OverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOverClause(s)
	}
}

func (s *OverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOverClause(s)
	}
}

func (s *OverClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOverClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OverClause() (localctx IOverClauseContext) {
	localctx = NewOverClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, MySqlParserRULE_overClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7143)
		p.Match(MySqlParserOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLR_BRACKET:
		{
			p.SetState(7144)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7145)
			p.WindowSpec()
		}
		{
			p.SetState(7146)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserARRAY, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPEAT, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNING, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserAUTHENTICATION_POLICY_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID:
		{
			p.SetState(7148)
			p.WindowName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	PartitionClause() IPartitionClauseContext
	OrderByClause() IOrderByClauseContext
	FrameClause() IFrameClauseContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *WindowSpecContext) FrameClause() IFrameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameClauseContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (s *WindowSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWindowSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, MySqlParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7152)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1064, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7151)
			p.WindowName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(7155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(7154)
			p.PartitionClause()
		}

	}
	p.SetState(7158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserORDER {
		{
			p.SetState(7157)
			p.OrderByClause()
		}

	}
	p.SetState(7161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserRANGE || _la == MySqlParserROWS {
		{
			p.SetState(7160)
			p.FrameClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowNameContext is an interface to support dynamic dispatch.
type IWindowNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsWindowNameContext differentiates from other interfaces.
	IsWindowNameContext()
}

type WindowNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowNameContext() *WindowNameContext {
	var p = new(WindowNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowName
	return p
}

func InitEmptyWindowNameContext(p *WindowNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_windowName
}

func (*WindowNameContext) IsWindowNameContext() {}

func NewWindowNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowNameContext {
	var p = new(WindowNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowName

	return p
}

func (s *WindowNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WindowNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowName(s)
	}
}

func (s *WindowNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowName(s)
	}
}

func (s *WindowNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWindowName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) WindowName() (localctx IWindowNameContext) {
	localctx = NewWindowNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, MySqlParserRULE_windowName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7163)
		p.Uid()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameClauseContext is an interface to support dynamic dispatch.
type IFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	FrameExtent() IFrameExtentContext

	// IsFrameClauseContext differentiates from other interfaces.
	IsFrameClauseContext()
}

type FrameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameClauseContext() *FrameClauseContext {
	var p = new(FrameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameClause
	return p
}

func InitEmptyFrameClauseContext(p *FrameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameClause
}

func (*FrameClauseContext) IsFrameClauseContext() {}

func NewFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameClauseContext {
	var p = new(FrameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameClause

	return p
}

func (s *FrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameClauseContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *FrameClauseContext) FrameExtent() IFrameExtentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameExtentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameExtentContext)
}

func (s *FrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameClause(s)
	}
}

func (s *FrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameClause(s)
	}
}

func (s *FrameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FrameClause() (localctx IFrameClauseContext) {
	localctx = NewFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, MySqlParserRULE_frameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7165)
		p.FrameUnits()
	}
	{
		p.SetState(7166)
		p.FrameExtent()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameUnits
	return p
}

func InitEmptyFrameUnitsContext(p *FrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameUnits
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameUnits(s)
	}
}

func (s *FrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameUnits(s)
	}
}

func (s *FrameUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FrameUnits() (localctx IFrameUnitsContext) {
	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, MySqlParserRULE_frameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7168)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserRANGE || _la == MySqlParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameExtentContext is an interface to support dynamic dispatch.
type IFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameRange() IFrameRangeContext
	FrameBetween() IFrameBetweenContext

	// IsFrameExtentContext differentiates from other interfaces.
	IsFrameExtentContext()
}

type FrameExtentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameExtentContext() *FrameExtentContext {
	var p = new(FrameExtentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameExtent
	return p
}

func InitEmptyFrameExtentContext(p *FrameExtentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameExtent
}

func (*FrameExtentContext) IsFrameExtentContext() {}

func NewFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameExtentContext {
	var p = new(FrameExtentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameExtent

	return p
}

func (s *FrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameExtentContext) FrameRange() IFrameRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameExtentContext) FrameBetween() IFrameBetweenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBetweenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBetweenContext)
}

func (s *FrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameExtent(s)
	}
}

func (s *FrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameExtent(s)
	}
}

func (s *FrameExtentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameExtent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FrameExtent() (localctx IFrameExtentContext) {
	localctx = NewFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, MySqlParserRULE_frameExtent)
	p.SetState(7172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1068, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7170)
			p.FrameRange()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7171)
			p.FrameBetween()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBetweenContext is an interface to support dynamic dispatch.
type IFrameBetweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AllFrameRange() []IFrameRangeContext
	FrameRange(i int) IFrameRangeContext
	AND() antlr.TerminalNode

	// IsFrameBetweenContext differentiates from other interfaces.
	IsFrameBetweenContext()
}

type FrameBetweenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBetweenContext() *FrameBetweenContext {
	var p = new(FrameBetweenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameBetween
	return p
}

func InitEmptyFrameBetweenContext(p *FrameBetweenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameBetween
}

func (*FrameBetweenContext) IsFrameBetweenContext() {}

func NewFrameBetweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBetweenContext {
	var p = new(FrameBetweenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameBetween

	return p
}

func (s *FrameBetweenContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBETWEEN, 0)
}

func (s *FrameBetweenContext) AllFrameRange() []IFrameRangeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameRangeContext); ok {
			len++
		}
	}

	tst := make([]IFrameRangeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameRangeContext); ok {
			tst[i] = t.(IFrameRangeContext)
			i++
		}
	}

	return tst
}

func (s *FrameBetweenContext) FrameRange(i int) IFrameRangeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *FrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBetweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameBetween(s)
	}
}

func (s *FrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameBetween(s)
	}
}

func (s *FrameBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FrameBetween() (localctx IFrameBetweenContext) {
	localctx = NewFrameBetweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, MySqlParserRULE_frameBetween)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7174)
		p.Match(MySqlParserBETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7175)
		p.FrameRange()
	}
	{
		p.SetState(7176)
		p.Match(MySqlParserAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7177)
		p.FrameRange()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameRangeContext is an interface to support dynamic dispatch.
type IFrameRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameRangeContext differentiates from other interfaces.
	IsFrameRangeContext()
}

type FrameRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameRangeContext() *FrameRangeContext {
	var p = new(FrameRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameRange
	return p
}

func InitEmptyFrameRangeContext(p *FrameRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_frameRange
}

func (*FrameRangeContext) IsFrameRangeContext() {}

func NewFrameRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameRangeContext {
	var p = new(FrameRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameRange

	return p
}

func (s *FrameRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameRangeContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *FrameRangeContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *FrameRangeContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *FrameRangeContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDING, 0)
}

func (s *FrameRangeContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWING, 0)
}

func (s *FrameRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameRange(s)
	}
}

func (s *FrameRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameRange(s)
	}
}

func (s *FrameRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFrameRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FrameRange() (localctx IFrameRangeContext) {
	localctx = NewFrameRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, MySqlParserRULE_frameRange)
	var _la int

	p.SetState(7186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1069, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7179)
			p.Match(MySqlParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7180)
			p.Match(MySqlParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7181)
			p.Match(MySqlParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7182)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWING || _la == MySqlParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7183)
			p.expression(0)
		}
		{
			p.SetState(7184)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWING || _la == MySqlParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (s *PartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, MySqlParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7188)
		p.Match(MySqlParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7189)
		p.Match(MySqlParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7190)
		p.expression(0)
	}
	p.SetState(7195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(7191)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7192)
			p.expression(0)
		}

		p.SetState(7197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarFunctionNameContext is an interface to support dynamic dispatch.
type IScalarFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionNameBase() IFunctionNameBaseContext
	ASCII() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATE_SUB() antlr.TerminalNode
	IF() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	MID() antlr.TerminalNode
	NOW() antlr.TerminalNode
	REPEAT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYSDATE() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	UTC_DATE() antlr.TerminalNode
	UTC_TIME() antlr.TerminalNode
	UTC_TIMESTAMP() antlr.TerminalNode

	// IsScalarFunctionNameContext differentiates from other interfaces.
	IsScalarFunctionNameContext()
}

type ScalarFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarFunctionNameContext() *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scalarFunctionName
	return p
}

func InitEmptyScalarFunctionNameContext(p *ScalarFunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_scalarFunctionName
}

func (*ScalarFunctionNameContext) IsScalarFunctionNameContext() {}

func NewScalarFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_scalarFunctionName

	return p
}

func (s *ScalarFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarFunctionNameContext) FunctionNameBase() IFunctionNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *ScalarFunctionNameContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *ScalarFunctionNameContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURDATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURTIME, 0)
}

func (s *ScalarFunctionNameContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_ADD, 0)
}

func (s *ScalarFunctionNameContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_SUB, 0)
}

func (s *ScalarFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *ScalarFunctionNameContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *ScalarFunctionNameContext) NOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOW, 0)
}

func (s *ScalarFunctionNameContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEAT, 0)
}

func (s *ScalarFunctionNameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *ScalarFunctionNameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *ScalarFunctionNameContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *ScalarFunctionNameContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSDATE, 0)
}

func (s *ScalarFunctionNameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *ScalarFunctionNameContext) UTC_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_DATE, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIME, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitScalarFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ScalarFunctionName() (localctx IScalarFunctionNameContext) {
	localctx = NewScalarFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, MySqlParserRULE_scalarFunctionName)
	p.SetState(7222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDATABASE, MySqlParserLEFT, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserYEAR, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserPOSITION, MySqlParserINVISIBLE, MySqlParserVISIBLE, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7198)
			p.FunctionNameBase()
		}

	case MySqlParserASCII:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7199)
			p.Match(MySqlParserASCII)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCURDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7200)
			p.Match(MySqlParserCURDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7201)
			p.Match(MySqlParserCURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7202)
			p.Match(MySqlParserCURRENT_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7203)
			p.Match(MySqlParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserCURTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7204)
			p.Match(MySqlParserCURTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDATE_ADD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7205)
			p.Match(MySqlParserDATE_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserDATE_SUB:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7206)
			p.Match(MySqlParserDATE_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserIF:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7207)
			p.Match(MySqlParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7208)
			p.Match(MySqlParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserLOCALTIME:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7209)
			p.Match(MySqlParserLOCALTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7210)
			p.Match(MySqlParserLOCALTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserMID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7211)
			p.Match(MySqlParserMID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserNOW:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7212)
			p.Match(MySqlParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPEAT:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7213)
			p.Match(MySqlParserREPEAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserREPLACE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7214)
			p.Match(MySqlParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSUBSTR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7215)
			p.Match(MySqlParserSUBSTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSUBSTRING:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7216)
			p.Match(MySqlParserSUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserSYSDATE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7217)
			p.Match(MySqlParserSYSDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserTRIM:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7218)
			p.Match(MySqlParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserUTC_DATE:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(7219)
			p.Match(MySqlParserUTC_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserUTC_TIME:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(7220)
			p.Match(MySqlParserUTC_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserUTC_TIMESTAMP:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(7221)
			p.Match(MySqlParserUTC_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordFunctionClauseContext is an interface to support dynamic dispatch.
type IPasswordFunctionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName token.
	GetFunctionName() antlr.Token

	// SetFunctionName sets the functionName token.
	SetFunctionName(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode

	// IsPasswordFunctionClauseContext differentiates from other interfaces.
	IsPasswordFunctionClauseContext()
}

type PasswordFunctionClauseContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName antlr.Token
}

func NewEmptyPasswordFunctionClauseContext() *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause
	return p
}

func InitEmptyPasswordFunctionClauseContext(p *PasswordFunctionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause
}

func (*PasswordFunctionClauseContext) IsPasswordFunctionClauseContext() {}

func NewPasswordFunctionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause

	return p
}

func (s *PasswordFunctionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordFunctionClauseContext) GetFunctionName() antlr.Token { return s.functionName }

func (s *PasswordFunctionClauseContext) SetFunctionName(v antlr.Token) { s.functionName = v }

func (s *PasswordFunctionClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *PasswordFunctionClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordFunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordFunctionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PasswordFunctionClause() (localctx IPasswordFunctionClauseContext) {
	localctx = NewPasswordFunctionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, MySqlParserRULE_passwordFunctionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7224)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PasswordFunctionClauseContext).functionName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserOLD_PASSWORD || _la == MySqlParserPASSWORD) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PasswordFunctionClauseContext).functionName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7225)
		p.Match(MySqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7226)
		p.FunctionArg()
	}
	{
		p.SetState(7227)
		p.Match(MySqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArgs
	return p
}

func InitEmptyFunctionArgsContext(p *FunctionArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArgs
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgsContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgsContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FunctionArgsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionArgs() (localctx IFunctionArgsContext) {
	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, MySqlParserRULE_functionArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1072, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7229)
			p.Constant()
		}

	case 2:
		{
			p.SetState(7230)
			p.FullColumnName()
		}

	case 3:
		{
			p.SetState(7231)
			p.FunctionCall()
		}

	case 4:
		{
			p.SetState(7232)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(7244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(7235)
			p.Match(MySqlParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1073, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7236)
				p.Constant()
			}

		case 2:
			{
				p.SetState(7237)
				p.FullColumnName()
			}

		case 3:
			{
				p.SetState(7238)
				p.FunctionCall()
			}

		case 4:
			{
				p.SetState(7239)
				p.expression(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(7246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgContext is an interface to support dynamic dispatch.
type IFunctionArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	FullColumnName() IFullColumnNameContext
	FunctionCall() IFunctionCallContext
	Expression() IExpressionContext

	// IsFunctionArgContext differentiates from other interfaces.
	IsFunctionArgContext()
}

type FunctionArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgContext() *FunctionArgContext {
	var p = new(FunctionArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArg
	return p
}

func InitEmptyFunctionArgContext(p *FunctionArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArg
}

func (*FunctionArgContext) IsFunctionArgContext() {}

func NewFunctionArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgContext {
	var p = new(FunctionArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArg

	return p
}

func (s *FunctionArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArg(s)
	}
}

func (s *FunctionArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArg(s)
	}
}

func (s *FunctionArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionArg() (localctx IFunctionArgContext) {
	localctx = NewFunctionArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, MySqlParserRULE_functionArg)
	p.SetState(7251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1075, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7247)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7248)
			p.FullColumnName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7249)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7250)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsExpression(s)
	}
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsExpression(s)
	}
}

func (s *IsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExpressionContext struct {
	ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPredicateExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MySqlParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 690
	p.EnterRecursionRule(localctx, 690, MySqlParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1077, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7254)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNOT || _la == MySqlParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7255)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7256)
			p.predicate(0)
		}
		{
			p.SetState(7257)
			p.Match(MySqlParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(7258)
				p.Match(MySqlParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7261)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE || _la == MySqlParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7263)
			p.predicate(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1078, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expression)
			p.SetState(7266)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			{
				p.SetState(7267)
				p.LogicalOperator()
			}
			{
				p.SetState(7268)
				p.expression(4)
			}

		}
		p.SetState(7274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1078, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyAll(ctx *PredicateContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SoundsLikePredicateContext struct {
	PredicateContext
}

func NewSoundsLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoundsLikePredicateContext {
	var p = new(SoundsLikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *SoundsLikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoundsLikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *SoundsLikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SoundsLikePredicateContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *SoundsLikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *SoundsLikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSoundsLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExpressionAtomPredicateContext struct {
	PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionAtomPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryComparisonPredicateContext struct {
	PredicateContext
	quantifier antlr.Token
}

func NewSubqueryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryComparisonPredicateContext {
	var p = new(SubqueryComparisonPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *SubqueryComparisonPredicateContext) GetQuantifier() antlr.Token { return s.quantifier }

func (s *SubqueryComparisonPredicateContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *SubqueryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryComparisonPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SubqueryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *SubqueryComparisonPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryComparisonPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SubqueryComparisonPredicateContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *SubqueryComparisonPredicateContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}

func (s *SubqueryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryComparisonPredicate(s)
	}
}

func (s *SubqueryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryComparisonPredicate(s)
	}
}

func (s *SubqueryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonMemberOfPredicateContext struct {
	PredicateContext
}

func NewJsonMemberOfPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonMemberOfPredicateContext {
	var p = new(JsonMemberOfPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *JsonMemberOfPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonMemberOfPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *JsonMemberOfPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *JsonMemberOfPredicateContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *JsonMemberOfPredicateContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *JsonMemberOfPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonMemberOfPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryComparisonPredicateContext struct {
	PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type InPredicateContext struct {
	PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext {
	var p = new(InPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *InPredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InPredicateContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *InPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *InPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInPredicate(s)
	}
}

func (s *InPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInPredicate(s)
	}
}

func (s *InPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenPredicateContext struct {
	PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext {
	var p = new(BetweenPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBETWEEN, 0)
}

func (s *BetweenPredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBetweenPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsNullPredicateContext struct {
	PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext {
	var p = new(IsNullPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikePredicateContext struct {
	PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext {
	var p = new(LikePredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *LikePredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *LikePredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *LikePredicateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

func (s *LikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type RegexpPredicateContext struct {
	PredicateContext
	regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext {
	var p = new(RegexpPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *RegexpPredicateContext) GetRegex() antlr.Token { return s.regex }

func (s *RegexpPredicateContext) SetRegex(v antlr.Token) { s.regex = v }

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserREGEXP, 0)
}

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRLIKE, 0)
}

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRegexpPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *MySqlParser) predicate(_p int) (localctx IPredicateContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 692
	p.EnterRecursionRule(localctx, 692, MySqlParserRULE_predicate, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(7276)
		p.expressionAtom(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1086, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7340)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1085, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7278)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(7279)
					p.ComparisonOperator()
				}
				{
					p.SetState(7280)

					var _x = p.predicate(9)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}

			case 2:
				localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7282)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				p.SetState(7284)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7283)
						p.Match(MySqlParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7286)
					p.Match(MySqlParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7287)
					p.predicate(0)
				}
				{
					p.SetState(7288)
					p.Match(MySqlParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7289)
					p.predicate(7)
				}

			case 3:
				localctx = NewSoundsLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7291)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(7292)
					p.Match(MySqlParserSOUNDS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7293)
					p.Match(MySqlParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7294)
					p.predicate(6)
				}

			case 4:
				localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7295)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				p.SetState(7297)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7296)
						p.Match(MySqlParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7299)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexpPredicateContext).regex = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserREGEXP || _la == MySqlParserRLIKE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexpPredicateContext).regex = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7300)
					p.predicate(4)
				}

			case 5:
				localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7301)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				p.SetState(7303)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7302)
						p.Match(MySqlParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7305)
					p.Match(MySqlParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7306)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(7309)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1082, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(7307)
						p.SelectStatement()
					}

				case 2:
					{
						p.SetState(7308)
						p.Expressions()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(7311)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7313)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(7314)
					p.Match(MySqlParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7315)
					p.NullNotnull()
				}

			case 7:
				localctx = NewSubqueryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7316)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(7317)
					p.ComparisonOperator()
				}
				{
					p.SetState(7318)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SubqueryComparisonPredicateContext).quantifier = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserANY || _la == MySqlParserSOME) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SubqueryComparisonPredicateContext).quantifier = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7319)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7320)
					p.SelectStatement()
				}
				{
					p.SetState(7321)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 8:
				localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7323)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(7325)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7324)
						p.Match(MySqlParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(7327)
					p.Match(MySqlParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7328)
					p.predicate(0)
				}
				p.SetState(7331)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1084, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(7329)
						p.Match(MySqlParserESCAPE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(7330)
						p.Match(MySqlParserSTRING_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 9:
				localctx = NewJsonMemberOfPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7333)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(7334)
					p.Match(MySqlParserMEMBER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7335)
					p.Match(MySqlParserOF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7336)
					p.Match(MySqlParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7337)
					p.predicate(0)
				}
				{
					p.SetState(7338)
					p.Match(MySqlParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(7344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1086, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
	return p
}

func InitEmptyExpressionAtomContext(p *ExpressionAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyAll(ctx *ExpressionAtomContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewCollateExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateExpressionAtomContext {
	var p = new(CollateExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *CollateExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *CollateExpressionAtomContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CollateExpressionAtomContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollateExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type VariableAssignExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewVariableAssignExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableAssignExpressionAtomContext {
	var p = new(VariableAssignExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *VariableAssignExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableAssignExpressionAtomContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *VariableAssignExpressionAtomContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *VariableAssignExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *VariableAssignExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVariableAssignExpressionAtom(s)
	}
}

func (s *VariableAssignExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVariableAssignExpressionAtom(s)
	}
}

func (s *VariableAssignExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitVariableAssignExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type MysqlVariableExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewMysqlVariableExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlVariableExpressionAtomContext {
	var p = new(MysqlVariableExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MysqlVariableExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableExpressionAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *MysqlVariableExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMysqlVariableExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedRowExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewNestedRowExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedRowExpressionAtomContext {
	var p = new(NestedRowExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedRowExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedRowExpressionAtomContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *NestedRowExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedRowExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedRowExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedRowExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedRowExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedRowExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type MathExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext {
	var p = new(MathExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathExpressionAtomContext) MultOperator() IMultOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultOperatorContext)
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *MathExpressionAtomContext) AddOperator() IAddOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddOperatorContext)
}

func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMathExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewExistsExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsExpressionAtomContext {
	var p = new(ExistsExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ExistsExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsExpressionAtomContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *ExistsExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExistsExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ExistsExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ExistsExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExistsExpressionAtom(s)
	}
}

func (s *ExistsExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExistsExpressionAtom(s)
	}
}

func (s *ExistsExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExistsExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewIntervalExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExpressionAtomContext {
	var p = new(IntervalExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *IntervalExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionAtomContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *IntervalExpressionAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionAtomContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewJsonExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExpressionAtomContext {
	var p = new(JsonExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *JsonExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *JsonExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *JsonExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *JsonExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *JsonExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExpressionAtomContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *JsonExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *JsonExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *JsonExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewSubqueryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionAtomContext {
	var p = new(SubqueryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *SubqueryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryExpressionAtom(s)
	}
}

func (s *SubqueryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryExpressionAtom(s)
	}
}

func (s *SubqueryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstantExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstantExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewFunctionCallExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionAtomContext {
	var p = new(FunctionCallExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FunctionCallExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionAtomContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionCallExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewBinaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExpressionAtomContext {
	var p = new(BinaryExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BinaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionAtomContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *BinaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BinaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnNameExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitExpressionAtomContext struct {
	ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewBitExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionAtomContext {
	var p = new(BitExpressionAtomContext)

	InitEmptyExpressionAtomContext(&p.ExpressionAtomContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BitExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *BitExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *BitExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *BitExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *BitExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionAtomContext) BitOperator() IBitOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitOperatorContext)
}

func (s *BitExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BitExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBitExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	return p.expressionAtom(0)
}

func (p *MySqlParser) expressionAtom(_p int) (localctx IExpressionAtomContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionAtomContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 694
	p.EnterRecursionRule(localctx, 694, MySqlParserRULE_expressionAtom, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1089, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7346)
			p.Constant()
		}

	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7347)
			p.FullColumnName()
		}

	case 3:
		localctx = NewFunctionCallExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7348)
			p.FunctionCall()
		}

	case 4:
		localctx = NewMysqlVariableExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7349)
			p.MysqlVariable()
		}

	case 5:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7350)
			p.UnaryOperator()
		}
		{
			p.SetState(7351)
			p.expressionAtom(12)
		}

	case 6:
		localctx = NewBinaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7353)
			p.Match(MySqlParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7354)
			p.expressionAtom(11)
		}

	case 7:
		localctx = NewVariableAssignExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7355)
			p.Match(MySqlParserLOCAL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7356)
			p.Match(MySqlParserVAR_ASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7357)
			p.expressionAtom(10)
		}

	case 8:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7358)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7359)
			p.expression(0)
		}
		p.SetState(7364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(7360)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7361)
				p.expression(0)
			}

			p.SetState(7366)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7367)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewNestedRowExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7369)
			p.Match(MySqlParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7370)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7371)
			p.expression(0)
		}
		p.SetState(7374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserCOMMA {
			{
				p.SetState(7372)
				p.Match(MySqlParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7373)
				p.expression(0)
			}

			p.SetState(7376)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7378)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewExistsExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7380)
			p.Match(MySqlParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7381)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7382)
			p.SelectStatement()
		}
		{
			p.SetState(7383)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewSubqueryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7385)
			p.Match(MySqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7386)
			p.SelectStatement()
		}
		{
			p.SetState(7387)
			p.Match(MySqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewIntervalExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7389)
			p.Match(MySqlParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7390)
			p.expression(0)
		}
		{
			p.SetState(7391)
			p.IntervalType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1091, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7414)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1090, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*BitExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7395)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(7396)
					p.BitOperator()
				}
				{
					p.SetState(7397)

					var _x = p.expressionAtom(5)

					localctx.(*BitExpressionAtomContext).right = _x
				}

			case 2:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7399)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(7400)
					p.MultOperator()
				}
				{
					p.SetState(7401)

					var _x = p.expressionAtom(4)

					localctx.(*MathExpressionAtomContext).right = _x
				}

			case 3:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7403)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(7404)
					p.AddOperator()
				}
				{
					p.SetState(7405)

					var _x = p.expressionAtom(3)

					localctx.(*MathExpressionAtomContext).right = _x
				}

			case 4:
				localctx = NewJsonExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*JsonExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7407)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(7408)
					p.JsonOperator()
				}
				{
					p.SetState(7409)

					var _x = p.expressionAtom(2)

					localctx.(*JsonExpressionAtomContext).right = _x
				}

			case 5:
				localctx = NewCollateExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7411)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(7412)
					p.Match(MySqlParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7413)
					p.CollationName()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(7418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1091, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLAMATION_SYMBOL() antlr.TerminalNode
	BIT_NOT_OP() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
	return p
}

func InitEmptyUnaryOperatorContext(p *UnaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, MySqlParserRULE_unaryOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7419)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNOT || ((int64((_la-1119)) & ^0x3f) == 0 && ((int64(1)<<(_la-1119))&387) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	EXCLAMATION_SYMBOL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, MySqlParserRULE_comparisonOperator)
	p.SetState(7435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1092, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7421)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7422)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7423)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7424)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7425)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7426)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7427)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7428)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7429)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7430)
			p.Match(MySqlParserEXCLAMATION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7431)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7432)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7433)
			p.Match(MySqlParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7434)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AND() antlr.TerminalNode
	AllBIT_AND_OP() []antlr.TerminalNode
	BIT_AND_OP(i int) antlr.TerminalNode
	XOR() antlr.TerminalNode
	OR() antlr.TerminalNode
	AllBIT_OR_OP() []antlr.TerminalNode
	BIT_OR_OP(i int) antlr.TerminalNode

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
	return p
}

func InitEmptyLogicalOperatorContext(p *LogicalOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserXOR, 0)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, MySqlParserRULE_logicalOperator)
	p.SetState(7444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7437)
			p.Match(MySqlParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7438)
			p.Match(MySqlParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7439)
			p.Match(MySqlParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserXOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7440)
			p.Match(MySqlParserXOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7441)
			p.Match(MySqlParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7442)
			p.Match(MySqlParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7443)
			p.Match(MySqlParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLESS_SYMBOL() []antlr.TerminalNode
	LESS_SYMBOL(i int) antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode
	BIT_AND_OP() antlr.TerminalNode
	BIT_XOR_OP() antlr.TerminalNode
	BIT_OR_OP() antlr.TerminalNode

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_bitOperator
	return p
}

func InitEmptyBitOperatorContext(p *BitOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_bitOperator
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (s *BitOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBitOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BitOperator() (localctx IBitOperatorContext) {
	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, MySqlParserRULE_bitOperator)
	p.SetState(7453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7446)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7447)
			p.Match(MySqlParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7448)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7449)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7450)
			p.Match(MySqlParserBIT_AND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7451)
			p.Match(MySqlParserBIT_XOR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7452)
			p.Match(MySqlParserBIT_OR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultOperatorContext is an interface to support dynamic dispatch.
type IMultOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultOperatorContext differentiates from other interfaces.
	IsMultOperatorContext()
}

type MultOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultOperatorContext() *MultOperatorContext {
	var p = new(MultOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multOperator
	return p
}

func InitEmptyMultOperatorContext(p *MultOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_multOperator
}

func (*MultOperatorContext) IsMultOperatorContext() {}

func NewMultOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultOperatorContext {
	var p = new(MultOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multOperator

	return p
}

func (s *MultOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *MultOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIVIDE, 0)
}

func (s *MultOperatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODULE, 0)
}

func (s *MultOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIV, 0)
}

func (s *MultOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMOD, 0)
}

func (s *MultOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultOperator(s)
	}
}

func (s *MultOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultOperator(s)
	}
}

func (s *MultOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMultOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) MultOperator() (localctx IMultOperatorContext) {
	localctx = NewMultOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, MySqlParserRULE_multOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7455)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1116)) & ^0x3f) == 0 && ((int64(1)<<(_la-1116))&103) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddOperatorContext is an interface to support dynamic dispatch.
type IAddOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsAddOperatorContext differentiates from other interfaces.
	IsAddOperatorContext()
}

type AddOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOperatorContext() *AddOperatorContext {
	var p = new(AddOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_addOperator
	return p
}

func InitEmptyAddOperatorContext(p *AddOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_addOperator
}

func (*AddOperatorContext) IsAddOperatorContext() {}

func NewAddOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOperatorContext {
	var p = new(AddOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_addOperator

	return p
}

func (s *AddOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AddOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *AddOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *AddOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAddOperator(s)
	}
}

func (s *AddOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAddOperator(s)
	}
}

func (s *AddOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAddOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AddOperator() (localctx IAddOperatorContext) {
	localctx = NewAddOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, MySqlParserRULE_addOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7457)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserPLUS || _la == MySqlParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOperator
	return p
}

func InitEmptyJsonOperatorContext(p *JsonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOperator
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *JsonOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *JsonOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (s *JsonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JsonOperator() (localctx IJsonOperatorContext) {
	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, MySqlParserRULE_jsonOperator)
	p.SetState(7464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1095, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7459)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7460)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7461)
			p.Match(MySqlParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7462)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7463)
			p.Match(MySqlParserGREATER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameBaseContext is an interface to support dynamic dispatch.
type ICharsetNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARMSCII8() antlr.TerminalNode
	ASCII() antlr.TerminalNode
	BIG5() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	CP1250() antlr.TerminalNode
	CP1251() antlr.TerminalNode
	CP1256() antlr.TerminalNode
	CP1257() antlr.TerminalNode
	CP850() antlr.TerminalNode
	CP852() antlr.TerminalNode
	CP866() antlr.TerminalNode
	CP932() antlr.TerminalNode
	DEC8() antlr.TerminalNode
	EUCJPMS() antlr.TerminalNode
	EUCKR() antlr.TerminalNode
	GB18030() antlr.TerminalNode
	GB2312() antlr.TerminalNode
	GBK() antlr.TerminalNode
	GEOSTD8() antlr.TerminalNode
	GREEK() antlr.TerminalNode
	HEBREW() antlr.TerminalNode
	HP8() antlr.TerminalNode
	KEYBCS2() antlr.TerminalNode
	KOI8R() antlr.TerminalNode
	KOI8U() antlr.TerminalNode
	LATIN1() antlr.TerminalNode
	LATIN2() antlr.TerminalNode
	LATIN5() antlr.TerminalNode
	LATIN7() antlr.TerminalNode
	MACCE() antlr.TerminalNode
	MACROMAN() antlr.TerminalNode
	SJIS() antlr.TerminalNode
	SWE7() antlr.TerminalNode
	TIS620() antlr.TerminalNode
	UCS2() antlr.TerminalNode
	UJIS() antlr.TerminalNode
	UTF16() antlr.TerminalNode
	UTF16LE() antlr.TerminalNode
	UTF32() antlr.TerminalNode
	UTF8() antlr.TerminalNode
	UTF8MB3() antlr.TerminalNode
	UTF8MB4() antlr.TerminalNode

	// IsCharsetNameBaseContext differentiates from other interfaces.
	IsCharsetNameBaseContext()
}

type CharsetNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameBaseContext() *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetNameBase
	return p
}

func InitEmptyCharsetNameBaseContext(p *CharsetNameBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetNameBase
}

func (*CharsetNameBaseContext) IsCharsetNameBaseContext() {}

func NewCharsetNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetNameBase

	return p
}

func (s *CharsetNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameBaseContext) ARMSCII8() antlr.TerminalNode {
	return s.GetToken(MySqlParserARMSCII8, 0)
}

func (s *CharsetNameBaseContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *CharsetNameBaseContext) BIG5() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIG5, 0)
}

func (s *CharsetNameBaseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CharsetNameBaseContext) CP1250() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1250, 0)
}

func (s *CharsetNameBaseContext) CP1251() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1251, 0)
}

func (s *CharsetNameBaseContext) CP1256() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1256, 0)
}

func (s *CharsetNameBaseContext) CP1257() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1257, 0)
}

func (s *CharsetNameBaseContext) CP850() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP850, 0)
}

func (s *CharsetNameBaseContext) CP852() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP852, 0)
}

func (s *CharsetNameBaseContext) CP866() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP866, 0)
}

func (s *CharsetNameBaseContext) CP932() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP932, 0)
}

func (s *CharsetNameBaseContext) DEC8() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC8, 0)
}

func (s *CharsetNameBaseContext) EUCJPMS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCJPMS, 0)
}

func (s *CharsetNameBaseContext) EUCKR() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCKR, 0)
}

func (s *CharsetNameBaseContext) GB18030() antlr.TerminalNode {
	return s.GetToken(MySqlParserGB18030, 0)
}

func (s *CharsetNameBaseContext) GB2312() antlr.TerminalNode {
	return s.GetToken(MySqlParserGB2312, 0)
}

func (s *CharsetNameBaseContext) GBK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGBK, 0)
}

func (s *CharsetNameBaseContext) GEOSTD8() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOSTD8, 0)
}

func (s *CharsetNameBaseContext) GREEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREEK, 0)
}

func (s *CharsetNameBaseContext) HEBREW() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEBREW, 0)
}

func (s *CharsetNameBaseContext) HP8() antlr.TerminalNode {
	return s.GetToken(MySqlParserHP8, 0)
}

func (s *CharsetNameBaseContext) KEYBCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYBCS2, 0)
}

func (s *CharsetNameBaseContext) KOI8R() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8R, 0)
}

func (s *CharsetNameBaseContext) KOI8U() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8U, 0)
}

func (s *CharsetNameBaseContext) LATIN1() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN1, 0)
}

func (s *CharsetNameBaseContext) LATIN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN2, 0)
}

func (s *CharsetNameBaseContext) LATIN5() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN5, 0)
}

func (s *CharsetNameBaseContext) LATIN7() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN7, 0)
}

func (s *CharsetNameBaseContext) MACCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACCE, 0)
}

func (s *CharsetNameBaseContext) MACROMAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACROMAN, 0)
}

func (s *CharsetNameBaseContext) SJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSJIS, 0)
}

func (s *CharsetNameBaseContext) SWE7() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWE7, 0)
}

func (s *CharsetNameBaseContext) TIS620() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIS620, 0)
}

func (s *CharsetNameBaseContext) UCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCS2, 0)
}

func (s *CharsetNameBaseContext) UJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUJIS, 0)
}

func (s *CharsetNameBaseContext) UTF16() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16, 0)
}

func (s *CharsetNameBaseContext) UTF16LE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16LE, 0)
}

func (s *CharsetNameBaseContext) UTF32() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF32, 0)
}

func (s *CharsetNameBaseContext) UTF8() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8, 0)
}

func (s *CharsetNameBaseContext) UTF8MB3() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB3, 0)
}

func (s *CharsetNameBaseContext) UTF8MB4() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB4, 0)
}

func (s *CharsetNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharsetNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CharsetNameBase() (localctx ICharsetNameBaseContext) {
	localctx = NewCharsetNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, MySqlParserRULE_charsetNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7466)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBINARY || ((int64((_la-745)) & ^0x3f) == 0 && ((int64(1)<<(_la-745))&2199023255551) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionLevelBaseContext is an interface to support dynamic dispatch.
type ITransactionLevelBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelBaseContext differentiates from other interfaces.
	IsTransactionLevelBaseContext()
}

type TransactionLevelBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelBaseContext() *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevelBase
	return p
}

func InitEmptyTransactionLevelBaseContext(p *TransactionLevelBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevelBase
}

func (*TransactionLevelBaseContext) IsTransactionLevelBaseContext() {}

func NewTransactionLevelBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionLevelBase

	return p
}

func (s *TransactionLevelBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelBaseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEATABLE, 0)
}

func (s *TransactionLevelBaseContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIALIZABLE, 0)
}

func (s *TransactionLevelBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionLevelBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TransactionLevelBase() (localctx ITransactionLevelBaseContext) {
	localctx = NewTransactionLevelBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, MySqlParserRULE_transactionLevelBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7468)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-798)) & ^0x3f) == 0 && ((int64(1)<<(_la-798))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegesBaseContext is an interface to support dynamic dispatch.
type IPrivilegesBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLES() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsPrivilegesBaseContext differentiates from other interfaces.
	IsPrivilegesBaseContext()
}

type PrivilegesBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesBaseContext() *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegesBase
	return p
}

func InitEmptyPrivilegesBaseContext(p *PrivilegesBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegesBase
}

func (*PrivilegesBaseContext) IsPrivilegesBaseContext() {}

func NewPrivilegesBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilegesBase

	return p
}

func (s *PrivilegesBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesBaseContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *PrivilegesBaseContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUTINE, 0)
}

func (s *PrivilegesBaseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *PrivilegesBaseContext) FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE, 0)
}

func (s *PrivilegesBaseContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESS, 0)
}

func (s *PrivilegesBaseContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELOAD, 0)
}

func (s *PrivilegesBaseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *PrivilegesBaseContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUPER, 0)
}

func (s *PrivilegesBaseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *PrivilegesBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegesBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrivilegesBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PrivilegesBase() (localctx IPrivilegesBaseContext) {
	localctx = NewPrivilegesBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, MySqlParserRULE_privilegesBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7470)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-707)) & ^0x3f) == 0 && ((int64(1)<<(_la-707))&23656792067) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTypeBaseContext is an interface to support dynamic dispatch.
type IIntervalTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeBaseContext differentiates from other interfaces.
	IsIntervalTypeBaseContext()
}

type IntervalTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeBaseContext() *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalTypeBase
	return p
}

func InitEmptyIntervalTypeBaseContext(p *IntervalTypeBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalTypeBase
}

func (*IntervalTypeBaseContext) IsIntervalTypeBaseContext() {}

func NewIntervalTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalTypeBase

	return p
}

func (s *IntervalTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *IntervalTypeBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *IntervalTypeBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *IntervalTypeBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *IntervalTypeBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *IntervalTypeBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *IntervalTypeBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *IntervalTypeBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *IntervalTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IntervalTypeBase() (localctx IIntervalTypeBaseContext) {
	localctx = NewIntervalTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, MySqlParserRULE_intervalTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7472)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-688)) & ^0x3f) == 0 && ((int64(1)<<(_la-688))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeBaseContext is an interface to support dynamic dispatch.
type IDataTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	TEXT() antlr.TerminalNode

	// IsDataTypeBaseContext differentiates from other interfaces.
	IsDataTypeBaseContext()
}

type DataTypeBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeBaseContext() *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataTypeBase
	return p
}

func InitEmptyDataTypeBaseContext(p *DataTypeBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_dataTypeBase
}

func (*DataTypeBaseContext) IsDataTypeBaseContext() {}

func NewDataTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataTypeBase

	return p
}

func (s *DataTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *DataTypeBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DataTypeBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DataTypeBaseContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DataTypeBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *DataTypeBaseContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *DataTypeBaseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *DataTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDataTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DataTypeBase() (localctx IDataTypeBaseContext) {
	localctx = NewDataTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, MySqlParserRULE_dataTypeBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7474)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&1179679) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordsCanBeIdContext is an interface to support dynamic dispatch.
type IKeywordsCanBeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALGORITHM() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	AUDIT_ABORT_EXEMPT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode
	AVG() antlr.TerminalNode
	AVG_ROW_LENGTH() antlr.TerminalNode
	ATTRIBUTE() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	BIT() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHANGED() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	CHECKSUM() antlr.TerminalNode
	PAGE_CHECKSUM() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CLOSE() antlr.TerminalNode
	CLUSTERING() antlr.TerminalNode
	COALESCE() antlr.TerminalNode
	CODE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COLUMN_FORMAT() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETION() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	COMPRESSION() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CPU() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFAULT_AUTH() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELAY_KEY_WRITE() antlr.TerminalNode
	DES_KEY_FILE() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DO() antlr.TerminalNode
	DUMPFILE() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTION() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EUR() antlr.TerminalNode
	EVEN() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_EXEMPT() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FIXED() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWS() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERAL() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORED() antlr.TerminalNode
	IGNORE_SERVER_IDS() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INPLACE() antlr.TerminalNode
	INSERT_METHOD() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	INSTANT() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IO() antlr.TerminalNode
	IO_THREAD() antlr.TerminalNode
	IPC() antlr.TerminalNode
	ISO() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	JIS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY_BLOCK_SIZE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_PORT() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	MEMBER() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MID() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MUTEX() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	NESTED() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOCOPY() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NOWAIT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	ODBC() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OF() antlr.TerminalNode
	OJ() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZER_COSTS() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PACK_KEYS() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	PARTITIONING() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	PHASE() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PLUGIN_DIR() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PORT() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	PREV() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	REBUILD() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	REDUNDANT() antlr.TerminalNode
	RELAY() antlr.TerminalNode
	RELAYLOG() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REORGANIZE() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPLICATE_DO_DB() antlr.TerminalNode
	REPLICATE_DO_TABLE() antlr.TerminalNode
	REPLICATE_IGNORE_DB() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE() antlr.TerminalNode
	REPLICATE_REWRITE_DB() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	RETURNING() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	RTREE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	SERIAL() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	SHARED() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SLOW() antlr.TerminalNode
	SKIP_QUERY_REWRITE() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SOUNDS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SQL_AFTER_GTIDS() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS() antlr.TerminalNode
	SQL_BEFORE_GTIDS() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS_AUTO_RECALC() antlr.TerminalNode
	STATS_PERSISTENT() antlr.TerminalNode
	STATS_SAMPLE_PAGES() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	SUM() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SWAPS() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TABLE_TYPE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TP_CONNECTION_ADMIN() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRANSACTIONAL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	USA() antlr.TerminalNode
	USER() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	USER_RESOURCES() antlr.TerminalNode
	VALIDATION() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	X509() antlr.TerminalNode
	XA() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	XML() antlr.TerminalNode

	// IsKeywordsCanBeIdContext differentiates from other interfaces.
	IsKeywordsCanBeIdContext()
}

type KeywordsCanBeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsCanBeIdContext() *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId
	return p
}

func InitEmptyKeywordsCanBeIdContext(p *KeywordsCanBeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId
}

func (*KeywordsCanBeIdContext) IsKeywordsCanBeIdContext() {}

func NewKeywordsCanBeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId

	return p
}

func (s *KeywordsCanBeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsCanBeIdContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserACCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserACTION, 0)
}

func (s *KeywordsCanBeIdContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *KeywordsCanBeIdContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *KeywordsCanBeIdContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *KeywordsCanBeIdContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *KeywordsCanBeIdContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserARRAY, 0)
}

func (s *KeywordsCanBeIdContext) AT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ABORT_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ABORT_EXEMPT, 0)
}

func (s *KeywordsCanBeIdContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHORS, 0)
}

func (s *KeywordsCanBeIdContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) AUTHENTICATION_POLICY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHENTICATION_POLICY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG, 0)
}

func (s *KeywordsCanBeIdContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG_ROW_LENGTH, 0)
}

func (s *KeywordsCanBeIdContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBACKUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *KeywordsCanBeIdContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND, 0)
}

func (s *KeywordsCanBeIdContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR, 0)
}

func (s *KeywordsCanBeIdContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR, 0)
}

func (s *KeywordsCanBeIdContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOCK, 0)
}

func (s *KeywordsCanBeIdContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *KeywordsCanBeIdContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *KeywordsCanBeIdContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBTREE, 0)
}

func (s *KeywordsCanBeIdContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUCKETS, 0)
}

func (s *KeywordsCanBeIdContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *KeywordsCanBeIdContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *KeywordsCanBeIdContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *KeywordsCanBeIdContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGED, 0)
}

func (s *KeywordsCanBeIdContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *KeywordsCanBeIdContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_CHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCIPHER, 0)
}

func (s *KeywordsCanBeIdContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLIENT, 0)
}

func (s *KeywordsCanBeIdContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLONE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *KeywordsCanBeIdContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLUSTERING, 0)
}

func (s *KeywordsCanBeIdContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOALESCE, 0)
}

func (s *KeywordsCanBeIdContext) CODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCODE, 0)
}

func (s *KeywordsCanBeIdContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *KeywordsCanBeIdContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *KeywordsCanBeIdContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPACT, 0)
}

func (s *KeywordsCanBeIdContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSED, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSION, 0)
}

func (s *KeywordsCanBeIdContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *KeywordsCanBeIdContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTAINS, 0)
}

func (s *KeywordsCanBeIdContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTEXT, 0)
}

func (s *KeywordsCanBeIdContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTRIBUTORS, 0)
}

func (s *KeywordsCanBeIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, 0)
}

func (s *KeywordsCanBeIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) CPU() antlr.TerminalNode {
	return s.GetToken(MySqlParserCPU, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *KeywordsCanBeIdContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *KeywordsCanBeIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *KeywordsCanBeIdContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *KeywordsCanBeIdContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEALLOCATE, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT_AUTH, 0)
}

func (s *KeywordsCanBeIdContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *KeywordsCanBeIdContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAY_KEY_WRITE, 0)
}

func (s *KeywordsCanBeIdContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_KEY_FILE, 0)
}

func (s *KeywordsCanBeIdContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIAGNOSTICS, 0)
}

func (s *KeywordsCanBeIdContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *KeywordsCanBeIdContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *KeywordsCanBeIdContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *KeywordsCanBeIdContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *KeywordsCanBeIdContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *KeywordsCanBeIdContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *KeywordsCanBeIdContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUPLICATE, 0)
}

func (s *KeywordsCanBeIdContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *KeywordsCanBeIdContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEMPTY, 0)
}

func (s *KeywordsCanBeIdContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *KeywordsCanBeIdContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDS, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINES, 0)
}

func (s *KeywordsCanBeIdContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *KeywordsCanBeIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *KeywordsCanBeIdContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *KeywordsCanBeIdContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *KeywordsCanBeIdContext) EUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUR, 0)
}

func (s *KeywordsCanBeIdContext) EVEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVEN, 0)
}

func (s *KeywordsCanBeIdContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *KeywordsCanBeIdContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *KeywordsCanBeIdContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVERY, 0)
}

func (s *KeywordsCanBeIdContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCEPT, 0)
}

func (s *KeywordsCanBeIdContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCHANGE, 0)
}

func (s *KeywordsCanBeIdContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, 0)
}

func (s *KeywordsCanBeIdContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPIRE, 0)
}

func (s *KeywordsCanBeIdContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT, 0)
}

func (s *KeywordsCanBeIdContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *KeywordsCanBeIdContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENT_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *KeywordsCanBeIdContext) FAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAST, 0)
}

func (s *KeywordsCanBeIdContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAULTS, 0)
}

func (s *KeywordsCanBeIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *KeywordsCanBeIdContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILTER, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_EXEMPT, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_USER, 0)
}

func (s *KeywordsCanBeIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *KeywordsCanBeIdContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *KeywordsCanBeIdContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH, 0)
}

func (s *KeywordsCanBeIdContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWS, 0)
}

func (s *KeywordsCanBeIdContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND, 0)
}

func (s *KeywordsCanBeIdContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *KeywordsCanBeIdContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *KeywordsCanBeIdContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERAL, 0)
}

func (s *KeywordsCanBeIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *KeywordsCanBeIdContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANTS, 0)
}

func (s *KeywordsCanBeIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_CONCAT, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *KeywordsCanBeIdContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *KeywordsCanBeIdContext) HELP() antlr.TerminalNode {
	return s.GetToken(MySqlParserHELP, 0)
}

func (s *KeywordsCanBeIdContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTORY, 0)
}

func (s *KeywordsCanBeIdContext) HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST, 0)
}

func (s *KeywordsCanBeIdContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *KeywordsCanBeIdContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE_SERVER_IDS, 0)
}

func (s *KeywordsCanBeIdContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *KeywordsCanBeIdContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEXES, 0)
}

func (s *KeywordsCanBeIdContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *KeywordsCanBeIdContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, 0)
}

func (s *KeywordsCanBeIdContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT_METHOD, 0)
}

func (s *KeywordsCanBeIdContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANCE, 0)
}

func (s *KeywordsCanBeIdContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANT, 0)
}

func (s *KeywordsCanBeIdContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERNAL, 0)
}

func (s *KeywordsCanBeIdContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKE, 0)
}

func (s *KeywordsCanBeIdContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *KeywordsCanBeIdContext) IO() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO, 0)
}

func (s *KeywordsCanBeIdContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) IPC() antlr.TerminalNode {
	return s.GetToken(MySqlParserIPC, 0)
}

func (s *KeywordsCanBeIdContext) ISO() antlr.TerminalNode {
	return s.GetToken(MySqlParserISO, 0)
}

func (s *KeywordsCanBeIdContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserISOLATION, 0)
}

func (s *KeywordsCanBeIdContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSUER, 0)
}

func (s *KeywordsCanBeIdContext) JIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJIS, 0)
}

func (s *KeywordsCanBeIdContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *KeywordsCanBeIdContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAMBDA, 0)
}

func (s *KeywordsCanBeIdContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLANGUAGE, 0)
}

func (s *KeywordsCanBeIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *KeywordsCanBeIdContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *KeywordsCanBeIdContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVES, 0)
}

func (s *KeywordsCanBeIdContext) LESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS, 0)
}

func (s *KeywordsCanBeIdContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *KeywordsCanBeIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIST, 0)
}

func (s *KeywordsCanBeIdContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *KeywordsCanBeIdContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *KeywordsCanBeIdContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_AUTO_POSITION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_CONNECT_RETRY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_DELAY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HOST, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PORT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_RETRY_COUNT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CA, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CAPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CERT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CIPHER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRLPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_KEY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_TLS_VERSION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_USER, 0)
}

func (s *KeywordsCanBeIdContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX, 0)
}

func (s *KeywordsCanBeIdContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_USER_CONNECTIONS, 0)
}

func (s *KeywordsCanBeIdContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUM, 0)
}

func (s *KeywordsCanBeIdContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *KeywordsCanBeIdContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *KeywordsCanBeIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *KeywordsCanBeIdContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *KeywordsCanBeIdContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *KeywordsCanBeIdContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIGRATE, 0)
}

func (s *KeywordsCanBeIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN, 0)
}

func (s *KeywordsCanBeIdContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *KeywordsCanBeIdContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFY, 0)
}

func (s *KeywordsCanBeIdContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMUTEX, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *KeywordsCanBeIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME, 0)
}

func (s *KeywordsCanBeIdContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAMES, 0)
}

func (s *KeywordsCanBeIdContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *KeywordsCanBeIdContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB_STORED_USER, 0)
}

func (s *KeywordsCanBeIdContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserNESTED, 0)
}

func (s *KeywordsCanBeIdContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEVER, 0)
}

func (s *KeywordsCanBeIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *KeywordsCanBeIdContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *KeywordsCanBeIdContext) NOCOPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOCOPY, 0)
}

func (s *KeywordsCanBeIdContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *KeywordsCanBeIdContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *KeywordsCanBeIdContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOWAIT, 0)
}

func (s *KeywordsCanBeIdContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMBER, 0)
}

func (s *KeywordsCanBeIdContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MySqlParserODBC, 0)
}

func (s *KeywordsCanBeIdContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *KeywordsCanBeIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *KeywordsCanBeIdContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *KeywordsCanBeIdContext) OJ() antlr.TerminalNode {
	return s.GetToken(MySqlParserOJ, 0)
}

func (s *KeywordsCanBeIdContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) ONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE, 0)
}

func (s *KeywordsCanBeIdContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *KeywordsCanBeIdContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *KeywordsCanBeIdContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *KeywordsCanBeIdContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZER_COSTS, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *KeywordsCanBeIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *KeywordsCanBeIdContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDINALITY, 0)
}

func (s *KeywordsCanBeIdContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOWNER, 0)
}

func (s *KeywordsCanBeIdContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPACK_KEYS, 0)
}

func (s *KeywordsCanBeIdContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE, 0)
}

func (s *KeywordsCanBeIdContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARSER, 0)
}

func (s *KeywordsCanBeIdContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTIAL, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD_LOCK_TIME, 0)
}

func (s *KeywordsCanBeIdContext) PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserPATH, 0)
}

func (s *KeywordsCanBeIdContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPHASE, 0)
}

func (s *KeywordsCanBeIdContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGINS, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN_DIR, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *KeywordsCanBeIdContext) PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPORT, 0)
}

func (s *KeywordsCanBeIdContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDES, 0)
}

func (s *KeywordsCanBeIdContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *KeywordsCanBeIdContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *KeywordsCanBeIdContext) PREV() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREV, 0)
}

func (s *KeywordsCanBeIdContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *KeywordsCanBeIdContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESSLIST, 0)
}

func (s *KeywordsCanBeIdContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILE, 0)
}

func (s *KeywordsCanBeIdContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILES, 0)
}

func (s *KeywordsCanBeIdContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *KeywordsCanBeIdContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *KeywordsCanBeIdContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MySqlParserREBUILD, 0)
}

func (s *KeywordsCanBeIdContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECOVER, 0)
}

func (s *KeywordsCanBeIdContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *KeywordsCanBeIdContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDUNDANT, 0)
}

func (s *KeywordsCanBeIdContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *KeywordsCanBeIdContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAYLOG, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREMOVE, 0)
}

func (s *KeywordsCanBeIdContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREORGANIZE, 0)
}

func (s *KeywordsCanBeIdContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_REWRITE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_APPLIER, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_USER, 0)
}

func (s *KeywordsCanBeIdContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESUME, 0)
}

func (s *KeywordsCanBeIdContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNED_SQLSTATE, 0)
}

func (s *KeywordsCanBeIdContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNING, 0)
}

func (s *KeywordsCanBeIdContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *KeywordsCanBeIdContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREUSE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *KeywordsCanBeIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *KeywordsCanBeIdContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROTATE, 0)
}

func (s *KeywordsCanBeIdContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *KeywordsCanBeIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *KeywordsCanBeIdContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) RTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRTREE, 0)
}

func (s *KeywordsCanBeIdContext) S3() antlr.TerminalNode {
	return s.GetToken(MySqlParserS3, 0)
}

func (s *KeywordsCanBeIdContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *KeywordsCanBeIdContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *KeywordsCanBeIdContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *KeywordsCanBeIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *KeywordsCanBeIdContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *KeywordsCanBeIdContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *KeywordsCanBeIdContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *KeywordsCanBeIdContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET_USER_ID, 0)
}

func (s *KeywordsCanBeIdContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *KeywordsCanBeIdContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, 0)
}

func (s *KeywordsCanBeIdContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW_ROUTINE, 0)
}

func (s *KeywordsCanBeIdContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *KeywordsCanBeIdContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIMPLE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *KeywordsCanBeIdContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLOW, 0)
}

func (s *KeywordsCanBeIdContext) SKIP_QUERY_REWRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSKIP_QUERY_REWRITE, 0)
}

func (s *KeywordsCanBeIdContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSNAPSHOT, 0)
}

func (s *KeywordsCanBeIdContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOCKET, 0)
}

func (s *KeywordsCanBeIdContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}

func (s *KeywordsCanBeIdContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *KeywordsCanBeIdContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *KeywordsCanBeIdContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOURCE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BEFORE_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *KeywordsCanBeIdContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTACKED, 0)
}

func (s *KeywordsCanBeIdContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *KeywordsCanBeIdContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTS, 0)
}

func (s *KeywordsCanBeIdContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_AUTO_RECALC, 0)
}

func (s *KeywordsCanBeIdContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_PERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_SAMPLE_PAGES, 0)
}

func (s *KeywordsCanBeIdContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *KeywordsCanBeIdContext) STD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTD, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_POP, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *KeywordsCanBeIdContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *KeywordsCanBeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING, 0)
}

func (s *KeywordsCanBeIdContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBJECT, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUM, 0)
}

func (s *KeywordsCanBeIdContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUSPEND, 0)
}

func (s *KeywordsCanBeIdContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWAPS, 0)
}

func (s *KeywordsCanBeIdContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWITCHES, 0)
}

func (s *KeywordsCanBeIdContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *KeywordsCanBeIdContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_TYPE, 0)
}

func (s *KeywordsCanBeIdContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *KeywordsCanBeIdContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *KeywordsCanBeIdContext) THAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHAN, 0)
}

func (s *KeywordsCanBeIdContext) TP_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTP_CONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRADITIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGERS, 0)
}

func (s *KeywordsCanBeIdContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *KeywordsCanBeIdContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *KeywordsCanBeIdContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *KeywordsCanBeIdContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *KeywordsCanBeIdContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *KeywordsCanBeIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *KeywordsCanBeIdContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *KeywordsCanBeIdContext) USA() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSA, 0)
}

func (s *KeywordsCanBeIdContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *KeywordsCanBeIdContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE_FRM, 0)
}

func (s *KeywordsCanBeIdContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER_RESOURCES, 0)
}

func (s *KeywordsCanBeIdContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *KeywordsCanBeIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *KeywordsCanBeIdContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_POP, 0)
}

func (s *KeywordsCanBeIdContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIABLES, 0)
}

func (s *KeywordsCanBeIdContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIANCE, 0)
}

func (s *KeywordsCanBeIdContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION_TOKEN_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *KeywordsCanBeIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIRTUAL, 0)
}

func (s *KeywordsCanBeIdContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *KeywordsCanBeIdContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *KeywordsCanBeIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *KeywordsCanBeIdContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *KeywordsCanBeIdContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRAPPER, 0)
}

func (s *KeywordsCanBeIdContext) X509() antlr.TerminalNode {
	return s.GetToken(MySqlParserX509, 0)
}

func (s *KeywordsCanBeIdContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *KeywordsCanBeIdContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA_RECOVER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) XML() antlr.TerminalNode {
	return s.GetToken(MySqlParserXML, 0)
}

func (s *KeywordsCanBeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsCanBeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsCanBeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitKeywordsCanBeId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) KeywordsCanBeId() (localctx IKeywordsCanBeIdContext) {
	localctx = NewKeywordsCanBeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, MySqlParserRULE_keywordsCanBeId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7476)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&378445391378654208) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&146666055054393409) != 0) || _la == MySqlParserSKIP_QUERY_REWRITE || _la == MySqlParserSTACKED || ((int64((_la-238)) & ^0x3f) == 0 && ((int64(1)<<(_la-238))&1769897061370560513) != 0) || ((int64((_la-304)) & ^0x3f) == 0 && ((int64(1)<<(_la-304))&-134217473) != 0) || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&-171798822913) != 0) || ((int64((_la-433)) & ^0x3f) == 0 && ((int64(1)<<(_la-433))&-33685505) != 0) || ((int64((_la-497)) & ^0x3f) == 0 && ((int64(1)<<(_la-497))&-2306265222165299201) != 0) || ((int64((_la-561)) & ^0x3f) == 0 && ((int64(1)<<(_la-561))&-35184640524289) != 0) || ((int64((_la-625)) & ^0x3f) == 0 && ((int64(1)<<(_la-625))&9077990211383719935) != 0) || ((int64((_la-696)) & ^0x3f) == 0 && ((int64(1)<<(_la-696))&514225960183805) != 0) || _la == MySqlParserMEMORY || _la == MySqlParserCATALOG_NAME || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserSCHEMA_NAME || _la == MySqlParserTP_CONNECTION_ADMIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameBaseContext is an interface to support dynamic dispatch.
type IFunctionNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABS() antlr.TerminalNode
	ACOS() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	ADDTIME() antlr.TerminalNode
	AES_DECRYPT() antlr.TerminalNode
	AES_ENCRYPT() antlr.TerminalNode
	AREA() antlr.TerminalNode
	ASBINARY() antlr.TerminalNode
	ASIN() antlr.TerminalNode
	ASTEXT() antlr.TerminalNode
	ASWKB() antlr.TerminalNode
	ASWKT() antlr.TerminalNode
	ASYMMETRIC_DECRYPT() antlr.TerminalNode
	ASYMMETRIC_DERIVE() antlr.TerminalNode
	ASYMMETRIC_ENCRYPT() antlr.TerminalNode
	ASYMMETRIC_SIGN() antlr.TerminalNode
	ASYMMETRIC_VERIFY() antlr.TerminalNode
	ATAN() antlr.TerminalNode
	ATAN2() antlr.TerminalNode
	BENCHMARK() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BIT_COUNT() antlr.TerminalNode
	BIT_LENGTH() antlr.TerminalNode
	BUFFER() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CEILING() antlr.TerminalNode
	CENTROID() antlr.TerminalNode
	CHARACTER_LENGTH() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR_LENGTH() antlr.TerminalNode
	COERCIBILITY() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COMPRESS() antlr.TerminalNode
	CONCAT() antlr.TerminalNode
	CONCAT_WS() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONV() antlr.TerminalNode
	CONVERT_TZ() antlr.TerminalNode
	COS() antlr.TerminalNode
	COT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CRC32() antlr.TerminalNode
	CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode
	CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode
	CREATE_DH_PARAMETERS() antlr.TerminalNode
	CREATE_DIGEST() antlr.TerminalNode
	CROSSES() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATE_FORMAT() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYNAME() antlr.TerminalNode
	DAYOFMONTH() antlr.TerminalNode
	DAYOFWEEK() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	DECODE() antlr.TerminalNode
	DEGREES() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	DES_DECRYPT() antlr.TerminalNode
	DES_ENCRYPT() antlr.TerminalNode
	DIMENSION() antlr.TerminalNode
	DISJOINT() antlr.TerminalNode
	ELT() antlr.TerminalNode
	ENCODE() antlr.TerminalNode
	ENCRYPT() antlr.TerminalNode
	ENDPOINT() antlr.TerminalNode
	ENVELOPE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	EXP() antlr.TerminalNode
	EXPORT_SET() antlr.TerminalNode
	EXTERIORRING() antlr.TerminalNode
	EXTRACTVALUE() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	FIND_IN_SET() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FOUND_ROWS() antlr.TerminalNode
	FROM_BASE64() antlr.TerminalNode
	FROM_DAYS() antlr.TerminalNode
	FROM_UNIXTIME() antlr.TerminalNode
	GEOMCOLLFROMTEXT() antlr.TerminalNode
	GEOMCOLLFROMWKB() antlr.TerminalNode
	GEOMETRYCOLLECTION() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	GEOMETRYFROMTEXT() antlr.TerminalNode
	GEOMETRYFROMWKB() antlr.TerminalNode
	GEOMETRYN() antlr.TerminalNode
	GEOMETRYTYPE() antlr.TerminalNode
	GEOMFROMTEXT() antlr.TerminalNode
	GEOMFROMWKB() antlr.TerminalNode
	GET_FORMAT() antlr.TerminalNode
	GET_LOCK() antlr.TerminalNode
	GLENGTH() antlr.TerminalNode
	GREATEST() antlr.TerminalNode
	GTID_SUBSET() antlr.TerminalNode
	GTID_SUBTRACT() antlr.TerminalNode
	HEX() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IFNULL() antlr.TerminalNode
	INET6_ATON() antlr.TerminalNode
	INET6_NTOA() antlr.TerminalNode
	INET_ATON() antlr.TerminalNode
	INET_NTOA() antlr.TerminalNode
	INSTR() antlr.TerminalNode
	INTERIORRINGN() antlr.TerminalNode
	INTERSECTS() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ISCLOSED() antlr.TerminalNode
	ISEMPTY() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISSIMPLE() antlr.TerminalNode
	IS_FREE_LOCK() antlr.TerminalNode
	IS_IPV4() antlr.TerminalNode
	IS_IPV4_COMPAT() antlr.TerminalNode
	IS_IPV4_MAPPED() antlr.TerminalNode
	IS_IPV6() antlr.TerminalNode
	IS_USED_LOCK() antlr.TerminalNode
	LAG() antlr.TerminalNode
	LAST_INSERT_ID() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	LCASE() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	LEAST() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LENGTH() antlr.TerminalNode
	LINEFROMTEXT() antlr.TerminalNode
	LINEFROMWKB() antlr.TerminalNode
	LINESTRING() antlr.TerminalNode
	LINESTRINGFROMTEXT() antlr.TerminalNode
	LINESTRINGFROMWKB() antlr.TerminalNode
	LN() antlr.TerminalNode
	LOAD_FILE() antlr.TerminalNode
	LOCATE() antlr.TerminalNode
	LOG() antlr.TerminalNode
	LOG10() antlr.TerminalNode
	LOG2() antlr.TerminalNode
	LOWER() antlr.TerminalNode
	LPAD() antlr.TerminalNode
	LTRIM() antlr.TerminalNode
	MAKEDATE() antlr.TerminalNode
	MAKETIME() antlr.TerminalNode
	MAKE_SET() antlr.TerminalNode
	MASTER_POS_WAIT() antlr.TerminalNode
	MBRCONTAINS() antlr.TerminalNode
	MBRDISJOINT() antlr.TerminalNode
	MBREQUAL() antlr.TerminalNode
	MBRINTERSECTS() antlr.TerminalNode
	MBROVERLAPS() antlr.TerminalNode
	MBRTOUCHES() antlr.TerminalNode
	MBRWITHIN() antlr.TerminalNode
	MD5() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MLINEFROMTEXT() antlr.TerminalNode
	MLINEFROMWKB() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHNAME() antlr.TerminalNode
	MPOINTFROMTEXT() antlr.TerminalNode
	MPOINTFROMWKB() antlr.TerminalNode
	MPOLYFROMTEXT() antlr.TerminalNode
	MPOLYFROMWKB() antlr.TerminalNode
	MULTILINESTRING() antlr.TerminalNode
	MULTILINESTRINGFROMTEXT() antlr.TerminalNode
	MULTILINESTRINGFROMWKB() antlr.TerminalNode
	MULTIPOINT() antlr.TerminalNode
	MULTIPOINTFROMTEXT() antlr.TerminalNode
	MULTIPOINTFROMWKB() antlr.TerminalNode
	MULTIPOLYGON() antlr.TerminalNode
	MULTIPOLYGONFROMTEXT() antlr.TerminalNode
	MULTIPOLYGONFROMWKB() antlr.TerminalNode
	NAME_CONST() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	NULLIF() antlr.TerminalNode
	NUMGEOMETRIES() antlr.TerminalNode
	NUMINTERIORRINGS() antlr.TerminalNode
	NUMPOINTS() antlr.TerminalNode
	OCT() antlr.TerminalNode
	OCTET_LENGTH() antlr.TerminalNode
	ORD() antlr.TerminalNode
	OVERLAPS() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PERIOD_ADD() antlr.TerminalNode
	PERIOD_DIFF() antlr.TerminalNode
	PI() antlr.TerminalNode
	POINT() antlr.TerminalNode
	POINTFROMTEXT() antlr.TerminalNode
	POINTFROMWKB() antlr.TerminalNode
	POINTN() antlr.TerminalNode
	POLYFROMTEXT() antlr.TerminalNode
	POLYFROMWKB() antlr.TerminalNode
	POLYGON() antlr.TerminalNode
	POLYGONFROMTEXT() antlr.TerminalNode
	POLYGONFROMWKB() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	POW() antlr.TerminalNode
	POWER() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUOTE() antlr.TerminalNode
	RADIANS() antlr.TerminalNode
	RAND() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RANDOM_BYTES() antlr.TerminalNode
	RELEASE_LOCK() antlr.TerminalNode
	REVERSE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROUND() antlr.TerminalNode
	ROW_COUNT() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	RPAD() antlr.TerminalNode
	RTRIM() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SEC_TO_TIME() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SHA() antlr.TerminalNode
	SHA1() antlr.TerminalNode
	SHA2() antlr.TerminalNode
	SIGN() antlr.TerminalNode
	SIN() antlr.TerminalNode
	SLEEP() antlr.TerminalNode
	SOUNDEX() antlr.TerminalNode
	SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode
	SQRT() antlr.TerminalNode
	SRID() antlr.TerminalNode
	STARTPOINT() antlr.TerminalNode
	STRCMP() antlr.TerminalNode
	STR_TO_DATE() antlr.TerminalNode
	ST_AREA() antlr.TerminalNode
	ST_ASBINARY() antlr.TerminalNode
	ST_ASTEXT() antlr.TerminalNode
	ST_ASWKB() antlr.TerminalNode
	ST_ASWKT() antlr.TerminalNode
	ST_BUFFER() antlr.TerminalNode
	ST_CENTROID() antlr.TerminalNode
	ST_CONTAINS() antlr.TerminalNode
	ST_CROSSES() antlr.TerminalNode
	ST_DIFFERENCE() antlr.TerminalNode
	ST_DIMENSION() antlr.TerminalNode
	ST_DISJOINT() antlr.TerminalNode
	ST_DISTANCE() antlr.TerminalNode
	ST_ENDPOINT() antlr.TerminalNode
	ST_ENVELOPE() antlr.TerminalNode
	ST_EQUALS() antlr.TerminalNode
	ST_EXTERIORRING() antlr.TerminalNode
	ST_GEOMCOLLFROMTEXT() antlr.TerminalNode
	ST_GEOMCOLLFROMTXT() antlr.TerminalNode
	ST_GEOMCOLLFROMWKB() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	ST_GEOMETRYFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYFROMWKB() antlr.TerminalNode
	ST_GEOMETRYN() antlr.TerminalNode
	ST_GEOMETRYTYPE() antlr.TerminalNode
	ST_GEOMFROMTEXT() antlr.TerminalNode
	ST_GEOMFROMWKB() antlr.TerminalNode
	ST_INTERIORRINGN() antlr.TerminalNode
	ST_INTERSECTION() antlr.TerminalNode
	ST_INTERSECTS() antlr.TerminalNode
	ST_ISCLOSED() antlr.TerminalNode
	ST_ISEMPTY() antlr.TerminalNode
	ST_ISSIMPLE() antlr.TerminalNode
	ST_LINEFROMTEXT() antlr.TerminalNode
	ST_LINEFROMWKB() antlr.TerminalNode
	ST_LINESTRINGFROMTEXT() antlr.TerminalNode
	ST_LINESTRINGFROMWKB() antlr.TerminalNode
	ST_NUMGEOMETRIES() antlr.TerminalNode
	ST_NUMINTERIORRING() antlr.TerminalNode
	ST_NUMINTERIORRINGS() antlr.TerminalNode
	ST_NUMPOINTS() antlr.TerminalNode
	ST_OVERLAPS() antlr.TerminalNode
	ST_POINTFROMTEXT() antlr.TerminalNode
	ST_POINTFROMWKB() antlr.TerminalNode
	ST_POINTN() antlr.TerminalNode
	ST_POLYFROMTEXT() antlr.TerminalNode
	ST_POLYFROMWKB() antlr.TerminalNode
	ST_POLYGONFROMTEXT() antlr.TerminalNode
	ST_POLYGONFROMWKB() antlr.TerminalNode
	ST_SRID() antlr.TerminalNode
	ST_STARTPOINT() antlr.TerminalNode
	ST_SYMDIFFERENCE() antlr.TerminalNode
	ST_TOUCHES() antlr.TerminalNode
	ST_UNION() antlr.TerminalNode
	ST_WITHIN() antlr.TerminalNode
	ST_X() antlr.TerminalNode
	ST_Y() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	SUBSTRING_INDEX() antlr.TerminalNode
	SUBTIME() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	TAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMEDIFF() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TIME_FORMAT() antlr.TerminalNode
	TIME_TO_SEC() antlr.TerminalNode
	TOUCHES() antlr.TerminalNode
	TO_BASE64() antlr.TerminalNode
	TO_DAYS() antlr.TerminalNode
	TO_SECONDS() antlr.TerminalNode
	UCASE() antlr.TerminalNode
	UNCOMPRESS() antlr.TerminalNode
	UNCOMPRESSED_LENGTH() antlr.TerminalNode
	UNHEX() antlr.TerminalNode
	UNIX_TIMESTAMP() antlr.TerminalNode
	UPDATEXML() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	UUID() antlr.TerminalNode
	UUID_SHORT() antlr.TerminalNode
	VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKDAY() antlr.TerminalNode
	WEEKOFYEAR() antlr.TerminalNode
	WEIGHT_STRING() antlr.TerminalNode
	WITHIN() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARWEEK() antlr.TerminalNode
	Y_FUNCTION() antlr.TerminalNode
	X_FUNCTION() antlr.TerminalNode
	JSON_ARRAY() antlr.TerminalNode
	JSON_OBJECT() antlr.TerminalNode
	JSON_QUOTE() antlr.TerminalNode
	JSON_CONTAINS() antlr.TerminalNode
	JSON_CONTAINS_PATH() antlr.TerminalNode
	JSON_EXTRACT() antlr.TerminalNode
	JSON_KEYS() antlr.TerminalNode
	JSON_OVERLAPS() antlr.TerminalNode
	JSON_SEARCH() antlr.TerminalNode
	JSON_VALUE() antlr.TerminalNode
	JSON_ARRAY_APPEND() antlr.TerminalNode
	JSON_ARRAY_INSERT() antlr.TerminalNode
	JSON_INSERT() antlr.TerminalNode
	JSON_MERGE() antlr.TerminalNode
	JSON_MERGE_PATCH() antlr.TerminalNode
	JSON_MERGE_PRESERVE() antlr.TerminalNode
	JSON_REMOVE() antlr.TerminalNode
	JSON_REPLACE() antlr.TerminalNode
	JSON_SET() antlr.TerminalNode
	JSON_UNQUOTE() antlr.TerminalNode
	JSON_DEPTH() antlr.TerminalNode
	JSON_LENGTH() antlr.TerminalNode
	JSON_TYPE() antlr.TerminalNode
	JSON_VALID() antlr.TerminalNode
	JSON_TABLE() antlr.TerminalNode
	JSON_SCHEMA_VALID() antlr.TerminalNode
	JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode
	JSON_PRETTY() antlr.TerminalNode
	JSON_STORAGE_FREE() antlr.TerminalNode
	JSON_STORAGE_SIZE() antlr.TerminalNode
	JSON_ARRAYAGG() antlr.TerminalNode
	JSON_OBJECTAGG() antlr.TerminalNode

	// IsFunctionNameBaseContext differentiates from other interfaces.
	IsFunctionNameBaseContext()
}

type FunctionNameBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameBaseContext() *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionNameBase
	return p
}

func InitEmptyFunctionNameBaseContext(p *FunctionNameBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySqlParserRULE_functionNameBase
}

func (*FunctionNameBaseContext) IsFunctionNameBaseContext() {}

func NewFunctionNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionNameBase

	return p
}

func (s *FunctionNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameBaseContext) ABS() antlr.TerminalNode {
	return s.GetToken(MySqlParserABS, 0)
}

func (s *FunctionNameBaseContext) ACOS() antlr.TerminalNode {
	return s.GetToken(MySqlParserACOS, 0)
}

func (s *FunctionNameBaseContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDDATE, 0)
}

func (s *FunctionNameBaseContext) ADDTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDTIME, 0)
}

func (s *FunctionNameBaseContext) AES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) AES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserAREA, 0)
}

func (s *FunctionNameBaseContext) ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASBINARY, 0)
}

func (s *FunctionNameBaseContext) ASIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASIN, 0)
}

func (s *FunctionNameBaseContext) ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASTEXT, 0)
}

func (s *FunctionNameBaseContext) ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKB, 0)
}

func (s *FunctionNameBaseContext) ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DERIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DERIVE, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_SIGN, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_VERIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_VERIFY, 0)
}

func (s *FunctionNameBaseContext) ATAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN, 0)
}

func (s *FunctionNameBaseContext) ATAN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN2, 0)
}

func (s *FunctionNameBaseContext) BENCHMARK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBENCHMARK, 0)
}

func (s *FunctionNameBaseContext) BIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIN, 0)
}

func (s *FunctionNameBaseContext) BIT_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_COUNT, 0)
}

func (s *FunctionNameBaseContext) BIT_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_LENGTH, 0)
}

func (s *FunctionNameBaseContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUFFER, 0)
}

func (s *FunctionNameBaseContext) CEIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEIL, 0)
}

func (s *FunctionNameBaseContext) CEILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEILING, 0)
}

func (s *FunctionNameBaseContext) CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCENTROID, 0)
}

func (s *FunctionNameBaseContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER_LENGTH, 0)
}

func (s *FunctionNameBaseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *FunctionNameBaseContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR_LENGTH, 0)
}

func (s *FunctionNameBaseContext) COERCIBILITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOERCIBILITY, 0)
}

func (s *FunctionNameBaseContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATION, 0)
}

func (s *FunctionNameBaseContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT, 0)
}

func (s *FunctionNameBaseContext) CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT_WS, 0)
}

func (s *FunctionNameBaseContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ID, 0)
}

func (s *FunctionNameBaseContext) CONV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONV, 0)
}

func (s *FunctionNameBaseContext) CONVERT_TZ() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT_TZ, 0)
}

func (s *FunctionNameBaseContext) COS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOS, 0)
}

func (s *FunctionNameBaseContext) COT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOT, 0)
}

func (s *FunctionNameBaseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *FunctionNameBaseContext) CRC32() antlr.TerminalNode {
	return s.GetToken(MySqlParserCRC32, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PUB_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_DH_PARAMETERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DH_PARAMETERS, 0)
}

func (s *FunctionNameBaseContext) CREATE_DIGEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DIGEST, 0)
}

func (s *FunctionNameBaseContext) CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSSES, 0)
}

func (s *FunctionNameBaseContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCUME_DIST, 0)
}

func (s *FunctionNameBaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *FunctionNameBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *FunctionNameBaseContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATEDIFF, 0)
}

func (s *FunctionNameBaseContext) DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_FORMAT, 0)
}

func (s *FunctionNameBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *FunctionNameBaseContext) DAYNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYNAME, 0)
}

func (s *FunctionNameBaseContext) DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFMONTH, 0)
}

func (s *FunctionNameBaseContext) DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFWEEK, 0)
}

func (s *FunctionNameBaseContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFYEAR, 0)
}

func (s *FunctionNameBaseContext) DECODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECODE, 0)
}

func (s *FunctionNameBaseContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEGREES, 0)
}

func (s *FunctionNameBaseContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDENSE_RANK, 0)
}

func (s *FunctionNameBaseContext) DES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) DES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIMENSION, 0)
}

func (s *FunctionNameBaseContext) DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISJOINT, 0)
}

func (s *FunctionNameBaseContext) ELT() antlr.TerminalNode {
	return s.GetToken(MySqlParserELT, 0)
}

func (s *FunctionNameBaseContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCODE, 0)
}

func (s *FunctionNameBaseContext) ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENVELOPE, 0)
}

func (s *FunctionNameBaseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUALS, 0)
}

func (s *FunctionNameBaseContext) EXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXP, 0)
}

func (s *FunctionNameBaseContext) EXPORT_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT_SET, 0)
}

func (s *FunctionNameBaseContext) EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) EXTRACTVALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACTVALUE, 0)
}

func (s *FunctionNameBaseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELD, 0)
}

func (s *FunctionNameBaseContext) FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIND_IN_SET, 0)
}

func (s *FunctionNameBaseContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST_VALUE, 0)
}

func (s *FunctionNameBaseContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOOR, 0)
}

func (s *FunctionNameBaseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORMAT, 0)
}

func (s *FunctionNameBaseContext) FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND_ROWS, 0)
}

func (s *FunctionNameBaseContext) FROM_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_BASE64, 0)
}

func (s *FunctionNameBaseContext) FROM_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_DAYS, 0)
}

func (s *FunctionNameBaseContext) FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_UNIXTIME, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *FunctionNameBaseContext) GET_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_LOCK, 0)
}

func (s *FunctionNameBaseContext) GLENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLENGTH, 0)
}

func (s *FunctionNameBaseContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATEST, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBSET, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBTRACT, 0)
}

func (s *FunctionNameBaseContext) HEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEX, 0)
}

func (s *FunctionNameBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *FunctionNameBaseContext) IFNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserIFNULL, 0)
}

func (s *FunctionNameBaseContext) INET6_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_ATON, 0)
}

func (s *FunctionNameBaseContext) INET6_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_NTOA, 0)
}

func (s *FunctionNameBaseContext) INET_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_ATON, 0)
}

func (s *FunctionNameBaseContext) INET_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_NTOA, 0)
}

func (s *FunctionNameBaseContext) INSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTR, 0)
}

func (s *FunctionNameBaseContext) INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *FunctionNameBaseContext) ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserISNULL, 0)
}

func (s *FunctionNameBaseContext) ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) IS_FREE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_FREE_LOCK, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_COMPAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_COMPAT, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_MAPPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_MAPPED, 0)
}

func (s *FunctionNameBaseContext) IS_IPV6() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV6, 0)
}

func (s *FunctionNameBaseContext) IS_USED_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_USED_LOCK, 0)
}

func (s *FunctionNameBaseContext) LAG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAG, 0)
}

func (s *FunctionNameBaseContext) LAST_INSERT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_INSERT_ID, 0)
}

func (s *FunctionNameBaseContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_VALUE, 0)
}

func (s *FunctionNameBaseContext) LCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLCASE, 0)
}

func (s *FunctionNameBaseContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAD, 0)
}

func (s *FunctionNameBaseContext) LEAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAST, 0)
}

func (s *FunctionNameBaseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *FunctionNameBaseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserLENGTH, 0)
}

func (s *FunctionNameBaseContext) LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LN() antlr.TerminalNode {
	return s.GetToken(MySqlParserLN, 0)
}

func (s *FunctionNameBaseContext) LOAD_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD_FILE, 0)
}

func (s *FunctionNameBaseContext) LOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCATE, 0)
}

func (s *FunctionNameBaseContext) LOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG, 0)
}

func (s *FunctionNameBaseContext) LOG10() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG10, 0)
}

func (s *FunctionNameBaseContext) LOG2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG2, 0)
}

func (s *FunctionNameBaseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOWER, 0)
}

func (s *FunctionNameBaseContext) LPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLPAD, 0)
}

func (s *FunctionNameBaseContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserLTRIM, 0)
}

func (s *FunctionNameBaseContext) MAKEDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKEDATE, 0)
}

func (s *FunctionNameBaseContext) MAKETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKETIME, 0)
}

func (s *FunctionNameBaseContext) MAKE_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKE_SET, 0)
}

func (s *FunctionNameBaseContext) MASTER_POS_WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_POS_WAIT, 0)
}

func (s *FunctionNameBaseContext) MBRCONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRCONTAINS, 0)
}

func (s *FunctionNameBaseContext) MBRDISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRDISJOINT, 0)
}

func (s *FunctionNameBaseContext) MBREQUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBREQUAL, 0)
}

func (s *FunctionNameBaseContext) MBRINTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) MBROVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBROVERLAPS, 0)
}

func (s *FunctionNameBaseContext) MBRTOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRTOUCHES, 0)
}

func (s *FunctionNameBaseContext) MBRWITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRWITHIN, 0)
}

func (s *FunctionNameBaseContext) MD5() antlr.TerminalNode {
	return s.GetToken(MySqlParserMD5, 0)
}

func (s *FunctionNameBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *FunctionNameBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMOD, 0)
}

func (s *FunctionNameBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *FunctionNameBaseContext) MONTHNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTHNAME, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) NAME_CONST() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME_CONST, 0)
}

func (s *FunctionNameBaseContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTH_VALUE, 0)
}

func (s *FunctionNameBaseContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTILE, 0)
}

func (s *FunctionNameBaseContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULLIF, 0)
}

func (s *FunctionNameBaseContext) NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) OCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCT, 0)
}

func (s *FunctionNameBaseContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCTET_LENGTH, 0)
}

func (s *FunctionNameBaseContext) ORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserORD, 0)
}

func (s *FunctionNameBaseContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOVERLAPS, 0)
}

func (s *FunctionNameBaseContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERCENT_RANK, 0)
}

func (s *FunctionNameBaseContext) PERIOD_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_ADD, 0)
}

func (s *FunctionNameBaseContext) PERIOD_DIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_DIFF, 0)
}

func (s *FunctionNameBaseContext) PI() antlr.TerminalNode {
	return s.GetToken(MySqlParserPI, 0)
}

func (s *FunctionNameBaseContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTN, 0)
}

func (s *FunctionNameBaseContext) POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *FunctionNameBaseContext) POW() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOW, 0)
}

func (s *FunctionNameBaseContext) POWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOWER, 0)
}

func (s *FunctionNameBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *FunctionNameBaseContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUOTE, 0)
}

func (s *FunctionNameBaseContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRADIANS, 0)
}

func (s *FunctionNameBaseContext) RAND() antlr.TerminalNode {
	return s.GetToken(MySqlParserRAND, 0)
}

func (s *FunctionNameBaseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM, 0)
}

func (s *FunctionNameBaseContext) RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANK, 0)
}

func (s *FunctionNameBaseContext) RANDOM_BYTES() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM_BYTES, 0)
}

func (s *FunctionNameBaseContext) RELEASE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE_LOCK, 0)
}

func (s *FunctionNameBaseContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *FunctionNameBaseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *FunctionNameBaseContext) ROUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUND, 0)
}

func (s *FunctionNameBaseContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_COUNT, 0)
}

func (s *FunctionNameBaseContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_NUMBER, 0)
}

func (s *FunctionNameBaseContext) RPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRPAD, 0)
}

func (s *FunctionNameBaseContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRTRIM, 0)
}

func (s *FunctionNameBaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *FunctionNameBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *FunctionNameBaseContext) SEC_TO_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEC_TO_TIME, 0)
}

func (s *FunctionNameBaseContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_USER, 0)
}

func (s *FunctionNameBaseContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *FunctionNameBaseContext) SHA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA, 0)
}

func (s *FunctionNameBaseContext) SHA1() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA1, 0)
}

func (s *FunctionNameBaseContext) SHA2() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA2, 0)
}

func (s *FunctionNameBaseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGN, 0)
}

func (s *FunctionNameBaseContext) SIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIN, 0)
}

func (s *FunctionNameBaseContext) SLEEP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLEEP, 0)
}

func (s *FunctionNameBaseContext) SOUNDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDEX, 0)
}

func (s *FunctionNameBaseContext) SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) SQRT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQRT, 0)
}

func (s *FunctionNameBaseContext) SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSRID, 0)
}

func (s *FunctionNameBaseContext) STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTPOINT, 0)
}

func (s *FunctionNameBaseContext) STRCMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRCMP, 0)
}

func (s *FunctionNameBaseContext) STR_TO_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTR_TO_DATE, 0)
}

func (s *FunctionNameBaseContext) ST_AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_AREA, 0)
}

func (s *FunctionNameBaseContext) ST_ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASBINARY, 0)
}

func (s *FunctionNameBaseContext) ST_ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKB, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKT, 0)
}

func (s *FunctionNameBaseContext) ST_BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_BUFFER, 0)
}

func (s *FunctionNameBaseContext) ST_CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CENTROID, 0)
}

func (s *FunctionNameBaseContext) ST_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) ST_CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CROSSES, 0)
}

func (s *FunctionNameBaseContext) ST_DIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIMENSION, 0)
}

func (s *FunctionNameBaseContext) ST_DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISJOINT, 0)
}

func (s *FunctionNameBaseContext) ST_DISTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISTANCE, 0)
}

func (s *FunctionNameBaseContext) ST_ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENVELOPE, 0)
}

func (s *FunctionNameBaseContext) ST_EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EQUALS, 0)
}

func (s *FunctionNameBaseContext) ST_EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTION, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTS, 0)
}

func (s *FunctionNameBaseContext) ST_ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ST_ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ST_ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) ST_NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) ST_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTN, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SRID, 0)
}

func (s *FunctionNameBaseContext) ST_STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_STARTPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_SYMDIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SYMDIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_TOUCHES, 0)
}

func (s *FunctionNameBaseContext) ST_UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_UNION, 0)
}

func (s *FunctionNameBaseContext) ST_WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_WITHIN, 0)
}

func (s *FunctionNameBaseContext) ST_X() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_X, 0)
}

func (s *FunctionNameBaseContext) ST_Y() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_Y, 0)
}

func (s *FunctionNameBaseContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBDATE, 0)
}

func (s *FunctionNameBaseContext) SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING_INDEX, 0)
}

func (s *FunctionNameBaseContext) SUBTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBTIME, 0)
}

func (s *FunctionNameBaseContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_USER, 0)
}

func (s *FunctionNameBaseContext) TAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTAN, 0)
}

func (s *FunctionNameBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *FunctionNameBaseContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMEDIFF, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPADD, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPDIFF, 0)
}

func (s *FunctionNameBaseContext) TIME_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_FORMAT, 0)
}

func (s *FunctionNameBaseContext) TIME_TO_SEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_TO_SEC, 0)
}

func (s *FunctionNameBaseContext) TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOUCHES, 0)
}

func (s *FunctionNameBaseContext) TO_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_BASE64, 0)
}

func (s *FunctionNameBaseContext) TO_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_DAYS, 0)
}

func (s *FunctionNameBaseContext) TO_SECONDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_SECONDS, 0)
}

func (s *FunctionNameBaseContext) UCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCASE, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESSED_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESSED_LENGTH, 0)
}

func (s *FunctionNameBaseContext) UNHEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNHEX, 0)
}

func (s *FunctionNameBaseContext) UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIX_TIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) UPDATEXML() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATEXML, 0)
}

func (s *FunctionNameBaseContext) UPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPPER, 0)
}

func (s *FunctionNameBaseContext) UUID() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID, 0)
}

func (s *FunctionNameBaseContext) UUID_SHORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID_SHORT, 0)
}

func (s *FunctionNameBaseContext) VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATE_PASSWORD_STRENGTH, 0)
}

func (s *FunctionNameBaseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION, 0)
}

func (s *FunctionNameBaseContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *FunctionNameBaseContext) WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *FunctionNameBaseContext) WEEKDAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKDAY, 0)
}

func (s *FunctionNameBaseContext) WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKOFYEAR, 0)
}

func (s *FunctionNameBaseContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *FunctionNameBaseContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHIN, 0)
}

func (s *FunctionNameBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *FunctionNameBaseContext) YEARWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEARWEEK, 0)
}

func (s *FunctionNameBaseContext) Y_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserY_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) X_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserX_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OBJECT, 0)
}

func (s *FunctionNameBaseContext) JSON_QUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_QUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS_PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_CONTAINS_PATH, 0)
}

func (s *FunctionNameBaseContext) JSON_EXTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_EXTRACT, 0)
}

func (s *FunctionNameBaseContext) JSON_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_KEYS, 0)
}

func (s *FunctionNameBaseContext) JSON_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) JSON_SEARCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SEARCH, 0)
}

func (s *FunctionNameBaseContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALUE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_APPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY_APPEND, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PATCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE_PATCH, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE_PRESERVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_REMOVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_REPLACE, 0)
}

func (s *FunctionNameBaseContext) JSON_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SET, 0)
}

func (s *FunctionNameBaseContext) JSON_UNQUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_UNQUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_DEPTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_DEPTH, 0)
}

func (s *FunctionNameBaseContext) JSON_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_LENGTH, 0)
}

func (s *FunctionNameBaseContext) JSON_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TYPE, 0)
}

func (s *FunctionNameBaseContext) JSON_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TABLE, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SCHEMA_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SCHEMA_VALIDATION_REPORT, 0)
}

func (s *FunctionNameBaseContext) JSON_PRETTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_PRETTY, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_FREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_STORAGE_FREE, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_STORAGE_SIZE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAYAGG() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAYAGG, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECTAGG() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OBJECTAGG, 0)
}

func (s *FunctionNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionNameBase() (localctx IFunctionNameBaseContext) {
	localctx = NewFunctionNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, MySqlParserRULE_functionNameBase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7478)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || ((int64((_la-96)) & ^0x3f) == 0 && ((int64(1)<<(_la-96))&11258999068426241) != 0) || ((int64((_la-216)) & ^0x3f) == 0 && ((int64(1)<<(_la-216))&-17179869161) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&8796109397507) != 0) || _la == MySqlParserINVISIBLE || ((int64((_la-672)) & ^0x3f) == 0 && ((int64(1)<<(_la-672))&-9223372036838064127) != 0) || ((int64((_la-802)) & ^0x3f) == 0 && ((int64(1)<<(_la-802))&-8589934599) != 0) || ((int64((_la-866)) & ^0x3f) == 0 && ((int64(1)<<(_la-866))&-257) != 0) || ((int64((_la-930)) & ^0x3f) == 0 && ((int64(1)<<(_la-930))&-1) != 0) || ((int64((_la-994)) & ^0x3f) == 0 && ((int64(1)<<(_la-994))&-1057) != 0) || ((int64((_la-1058)) & ^0x3f) == 0 && ((int64(1)<<(_la-1058))&562949416550399) != 0) || _la == MySqlParserMOD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *MySqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 345:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 346:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	case 347:
		var t *ExpressionAtomContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionAtomContext)
		}
		return p.ExpressionAtom_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MySqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 14)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
